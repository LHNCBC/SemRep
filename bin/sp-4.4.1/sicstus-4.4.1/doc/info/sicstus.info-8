This is sicstus.info, produced by makeinfo version 5.2 from
sicstus.texi.

INFO-DIR-SECTION SICStus Prolog
START-INFO-DIR-ENTRY
* SICStus Prolog Manual: (sicstus).			SICStus Prolog User's Manual.
END-INFO-DIR-ENTRY

Generated March 15, 2018.



File: sicstus.info,  Node: mpg-ref-foreign_resource,  Next: mpg-ref-format,  Prev: mpg-ref-foreign,  Up: mpg-bpr

11.3.84 'foreign_resource/2'   hook
-----------------------------------

Synopsis
--------

':- discontiguous foreign_resource/2.'

   'foreign_resource(+RESOURCENAME, +FOREIGNFUNCTIONS)'

   Describes the foreign functions in RESOURCENAME to interface to.

Arguments
---------

RESOURCENAME
     "atom", must be nonvar

FOREIGNFUNCTIONS
     "list of atom", must be ground

     A list of foreign function symbols that will be obtained from
     RESOURCENAME.

Description
-----------

The user has to define a 'foreign_resource/2' fact for every foreign
resource that is to be loaded into Prolog.  The FOREIGNFUNCTIONS gives
the list of foreign symbols that are to be found in the given foreign
resource.  When a foreign resource is loaded using
'load_foreign_resource/1', Prolog looks for a 'foreign_resource/2' fact
for that foreign resource and finds the address of each symbol listed in
that fact.  Prolog also expects a 'foreign/[2,3]' definition for each
symbol in the second argument of that fact.

   The 'foreign_resource/2' facts are used only in the context of a
'load_foreign_resource/1' command and can be removed once the foreign
resource has been loaded.

   Contrary to most hook predicates which reside in the 'user' module,
'load_foreign_resource/1' will look for 'foreign_resource/2' facts
defined in its source module.

Exceptions
----------

Error handling is performed by 'load_foreign_resource/1'.

See Also
--------

'load_foreign_resource/1', 'foreign/[2,3]', *note Calling C from
Prolog::.


File: sicstus.info,  Node: mpg-ref-format,  Next: mpg-ref-freeze,  Prev: mpg-ref-foreign_resource,  Up: mpg-bpr

11.3.85 'format/[2,3]'
----------------------

Synopsis
--------

'format(+CONTROL, +ARGUMENTS)'

   'format(+STREAM, +CONTROL, +ARGUMENTS)'

   Interprets the ARGUMENTS according to the CONTROL string and prints
the result on STREAM.

Arguments
---------

STREAM
     "stream_object", must be ground

     Defaults to the current output stream.

CONTROL
     "chars" or "codes" or "atom", must be ground

     A string, which can contain control sequences of the form '~N<C>':

     <C>
          a format control option

     N
          optional; if given, must be '*' or an integer.

     Any characters that are not part of a control sequence are written
     to the specified output stream.

:ARGUMENTS
     "list of term", must be proper list

     List of arguments, which will be interpreted and possibly printed
     by format control options.

Description
-----------

If a parameter N can be specified, then it can be either an integer,
specified as an optional minus sign followed by a sequence of decimal
digits, or the character '*'.

   If the parameter is specified as '*', then the value used will be the
truncated integer value of the next element from ARGUMENTS interpreted
as a numerical expression.

   The following control options cause formatted printing of the next
element from ARGUMENTS to the current output stream.

'~a'
     The argument is an atom.  The atom is printed without quoting.

'~Nc'
     (Print character.)  The argument is a number that will be
     interpreted as a "code".  N defaults to one and is interpreted as
     the number of times to print the character.  If N is zero, or
     negative, then the character is not printed.

'~Ne'
'~NE'
     (Print float in exponential notation.)  The argument is a float,
     which will be printed in exponential notation with one digit before
     the decimal point and N digits after it.  If N is zero, or
     negative, then one digit appears after the decimal point.  A sign
     and at least two digits appear in the exponent, which is introduced
     by the letter used in the control sequence.  N defaults to 6.

     The magnitude of N must be less than 100000, but useful values are
     much smaller than that.

'~Nf'
'~NF'
     (Print float in fixed-point notation.)  The argument is a float,
     which will be printed in fixed-point notation with N digits after
     the decimal point.  N may be zero, or negative, in which case a
     single zero appears after the decimal point.  At least one digit
     appears before the decimal point and at least one after it.  N
     defaults to 6.

     The magnitude of N must be less than 100000, but useful values are
     much smaller than that.

'~Ng'
'~NG'
     (Print float in generic notation.)  The argument is a float, which
     will be printed in 'f' or 'e' (or 'E' if 'G' is used) notation with
     N significant digits.  If N is zero, then one significant digit is
     printed.  'E' notation is used if the exponent from its conversion
     is less than -4 or greater than or equal to N, otherwise 'f'
     notation.  Trailing zeroes are removed from the fractional part of
     the result.  A decimal point and at least one digit after it always
     appear.  N defaults to 6.

     The magnitude of N must be less than 100000, but useful values are
     much smaller than that.

'~Nh'
'~NH'
     (Print float precisely.)  The argument is a float, which will be
     printed in 'f' or 'e' (or 'E' if 'H' is used) notation with D
     significant digits, where D is the smallest number of digits that
     will yield the same float when read in.  'E' notation is used if
     N<0 or if the exponent is less than -N-1 or greater than or equal
     to N+D, otherwise 'f' notation.  N defaults to 3.

     The intuition is that for numbers like 123000000.0, at most N
     consecutive zeroes before the decimal point are allowed in 'f'
     notation.  Similarly for numbers like 0.000000123.

     'E' notation is forced by using '~-1H'.  'F' is forced by using
     '~999H'.

     The magnitude of N must be less than 100000, but useful values are
     much smaller than that.

'~Nd'
     (Print decimal.)  The argument is an integer.  N is interpreted as
     the number of digits after the decimal point.  If N is 0 or
     missing, then no decimal point will be printed.

     N must be non-negative.

'~ND'
     (Print decimal.)  The argument is an integer.  Identical to '~Nd'
     except that ',' will separate groups of three digits to the left of
     the decimal point.

'~Nr'
     (Print radix.)  The argument is an integer.  N is interpreted as a
     radix, 2 \leq N \leq 36.  If N is missing, then the radix defaults
     to 8.  The letters 'a-z' will denote digits larger than 9.

'~NR'
     (Print radix.)  The argument is an integer.  Identical to '~Nr'
     except that the letters 'A-Z' will denote digits larger than 9.

'~Ns'
     (Print string.)  The argument is a code-list.  If N is zero, or
     negative, then no characters are output.

     If N is positive, then the first N characters of the code-list will
     be written, and if the code-list is exhausted, then extra <SPC>
     characters will be written, for a total of N characters output.

'~i'
     (Ignore.)  The argument, which may be of any type, is ignored.

'~k'
     (Print canonical.)  The argument may be of any type.  The argument
     will be passed to 'write_canonical/1' (*note ref-iou-tou::).

'~p'
     (Print.)  The argument may be of any type.  The argument will be
     passed to 'print/1' (*note ref-iou-tou::).

'~q'
     (Print quoted.)  The argument may be of any type.  The argument
     will be passed to 'writeq/1' (*note ref-iou-tou::).

'~w'
     (Write.)  The argument may be of any type.  The argument will be
     passed to 'write/1' (*note ref-iou-tou::).

'~@'
     (Call.)  The argument ARG is a goal, which will be called as if by
     '\+ \+ ARG' and is expected to print on the current output stream.
     If the goal performs other side-effects, then the behavior is
     undefined.

'~~'
     (Print tilde.)  Takes no argument.  Prints '~'.

'~Nn'
     (Print newline.)  Takes no argument.  Prints N newlines.  N
     defaults to 1.

     If N is negative or zero, then no newlines are output.

'~N'
     (Print Newline.)  Prints a newline if not at the beginning of a
     line.

   The following control sequences set column boundaries and specify
padding.  A column is defined as the available space between two
consecutive column boundaries on the same line.  A boundary is initially
assumed at line position 0.  The specifications only apply to the line
currently being written.

   When a column boundary is set ('~|' or '~+') and there are fewer
characters written in the column than its specified width, the remaining
space is divided equally amongst the pad sequences ('~t') in the column.
If there are no pad sequences, then the column is space padded at the
end.

   If '~|' or '~+' specifies a position preceding the current position,
then the boundary is set at the current position.

'~N|'
     Set a column boundary at line position N.  N defaults to the
     current position.

     The control sequence '~N|' (with explicit N) will not work
     correctly on bi-directional streams(1), e.g.  those created by
     'library(sockets)'.  A workaround for bi-directional streams may be
     to use '~|' (without explicit N) and '~N+', see below.

'~N+'
     Set a column boundary at N positions past the previous column
     boundary.  N defaults to 8.

'~Nt'
     Specify padding in a column.  N is the fill character code.  N may
     also be specified as '`C' where C is the fill character.  The
     default fill character is <SPC>.  Any ('~t') after the last column
     boundary on a line is ignored.

Exceptions
----------

Stream errors (*note ref-iou-sfh-est::), plus:

'consistency_error'
     Wrong number of ARGUMENTS.
'type_error'
'domain_error'
     Argument of the wrong type or domain.

Examples
--------

     | ?- Pi=3.14159265, format('~e ~2E ~0E\n', [Pi,Pi,Pi]).
     3.141593e+00 3.14E+00 3.0E+00

     | ?- Pi=3.14159265, format('~f, ~2F, ~0F\n', [Pi,Pi,Pi]).
     3.141593, 3.14, 3.0

     | ?- format('~g ~2G ~0G\n', [1.23456789e+10, 3.14159265, 0.0123]).
     1.23457e+10 3.1 0.01

     | ?- F = 123000.0, G = 0.000123,
          format('~h ~h ~2h ~2H ~-1H\n', [F,G,F,G,3.14]).
     123000.0 0.000123 1.23e+05 1.23E-04 3.14E+00

     | ?- format('Hello ~1d world!\n', [42]).
     Hello 4.2 world!

     | ?- format('Hello ~d world!\n', [42]).
     Hello 42 world!

     | ?- format('Hello ~1D world!\n', [12345]).
     Hello 1,234.5 world!

     | ?- format('Hello ~2r world!\n', [15]).
     Hello 1111 world!

     | ?- format('Hello ~16r world!\n', [15]).
     Hello f world!

     | ?- format('Hello ~16R world!\n', [15]).
     Hello F world!

     | ?- format('Hello ~4s ~4s!\n', ["new","world"]).
     Hello new  worl!

     | ?- format('Hello ~s world!\n', ["new"]).
     Hello new world!

     | ?- format('Hello ~i~s world!\n', ["old","new"]).
     Hello new world!

     | ?- format('Hello ~k world!\n', [[a,b,c]]).
     Hello '.'(a,'.'(b,'.'(c,[]))) world!

     | ?- assert((portray([X|Y]) :- print(cons(X,Y)))).
     | ?- format('Hello ~p world!\n', [[a,b,c]]).
     Hello cons(a,cons(b,cons(c,[]))) world!

     | ?- format('Hello ~q world!\n', [['A','B']]).
     Hello ['A','B'] world!

     | ?- format('Hello ~w world!\n', [['A','B']]).
     Hello [A,B] world!

     | ?- format('Hello ~@ world!\n', [write(new)]).
     Hello new world!

     | ?- format('Hello ~~ world!\n', []).
     Hello ~ world!

     | ?- format('Hello ~n world!\n', []).
     Hello
      world!

     | ?-    format('~`*t NICE TABLE ~`*t~61|~n', []),
             format('*~t*~61|~n', []),
             format('*~t~a~20|~t~a~t~20+~a~t~20+~t*~61|~n',
                    ['Right aligned','Centered','Left aligned']),
             format('*~t~d~20|~t~d~t~20+~d~t~20+~t*~61|~n',
                    [123,45,678]),
             format('*~t~d~20|~t~d~t~20+~d~t~20+~t*~61|~n',
                    [1,2345,6789]),
             format('~`*t~61|~n', []).

     ************************ NICE TABLE *************************
     *                                                           *
     *      Right aligned      Centered      Left aligned        *
     *                123         45         678                 *
     *                  1        2345        6789                *
     *************************************************************

     | ?-
         format('Table of Contents ~t ~a~72|~*n', [i,3]),
         format('~tTable of Contents~t~72|~*n', 2),
         format("1. Documentation supplement for ~s~1f ~`.t ~d~72|~*n", ["Quintus Prolog Release ",1.5,2,2]),
         format("~t~*+~w Definition of the term \"loaded\" ~`.t ~d~72|~n", [3,1-1,2]),
         format("~t~*+~w Finding all solutions ~`.t ~d~72|~n", [3,1-2,3]),
         format("~t~*+~w Searching for a file in a library ~`.t ~d~72|~n", [3,1-3,4]),
         format("~t~*+~w New Built-in Predicates ~`.t ~d~72|~n", [3,1-4,5]),
         format("~t~*+~w write_canonical (?Term) ~`.t ~d~72|~n", [7,1-4-1,5]),
         format("~*+.~n~*+.~n~*+.~n", [20,20,20]),
         format("~t~*+~w File Specifications ~`.t ~d~72|~n", [3,1-7,17]),
         format("~t~*+~w multifile(+PredSpec) ~`.t ~d~72|~n", [7,1-7-1,18]).

                                Table of Contents

     1. Documentation supplement for Quintus Prolog Release 1.5 ........... 2

        1-1 Definition of the term "loaded" ............................... 2
        1-2 Finding all solutions ......................................... 3
        1-3 Searching for a file in a library ............................. 4
        1-4 New Built-in Predicates ....................................... 5
            1-4-1 write_canonical (?Term) ................................. 5
                         .
                         .
                         .
        1-7 File Specifications .......................................... 17
            1-7-1 multifile(+PredSpec) ................................... 18

See Also
--------

*note ref-iou-tou::.

   ---------- Footnotes ----------

   (1) This is because streams only have one counter for line position,
and for bidirectional streams that counter tracks the input direction
(*note cpg-ref-SP_get_stream_counts::).


File: sicstus.info,  Node: mpg-ref-freeze,  Next: mpg-ref-frozen,  Prev: mpg-ref-format,  Up: mpg-bpr

11.3.86 'freeze/2'
------------------

Synopsis
--------

'freeze(+FLAG, +GOAL)'

   Blocks GOAL until FLAG is bound.

Arguments
---------

FLAG
     "term"

:GOAL
     "callable", must be nonvar

Description
-----------

Defined as if by:

     freeze(X, Goal) :- when(nonvar(X), Goal).

or

     :- block freeze(-, ?).
     freeze(_, Goal) :- Goal.

Backtracking
------------

Depends on GOAL.

Exceptions
----------

Call errors (*note ref-sem-exc::).

See Also
--------

*note ref-sem-sec::.


File: sicstus.info,  Node: mpg-ref-frozen,  Next: mpg-ref-functor,  Prev: mpg-ref-freeze,  Up: mpg-bpr

11.3.87 'frozen/2'
------------------

Synopsis
--------

'frozen(+VAR,-GOAL)'

   GOAL is unified with the conjunction of goals blocked on VAR.

Arguments
---------

VAR
     "term", must be var

GOAL
     "callable"

Description
-----------

If some goal is blocked on the variable VAR, or VAR has attributes that
can be interpreted as a goal (*note lib-atts::), then that goal is
unified with GOAL.  If no goals are blocked, then GOAL is unified with
the atom 'true'.  If more than one goal is blocked, then a conjunction
is unified with GOAL.

Exceptions
----------

'uninstantiation_error'
     VAR is not a variable

See Also
--------

*note ref-sem-sec::.


File: sicstus.info,  Node: mpg-ref-functor,  Next: mpg-ref-garbage_collect,  Prev: mpg-ref-frozen,  Up: mpg-bpr

11.3.88 'functor/3'   ISO
-------------------------

Synopsis
--------

'functor(+Term, -Name, -Arity)'

   'functor(-Term, +Name, +Arity)'

   Succeeds if the principal functor of term TERM has name NAME and
arity ARITY.

Arguments
---------

TERM
     "term"

NAME
     "atom"

ARITY
     "arity"

Description
-----------

There are two ways of using this predicate:

  1. If TERM is initially instantiated, then

        * if TERM is a compound term, then NAME and ARITY are unified
          with the name and arity of its principal functor.
        * otherwise, NAME is unified with TERM, and ARITY is unified
          with 0.

  2. If TERM is initially uninstantiated, then NAME and ARITY must both
     be instantiated, and

        * if ARITY is an integer in the range 1..255, then NAME must be
          an atom, and TERM becomes instantiated to the most general
          term having the specified NAME and ARITY; that is, a term with
          distinct variables for all of its arguments.
        * if ARITY is 0, then NAME must be atomic, and it is unified
          with TERM.

Exceptions
----------

'instantiation_error'
     TERM and either NAME or ARITY are uninstantiated.

'type_error'
     NAME is not atomic, or ARITY is not an integer, or NAME is not an
     atom when ARITY > 0.

'domain_error'
     ARITY is an integer < 0.

'representation_error'
     TERM is uninstantiated and ARITY > 255.

Examples
--------


     | ?- functor(foo(a,b), N, A).

     N = foo,
     A = 2

     | ?- functor(X, foo, 2).

     X = foo(_A,_B)

     | ?- functor(X, 2, 0).

     X = 2

See Also
--------

'arg/3', 'name/2', '=../2', *note ref-lte-act::.


File: sicstus.info,  Node: mpg-ref-garbage_collect,  Next: mpg-ref-garbage_collect_atoms,  Prev: mpg-ref-functor,  Up: mpg-bpr

11.3.89 'garbage_collect/0'
---------------------------

Synopsis
--------

'garbage_collect'

   Invokes the garbage collector.

Description
-----------

This predicate invokes the garbage collector to reclaim data structures
on the Prolog stack that are no longer accessible to the computation.

Examples
--------

In the code fragment:
     cycle(X) :- big_goal(X, X1), cycle(X1).

   if 'cycle/1' is to run for a long time, and if 'big_goal/2' generates
a lot of garbage, then rewrite the code like this:
     cycle(X) :- big_goal(X, X1), !, garbage_collect, cycle(X1).

Tips
----

Use of the '!, garbage_collect' idiom is only desirable when you notice
that your code does frequent garbage collections.  It will allow the
garbage collector to collect garbage more effectively, and the cycle
will run without demanding increasing amounts of memory.

Exceptions
----------

None.

See Also
--------

*note ref-mgc::.


File: sicstus.info,  Node: mpg-ref-garbage_collect_atoms,  Next: mpg-ref-generate_message,  Prev: mpg-ref-garbage_collect,  Up: mpg-bpr

11.3.90 'garbage_collect_atoms/0'
---------------------------------

Synopsis
--------

'garbage_collect_atoms'

   Invokes the atom garbage collector.

Description
-----------

This predicate invokes the atom garbage collector to discard atoms that
are no longer accessible to the computation, reclaiming their space.

Tips
----

A program can use the 'atoms' keyword to 'statistics/2' to determine if
a call to 'garbage_collect_atoms/0' would be appropriate.

Exceptions
----------

None.

See Also
--------

*note ref-mgc::.


File: sicstus.info,  Node: mpg-ref-generate_message,  Next: mpg-ref-generate_message_hook,  Prev: mpg-ref-garbage_collect_atoms,  Up: mpg-bpr

11.3.91 'generate_message/3'   extendible
-----------------------------------------

Synopsis
--------

':- multifile 'SU_messages':generate_message/3.'

   ''SU_messages':generate_message(+MESSAGETERM, -S0, -S)'

   For a given MESSAGETERM, generates a list composed of CONTROL-ARG
pairs and the atom 'nl'.  This can be translated into a nested list of
CONTROL-ARG pairs, which can be used as input to
'print_message_lines/3'.

Arguments
---------

MESSAGETERM
     "term"

     May be any term.

S0
     "list of pair"

     The resulting list of CONTROL-ARGS pairs.

S
     "list of pair"

     The remaining list.

Description
-----------

Clauses for ''SU_messages':generate_message/3' underly all messages from
Prolog.  They may be examined and altered.  They are found in
'library('SU_messages')'.

   The purpose of this predicate is to allow you to redefine the
displayal of Prolog's messages.  For example, to translate all the
messages from English into some other language.

   This predicate should _not_ be modified if all you want to do is
modify or add a few messages: 'user:generate_message_hook/3' is provided
for that purpose.

   The Prolog system uses the built-in predicate 'print_message/2' to
print all its messages.  When 'print_message/2' is called, it calls
'user:generate_message_hook(Message,L,[])' to generate the message.  If
that fails, then ''SU_messages':generate_message(Message,L,[])' is
called instead.  If that succeeds, then L is assumed to have been bound
to a list whose elements are either CONTROL-ARGS pairs or the atom 'nl'.
Each CONTROL-ARG pair should be such that the call

     format(user_error, CONTROL, ARGS)

is valid.  The atom 'nl' is used for breaking the message into lines.
Using the format specification '~n' (new-line) is discouraged, since the
routine that actually prints the message (see 'user:message_hook/3' and
'print_message_lines/3') may need to have control over newlines.

   ''SU_messages':generate_message/3' is not included by default in
runtime systems, since end-users of application programs should probably
not be seeing any messages from the Prolog system.

   If there is a call to 'print_message/2' when when
''SU_messages':generate_message/3' does not succeed for some reason,
then the message term itself is printed, for example:

     | ?- print_message(error,unexpected_error(37)).
     ! unexpected_error(37)

   ''SU_messages':generate_message/3' failed because the message term
was not recognized.  In the following example 'print_message/2' is being
called by the default exception handler:

     | ?- write(A,B).
     ! Instantiation error in argument 1 of write/2
     ! goal:  write(_2107,_2108)

Examples
--------

     :- multifile user:generate_message_hook/3.
     user:generate_message_hook(hello_world) -->
             ['hello world'-[],nl].

   Note that the terminating 'nl' is required.

Exceptions
----------

'print_message/2' checks that the generated list is a valid parse.

See Also
--------

*note ref-msg::.


File: sicstus.info,  Node: mpg-ref-generate_message_hook,  Next: mpg-ref-get_byte,  Prev: mpg-ref-generate_message,  Up: mpg-bpr

11.3.92 'generate_message_hook/3'   hook
----------------------------------------

Synopsis
--------

':- multifile user:generate_message_hook/3.'

   'user:generate_message_hook(+MESSAGETERM, -S0, -S)'

   A way for the user to override the call to
''SU_messages':generate_message/3' in 'print_message/2'.

Arguments
---------

MESSAGETERM
     "term"

     May be any term.

S0
     "list of pair"

     The resulting list of CONTROL-ARGS pairs.

S
     "list of pair"

     The remaining list.

Description
-----------

For a given MESSAGETERM, generates the list of CONTROL-ARGS pairs
required for 'print_message_lines/3' to format the message for display.

   This is the same as ''SU_messages':generate_message/3' except that it
is a hook.  It is intended to be used when you want to override
particular messages from the Prolog system, or when you want to add some
messages.  If you are using your own exception classes (see
'raise_exception/1'), then it may be useful to provide
generate_message_hook clauses for those exceptions so that the
'print_message/2' (and thus the default exception handler that calls
'print_message/2') can print them out nicely.

   The Prolog system uses the built-in predicate 'print_message/2' to
print all its messages.  When 'print_message/2' is called, it calls
'user:generate_message_hook(Message,L,[])' to generate the message.  If
that fails, then ''SU_messages':generate_message(Message,L,[])' is
called instead.  If that succeeds, then L is assumed to have been bound
to a list whose elements are either CONTROL-ARGS pairs or the atom 'nl'.
Each CONTROL-ARG pair should be such that the call

     format(user_error, CONTROL, ARGS)

is valid.  The atom 'nl' is used for breaking the message into lines.
Using the format specification '~n' (new-line) is discouraged, since the
routine that actually prints the message (see 'user:message_hook/3' and
'print_message_lines/3') may need to have control over newlines.

Examples
--------

     :- multifile user:generate_message_hook/3.
     user:generate_message_hook(hello_world) -->
             ['hello world'-[],nl].

   Note that the terminating 'nl' is required.

Exceptions
----------

All error handling is done by the predicates extended by this hook.

See Also
--------

*note ref-msg::.


File: sicstus.info,  Node: mpg-ref-get_byte,  Next: mpg-ref-get_char,  Prev: mpg-ref-generate_message_hook,  Up: mpg-bpr

11.3.93 'get_byte/[1,2]'   ISO
------------------------------

Synopsis
--------

'get_byte(-BYTE)'

   'get_byte(+STREAM, -BYTE)'

   Unifies BYTE with the next "byte" from STREAM or with -1 if there are
no more bytes.

Arguments
---------

STREAM
     "stream_object", must be ground

     valid input _binary_ stream, defaults to the current input stream.

BYTE
     "byte" or -1

Exceptions
----------

Stream errors (*note ref-iou-sfh-est::), plus:

'type_error'
     BYTE is an invalid byte.

'permission_error'
     Trying to read beyond end of STREAM

See Also
--------

*note ref-iou-cin::.


File: sicstus.info,  Node: mpg-ref-get_char,  Next: mpg-ref-get_code,  Prev: mpg-ref-get_byte,  Up: mpg-bpr

11.3.94 'get_char/[1,2]'   ISO
------------------------------

Synopsis
--------

'get_char(-CHAR)'

   'get_char(+STREAM, -CHAR)'

   Unifies CHAR with the next "char" from STREAM or with 'end_of_file'
if there are no more characters.

Arguments
---------

STREAM
     "stream_object", must be ground.

     Valid input _text_ stream, defaults to the current input stream.

CHAR
     "char" or "one of ['end_of_file']"

Exceptions
----------

Stream errors (*note ref-iou-sfh-est::), plus:

'permission_error'
     Trying to read beyond end of STREAM

See Also
--------

*note ref-iou-cin::.


File: sicstus.info,  Node: mpg-ref-get_code,  Next: mpg-ref-get_mutable,  Prev: mpg-ref-get_char,  Up: mpg-bpr

11.3.95 'get_code/[1,2]'   ISO
------------------------------

Synopsis
--------

'get_code(-CODE)'

   'get_code(+STREAM, -CODE)'

   Unifies CODE with the next "code" from STREAM or with -1 if there are
no more characters.

Arguments
---------

STREAM
     "stream_object", must be ground

     Valid input _text_ stream, defaults to the current input stream.

CODE
     "code" or -1

Exceptions
----------

Stream errors (*note ref-iou-sfh-est::), plus:

'permission_error'
     Trying to read beyond end of STREAM

See Also
--------

*note ref-iou-cin::.


File: sicstus.info,  Node: mpg-ref-get_mutable,  Next: mpg-ref-goal_expansion,  Prev: mpg-ref-get_code,  Up: mpg-bpr

11.3.96 'get_mutable/2'
-----------------------

Synopsis
--------

'get_mutable(-DATUM, +MUTABLE)'

   DATUM is the current value of the mutable term MUTABLE.

Arguments
---------

DATUM
     "term", must be nonvar

MUTABLE
     "mutable", must be nonvar

Exceptions
----------

'instantiation_error'
     MUTABLE is uninstantiated.

'type_error'
     MUTABLE is not a mutable.

See Also
--------

*note ref-lte-mut::.


File: sicstus.info,  Node: mpg-ref-goal_expansion,  Next: mpg-ref-goal_source_info,  Prev: mpg-ref-get_mutable,  Up: mpg-bpr

11.3.97 'goal_expansion/5'   hook
---------------------------------

Synopsis
--------

'M:goal_expansion(+GOAL1, +LAYOUT1, +MODULE, -GOAL2, -LAYOUT2)'

   Defines transformations on goals while clauses are being compiled or
asserted, and during meta-calls at runtime.

Arguments
---------

GOAL1
     "callable"

     Goal to transform.

LAYOUT1
     "term"

     Layout of goal to transform.

MODULE
     "atom"

     Source module of goal to transform.

GOAL2
     "callable"

     Transformed goal.

LAYOUT2
     "term"

     Layout of transformed goal.

Description
-----------

Defines transformations on goals while clauses are being consulted,
compiled or asserted, _after_ any processing by 'user:term_expansion/6'
of the terms being read in.  It is called for every simple GOAL1,
defined in M, in the source module MODULE found while traversing the
clause bodies.  Typically, MODULE has imported the predicate GOAL1 from
module M but it happens also if MODULE uses an explicit module prefix,
i.e. 'M:GOAL1'.

   If it succeeds, then GOAL1 is replaced by GOAL2; otherwise, GOAL1 =
GOAL2.  GOAL2 may be an arbitrarily complex goal, and
'M:goal_expansion/5' is recursively applied to the expansion and its
subgoals.

     *Please note*: the arguments of meta-predicates such as 'call/1',
     'setof/3' and 'on_exception/3' are _not_ subject to such
     compile-time processing.  Instead the expansion is performed at
     runtime, see below.

   The above description holds even if 'Goal1' is exported but not
defined in the module M, i.e. it is possible to define a goal expansion
for an exported, but otherwise undefined, predicate.  However, in
general, it is better to provide an ordinary predicate definition as a
fallback, e.g. to be able to handle meta calls if the goal expansion is
not defined at runtime.

   This predicate is also used to resolve any meta-calls to GOAL1 at
runtime via the same mechanism.  If the transformation succeeds, then
GOAL2 is simply called instead of GOAL1.  Otherwise, if GOAL1 is a goal
of an existing predicate, then that predicate is invoked.  Otherwise,
error recovery is attempted by 'user:unknown_predicate_handler/3'.

   'M:goal_expansion/5' can be regarded as a macro expansion facility.
It is used for this purpose to support the interface to attributed
variables in 'library(atts)', which defines the predicates
'M:get_atts/2' and 'M:put_atts/2' to access module-specific variable
attributes.  These "predicates" are actually implemented via the
'M:goal_expansion/5' mechanism.  This has the effect that calls to the
interface predicates are expanded at compile time to efficient code.

   For accessing aspects of the load context, e.g. the name of the file
being compiled, the predicate 'prolog_load_context/2' (*note
ref-lps-lco::) can be used.  Note that 'prolog_load_context/2' only
gives meaningful results during compile (or consult) time.  This means
that when a meta call is goal expanded, at runtime, the load context
will not be available, and there is no reliable way for a goal expansion
to distinguish between these cases.

   The goal expansion may happen both at compile time (the normal case)
at runtime (for meta calls).  In some cases the compiler may try to
avoid meta calls by calling goal expansion also for meta calls.  This
all means that the code implementing goal expansion should be present at
both compile time and runtime.  It also implies that goal expansion
should not misbehave if it is called more times than expected.

   LAYOUT1 and LAYOUT2 are for supporting source-linked debugging in the
context of goal expansion.  The predicate should construct a suitable
LAYOUT2 compatible with TERM2 that contains the line number information
from LAYOUT1.  If source-linked debugging of TERM2 is not important,
then LAYOUT2 should be '[]'.  The recording of source info is affected
by the 'source_info' prolog flag (*note ref-lps-flg::).

Exceptions
----------

Exceptions are treated as failures, except an error message is printed
as well.

See Also
--------

*note ref-lod-exp::, *note Glossary::.


File: sicstus.info,  Node: mpg-ref-goal_source_info,  Next: mpg-ref-greater_than,  Prev: mpg-ref-goal_expansion,  Up: mpg-bpr

11.3.98 'goal_source_info/3'
----------------------------

Synopsis
--------

'goal_source_info(+AGOAL, -GOAL, -SOURCEINFO)'

   Decompose the AGOAL annotated goal into a GOAL proper and the
SOURCEINFO descriptor term, indicating the source position of the goal.

Arguments
---------

AGOAL
     "callable", must be nonvar

GOAL
     "callable"

SOURCEINFO
     "term"

Description
-----------

Annotated goals occur in most of error message terms, and carry
information on the GOAL causing the error and its source position.  The
SOURCEINFO term, retrieved by 'goal_source_info/3' will be one of the
following:
'[]'
     The goal has no source information associated with it.

'fileref(FILE,LINE)'
     The goal occurs in file FILE, line LINE.

'clauseref(FILE,MFUNC,CLAUSENO,CALLNO,LINE)'
     The goal occurs in file FILE, within predicate MFUNC, clause number
     CLAUSENO, call number CALLNO and virtual line number LINE.  Here,
     MFUNC is of form 'MODULE:NAME/ARITY', calls are numbered textually
     and the virtual line number shows the position of the goal within
     the listing of the predicate MFUNC, as produced by 'listing/1'.
     Such a term is returned for goals occurring in interpreted
     predicates, which do not have "real" line number information, e.g.
     because they were entered from the terminal, or created
     dynamically.

Exceptions
----------

'instantiation_error'
     GOAL is uninstantiated

'type_error'
     GOAL is not a callable

See Also
--------

*note ref-msg::.


File: sicstus.info,  Node: mpg-ref-greater_than,  Next: mpg-ref-ground,  Prev: mpg-ref-goal_source_info,  Up: mpg-bpr

11.3.99 '>/2'   ISO
-------------------

Synopsis
--------

+EXPR1 '>' +EXPR2

   Succeeds if the result of evaluating EXPR1 is strictly _greater than_
the result of evaluating EXPR2.

Arguments
---------

EXPR1
     "expr", must be ground
EXPR2
     "expr", must be ground

Description
-----------

Evaluates EXPR1 and EXPR2 as arithmetic expressions and compares the
results.

Exceptions
----------

Arithmetic errors (*note ref-ari-exc::).

Examples
--------

     | ?- "g" > "g".

     no

     | ?- 4*2 > 15/2.

     yes

See Also
--------

*note ref-ari::


File: sicstus.info,  Node: mpg-ref-ground,  Next: mpg-ref-halt,  Prev: mpg-ref-greater_than,  Up: mpg-bpr

11.3.100 'ground/1'   ISO
-------------------------

Synopsis
--------

'ground(+TERM)'

   TERM is currently instantiated to a ground term.

Arguments
---------

TERM
     "term"

Description
-----------

Tests whether X is completely instantiated, i.e. free of unbound
variables.  In this context, mutable terms are treated as nonground, so
as to make 'ground/1' a monotone predicate.

Examples
--------

     | ?- ground(9).

     yes
     | ?- ground(major(tom)).

     yes
     | ?- ground(a(1,Term,3)).

     no
     | ?- ground("a").

     yes
     | ?- ground([1,foo(Term)]).

     no

Exceptions
----------

None.

See Also
--------

*note ref-lte-met-typ::.


File: sicstus.info,  Node: mpg-ref-halt,  Next: mpg-ref-if,  Prev: mpg-ref-ground,  Up: mpg-bpr

11.3.101 'halt/[0,1]'   ISO
---------------------------

Synopsis
--------

'halt'

   'halt(+EXITCODE)'

   Causes an exit from the running process.

Arguments
---------

EXITCODE
     "integer", must be nonvar

     Exit status code.  Only the lower 8 bits of this value is used.

Description
-----------

Causes an exit from the running process with exit code EXITCODE.
EXITCODE defaults to zero which, by convention, signifies a successful
exit from the process.

   'halt/[0,1]' is implemented by raising a reserved exception, which is
handled at the top level; *note ref-ere-int::.

Exceptions
----------

'instantiation_error'
     EXITCODE is uninstantiated.

'type_error'
     EXITCODE is not an integer.

See Also
--------

'abort/0', 'break/0', 'runtime_entry/1', *note ref-ere-int::.


File: sicstus.info,  Node: mpg-ref-if,  Next: mpg-ref-if_then,  Prev: mpg-ref-halt,  Up: mpg-bpr

11.3.102 'if/3'
---------------

Synopsis
--------

'if(+P,+Q,+R)'

   _If_ P _then_ Q _else_ R, for all solution of P.

Arguments
---------

:P
     "callable", must be nonvar
:Q
     "callable", must be nonvar
:R
     "callable", must be nonvar

Description
-----------

Analogous to

     if P then Q else R

but differs from 'P -> Q ; R' in that 'if(P, Q, R)' explores _all_
solutions to the goal P.  There is a small time penalty for this--if P
is known to have only one solution of interest, then the form 'P -> Q ;
R' should be preferred.

   This is normally regarded as part of the syntax of the language, but
it is like a built-in predicate in that you can write 'call(if(P,Q,R))'.

   Cuts in P do not make sense, but are allowed, their scope being the
goal P.  The scope of cuts in Q and R extends to the containing clause.

Backtracking
------------

Depends on the arguments.

Exceptions
----------

Call errors (*note ref-sem-exc::).

See Also
--------

*note ref-sem::.


File: sicstus.info,  Node: mpg-ref-if_then,  Next: mpg-ref-include,  Prev: mpg-ref-if,  Up: mpg-bpr

11.3.103 '->/2'   ISO
---------------------

Synopsis
--------

+P '->' +Q

   When occurring other than as the first argument of a disjunction
operator (';/2'), this is equivalent to:

     P -> Q ; fail.

Arguments
---------

:P
     "callable", must be nonvar
:Q
     "callable", must be nonvar

Description
-----------

This is not normally regarded as a built-in predicate, since it is part
of the syntax of the language.  However, it is like a built-in predicate
in that you can say 'call((P -> Q))'.

   '->' cuts away any choice points in the execution of P

   Note that the operator precedence of '->' is greater than 1000, so it
dominates commas.  Thus, in:
     f :- p, q -> r, s.
     f.

   '->' cuts away any choices in 'p' or in 'q', but unlike cut ('!') it
does not cut away the alternative choice for 'f'.

   Cuts in P do not make sense, but are allowed, their scope being the
goal P.  The scope of cuts in Q extends to the containing clause.

Backtracking
------------

Depends on Q.

Exceptions
----------

Call errors (*note ref-sem-exc::).

See Also
--------

*note ref-sem::.


File: sicstus.info,  Node: mpg-ref-include,  Next: mpg-ref-initialization,  Prev: mpg-ref-if_then,  Up: mpg-bpr

11.3.104 'include/1'   declaration, ISO
---------------------------------------

Synopsis
--------

':- include +FILES'

   Literally embed the Prolog clauses and directives in FILES into the
file being loaded.  The file or files will be opened with default
options.

Arguments
---------

:FILES
     "file_spec" or "list of file_spec", must be ground

     A file specification or a list of file specifications; extension
     optional.

Description
-----------

The effect is such as if the declaration itself was replaced by the text
in the FILES.  Including some files is thus different from loading them
in several respects:

   * The embedding file counts as the source file of the predicates
     loaded, e.g. with respect to the built-in predicate
     'source_file/2'; *note ref-lps-apf::.
   * Some clauses of a predicate can come from the embedding file, and
     some from included files.
   * When including a file twice, all the clauses in it will be entered
     twice into the program (although this is not very meaningful).

Comments
--------

'include' is not an ISO predefined prefix operator.

Exceptions
----------

Exceptions in the context of loading code are printed as error messages.
See also 'load_files/[2,3]'.

'context_error'
     Declaration appeared in a goal.

'permission_error'
     Declaration appeared as a clause.

See Also
--------

*note Include Declarations::.


File: sicstus.info,  Node: mpg-ref-initialization,  Next: mpg-ref-instance,  Prev: mpg-ref-include,  Up: mpg-bpr

11.3.105 'initialization/1'   declaration, ISO
----------------------------------------------

Synopsis
--------

':- initialization +GOAL'

   Declares that GOAL is to be run when the file in which the
declaration appears is loaded into a running system, or when a
stand-alone program or runtime system that contains the file is started
up.

Arguments
---------

:GOAL
     "callable", must be nonvar

Description
-----------

Callable at any point during loading of a file.  That is, it can be used
as a directive, or as part of a goal called at load time.  The
initialization goal will be run as soon as the loading of the file is
completed.  That is at the end of the load, and notably after all other
directives appearing in the file have been run.

   'save_program/[1,2]' saves initialization goals in the saved state,
so that they will run when the saved state is restored.  When they run,
they have access to the load context ('prolog_load_context/2'), just
like other goals appearing in directives.

   GOAL is associated with the file loaded and a module.  When a file,
or module, is going to be reloaded, all goals earlier installed by that
file or in that module, are removed.  This is done before the actual
load, thus allowing a new initialization GOAL to be specified, without
creating duplicates.

Comments
--------

'initialization' is not an ISO predefined prefix operator.

Exceptions
----------

'instantiation_error'
     The argument GOAL is not instantiated.

'context_error'
     Initialization appeared in a goal.

'permission_error'
     Initialization appeared as a clause.

See Also
--------

*note Initializations::.


File: sicstus.info,  Node: mpg-ref-instance,  Next: mpg-ref-integer,  Prev: mpg-ref-initialization,  Up: mpg-bpr

11.3.106 'instance/2'
---------------------

Synopsis
--------

'instance(+REF, -TERM)'

   Unifies TERM with the most general instance of the dynamic clause or
recorded term indicated by the database reference REF.

Arguments
---------

REF
     "db_reference", must be nonvar

TERM
     "term"

Description
-----------

REF must be instantiated to a database reference to an existing clause
or recorded term.  'instance/2' is not sensitive to the source module
and can be used to access any clause, regardless of its module.

Exceptions
----------

'instantiation_error'
     if REF is not instantiated

'type_error'
     if REF is not a syntactically valid database reference

'existence_error'
     if REF is a syntactically valid database reference but does not
     refer to an existing clause or recorded term.

Examples
--------

     | ?- assert(foo:bar,R).

     R = '$ref'(771292,1)

     | ?- instance('$ref'(771292,1),T).

     T = (bar:-true)

     | ?- clause(H,B,'$ref'(771292,1)).

     no
     | ?- clause(foo:H,B,'$ref'(771292,1)).

     H = bar,
     B = true

See Also
--------

*note ref-mdb-acl::.


File: sicstus.info,  Node: mpg-ref-integer,  Next: mpg-ref-is,  Prev: mpg-ref-instance,  Up: mpg-bpr

11.3.107 'integer/1'   ISO
--------------------------

Synopsis
--------

'integer(+TERM)'

   TERM is currently instantiated to an integer.

Arguments
---------

TERM
     "term"

Examples
--------

     | ?- integer(5).

     yes
     | ?- integer(5.0).

     no

Exceptions
----------

None.

See Also
--------

*note ref-lte-met-typ::.


File: sicstus.info,  Node: mpg-ref-is,  Next: mpg-ref-keysort,  Prev: mpg-ref-integer,  Up: mpg-bpr

11.3.108 'is/2'   ISO
---------------------

Synopsis
--------

'-TERM is +EXPRESSION'

   Evaluates EXPRESSION as an arithmetic expression, and unifies the
resulting number with TERM.

Arguments
---------

EXPRESSION
     "expr", must be ground.

     An expression made up of:

        * functors representing arithmetic operations
        * numbers
        * variables bound to numbers or arithmetic expressions

TERM
     "number"

Exceptions
----------

Arithmetic errors (*note ref-ari-exc::).

Examples
--------

     | ?- X is 2 * 3 + 4.

     X = 10

     | ?- Y = 32.1, X is Y * Y.

     X = 1030.41
     Y = 32.1

     | ?- Arity is 3 * 8, X is 4 + Arity + (3 * Arity * Arity).

     Arity = 24
     X = 1756

     | ?- X is 6/0.
     ! Domain error in argument 2 of is/2
     ! expected an integer not equal to 0, but found 0
     ! goal:  _98 is 6/0

     | ?- X is "a".

     X = 97

     | ?- X is 4 * 5, Y is X * 4.

     X = 20,
     Y = 80

Comments
--------

If a variable in an arithmetic expression is bound to another arithmetic
expression (as opposed to a number) at runtime, then the cost of
evaluating that expression is much greater.  It is approximately equal
to the cost of 'call/1' of an arithmetic goal.

See Also
--------

*note ref-ari::.


File: sicstus.info,  Node: mpg-ref-keysort,  Next: mpg-ref-leash,  Prev: mpg-ref-is,  Up: mpg-bpr

11.3.109 'keysort/2'   ISO
--------------------------

Synopsis
--------

'keysort(+PAIRS, -SORTED)'

   Sorts the elements of the list PAIRS into ascending standard order
(*note ref-lte-cte-sot::) with respect to the key of the pair structure.

Arguments
---------

     PAIRS
          "list of pair", must be a proper list of proper pairs

     SORTED
          "list of pair"

Description
-----------

The list PAIRS must consist of terms of the form KEY-VALUE.  Multiple
occurrences of pairs with the same key are not removed.

   (The time taken to do this is at worst order (N log N) where N is the
length of the list.)

   Note that the elements of PAIRS are sorted _only_ according to the
value of KEY, _not_ according to the value of VALUE.

   'keysort/2' is stable in the sense that the relative position of
elements with the same key is maintained.

   SORTED is type checked since release 4.3 for alignment with the ISO
Prolog standard.  Previous releases simply failed instead of reporting
an error for malformed SORTED.

Exceptions
----------

'instantiation_error'
     If PAIRS is not properly instantiated

'type_error'
     If PAIRS is not a proper "list of pair".

'type_error'
     If SORTED cannot be unified with a "list of pair".

Examples
--------

     | ?- keysort([3-a,1-b,2-c,1-a,1-b], X).

     X = [1-b,1-a,1-b,2-c,3-a]

     |?- keysort([2-1, 1-2], [1-2, 2-1]).

     yes

See Also
--------

*note ref-lte-cte-sor::.


File: sicstus.info,  Node: mpg-ref-leash,  Next: mpg-ref-length,  Prev: mpg-ref-keysort,  Up: mpg-bpr

11.3.110 'leash/1'   development
--------------------------------

Synopsis
--------

'leash(+MODE)'

   Starts leashing on the ports given by MODE.

Arguments
---------

MODE

     "list of one of
     '[call,exit,redo,fail,exception,all,half,loose,tight,off]'", must
     be ground

     A list of the ports to be leashed.  A single keyword can be given
     without enclosing it in a list.

Description
-----------

Some of the keywords denote a set of ports:

'all'
     Stands for all five port.

'half'
     Stands for the Exception, Call and Redo ports.

'loose'
     Stands for the Exception and Call ports.

'tight'
     Stands for all ports but Exit.

'off'
     Stands for no ports.

   The leashing mode only applies to procedures that do not have
spypoints on them, and it determines which ports of such procedures are
leashed.  By default, all five ports are leashed.  On arrival at a
leashed port, the debugger will stop to allow you to look at the
execution state and decide what to do next.  At unleashed ports, the
goal is displayed but program execution does not stop to allow user
interaction.

Exceptions
----------

'instantiation_error'
     MODE is not ground

'domain_error'
     MODE is not a valid leash specification

Examples
--------

     | ?- leash(off).

   turns off all leashing; now when you creep you will get an exhaustive
trace but no opportunity to interact with the debugger.  You can get
back to the debugger to interact with it by pressing '^c t'.

     | ?- leash([call,redo]).

   leashes on the Call and Redo ports.  When creeping, the debugger will
now stop at every Call and Redo port to allow you to interact.

See Also
--------

*note Basic Debug::.


File: sicstus.info,  Node: mpg-ref-length,  Next: mpg-ref-less_than,  Prev: mpg-ref-leash,  Up: mpg-bpr

11.3.111 'length/2'
-------------------

Synopsis
--------

'length(?LIST, ?INTEGER)'

   INTEGER is the length of LIST.  If LIST is instantiated to a proper
"list of term", or INTEGER to an integer, then the predicate is
determinate.

Arguments
---------

LIST
     "list of term"

INTEGER
     "integer", non-negative

Description
-----------

If LIST is a list of indefinite length (that is, either a variable or of
the form '[...|X]', where 'X' is a variable) and if INTEGER is bound to
an integer, then LIST is made to be a list of length INTEGER with unique
variables used to "pad" the list.  If LIST cannot be made into a list of
length INTEGER, then the call fails.
     | ?-  List = [a,b|X], length(List, 4).

     List = [a,b,_A,_B],
     X = [_A,_B] ;

     | ?-

   If LIST is bound, and is not a list, then 'length/2' simply fails.

   If LIST is a cyclic list, and INTEGER is bound to a non-negative
integer, then 'length/2' simply fails.

   If LIST is a cyclic list, and INTEGER is a variable, then the
behavior is unspecified and may change in the some future version.

Backtracking
------------

If INTEGER is unbound, then it is unified with all possible lengths for
the list LIST.

Exceptions
----------

'type_error'
     INTEGER is not an integer

'domain_error'
     INTEGER < 0

Examples
--------


     | ?- length([1,2], 2).

     yes
     | ?- length([1,2], 0).

     no
     | ?- length([1,2], X).

     X = 2 ;

     no

See Also
--------

*note ref-lte-acl::, 'library(lists)'.


File: sicstus.info,  Node: mpg-ref-less_than,  Next: mpg-ref-library_directory,  Prev: mpg-ref-length,  Up: mpg-bpr

11.3.112 '</2'   ISO
--------------------

Synopsis
--------

+EXPR1 '<' +EXPR2

   Evaluates EXPR1 and EXPR2 as arithmetic expressions.  The goal
succeeds if the result of evaluating EXPR1 is strictly _less than_ the
result of evaluating EXPR2.

Arguments
---------

EXPR1
     "expr", must be ground
EXPR2
     "expr", must be ground

Description
-----------

Evaluates EXPR1 and EXPR2 as arithmetic expressions and compares the
results.

Exceptions
----------

Arithmetic errors (*note ref-ari-exc::).

Examples
--------

     | ?- 23 + 2.2  <  23 - 2.2.

     yes
     | ?- X = 31, Y = 25, X + Y  <  X - Y

     no

See Also
--------

*note ref-ari::


File: sicstus.info,  Node: mpg-ref-library_directory,  Next: mpg-ref-line_count,  Prev: mpg-ref-less_than,  Up: mpg-bpr

11.3.113 'library_directory/1'   hook
-------------------------------------

Synopsis
--------

':- multifile user:library_directory/1.'

   'user:library_directory(+DIRSPEC)'

   Defines a library directory.  Used by predicates taking "file_spec"
as input argument.

Arguments
---------

DIRSPEC
     "file_spec"

     Either an atom giving the path to a file or directory, or
     PATHALIAS(DIRSPEC), where PATHALIAS is defined by a
     'file_search_path/2' rule.

Description
-----------

These facts define directories to search when a file specification
'library(FILE)' is expanded to the full path, in addition to the
predefined library path, which is tried first.

   The 'file_search_path' mechanism is an extension of the
'library_directory' scheme and is preferred.

Examples
--------

     | ?- [user].
     % compiling user...
     | :- multifile user:library_directory/1.
     | library_directory('/usr/joe_bob/prolog/libs').
     | end_of_file.
     % compiled user in module user, 0 msec 384 bytes
     yes
     | ?- ensure_loaded(library(flying)).
     % loading file /usr/joe_bob/prolog/libs/flying.qof
     ...

Exceptions
----------

All error handling is done by the predicates extended by this hook.

See Also
--------

'absolute_file_name/[2,3]', 'file_search_path/2', 'load_files/[1,2]',


File: sicstus.info,  Node: mpg-ref-line_count,  Next: mpg-ref-line_position,  Prev: mpg-ref-library_directory,  Up: mpg-bpr

11.3.114 'line_count/2'
-----------------------

Synopsis
--------

'line_count(+STREAM, -COUNT)'

   Obtains the total number of lines either input from or output to the
open text stream STREAM and unifies it with COUNT.

Arguments
---------

STREAM
     "stream_object", must be ground

     A valid open _text_ stream.

COUNT
     "integer"

     The resulting line count of the stream.

Description
-----------

A freshly opened stream has a line count of 0, i.e. this predicate
counts the number of newlines seen.  When a line is input from or output
to a non-interactive Prolog stream, the line count of the Prolog stream
is increased by one.  Line count for an interactive stream reflects the
total line input from or output to any interactive stream, i.e. all
interactive streams share the same counter.

   The count is reset by 'set_stream_position/2'.

Exceptions
----------

Stream errors (*note ref-iou-sfh-est::).

See Also
--------

'byte_count/2', 'character_count/2', 'line_position/2',
'stream_position/2', 'set_stream_position/2', *note ref-iou-sfh::.


File: sicstus.info,  Node: mpg-ref-line_position,  Next: mpg-ref-listing,  Prev: mpg-ref-line_count,  Up: mpg-bpr

11.3.115 'line_position/2'
--------------------------

Synopsis
--------

'line_position(+STREAM, -COUNT)'

   Obtains the total number of characters either input from or output to
the current line of the open text stream STREAM and unifies it with
COUNT.

Arguments
---------

STREAM
     "stream_object", must be ground

     A valid open _text_ stream.

COUNT
     "integer"

     The resulting line count of the stream.

Description
-----------

A fresh line has a line position of 0, i.e. this predicate counts the
length of the current line.  Line count for an interactive stream
reflects the total line input from or output to any interactive stream,
i.e. all interactive streams share the same counter.

   The count is reset by 'set_stream_position/2'.

Exceptions
----------

Stream errors (*note ref-iou-sfh-est::).

See Also
--------

'byte_count/2', 'character_count/2', 'line_count/2',
'stream_position/2', 'set_stream_position/2', *note ref-iou-sfh::.


File: sicstus.info,  Node: mpg-ref-listing,  Next: mpg-ref-load_files,  Prev: mpg-ref-line_position,  Up: mpg-bpr

11.3.116 'listing/[0,1]'
------------------------

Synopsis
--------

'listing'

   'listing(+PREDSPECS)'

   Prints the clauses of all the interpreted procedures currently in the
type-in module of the Prolog database, or of PREDSPECS, to the current
output stream, using 'portray_clause/1'.

Arguments
---------

:PREDSPECS
     "pred_spec_tree"

     A predicate specification, or a list of such.

Exceptions
----------

'type_error'
     PREDSPECS of the wrong type.

Examples
--------

You could list the entire program to a file using the command
     | ?- tell(file), listing, told.

   Note that 'listing/[0,1]' does not work on compiled procedures.

   'listing/1' is dependent on the source module.  As a special case,
     | ?- listing(mod:_).

   will list all the dynamic predicates in module mod.  However,
'listing/0' is not dependent on the source module; it refers instead to
the type-in module.

   Variables may be included in predicate specifications given to
'listing/1'.  For example, you can list clauses for 'f' in any current
module with:
     | ?- listing(_:f).

See Also
--------

*note ref-mod::.


File: sicstus.info,  Node: mpg-ref-load_files,  Next: mpg-ref-load_foreign_resource,  Prev: mpg-ref-listing,  Up: mpg-bpr

11.3.117 'load_files/[1,2]'
---------------------------

Synopsis
--------

'load_files(+FILES)'

   'load_files(+FILES, +OPTIONS)'

   '[+FILES]'

   Loads the specified Prolog source and/or object file(s) into memory.
Subsumes all other load predicates.

Arguments
---------

:FILES
     "file_spec" or "list of file_spec", must be ground

     A file specification or a list of file specifications; extensions
     optional.

OPTIONS
     "list of term", must be ground

     A list of zero or more options of the form:
     'if(X)'
          'true' (the default) to always load, or 'changed' to load only
          if the file has not yet been loaded or if it has been modified
          since it was last loaded.  A non-module-file is not considered
          to have been previously loaded if it was loaded into a
          different module.  The file specification 'user' is never
          considered to have been previously loaded.

     'when(WHEN)'
          'always' (the default) to always load, or 'compile_time' to
          load only if the goal is not in the scope of another
          'load_files/[1,2]' directive occurring in a PO file.

          The latter is intended for use when the file only defines
          predicates that are needed for proper term or goal expansion
          during compilation of other files.

     'load_type(LOADTYPE)'
          'source' to load source files only, 'object' to load object
          (PO) files only, or 'latest' (the default) to load any type of
          file, whichever is newest.  If the file specification is
          'user', then 'source' is forced.

     'imports(IMPORTS)'
          'all' (the default) to import all exported predicates if the
          file is a module-file, or a list of predicates to import.

     'compilation_mode(MODE)'
          'compile' to translate into compiled code, 'consult' to
          translate into static, interpreted code, or 'assert_all' to
          translate into dynamic, interpreted code.

          The default is the compilation mode of any ancestor
          'load_files/[1,2]' goal, or 'compile' otherwise.  Note that
          MODE has no effect when a PO file is loaded, and that it is
          recommended to use 'assert_all' in conjunction with
          'load_type(source)', to ensure that the source file will be
          loaded even in the presence of a PO file.

     In addition the 'open/4' options 'encoding/1',
     'encoding_signature/1' and 'eol/1' can be specified.  These will be
     used if the Prolog code is loaded from a source file.  *Note
     mpg-ref-open::, for details.

Description
-----------

'load_files/[1,2]' reads Prolog clauses, in source or precompiled form,
and adds them to the Prolog database, after first deleting any previous
versions of the predicates they define.  Clauses for a single predicate
must all be in the same file unless that predicate is declared to be
'multifile'.

   If a source file contains directives, that is, terms with principal
functor ':-/1' or '?-/1', then these are executed as they are
encountered.  Initialization goals specified with 'initialization/1' are
executed after the load.

   A non-module source file can be loaded into any module by
'load_files/[1,2]', but the module of the predicates in a precompiled
file is fixed at the time it is created.

Exceptions
----------

'instantiation_error'
     FILES or OPTIONS is not ground.

'type_error'
     In FILES or OPTIONS.

'domain_error'
     Illegal option in OPTIONS.

'existence_error'
     A specified file does not exist.  If the 'fileerrors' flag is
     'off', then the predicate fails instead of raising this exception.

'permission_error'
     A specified file not readable.  If the 'fileerrors' flag is 'off',
     then the predicate fails instead of raising this exception.

     While loading clauses from a PO file, clauses for an existing
     multifile predicate were encountered, but were compiled in a way
     different from the existing clauses.  In this case, the existing
     clauses remain untouched, the multifile clauses from the PO file
     are simply ignored, the load continues, and an exception is raised
     at the end.

Examples
--------

Several of the other built-in predicates of this category could be
defined in terms of 'load_files/2':

     [File|Files] :-
         load_files([File|Files]).

     consult(Files) :-
         load_files(Files, [load_type(source),compilation_mode(consult)]).

     ensure_loaded(Files) :-
             load_files(Files, [if(changed)]).

     use_module(File) :-
         load_files(File, [if(changed)]).

     use_module(File, Imports) :-
         load_files(File, [if(changed),imports(Imports)]).

   Code that is only needed at compile-time, e.g. for operator
declarations or compile-time expansion, is conveniently loaded with the
following idiom:

     :- load_files(library(obj_decl), [when(compile_time), if(changed)]).

See Also
--------

*note ref-lod-lod::.


File: sicstus.info,  Node: mpg-ref-load_foreign_resource,  Next: mpg-ref-member,  Prev: mpg-ref-load_files,  Up: mpg-bpr

11.3.118 'load_foreign_resource/1'   hookable
---------------------------------------------

Synopsis
--------

'load_foreign_resource(:RESOURCE)'

   Load the foreign resource RESOURCE into Prolog.  Relies on the hook
predicates 'foreign_resource/2' and 'foreign/[2,3]'.

Arguments
---------

:RESOURCE
     "file_spec", must be ground

     The foreign resource to be loaded.  The file extension can be
     omitted.

Description
-----------

'load_foreign_resource/1' takes a foreign resource and loads it into
Prolog.

   The extension can be omitted from the filename given in the RESOURCE
argument.

   Uses the 'foreign/[2,3]' and 'foreign_resource/2' facts defined by
the user to make the connection between a Prolog procedure and the
foreign function.  In this context, the "resource name" is derived from
RESOURCE name by deleting any leading path and extension from the
absolute file name of RESOURCE.

   When loading the foreign resource, it looks for a
'foreign_resource/2' fact for the resource name.  For each symbol in
that fact, it looks for a 'foreign/[2,3]' fact that gives the name of
the Prolog procedure associated with the foreign symbol and the argument
specification.

   Contrary to most hook predicates which reside in the 'user' module,
'load_foreign_resource/1' will look for 'foreign_resource/2' and
'foreign/[2,3]' facts defined in its source module.

   Foreign resources are created with the 'splfr' tool (*note The
Foreign Resource Linker::).

Exceptions
----------

Errors in the specification of 'foreign/[2,3]' and 'foreign_resource/2'
will all be reported when 'load_foreign_resource/1' is called.

'instantiation_error'
     RESOURCE not ground.

'type_error'
     RESOURCE not an atom, or argument of a declared fact of the wrong
     type.

'domain_error'
     Invalid argument of 'foreign/[2,3]' fact.

'existence_error'
     RESOURCE does not exist as a foreign resource, or RESOURCE does not
     have a 'foreign_resource/2' fact, or declared function does not
     exist, or declared function does not have a 'foreign/[2,3]' fact.

'domain_error'
     Invalid option to 'foreign_resource/2'.

'consistency_error'
     Function declared twice with clashing declarations.

'permission_error'
     Attempt to redefine built-in predicate.

Examples
--------

'library(codesio)' contains a foreign resource consisting of three
foreign functions, one init function, and one deinit function.  The
Prolog source file contains the following lines of code:

     :- dynamic foreign/2, foreign_resource/2.

     foreign(codes_to_stream, '$codes_to_stream'(+codes,-address('SP_stream'))).
     foreign(open_buf_stream, '$open_buf_stream'(-address('SP_stream'))).
     foreign(stream_to_codes, '$stream_to_codes'(+address('SP_stream'),-term,-term)).

     foreign_resource(codesio, [
             init(codesio_init),
             deinit(codesio_deinit),
             codes_to_stream,
             open_buf_stream,
             stream_to_codes
                               ]).

     :- load_foreign_resource(library(system(codesio))).

Comments
--------

Note that the foreign declarations are needed by other operations as
well and should *not* be abolished after loading the foreign resource.

See Also
--------

'unload_foreign_resource/1', 'foreign_resource/2', 'foreign/[2,3]',
*note Foreign Resources::, *note Calling C from Prolog::.


File: sicstus.info,  Node: mpg-ref-member,  Next: mpg-ref-memberchk,  Prev: mpg-ref-load_foreign_resource,  Up: mpg-bpr

11.3.119 'member/2'
-------------------

Synopsis
--------

'member(?ELEMENT, ?LIST)'

   is true if ELEMENT occurs in the LIST.  It may be used to test for an
element or to enumerate all the elements by backtracking.  Indeed, it
may be used to generate the LIST!

Arguments
---------

ELEMENT
     "term"

LIST
     "list of term"

Description
-----------

In the context of this predicate, a term occurs in a list if it can be
unified with an element of the list.

Backtracking
------------

On backtracking, an attempt is made to unify ELEMENT with successive
elements of LIST.  If LIST is not a proper list, then on backtracking it
is unified with lists of ever increasing length.

Examples
--------


     | ?- member(foo(X), [foo(1), bar(2), foo(3)]).
     X = 1 ? ;
     X = 3 ? ;
     no

Exceptions
----------

None.

See Also
--------

*note ref-lte-acl::, 'library(lists)'.


File: sicstus.info,  Node: mpg-ref-memberchk,  Next: mpg-ref-message_hook,  Prev: mpg-ref-member,  Up: mpg-bpr

11.3.120 'memberchk/2'
----------------------

Synopsis
--------

'memberchk(?ELEMENT, ?LIST)'

   is true if the given ELEMENT occurs in the given LIST.  Its purpose
is to test for membership.  Normally, the two arguments are ground.

Arguments
---------

ELEMENT
     "term"

LIST
     "list of term"

Description
-----------

In the context of this predicate, a term occurs in a list if it can be
unified with an element of the list.

Backtracking
------------

The predicate is determinate and commits to the first successful
unification, if any.

Examples
--------


     | ?- memberchk(bar, [foo,bar,baz]).
     yes

Exceptions
----------

None.

See Also
--------

*note ref-lte-acl::, 'library(lists)'.


File: sicstus.info,  Node: mpg-ref-message_hook,  Next: mpg-ref-meta_predicate,  Prev: mpg-ref-memberchk,  Up: mpg-bpr

11.3.121 'message_hook/3'   hook
--------------------------------

Synopsis
--------

':- multifile user:message_hook/3.'

   'user:message_hook(+SEVERITY, +MESSAGETERM, +LINES)'

   Overrides the call to 'print_message_lines/3' in 'print_message/2'.
A way for the user to intercept the MESSAGE of type SEVERITY, whose
translations is LINES, before it is actually printed.

Arguments
---------

SEVERITY
     "one of '[informational,warning,error,help,silent]'"

MESSAGETERM
     "term"

LINES
     "list of list of pair"

     Is of the form '[LINE1, LINE2, ...]', where each LINEI is of the
     form '[CONTROL_1-ARGS_1,CONTROL_2-ARGS_2, ...]'.

Description
-----------

After a message is parsed, but before the message is written,
'print_message/2' calls

     user:message_hook(+Severity,+MsgTerm,+Lines)

   If the call to 'user:message_hook/3' succeeds, then 'print_message/2'
succeeds without further processing.  Otherwise the built-in message
portrayal is used.  It is often useful to have a message hook that
performs some action and then fails, allowing other message hooks to
run, and eventually allowing the message to be printed as usual.

Exceptions
----------

An exception raised by this predicate causes an error message to be
printed and then the original message is printed using the default
message text and formatting.

See Also
--------

*note ref-msg::.


File: sicstus.info,  Node: mpg-ref-meta_predicate,  Next: mpg-ref-mode,  Prev: mpg-ref-message_hook,  Up: mpg-bpr

11.3.122 'meta_predicate/1'   declaration
-----------------------------------------

Synopsis
--------

':- meta_predicate +METASPEC'

   Provides for module name expansion of arguments in calls to the
predicate given by METASPEC.  All 'meta_predicate/1' declarations should
be at the beginning of a module.

Arguments
---------

:METASPEC
     "callable", must be ground

     Goal template or list of goal templates, of the form 'functor(ARG1,
     ARG2,...)'.  Each ARGN is one of:

     ':'
          requires module name expansion

          If the argument will be treated as a goal, then it is better
          to explicitly indicate this using an integer, see the next
          item.

     NSUPPRESSED
          a non-negative integer.

          This is a special case of ':' that means that the argument can
          be made into a goal by adding NSUPPRESSED additional
          arguments.  E.g., if the argument will be passed to 'call/1',
          then '0' (zero) should be used.

          As another example, the meta_predicate declaration for the
          built-in 'call/3' would be ':- meta_predicate call(2,?,?)',
          since 'call/3' will add two arguments to its first argument in
          order to to construct the goal to invoke.

          An integer is treated the same as ':' above by the SICStus
          runtime.  Other tools, such as the cross referencer (*note The
          Cross-Referencer::) and the SICStus Prolog IDE (*note SICStus
          Prolog IDE: SPIDER.), will use this information to better
          follow predicate references in analyzed source code.

     '*'
     '+'
     '-'
     '?'
          ignored

Exceptions
----------

Exceptions in the context of loading code are printed as error messages.

'instantiation_error'
     METASPEC not ground.

'type_error'
     METASPEC not a valid specification.

'context_error'
     Declaration appeared in a goal.

'permission_error'
     Declaration appeared as a clause.

Examples
--------

Consider a sort routine, 'mysort/3', to which the name of the comparison
predicate is passed as an argument:
     mysort(LESSTHANOREQUAL, INPUTLIST, OUTPUTLIST) :-
        ...
        %% LessThanOrEqual is called exactly like the built-in @=</2
        ( call(LessThanOrEqual, Term1, Term2) -> ... ; ... ),
        ...

   An appropriate 'meta_predicate' declaration for 'mysort/3' is:
     :- meta_predicate mysort(2, +, -).

since the first argument, LESSTHANOREQUAL, will have two additional
arguments added to it (by 'call/3') when invoked.

   This means that whenever a goal 'mysort(A, B, C)' appears in a
clause, it will be transformed at load time into 'mysort(M:A, B, C)',
where M is the source module.  The transformation will happen unless:

  1. A has an explicit module prefix, or
  2. A is a variable and the same variable appears in the head of the
     clause in a module-name-expansion position.

See Also
--------

*note Meta-Predicate Declarations::, *note ref-mod-mne::.


File: sicstus.info,  Node: mpg-ref-mode,  Next: mpg-ref-module,  Prev: mpg-ref-meta_predicate,  Up: mpg-bpr

11.3.123 'mode/1'   declaration
-------------------------------

Synopsis
--------

':- mode +MODE'

   Currently a dummy declaration.

Arguments
---------

:MODE
     "term"

Exceptions
----------

Exceptions in the context of loading code are printed as error messages.

'context_error'
     Declaration appeared in a goal.

'permission_error'
     Declaration appeared as a clause.

See Also
--------

*note Mode Declarations::.


File: sicstus.info,  Node: mpg-ref-module,  Next: mpg-ref-multifile,  Prev: mpg-ref-mode,  Up: mpg-bpr

11.3.124 'module/[2,3]'   declaration
-------------------------------------

Synopsis
--------

':- module(+MODULENAME, +PUBLICPRED)'.

   ':- module(+MODULENAME, +PUBLICPRED, +OPTIONS)'.

   Declares the file in which the declaration appears to be a
module-file named MODULENAME, with public predicates PUBLICPRED.  Must
appear as the first term in the file.

Arguments
---------

MODULENAME
     "atom", must be nonvar

PUBLICPRED
     "list of simple_pred_spec", must be ground

     List of predicate specifications of the form NAME/ARITY.

OPTIONS
     "list of term", must be ground

     A list of zero or more options of the form:

     'hidden(BOOLEAN)'
          BOOLEAN is 'false' (the default) or 'true'.  In the latter
          case, tracing of the predicates of the module is disabled
          (although spypoints can be set), and no source information is
          generated at compile time.

Description
-----------

The definition of a module is not limited to a single file, because a
module-file may contain commands to load other files.  If 'myfile', a
module-file for MODULENAME, contains an embedded command to load
'yourfile' and if 'yourfile' is not itself a module-file, then all the
predicates in 'yourfile' are loaded into module MODULENAME.

Exceptions
----------

Exceptions in the context of loading code are printed as error messages.

'instantiation_error'
     Declaration not ground.

'type_error'
     An argument has the wrong type.

'domain_error'
     Some arity is an integer < 0, or invalid option given.

'representation_error'
     Some arity is an integer > 255.

'context_error'
     Declaration appeared in a goal, or not first in the file being
     loaded.

'permission_error'
     Declaration appeared as a clause.

Examples
--------

A module declaration from the Prolog library:

     :- module(varnumbers, [
     	numbervars/1,
     	varnumbers/2,
     	varnumbers/3
        ],[
     	hidden(true)
        ]).

See Also
--------

*note Module Declarations::, *note ref-mod::.


File: sicstus.info,  Node: mpg-ref-multifile,  Next: mpg-ref-mutable,  Prev: mpg-ref-module,  Up: mpg-bpr

11.3.125 'multifile/1'   declaration, ISO
-----------------------------------------

Synopsis
--------

':- multifile +PREDSPECS'

   Declares the clauses of the predicates defined by PREDSPECS to be
multifile in the source file (suppresses compile-time warnings).

Arguments
---------

:PREDSPECS
     "pred_spec_forest", must be ground

     A predicate specification, or a list of such, or a sequence of such
     separated by commas.

Description
-----------

By default, all clauses for a predicate are expected to come from just
one file.  This assists with reloading and debugging of code.  Declaring
a predicate 'multifile' means that its clauses can be spread across
several different files.  This is independent of whether or not the
predicate is declared 'dynamic'.

   Should precede all the clauses for the specified predicates in the
file.

   There should be a 'multifile' declaration for a predicate P in every
file that contains clauses for P.  If a 'multifile' predicate is
dynamic, then there should be a 'dynamic' declaration in every file
containing clauses for the predicate.

   When a file containing clauses for a 'multifile' predicate (P) is
reloaded, the clauses for P that previously came from that file are
removed.  Then the new clauses for P (which may be the same as the old
ones) are added to the end of the definition of the 'multifile'
predicate.

   If a 'multifile' declaration is found for a predicate that has
already been defined in another file (without a 'multifile'
declaration), then this is considered to be a redefinition of that
predicate.  Normally this will result in a multiple-definition
style-check warning (see 'style_check/1').

   The predicate 'source_file/2' can be used to find all the files
containing clauses for a 'multifile' predicate.

Comments
--------

'multifile' is not an ISO predefined prefix operator.

Exceptions
----------

Exceptions in the context of loading code are printed as error messages.

'instantiation_error'
     PREDSPECS not ground.

'type_error'
     PREDSPECS not a valid "pred_spec_forest".

'domain_error'
     Some arity is an integer < 0.

'representation_error'
     Some arity is an integer > 255.

'context_error'
     Declaration appeared in a goal.

'permission_error'
     Declaration appeared as a clause.

See Also
--------

*note Multifile Declarations::.


File: sicstus.info,  Node: mpg-ref-mutable,  Next: mpg-ref-name,  Prev: mpg-ref-multifile,  Up: mpg-bpr

11.3.126 'mutable/1'
--------------------

Synopsis
--------

'mutable(+TERM)'

   Succeeds if TERM is currently instantiated to a mutable term.

Arguments
---------

TERM
     "term"

Exceptions
----------

None.

See Also
--------

*note ref-lte-met-typ::, *note ref-lte-mut::.


File: sicstus.info,  Node: mpg-ref-name,  Next: mpg-ref-nl,  Prev: mpg-ref-mutable,  Up: mpg-bpr

11.3.127 'name/2'   deprecated
------------------------------

Synopsis
--------

'name(+CONSTANT, -CODES)'

   'name(-CONSTANT, +CODES)'

   CODES is the list consisting of the "codes" comprising the printed
representation of CONSTANT.

Arguments
---------

CONSTANT
     "atomic"

CODES
     "codes"

Description
-----------

Initially, either CONSTANT must be instantiated to a number or an atom,
or CODES must be instantiated to a proper "codes".

   If CODES is instantiated to a proper "codes" that corresponds to the
correct syntax of a number, then CONSTANT will be unified with that
number.

   Else if CODES is instantiated to a proper "codes", then CONSTANT will
be unified with the atom containing exactly those characters.

   Else, CONSTANT should be instantiated to a number or atom, and CODES
will be unified with the "codes" that make up its printed
representation.

   There are atoms for which 'name(CONSTANT,CODES)' is true, but which
will not be constructed if 'name/2' is called with CONSTANT
uninstantiated.  One such atom is the atom ''1976''.  It is recommended
that new programs use 'atom_codes/2' or 'number_codes/2', as these
predicates do not have this ambiguity.

Exceptions
----------

'instantiation_error'
     CONSTANT is uninstantiated and CODES is not instantiated enough

'type_error'
     If CONSTANT is a compound term

'representation_error'
     An element of CODES is an invalid character code, or CODES is a
     list corresponding to a number or atom that can't be represented

Examples
--------

     | ?- name(foo, L).

     L = [102,111,111]

     | ?- name('Foo', L).

     L = [70,111,111]

     | ?- name(431, L).

     L = [52,51,49]

     | ?- name(X, [102,111,111]).

     X = foo

     | ?- name(X, [52,51,49]).

     X = 431

     | ?- name(X, "15.0e+12").

     X = 1.5E+13

See Also
--------

*note ref-lte-c2t::.


File: sicstus.info,  Node: mpg-ref-nl,  Next: mpg-ref-nodebug,  Prev: mpg-ref-name,  Up: mpg-bpr

11.3.128 'nl/[0,1]'   ISO
-------------------------

Synopsis
--------

'nl'

   'nl(+STREAM)'

   Terminates the current output record on the current output stream or
on STREAM.

Arguments
---------

STREAM
     "stream_object", must be ground

     A valid output _text_ stream, defaults to the current output
     stream.

Exceptions
----------

Stream errors (*note ref-iou-sfh-est::).

See Also
--------

*note ref-iou-cou::.


File: sicstus.info,  Node: mpg-ref-nodebug,  Next: mpg-ref-nonmember,  Prev: mpg-ref-nl,  Up: mpg-bpr

11.3.129 'nodebug/0'   development
----------------------------------

Synopsis
--------

'nodebug'

   Turns the debugger off.

Exceptions
----------

None.

See Also
--------

*note Basic Debug::.


File: sicstus.info,  Node: mpg-ref-nonmember,  Next: mpg-ref-nonvar,  Prev: mpg-ref-nodebug,  Up: mpg-bpr

11.3.130 'nonmember/2'
----------------------

Synopsis
--------

'nonmember(?ELEMENT, ?LIST)'

   is true if the given ELEMENT does not occur in the given LIST.  Its
purpose is to test for membership.  Normally, the two arguments are
ground.

Arguments
---------

ELEMENT
     "term"

LIST
     "list of term"

Description
-----------

In the context of this predicate, a term occurs in a list if it can be
unified with an element of the list.

Backtracking
------------

The predicate is determinate and either succeeds or fails.  It never
binds variables.

Examples
--------


     | ?- nonmember(bar, [foo,bar,baz]).
     no

Exceptions
----------

None.

See Also
--------

*note ref-lte-acl::, 'library(lists)'.


File: sicstus.info,  Node: mpg-ref-nonvar,  Next: mpg-ref-nospy,  Prev: mpg-ref-nonmember,  Up: mpg-bpr

11.3.131 'nonvar/1'   ISO
-------------------------

Synopsis
--------

'nonvar(+TERM)'

   TERM is currently instantiated.

Arguments
---------

TERM
     "term"

Examples
--------

     | ?- nonvar(foo(X,Y)).

     true ;
     no
     | ?- nonvar([X,Y]).

     true ;
     no
     | ?- nonvar(X).

     no
     | ?- Term = foo(X,Y), nonvar(Term).

     true ;
     no

Exceptions
----------

None.

See Also
--------

*note ref-lte-met-typ::.


File: sicstus.info,  Node: mpg-ref-nospy,  Next: mpg-ref-nospyall,  Prev: mpg-ref-nonvar,  Up: mpg-bpr

11.3.132 'nospy/1'   development
--------------------------------

Synopsis
--------

'nospy +PREDSPECS'

   Any spypoints (plain and conditional) on the predicates represented
by PREDSPECS are removed.

Arguments
---------

:PREDSPECS
     "pred_spec_tree"

     A predicate specification, or a list of such.

Exceptions
----------

'instantiation_error'
'type_error'
'domain_error'
     if a PREDSPEC is not a valid procedure specification

See Also
--------

*note Basic Debug::, *note Plain Spypoint::.


File: sicstus.info,  Node: mpg-ref-nospyall,  Next: mpg-ref-not_equal_to,  Prev: mpg-ref-nospy,  Up: mpg-bpr

11.3.133 'nospyall/0'   development
-----------------------------------

Synopsis
--------

'nospyall'

   Removes all the spypoints (including the generic ones) that have been
set.

Exceptions
----------

None.

See Also
--------

*note Basic Debug::.


File: sicstus.info,  Node: mpg-ref-not_equal_to,  Next: mpg-ref-not_greater_than,  Prev: mpg-ref-nospyall,  Up: mpg-bpr

11.3.134 '=\=/2'   ISO
----------------------

Synopsis
--------

+EXPR1 '=\=' +EXPR2

   Succeeds if the results of evaluating EXPR1 and EXPR2 are _not
equal_.

Arguments
---------

EXPR1
     "expr", must be ground
EXPR2
     "expr", must be ground

Description
-----------

Evaluates EXPR1 and EXPR2 as arithmetic expressions and compares the
results.

Exceptions
----------

Arithmetic errors (*note ref-ari-exc::).

Examples
--------

     | ?- 7 =\= 14/2.

     no

     | ?- 7 =\= 15/2.

     yes

See Also
--------

*note ref-ari::


File: sicstus.info,  Node: mpg-ref-not_greater_than,  Next: mpg-ref-not_less_than,  Prev: mpg-ref-not_equal_to,  Up: mpg-bpr

11.3.135 '=</2'   ISO
---------------------

Synopsis
--------

+EXPR1 '=<' +EXPR2

   Succeeds if the result of evaluating EXPR1 is _less than or equal_ to
the result of evaluating EXPR2.

Arguments
---------

EXPR1
     "expr", must be ground
EXPR2
     "expr", must be ground

Description
-----------

Evaluates EXPR1 and EXPR2 as arithmetic expressions and compares the
results.

Exceptions
----------

Arithmetic errors (*note ref-ari-exc::).

Examples
--------

     | ?- 42 =< 42.

     yes

     | ?- "b" =< "a".

     no

Comments
--------

Note that the symbol '=<' is used here rather than '<=', which is used
in some other languages.  One way to remember this is that the
inequality symbols in Prolog are the ones that cannot be thought of as
looking like arrows.  The '<' or '>' always points at the '='.

See Also
--------

*note ref-ari::


File: sicstus.info,  Node: mpg-ref-not_less_than,  Next: mpg-ref-not_provable,  Prev: mpg-ref-not_greater_than,  Up: mpg-bpr

11.3.136 '>=/2'   ISO
---------------------

Synopsis
--------

+EXPR1 '>=' +EXPR2

   Succeeds if the results of evaluating EXPR1 and EXPR2 _are equal_.

Arguments
---------

EXPR1
     "expr", must be ground
EXPR2
     "expr", must be ground

Description
-----------

Succeeds if the result of evaluating EXPR1 is _greater than or equal to_
the result of evaluating EXPR2.

Exceptions
----------

Arithmetic errors (*note ref-ari-exc::).

Examples
--------

     | ?- 42 >= 42.

     yes

     | ?- "b" >= "a".

     yes

See Also
--------

*note ref-ari::


File: sicstus.info,  Node: mpg-ref-not_provable,  Next: mpg-ref-not_unifiable,  Prev: mpg-ref-not_less_than,  Up: mpg-bpr

11.3.137 '\+/1'   ISO
---------------------

Synopsis
--------

'\+' +P

   Fails if the goal P has a solution, and succeeds otherwise.
Equivalent to:

     call(P) -> fail ; true.
except that the use of 'call/1' often can be avoided.

Arguments
---------

:P
     "callable", must be nonvar

Description
-----------

This is not normally regarded as a built-in predicate, since it is part
of the syntax of the language.  However, it is like a built-in predicate
in that you can say 'call((\+ P))'.

   Cuts in P do not make sense, but are allowed, their scope being the
goal P.

Comments
--------

Remember that with prefix operators such as this one it is necessary to
be careful about spaces if the argument starts with a '('.  For example:

     | ?- \+ (P,Q).

is this operator applied to the conjunction of P and Q, but

     | ?- \+(P,Q).

would require a predicate '\+ /2' for its solution.  The prefix operator
can however be written as a functor of one argument; thus

     | ?- \+((P,Q)).

is also correct.

Exceptions
----------

Call errors (*note ref-sem-exc::).

See Also
--------

*note ref-sem::.


File: sicstus.info,  Node: mpg-ref-not_unifiable,  Next: mpg-ref-notrace,  Prev: mpg-ref-not_provable,  Up: mpg-bpr

11.3.138 '\=/2'   ISO
---------------------

Synopsis
--------

+TERM1 '\=' +TERM2

   TERM1 and TERM2 do not unify.

Arguments
---------

TERM1
     "term"
TERM2
     "term"

Description
-----------

The same as '\+ X = Y'; i.e. X and Y are not unifiable.

Exceptions
----------

None.

See Also
--------

*note Glossary::.


File: sicstus.info,  Node: mpg-ref-notrace,  Next: mpg-ref-nozip,  Prev: mpg-ref-not_unifiable,  Up: mpg-bpr

11.3.139 'notrace/0'   development
----------------------------------

Synopsis
--------

'notrace'

   Turns the debugger off.

Exceptions
----------

None.

See Also
--------

*note Basic Debug::.


File: sicstus.info,  Node: mpg-ref-nozip,  Next: mpg-ref-number,  Prev: mpg-ref-notrace,  Up: mpg-bpr

11.3.140 'nozip/0'   development
--------------------------------

Synopsis
--------

'nozip'

   Turns the debugger off.

Exceptions
----------

None.

See Also
--------

*note Basic Debug::.


File: sicstus.info,  Node: mpg-ref-number,  Next: mpg-ref-number_chars,  Prev: mpg-ref-nozip,  Up: mpg-bpr

11.3.141 'number/1'   ISO
-------------------------

Synopsis
--------

'number(+TERM)'

   TERM is currently instantiated to a number.

Arguments
---------

TERM
     "term"

Examples
--------

     | ?- number(5.2).

     yes
     | ?- number(5).

     yes

Exceptions
----------

None.

See Also
--------

*note ref-lte-met-typ::.


File: sicstus.info,  Node: mpg-ref-number_chars,  Next: mpg-ref-number_codes,  Prev: mpg-ref-number,  Up: mpg-bpr

11.3.142 'number_chars/2'   ISO
-------------------------------

Synopsis
--------

'number_chars(+NUMBER, -CHARS)'

   'number_chars(-NUMBER, +CHARS)'

   CHARS is the "chars" comprising the printed representation of NUMBER.

Arguments
---------

NUMBER
     "number"

CHARS
     "chars"

Description
-----------

Initially, either NUMBER must be instantiated to a number, or CHARS must
be instantiated to a proper "chars".

   If CHARS is instantiated to a "chars" that corresponds to the correct
syntax of a number, then NUMBER will be unified with that number.

   Else, NUMBER should be instantiated to a number, and CHARS will be
unified with the "chars" that make up its printed representation.

Exceptions
----------

'instantiation_error'
     NUMBER is uninstantiated and CHARS is not instantiated enough

'type_error'
     NUMBER is not a number or CHARS cannot be unified with a "chars"

'representation_error'
     CHARS is a list corresponding to a number that can't be represented

'syntax_error'
     CHARS does not correspond to a syntactically valid number

   The check of CHARS when NUMBER is instantiated was added in release
4.3 for alignment with the ISO Prolog standard.  Previous releases
simply failed in this case instead of reporting an error for malformed
CHARS.

See Also
--------

'number_codes/2'.


File: sicstus.info,  Node: mpg-ref-number_codes,  Next: mpg-ref-numbervars,  Prev: mpg-ref-number_chars,  Up: mpg-bpr

11.3.143 'number_codes/2'   ISO
-------------------------------

Synopsis
--------

'number_codes(+NUMBER, -CODES)'

   'number_codes(-NUMBER, +CODES)'

   CODES is the "codes" comprising the printed representation of NUMBER.

Arguments
---------

NUMBER
     "number"

CODES
     "codes"

Description
-----------

Initially, either NUMBER must be instantiated to a number, or CODES must
be instantiated to a proper "codes".

   If CODES is instantiated to a "codes" that corresponds to the correct
syntax of a number, then NUMBER will be unified with that number.

   Else, NUMBER should be instantiated to a number, and CODES will be
unified with the "codes" that make up its printed representation.

Exceptions
----------

'instantiation_error'
     NUMBER is uninstantiated and CHARS is not instantiated enough

'type_error'
     NUMBER is not a number or CODES cannot be unified with a list of
     integers

'representation_error'
     An element of CODES is an invalid character code, or CODES is a
     list corresponding to a number that can't be represented

'syntax_error'
     CODES does not correspond to a syntactically valid number

   The check of CODES when NUMBER is instantiated was added in release
4.3 for alignment with the ISO Prolog standard.  Previous releases
simply failed in this case instead of reporting an error for malformed
CODES.

Examples
--------

     | ?- number_codes(foo, L).

     ! Type error in argument 1 of number_codes/2
     ! expected a number, but found foo
     ! goal:  number_codes(foo,_104)

     | ?- number_codes(431, L).

     L = [52,51,49]

     | ?- number_codes(X, [102,111,111]).

     ! Syntax error in number_codes/2
     ! number syntax
     ! in line 0

     | ?- number_codes(X, [52,51,49]).

     X = 431

     | ?- number_codes(X, "15.0e+12").

     X = 1.5E+13

See Also
--------

'number_chars/2'.


File: sicstus.info,  Node: mpg-ref-numbervars,  Next: mpg-ref-on_exception,  Prev: mpg-ref-number_codes,  Up: mpg-bpr

11.3.144 'numbervars/3'
-----------------------

Synopsis
--------

'numbervars(+TERM, +FIRSTVAR, -LASTVAR)'

   instantiates each of the variables in TERM to a term of the form
''$VAR'(N)'.

Arguments
---------

TERM
     "term"

FIRSTVAR
     "integer", must be nonvar

LASTVAR
     "integer"

Description
-----------

FIRSTVAR is used as the value of N for the first variable in TERM
(starting from the left).  The second distinct variable in TERM is given
a value of N satisfying "N is FIRSTVAR+1"; the third distinct variable
gets the value FIRSTVAR+2, and so on.  The last variable in TERM has the
value LASTVAR-1.

   Notice that in the example below, 'write_canonical/1' is used rather
than 'writeq/1'.  This is because 'writeq/1' treats terms of the form
''$VAR'(N)' specially; it writes 'A' if N=0, 'B' if N=1, ...'Z' if N=25,
'A1' if N=26, etc.  That is why, if you type the goal in the example
below, then the variable bindings will also be printed out as follows:

     Term = foo(W,W,X),
     A = W,
     B = X

Exceptions
----------

'instantiation_error'
     FIRSTVAR is uninstantiated

'type_error'
     FIRSTVAR is not an integer

Examples
--------

     | ?- Term = foo(A, A, B), numbervars(Term, 22, _), write_canonical(Term).
     foo('$VAR'(22),'$VAR'(22),'$VAR'(23))

See Also
--------

*note ref-lte-anv::, 'write_term/[2,3]'.


File: sicstus.info,  Node: mpg-ref-on_exception,  Next: mpg-ref-once,  Prev: mpg-ref-numbervars,  Up: mpg-bpr

11.3.145 'on_exception/3'
-------------------------

Synopsis
--------

'on_exception(-EXCEPTION, +PROTECTEDGOAL, +HANDLER)'

   same as:

   'catch(PROTECTEDGOAL, EXCEPTION, HANDLER)'

   Specify an exception handler for PROTECTEDGOAL, and call
PROTECTEDGOAL, as described in *note ref-ere::.

Arguments
---------

EXCEPTION
     "term"

:PROTECTEDGOAL
     "callable", must be nonvar

:HANDLER
     "callable", must be nonvar

Examples
--------

Fail on exception:
     :- meta_predicate fail_on_exception(0).
     fail_on_exception(C):-
         on_exception(E, C, print_exception_then_fail(C, E)).

     print_exception_then_fail(C, E):-
         format(user_error, 'Exception occured while calling ~q:~n', [C]),
         print_message(warning, E),
         fail.

Backtracking
------------

Depends on PROTECTEDGOAL and HANDLER.

Exceptions
----------

None.

See Also
--------

*note ref-ere::.


File: sicstus.info,  Node: mpg-ref-once,  Next: mpg-ref-op,  Prev: mpg-ref-on_exception,  Up: mpg-bpr

11.3.146 'once/1'   ISO
-----------------------

Synopsis
--------

'once(+P)'

   Equivalent to:

     call(P) -> true ; fail.
except that the use of 'call/1' often can be avoided.

Arguments
---------

:P
     "callable", must be nonvar

   Cuts in P do not make sense, but are allowed, their scope being the
goal P.

Exceptions
----------

Call errors (*note ref-sem-exc::).

See Also
--------

*note ref-sem::.


File: sicstus.info,  Node: mpg-ref-op,  Next: mpg-ref-open,  Prev: mpg-ref-once,  Up: mpg-bpr

11.3.147 'op/3'   ISO
---------------------

Synopsis
--------

'op(+PRECEDENCE, +TYPE, +NAME)'

   declares NAME to be an operator of the stated TYPE and PRECEDENCE.

Arguments
---------

PRECEDENCE
     "integer", must be nonvar and in the range 1-1200

TYPE
     "one of '[xfx,xfy,yfx,fx,fy,xf,yf]'", must be nonvar

NAME
     "atom" or "list of atom", must be ground

Description
-----------

Operators are a notational convenience to read and write Prolog terms.
You can define new operators using 'op/3'.

   The PRECEDENCE of an operator is used to disambiguate the way terms
are parsed.  The general rule is that the operator with the highest
precedence is the principal functor.

   The TYPE of an operator decides the position of an operator and its
associativity.  In the atom that represents the type the character 'f'
represents the position of the operator.  For example, a type 'fx' says
that the operator is a prefix operator.  The character 'y' indicates
that the operator is associative in that direction.  For example, an
operator of type 'xfy' is a right-associative, infix operator.

   To cancel the operator properties of NAME (if any) set PRECEDENCE to
0.

   *Please note*: operators are _global_, as opposed to being local to
the current module, Prolog text, or otherwise.

Exceptions
----------

'instantiation_error'
     An argument is not ground

'type_error'
     PRECEDENCE is not an integer or TYPE is not an integer or an
     operator is not an atom

'domain_error'
     PRECEDENCE is not in the range 1-1200, or TYPE is invalid,

'permission_error'
     Attempt to redefine the operator '',''

See Also
--------

'current_op/3', *note ref-syn-ops::.


File: sicstus.info,  Node: mpg-ref-open,  Next: mpg-ref-open_null_stream,  Prev: mpg-ref-op,  Up: mpg-bpr

11.3.148 'open/[3,4]'   ISO
---------------------------

Synopsis
--------

'open(+FILESPEC, +MODE, -STREAM)'

   'open(+FILESPEC, +MODE, -STREAM, +OPTIONS)'

   Creates a Prolog stream by opening the file FILESPEC in mode MODE
with options OPTIONS.

Arguments
---------

FILESPEC
     "file_spec", must be ground

     A file specification.

MODE
     "one of '[read,write,append]'", must be nonvar

     An atom specifying the open mode of the target file.  One of:

     'read'
          open FILESPEC for input.

     'write'
          open FILESPEC for output.  A new file is created if FILESPEC
          does not exist.  If the file already exists, then it is set to
          empty and its previous contents are lost.

     'append'
          opens FILESPEC for output.  If FILESPEC already exists, then
          it adds output to the end of it.  If not, then a new file is
          created, as for the 'write' mode.

OPTIONS
     "list of term", must be ground

     A list of zero or more of the following.

     'type(+T)'
          Specifies whether the stream is a 'text' or 'binary' stream.
          Default is 'text'.

     'reposition(+BOOLEAN)'
          Specifies whether repositioning is required for the stream
          ('true'), or not ('false').  The latter is the default.

          For text streams 'reposition(true)' affects the default
          'eol/1' and 'encoding_signature/1' options, see below.  Also,
          not all encodings supports this option (*note
          ref-iou-sfh-enc::).

     'alias(+A)'
          Specifies that the atom A is to be an alias for the stream.

     'eof_action(+ACTION)'
          Specifies what action is to be taken when the end of stream
          has already been reported (by returning -1 or 'end_of_file'),
          and a further attempt to input is made.  ACTION can have the
          following values:

          'error'
               An exception is raised.  This is the default.

          'eof_code'
               An end of stream indicator (-1 or 'end_of_file') is
               returned again.

          'reset'
               The stream is considered not to be past end of stream and
               another attempt is made to input from it.

     'encoding(ENCODING)'

          Specifies the encoding to use if the stream is opened in text
          mode, as an atom.  The default is ''ISO-8859-1'', the 8 bit
          subset of UNICODE, i.e. "ISO-8859-1" (Latin 1) (*note
          ref-iou-sfh-enc::).

          Overridden by the 'encoding_signature/1' option, see below.

     'encoding_signature(+BOOLEAN)'

          Specifies whether an encoding signature should be used
          ('true'), or not ('false').  An encoding signature is a
          special byte sequence that identifies the encoding used in the
          file.  The most common case is one of the Unicode signatures,
          often called "byte order mark" (BOM).

          A Unicode signature is a special byte sequence that can be
          used to distinguish between several UTF encoding variants,
          such as "UTF-8", "UTF-16-BE" and "UTF-16-LE".

          If 'reposition(true)' is specified, then
          'encoding_signature/1' defaults to 'false' for both streams
          opened in write mode and streams opened in read mode.

          If 'reposition(true)' is not specified, and if the file is
          opened in mode read, then 'encoding_signature/1' defaults to
          'true'.

          When 'encoding_signature/1' option is 'true' additional
          heuristics will be used if no Unicode signature is detected.
          Only if neither a Unicode signature nor these heuristics
          specifies a character encoding will the 'encoding/1' option,
          if any, be used.

          The method used for selecting character encoding when a text
          file is opened in mode 'read' is the first applicable item in
          the following list:

            1. If the 'encoding_signature/1' option is 'true': If a byte
               order mark is detected, then it will be used to select
               between the encodings "UTF-8", "UTF-16" or "UTF-32" with
               suitable endianess.

            2. If the 'encoding_signature/1' option is 'true': If an
               Emacs style '-*- coding: CODING-SYSTEM-*-' is present on
               the first non-empty line of the file, then it will be
               used.

            3. If an option 'encoding(ENCODING)' Is supplied, then the
               specified encoding will be used.

            4. As a final fallback, "ISO-8859-1" (Latin 1) will be used.

          the character encoding selected in this way will be used if it
          is recognized, otherwise an error exception is raised.

          If 'reposition(true)' is not specified, and if the file is
          opened in mode write, then it depends on the character
          encoding whether an encoding signature will be output by
          default or not.  If you want to force an encoding signature to
          be output for those encodings that supports it, then you can
          specify 'encoding_signature(true)'.  Conversely, if you want
          to prevent an encoding signature from being output, then you
          can explicitly specify 'encoding_signature(false)'.

          All UTF encodings supports an encoding signature in the form
          of a BOM. "UTF-8" does not write a BOM unless you explicitly
          specify 'encoding_signature(true)', the 16 and 32 bit UTF
          encodings, e.g.  "UTF-16 BE", "UTF-32 LE" writes a BOM unless
          explicitly requested not to with 'encoding_signature(false)'.

          If the file is opened in mode append, then
          'encoding_signature/1' defaults to 'false'.

     'eol(EOL)'
          Specifies how line endings in the file should be handled if
          the stream is opened in text mode.

          In Prolog code, end of line is always represented by the
          character ''\n'', which has character code 10, i.e. the same
          as ASCII Line Feed (<LFD>).  The representation in the file
          may be different, however.

          EOL can have the following values:

          'lf'
               Line Feed ('LF', character code 10) is used to specify a
               end of line.  This can be used for both read mode and
               write mode streams.

          'crlf'
               A two character sequence Carriage Return ('CR', character
               code 13) followed by Line Feed ('LF', character code 10)
               is used to specify a end of line.  This can be used for
               both read mode and write mode streams.

          'auto'
               Translate both the two character sequence 'CR' 'LF' and
               single 'CR' or 'LF' into an end of line character.  This
               can be used only for read mode streams.

          'default'
               Use a default end of line convention.  This is the
               default.

               If 'reposition(true)' is specified, then this uses 'lf'
               for both streams opened in write mode and streams opened
               in read mode, on all platforms.

               If 'reposition(true)' is not specified, then under UNIX,
               this uses 'lf' for streams opened in write mode and
               'auto' for streams opened in read mode.  Under Windows,
               this uses 'crlf' for streams opened in write mode and
               'auto' for streams opened in read mode.  This can be used
               for both read mode and write mode streams.

     'if_exists(+ACTION)'
          Specifies what should happen if the file already exists.  Only
          valid if MODE is 'write' or 'append'.  ACTION can have the
          following values:

          'default'
               The file is overwritten or appended to, according to the
               MODE argument.  This is the default.

          'error'
               An exception is raised.

          'generate_unique_name'
               If a file named FILESPEC already exists, then FILESPEC is
               rewritten so that it refers to a non-existing file.
               FILESPEC is rewritten by adding digits at the end of the
               file name (but before any extension).  The generated
               name, REALNAME can be obtained by using
               'stream_property(STREAM, file_name(RealName))' on the
               resulting stream.  See the example below.

               With this option 'open/4' will never open an existing
               file but it may still fail to find a unique name.
               'open/4' may fail to find a unique name if there are
               thousands of files with similar names.  In that case
               'open/4' behaves as if 'if_exists(error)' had been
               passed.

Description
-----------

If FILESPEC is a valid file specification, then the file that it denotes
is opened in mode MODE.

   The resulting stream is unified with STREAM.

   STREAM is used as an argument to Prolog input and output predicates.

   STREAM can also be converted to the corresponding foreign
representation through 'stream_code/2' and used in foreign code to
perform input/output operations.

   On Windows, where file names are usually subject to
case-normalization, the file will be created with the same case as in
FILESPEC.  As an example, 'open('HelloWorld.txt', write, S),
stream_property(S,file_name(Name)),close(S).' will create a file with
the mixed case name 'HelloWorld.txt' whereas the stream property will
reflect the case-normalized name '.../helloworld.txt'.  Prior to release
4.3 the file would have been created in the file system with the
case-normalized name 'helloworld.txt'.

Exceptions
----------

'instantiation_error'
     FILESPEC or MODE is not instantiated.  OPTIONS argument is not
     instantiated enough.

'type_error'
     FILESPEC or MODE is not an atom type.  OPTIONS is not a list type
     or an element in OPTIONS is not a correct type for open options or

'domain_error'
     MODE is not one of 'read', 'write' or 'append'.  OPTIONS has an
     undefined option or an element in OPTIONS is out of the domain of
     the option.

'uninstantiation_error'
     STREAM is not a variable

'existence_error'
     The specified FILESPEC does not exist.

'permission_error'
     Cannot open FILESPEC with specified MODE and OPTIONS.

'system_error'
     Unexpected error detected by the operating system

Examples
--------

The following example creates two log files, both based on the base name
'my.log'.  The files will be written to a directory suitable for
temporary files (*note ref-fdi-fsp-pre::).

     | ?- open(temp('my.log'), write, S1, [if_exists(generate_unique_name)]),
          open(temp('my.log'), write, S2, [if_exists(generate_unique_name)]),
          stream_property(S1, file_name(N1)),
          stream_property(S2, file_name(N2)),
          format('Logging to ~a and ~a~n', [N1, N2]),
          ...

   Under UNIX this would produce something like:

     Logging to /tmp/my.log and /tmp/my1886415233.log

See Also
--------

*note ref-iou-sfh::.


File: sicstus.info,  Node: mpg-ref-open_null_stream,  Next: mpg-ref-or,  Prev: mpg-ref-open,  Up: mpg-bpr

11.3.149 'open_null_stream/1'
-----------------------------

Synopsis
--------

'open_null_stream(-STREAM)'

   opens an output _text_ stream that is not connected to any file and
unifies its stream object with STREAM.

Arguments
---------

STREAM
     "stream_object"

Description
-----------

Characters or terms that are sent to this stream are thrown away.  This
predicate is useful because various pieces of local state are kept for
null streams: the predicates 'character_count/2', 'line_count/2', and
'line_position/2' can be used on these streams.

Exceptions
----------

'uninstantiation_error'
     STREAM is not a variable

'system_error'
     Unexpected error detected by the operating system

See Also
--------

*note ref-iou-sfh::.


File: sicstus.info,  Node: mpg-ref-or,  Next: mpg-ref-otherwise,  Prev: mpg-ref-open_null_stream,  Up: mpg-bpr

11.3.150 ';/2'   ISO
--------------------

Synopsis
--------

+P ';' +Q

   Disjunction: Succeeds if P succeeds _or_ Q succeeds.

   +P '->' +Q ';' +R

   _If_ P _then_ Q _else_ R, using first solution of P only.

Arguments
---------

:P
     "callable", must be nonvar
:Q
     "callable", must be nonvar
:R
     "callable", must be nonvar

Description
-----------

These are normally regarded as part of the syntax of the language, but
they are like a built-in predicate in that you can write 'call((P ; Q))'
or 'call((P -> Q ; R))'.

   By default, the character '|' (vertical bar) can be used as an
alternative to the infix operator ';'.  This equivalence does not hold
when '|' has been declared as an operator.

   Using '|' as an alternative to the infix operator ';' is not
recommended.  A future version of the ISO Prolog standard is likely to
define '|' as an operator and with such an operator definition the '|'
will no longer be equivalent to ';'.

   The operator precedences of the ';' and '->' are both greater than
1000, so that they dominate commas.

   Cuts in P do not make sense, but are allowed, their scope being the
goal P.  The scope of cuts in Q and R extends to the containing clause.

Backtracking
------------

For the if-then-else construct: if P succeeds and Q then fails, then
backtracking into P does not occur.  A cut in P does not make sense.
'->' acts like a cut except that its range is restricted to within the
disjunction: it cuts away R and any choice points within P.  '->' may be
thought of as a "local cut".

Exceptions
----------

Call errors (*note ref-sem-exc::).

See Also
--------

*note ref-sem::.


File: sicstus.info,  Node: mpg-ref-otherwise,  Next: mpg-ref-peek_byte,  Prev: mpg-ref-or,  Up: mpg-bpr

11.3.151 'otherwise/0'
----------------------

Synopsis
--------

'otherwise'

   Always succeeds (same as 'true/0').

Tips
----

Useful for laying out conditionals in a readable way.

Exceptions
----------

None.

See Also
--------

*note ref-sem::.


File: sicstus.info,  Node: mpg-ref-peek_byte,  Next: mpg-ref-peek_char,  Prev: mpg-ref-otherwise,  Up: mpg-bpr

11.3.152 'peek_byte/[1,2]'   ISO
--------------------------------

Synopsis
--------

'peek_byte(-BYTE)'

   'peek_byte(+STREAM, -BYTE)'

   looks ahead for next input byte on the input stream STREAM.

Arguments
---------

STREAM
     "stream_object", must be ground

     A valid input _binary_ stream, defaults to the current input
     stream.

BYTE
     "byte" or -1

     The resulting next input byte available on the stream.

Description
-----------

'peek_byte/[1,2]' looks ahead of the next input byte of the specified
input stream and unifies the "byte" with BYTE.  The peeked byte is still
available for subsequent input on the stream.

Exceptions
----------

Stream errors (*note ref-iou-sfh-est::), plus:

'type_error'
     BYTE is an invalid byte.

'permission_error'
     Trying to read beyond end of STREAM

See Also
--------

*note ref-iou-cin::.


File: sicstus.info,  Node: mpg-ref-peek_char,  Next: mpg-ref-peek_code,  Prev: mpg-ref-peek_byte,  Up: mpg-bpr

11.3.153 'peek_char/[1,2]'   ISO
--------------------------------

Synopsis
--------

'peek_char(-CHAR)'

   'peek_char(+STREAM, -CHAR)'

   looks ahead for next input character on the current input stream or
on the input stream STREAM.

Arguments
---------

STREAM
     "stream_object", must be ground

     A valid input _text_ stream.

CHAR
     "char" or "one of ['end_of_file']"

     The resulting next input character available on the stream.

Description
-----------

'peek_char/[1,2]' looks ahead of the next input character of the
specified input stream and unifies the character with CHAR.  The peeked
character is still available for subsequent input on the stream.

Comments
--------

It is safe to call 'peek_char/[1,2]' several times without actually
inputting any character.  For example:
     | ?- peek_char(X), peek_char(X), get_char(X).
     |: a

     X = a

Exceptions
----------

Stream errors (*note ref-iou-sfh-est::), plus:

'permission_error'
     Trying to read beyond end of STREAM

See Also
--------

*note ref-iou-cin::.


File: sicstus.info,  Node: mpg-ref-peek_code,  Next: mpg-ref-phrase,  Prev: mpg-ref-peek_char,  Up: mpg-bpr

11.3.154 'peek_code/[1,2]'   ISO
--------------------------------

Synopsis
--------

'peek_code(-CODE)'

   'peek_code(+STREAM, -CODE)'

   looks ahead for next input character on the input stream STREAM.

Arguments
---------

STREAM
     "stream_object", must be ground

     A valid input _text_ stream, defaults to the current input stream.

CODE
     "code" or -1

     The resulting next input character available on the stream.

Description
-----------

'peek_code/[1,2]' looks ahead of the next input character of the
specified input stream and unifies the character with CODE.  The peeked
character is still available for subsequent input on the stream.

Comments
--------

Comments
--------

It is safe to call 'peek_code/[1,2]' several times without actually
inputting any character.  For example:
     | ?- peek_code(X), peek_code(X), get_code(X).
     |: a

     X = 97

Exceptions
----------

Stream errors (*note ref-iou-sfh-est::), plus:

'permission_error'
     Trying to read beyond end of STREAM

See Also
--------

*note ref-iou-cin::.


File: sicstus.info,  Node: mpg-ref-phrase,  Next: mpg-ref-portray,  Prev: mpg-ref-peek_code,  Up: mpg-bpr

11.3.155 'phrase/[2,3]'
-----------------------

Synopsis
--------

'phrase(+PHRASETYPE, +LIST)'

   'phrase(+PHRASETYPE, +LIST, -REST)'

   Used in conjunction with a grammar to parse or generate strings.

Arguments
---------

:PHRASETYPE
     "callable", must be nonvar

     Name of a phrase type.

LIST
     "list of term"

     A list of symbols -- tokens or "codes".

REST
     "list of term"

     A suffix of LIST; what remains of LIST after PHRASETYPE has been
     found.  Defaults to '[]'.

Description
-----------

This predicate is a convenient way to start execution of grammar rules.
Runs through the grammar rules checking whether there is a path by which
PHRASETYPE can be rewritten as LIST.

   If LIST is bound, then this goal corresponds to using the grammar for
parsing.  If LIST is unbound, then this goal corresponds to using the
grammar for generation.

   'phrase/[2,3]' succeeds when the portion of LIST between the start of
LIST and the start of REST is a phrase of type PHRASETYPE (according to
the current grammar rules), where PHRASETYPE is either a non-terminal
or, more generally, a grammar rule body.

   'phrase/[2,3]' allows variables to occur as non-terminals in grammar
rule bodies, just as 'call/1' allows variables to occur as goals in
clause bodies.

Backtracking
------------

Depends on PHRASETYPE.

Exceptions
----------

Call errors (*note ref-sem-exc::).

Examples
--------

Here is a simple grammar that parses an arithmetic expression (made up
of digits and operators) and computes its value.  Create a file
containing the following rules:

                                                           _grammar.pl_
     expr(Z) --> term(X), "+", expr(Y), {Z is X + Y}.
     expr(Z) --> term(X), "-", expr(Y), {Z is X - Y}.
     expr(X) --> term(X).

     term(Z) --> number(X), "*", term(Y), {Z is X * Y}.
     term(Z) --> number(X), "/", term(Y), {Z is X / Y}.
     term(Z) --> number(Z).

     number(C) --> "+", number(C).
     number(C) --> "-", number(X), {C is -X}.
     number(X) --> [C], {"0"=<C, C=<"9", X is C - "0"}.

   In the last rule, C is the character code of a decimal digit.

   This grammar can now be used to parse and evaluate an expression:

     | ?- [grammar].
     | ?- phrase(expr(Z), "-2+3*5+1").

     Z = 14

     | ?- phrase(expr(Z), "-2+3*5", Rest).

     Z = 13,
     Rest = [] ;

     Z = 1,
     Rest = "*5" ;

     Z = -2,
     Rest = "+3*5" ;

     no

See Also
--------

*note ref-lod-exp::, *note ref-gru::.


File: sicstus.info,  Node: mpg-ref-portray,  Next: mpg-ref-portray_clause,  Prev: mpg-ref-phrase,  Up: mpg-bpr

11.3.156 'portray/1'   hook
---------------------------

Synopsis
--------

':- multifile user:portray/1.'

   'user:portray(+TERM)'

   A way for the user to over-ride the default behavior of 'print/1'.

Arguments
---------

TERM
     "term"

Description
-----------

If 'user:portray/1' is defined, then the predicates listed below
performing term output will call it on the term itself and on every
non-variable subterm T.  If 'user:portray/1' succeeds, then it is
assumed to have written T.  If it fails, then the calling predicate will
write the principal functor of T and treat the arguments of T
recursively.

   Note that on lists ('[_|_]'), 'user:portray/1' will be called on the
whole list to 'user:portray/1' and, if that call fails, on each list
element, but _not_ on every suffix of the list.

   Note that a variable written from within 'user:portray/1' may be
written with a different name than that used by the surrounding write
predicate.

   The affected predicates are:

'print/[1,2]'

'write_term/[2,3]'
     when used with the option 'portrayed(true)'

goals during debugging
     controlled by the 'debugger_print_options' Prolog flag, whose value
     by default includes 'portrayed(true)'

top-level variable bindings
     controlled by the 'toplevel_print_options' Prolog flag, whose value
     by default includes 'portrayed(true)'

Exceptions
----------

Exceptions are treated as failures, except an error message is also
printed.

See Also
--------

*note ref-iou-tou::, *note ref-lps-flg::.


File: sicstus.info,  Node: mpg-ref-portray_clause,  Next: mpg-ref-portray_message,  Prev: mpg-ref-portray,  Up: mpg-bpr

11.3.157 'portray_clause/[1,2]'
-------------------------------

Synopsis
--------

'portray_clause(+CLAUSE)'

   'portray_clause(+STREAM, +CLAUSE)'

   Writes CLAUSE to the current output stream.  Used by 'listing/[0,1]'.

Arguments
---------

STREAM
     "stream_object", must be ground

     A valid open Prolog stream, defaults to the current output stream.

CLAUSE
     "term"

Description
-----------

The operation used by 'listing/[0,1]'.  CLAUSE is written to STREAM, in
exactly the format in which 'listing/[0,1]' would have written it,
including a terminating full-stop.

   If you want to print a clause, then this is almost certainly the
command you want.  By design, none of the other term output commands
puts a full-stop after the written term.  If you are writing a file of
facts to be loaded by the Load Predicates, then use
'portray_clause/[1,2]', which attempts to ensure that the clauses it
writes out can be read in again as clauses.

   The output format used by 'portray_clause/[1,2]' and 'listing/[0,1]'
has been carefully designed to be clear.  We recommend that you use a
similar style.  In particular, never put a semicolon (disjunction
symbol) at the end of a line in Prolog.

Exceptions
----------

Stream errors (*note ref-iou-sfh-est::).

Examples
--------

     | ?- portray_clause((X:- a -> b ; c)).
     _ :-
             (   a ->
                 b
             ;   c
             ).

     | ?- portray_clause((X:- a -> (b -> c ; d ; e); f)).
     _ :-
             (   a ->
                 (   b ->
                     c
                 ;   d
                 ;   e
                 )
             ;   f
             ).

     | ?- portray_clause((a:-b)).
     a :-
             b.

     | ?- portray_clause((a:-b,c)).
     a :-
             b,
             c.

     | ?- portray_clause((a:-(b,!,c))).
     a :-
             b, !,
             c.

See Also
--------

'listing/[0,1]', *note ref-iou-tou::.


File: sicstus.info,  Node: mpg-ref-portray_message,  Next: mpg-ref-predicate_property,  Prev: mpg-ref-portray_clause,  Up: mpg-bpr

11.3.158 'portray_message/2'   hook
-----------------------------------

Synopsis
--------

':- multifile user:portray_message/2.'

   'user:portray_message(+SEVERITY, +MESSAGETERM)'

   Called by 'print_message/2' before processing the message.  If this
succeeds, then it is assumed that the message has been processed and
nothing further is done.

Arguments
---------

SEVERITY
     "one of '[informational,warning,error,help,silent]'"

MESSAGETERM
     "term"

Exceptions
----------

An exception raised by this predicate causes an error message to be
printed and then the original message is printed using the default
message text and formatting.

See Also
--------

*note ref-msg::.


File: sicstus.info,  Node: mpg-ref-predicate_property,  Next: mpg-ref-print,  Prev: mpg-ref-portray_message,  Up: mpg-bpr

11.3.159 'predicate_property/2'
-------------------------------

Synopsis
--------

'predicate_property(?CALLABLE, ?PREDPROPERTY)'

   Unifies PREDPROPERTY with a predicate property of an existing
predicate, and CALLABLE with the most general term that corresponds to
that predicate.

Arguments
---------

:CALLABLE
     "callable"

     The skeletal specification of a loaded predicate.

PREDPROPERTY
     "term"

     The various properties associated with CALLABLE.  Each loaded
     predicate will have one or more of the properties:

        * one of the atoms 'built_in' (for built-in predicates) or
          'compiled' or 'interpreted' (for user defined predicates) or
          'fd_constraint' for FD predicates *note Defining Primitive
          Constraints::.

        * the atom 'dynamic' for predicates that have been declared
          dynamic (*note Dynamic Declarations::),

        * the atom 'multifile' for predicates that have been declared
          multifile (*note Multifile Declarations::),

        * the atom 'volatile' for predicates that have been declared
          volatile (*note Volatile Declarations::),

        * the atom 'jittable' for predicates that are amenable to JIT
          compilation,

        * the atom 'jitted' for predicates that have been JIT compiled,

        * one or more terms '(block TERM)' for predicates that have
          block declarations (*note Block Declarations::),

        * the atom 'exported' or terms 'imported_from(MODULEFROM)' for
          predicates exported or imported from modules (*note
          ref-mod::),

        * the term '(meta_predicate TERM)' for predicates that have
          meta-predicate declarations (*note ref-mod-met::).

Description
-----------

If CALLABLE is instantiated, then 'predicate_property/2' successively
unifies PREDPROPERTY with the various properties associated with
CALLABLE.

   If PREDPROPERTY is bound to a valid predicate property, then
'predicate_property/2' successively unifies CALLABLE with the skeletal
specifications of all loaded predicates having PREDPROPERTY.

   If CALLABLE is not a loaded predicate or PREDPROPERTY is not a valid
predicate property, then the call fails.

   If both arguments are unbound, then 'predicate_property/2' can be
used to backtrack through all currently defined predicates and their
corresponding properties.

Examples
--------

   * Predicates acquire properties when they are defined:

          | ?- [user].
          | :- dynamic p/1.
          | p(a).
          | end_of_file.
          % user compiled 0.117 sec 296 bytes

          yes
          | ?- predicate_property(p(_), Property).

          Property = dynamic ;

          Property = interpreted ;

   * To backtrack through all the predicates 'P' imported into module
     'm' from any module:
          | ?- predicate_property(m:P, imported_from(_)).

   * To backtrack through all the predicates 'P' imported into module
     'm1' from module 'm2':
          | ?- predicate_property(m1:P, imported_from(m2)).

   * To backtrack through all the predicates 'P' exported by module 'm':
          | ?- predicate_property(m:P, exported).

   * A variable can also be used in place of a module atom to find the
     names of modules having a predicate and property association:

          | ?- predicate_property(M:f, imported_from(m1)).

     will return all modules 'M' that import 'f/0' from 'm1'.

Exceptions
----------

None.

See Also
--------

*note ref-lps-ove::.


File: sicstus.info,  Node: mpg-ref-print,  Next: mpg-ref-print_coverage,  Prev: mpg-ref-predicate_property,  Up: mpg-bpr

11.3.160 'print/[1,2]'   hookable
---------------------------------

Synopsis
--------

'print(+STREAM, +TERM)'

   'print(+TERM)'

   Writes TERM on the standard output stream, without quoting atoms,
calling 'user:portray/1' on subterms.

Arguments
---------

STREAM
     "stream_object", must be ground

     A valid open Prolog stream, defaults to the current output stream.

TERM
     "term"

Description
-----------

'print(Term)' is equivalent to:

     write_term(Term, [portrayed(true),numbervars(true)])

Exceptions
----------

Stream errors (*note ref-iou-sfh-est::).

See Also
--------

*note ref-iou-tou::, 'user:portray/1'.


File: sicstus.info,  Node: mpg-ref-print_coverage,  Next: mpg-ref-print_message,  Prev: mpg-ref-print,  Up: mpg-bpr

11.3.161 'print_coverage/[0,1]'   development
---------------------------------------------

Synopsis
--------

'print_coverage'   since release 4.2

   Prints the coverage data accumulated so far, to the current output
stream, in a hierarchical format.

   'print_coverage(+DATA)'   since release 4.2

   Prints the coverage data DATA, to the current output stream, in a
hierarchical format.  DATA should be of type "list of coverage_pair";
see 'coverage_data/1'.

Arguments
---------

DATA
     "list of coverage_pair"

Description
-----------

The output is formatted hierarchically into blocks of lines, one block
per source file.  A typical block looks like:

     /home/matsc/tmp/primes.pl
         user:integers/3
             clause 1
                5:        100
                8:         99
             clause 2
                9:          1
         user:primes/2
             clause 1
                1:          1
                2:          1
                3:         *1
         user:remove/3
             clause 1
               16:        436
             clause 2
               17:        411
               20:       *337
             clause 3
               21:         74
               22:        *74
         user:sift/2
             clause 1
               11:          1
             clause 2
               12:         25
               13:        *25
               14:        *25

   This block lists all the coverage sites for the given file.  They are
distributed over 4 predicates, 8 clauses, and 16 active lines of code.
The coverage site on line 8 was hit 99 times.  The coverage site on line
20 was hit 337 times, making at least one nondet call.  And so on.

   The variant 'print_coverage/1' is useful e.g.  if you want to somehow
filter the execution coverage computed by 'coverage_data/1' before
printing it.

Exceptions
----------

None.

See Also
--------

*note Coverage Analysis::.  The Emacs interface has commands for code
coverage highlighting of the current buffer ('C-c C-o', or use the
Prolog menu; *note Usage::).


File: sicstus.info,  Node: mpg-ref-print_message,  Next: mpg-ref-print_message_lines,  Prev: mpg-ref-print_coverage,  Up: mpg-bpr

11.3.162 'print_message/2'   hookable
-------------------------------------

Synopsis
--------

'print_message(+SEVERITY, +MESSAGETERM)'

   Print a MESSAGE of a given SEVERITY.  The behavior can be customized
using the hooks 'user:portray_message/2', 'user:generate_message_hook/3'
and 'user:message_hook/3'.

Arguments
---------

SEVERITY
     "atom", must be nonvar

     Unless the default system portrayal is overidden with
     'user:message_hook/3', SEVERITY must be one of:

     Value
          Prefix

     'informational'
          '% '

     'warning'
          '* '

     'error'
          '! '

     'help'
     'query'
     'silent'
          no prefix

MESSAGETERM
     "term"

Description
-----------

First 'print_message/2' calls 'user:portray_message/2' with the same
arguments.  If this does not succeed, then the message is processed in
the following phases:

   * Message generation phase: the abstract message term MESSAGE is
     formatted, i.e. converted to a format-command list.  First the hook
     predicate 'user:generate_message_hook/3' is tried, then if it does
     not succeed, then ''SU_messages':generate_message/3' is called.
     The latter predicate is defined in terms of definite clause
     grammars in 'library('SU_messages')'.  If that also does not
     succeed, then the built-in default conversion is used, which gives
     the following result:

          ['~q'-[MESSAGE],nl]

   * Line splitting transformation: the format-command list is converted
     to format-command lines--the list is broken up into a list of
     lists, each list containing format-commands for one line.

   * Message printing phase: The text of the message (format-command
     lines generated in the previous stage) is printed.  First the hook
     predicate 'user:message_hook/3' is tried, then, if it does not
     succeed, then the built-in predicate 'print_message_lines/3' is
     called for the 'user_error' stream.

   An unhandled exception message E calls 'print_message(error, E)'
before returning to the top level.  The convention is that an error
message is the result of an unhandled exception.  Thus, an error message
should only be printed if 'raise_exception/1' does not find a handler
and unwinds to the top-level.

   All messages from the system are printed using this predicate.  Means
of intercepting these messages before they are printed are provided.

   'print_message/2' always prints to 'user_error'.  Messages can be
redirected to other streams using 'user:message_hook/3' and
'print_message_lines/3'

   Silent messages do not get translated or printed, but they can be
intercepted with 'user:portray_message/2' and 'user:message_hook/3'.

Exceptions
----------

'instantiation_error'
'type_error'
'domain_error'
     in SEVERITY

See Also
--------

*note ref-msg::.


File: sicstus.info,  Node: mpg-ref-print_message_lines,  Next: mpg-ref-print_profile,  Prev: mpg-ref-print_message,  Up: mpg-bpr

11.3.163 'print_message_lines/3'
--------------------------------

Synopsis
--------

'print_message_lines(+STREAM, +SEVERITY, +LINES)'

   Print the LINES to STREAM, preceding each line with a prefix
corresponding to SEVERITY.

Arguments
---------

STREAM
     "stream_object", must be ground

     Any valid output stream.

SEVERITY
     "one of '[query,help,informational,warning,error,silent,"term"]'"

LINES
     "list of list of pair"

     Must be of the form '[LINE1, LINE2, ...]', where each LINEI must be
     of the form '[CONTROL_1-ARGS_1,CONTROL_2-ARGS_2, ...]'.

Description
-----------

If SEVERITY is a valid severity, then the prefix will be as described
for 'print_message/2', otherwise SEVERITY itself will be used as the
prefix.  If SEVERITY is 'query', then no newline is written after the
last line (otherwise, a newline is written).

   This predicate is intended to be used in conjunction with
'user:message_hook/3'.  After a message is intercepted using
'user:message_hook/3', this command is used to print the lines.  If the
hook has not been defined, then the arguments are those provided by the
system.

Exceptions
----------

Stream errors (*note ref-iou-sfh-est::), plus:

'instantiation_error'
'type_error'
     in LINES.

Examples
--------

Suppose you want to intercept messages and force them to go to a
different stream:

     user:message_hook(Severity, Message, Lines):-
         my_stream(MyStream),
         print_message_lines(MyStream, Severity, Lines).

See Also
--------

*note ref-msg::.


File: sicstus.info,  Node: mpg-ref-print_profile,  Next: mpg-ref-profile_data,  Prev: mpg-ref-print_message_lines,  Up: mpg-bpr

11.3.164 'print_profile/[0,1]'   development
--------------------------------------------

Synopsis
--------

'print_profile'   since release 4.2

   Prints the profiling data accumulated so far, to the current output
stream, in a format similar to 'gprof(1)'.

   'print_profile(+DATA)'   since release 4.2

   Prints the profiling data DATA, to the current output stream, in a
format similar to 'gprof(1)'.  DATA should be of type "list of
profile_pair"; see 'profile_data/1'.

Arguments
---------

DATA
     "list of profile_pair"

Description
-----------

The output is formatted into blocks of lines.  There is one block per
predicate with profiling data.  A typical block looks like:

     ----------------------------------------------------------------
                                     6667/11582      user:extract_index_2/5
                                     4915/11582      user:safe_insns/5
           174446       21862       11582        user:safe_insns/5
                                   *10280/37221      user:safe_insn/1
                                     4915/11582      user:safe_insns/5
     ----------------------------------------------------------------

   This block concerns 'user:safe_insns/5'.  We are told that 174446
virtual instructions were executed and 21862 choicepoints were accessed,
and that it was called 11582 times.  There are two callers:
'user:extract_index_2/5' and 'user:safe_insns/5' itself, which called
'user:safe_insns/5' 6667 and 4915 times respectively.  Finally
'user:safe_insns/5' accounts for 10280 out of the 37221 calls to
'user:safe_insn/1' and, as we already know, for 4915 out of the 11582
calls to itself.  The asterisk in front 10280 tells us that for at least
one of the 10280 calls, 'user:safe_insn/1' left a choicepoint behind,
which could be a case of unwanted nondeterminacy; *note The Determinacy
Checker::.

   The variant 'print_profile/1' is useful e.g.  if you want to somehow
filter the execution profile computed by 'profile_data/1' before
printing it.

Exceptions
----------

None.

See Also
--------

*note Execution Profiling::.


File: sicstus.info,  Node: mpg-ref-profile_data,  Next: mpg-ref-profile_reset,  Prev: mpg-ref-print_profile,  Up: mpg-bpr

11.3.165 'profile_data/1'   development
---------------------------------------

Synopsis
--------

'profile_data(-DATA)'   since release 4.2

   DATA is the profiling data accumulated so far.

Arguments
---------

DATA
     "list of profile_pair"

     where:

     PROFILE_PAIR       ::= 'CALLER-PROFILE_INFO'
     PROFILE_INFO       ::= 'counter(LIST OF
                        CALLEE_PAIR,INSNS,CHPTS,TAGGED_CALLS)'
     INSNS              ::= INTEGER {virtual instructions executed}
     CHPTS              ::= INTEGER {choicepoints accessed}
     CALLEE_PAIR        ::= 'CALLEE-TAGGED_CALLS'
     TAGGED_CALLS       ::= 'det(CALLS)' {all calls were determinate}
                        | 'nondet(CALLS)' {not all calls were determinate}
     CALLS              ::= INTEGER {number of calls}
     CALLER             ::= PRED_SPEC
     CALLEE             ::= PRED_SPEC

Description
-----------

The profiling data accumulated so far is collected into a term of type
"list of profile_pair" and unified with DATA.

   *Please note*: The number of instructions and choicepoints are not
counted for interpreted code, so INSNS and CHPTS will be 0 for such
predicates.

   *Please note*: In a LIST OF CALLEE_PAIR, CALLEE is not necessarily
unique.  This happens if the given CALLER code contains more than one
call to CALLEE.

   *Please note*: The CALLS of a PROFILE_INFO can be greater than the
total CALLS of its LIST OF CALLEE_PAIR.  This happens e.g.  if CALLER
occurred in a metacall context.

Exceptions
----------

None.

See Also
--------

*note Execution Profiling::.


File: sicstus.info,  Node: mpg-ref-profile_reset,  Next: mpg-ref-prolog_flag,  Prev: mpg-ref-profile_data,  Up: mpg-bpr

11.3.166 'profile_reset/0'   development
----------------------------------------

Synopsis
--------

'profile_reset'   since release 4.2

   Resets all profiling data.

Exceptions
----------

None.

See Also
--------

*note Execution Profiling::.


File: sicstus.info,  Node: mpg-ref-prolog_flag,  Next: mpg-ref-prolog_load_context,  Prev: mpg-ref-profile_reset,  Up: mpg-bpr

11.3.167 'prolog_flag/[2,3]'
----------------------------

Synopsis
--------

'prolog_flag(?FLAGNAME, ?VALUE)'

   FLAGNAME is a flag, which currently is set to VALUE.

   'prolog_flag(+FLAGNAME, -OLDVALUE, +NEWVALUE)'

   Unifies the current value of FLAGNAME with OLDVALUE and then sets the
value of the flag to NEWVALUE.  The available Prolog flags are listed in
*note ref-lps-flg::.

Arguments
---------

FLAGNAME
     "atom", must be nonvar and a legal flag in 'prolog_flag/3'

VALUE
     "term"

OLDVALUE
     "term"

NEWVALUE
     "term", must be nonvar and belong to proper type/domain

Description
-----------

To inspect the value of a flag without changing it, use 'prolog_flag/2'
or the following idiom, where FLAGNAME is bound to one of the valid
flags above.
      | ?- prolog_flag(FlagName, Value, Value).

   Use 'prolog_flag/2' to query and 'set_prolog_flag/2' or
'prolog_flag/3' to set values.

   'prolog_flag/3' can be used to save flag values so that one can
return a flag to its previous state.  For example:
     ...
     prolog_flag(debugging,Old,on), % Save in Old and set
     ...
     prolog_flag(debugging,_,Old),  % Restore from Old
     ...

Backtracking
------------

'prolog_flag/2' enumerates all valid flagnames of a given current value,
or all pairs of flags and their current values.

Exceptions
----------

'instantiation_error'
     In 'prolog_flag/3', FLAGNAME unbound, _or_ NEWVALUE unbound and not
     identical to OLDVALUE.

'type_error'
     FLAGNAME is not an atom.

'domain_error'
     In 'prolog_flag/3', FLAGNAME bound to an atom that does not
     represent a supported flag, _or_ NEWVALUE bound to a term that does
     not represent a valid value for FLAGNAME.

'permission_error'
     In 'prolog_flag/3', NEWVALUE not identical to OLDVALUE for a
     read-only flag.

Examples
--------

     | ?- prolog_flag(X,Y).
     X = bounded,
     Y = false ? <RET>
     yes

     | ?- prolog_flag(X,Y,Y).
     ! Instantiation error in argument 1 of prolog_flag/3
     ! goal:  prolog_flag(_94,_95,_95)

     | ?- prolog_flag(source_info,X,X).
     X = on ? <RET>
     yes

See Also
--------

'current_prolog_flag/2', 'set_prolog_flag/2', *note ref-lps-flg::.


File: sicstus.info,  Node: mpg-ref-prolog_load_context,  Next: mpg-ref-prompt,  Prev: mpg-ref-prolog_flag,  Up: mpg-bpr

11.3.168 'prolog_load_context/2'
--------------------------------

Synopsis
--------

'prolog_load_context(?KEY, ?VALUE)'

   Finds out the context of the current load.  The available context
keys are described in *note ref-lps-lco::.

Arguments
---------

KEY
     "atom"

VALUE
     "term"

Description
-----------

You can call 'prolog_load_context/2' from an embedded command or from
'term_expansion/6' to find out the context of the current load.  If
called outside the context of a load, then it simply fails.

Backtracking
------------

Can be used to backtrack through all keys and values.

Exceptions
----------

None.

See Also
--------

'load_files/[2,3]', *note ref-lps-lco::.


File: sicstus.info,  Node: mpg-ref-prompt,  Next: mpg-ref-public,  Prev: mpg-ref-prolog_load_context,  Up: mpg-bpr

11.3.169 'prompt/2'
-------------------

Synopsis
--------

'prompt(-OLDPROMPT, +NEWPROMPT)'

   Queries or changes the prompt string of the current input stream or
an input stream STREAM.

Arguments
---------

OLDPROMPT
     "atom"

     The old prompt atom.

NEWPROMPT
     "atom", must be nonvar

     The new prompt atom.

Description
-----------

A "prompt atom" is a sequence of characters that indicates the Prolog
system is waiting for input when a "Read" or "Get" predicate is called.
If an input stream connected to a terminal is waiting for input at the
beginning of a line (at line position 0), then the prompt atom will be
printed through an output stream associated with the same terminal.

   Prolog sets the prompt to '|: ' for every new top-level query.  This
is the prompt that can be changed by invoking 'prompt/2'.

   Unlike state changes such as those implemented as prolog flags, the
scope of a prompt change is a goal typed at the toplevel.  Therefore,
the change is in force only until returning to the toplevel (prompt =
'| ?- ').

   To _query_ the current prompt atom, OLDPROMPT and NEWPROMPT should be
the same unbound variable.

   To _set_ the prompt, NEWPROMPT should be an instantiated atom.

   The "Load" predicates change the prompt during the time operations
are performed: If a built-in loading predicate is performed on 'user'
(such as 'compile(user)', etc.), then the prompt is set to '| '.  This
prompt is not affected by 'prompt/2'.

Exceptions
----------

'instantiation_error'
'type_error'
     NEWPROMPT is not an atom

See Also
--------

*note ref-iou-tin-cpr::.


File: sicstus.info,  Node: mpg-ref-public,  Next: mpg-ref-put_byte,  Prev: mpg-ref-prompt,  Up: mpg-bpr

11.3.170 'public/1'   declaration
---------------------------------

Synopsis
--------

':- public +TERM'

   Currently a dummy declaration.

Arguments
---------

:TERM
     "term"

Exceptions
----------

Exceptions in the context of loading code are printed as error messages.

'context_error'
     Declaration appeared in a goal.

'permission_error'
     Declaration appeared as a clause.

See Also
--------

*note Public Declarations::.


File: sicstus.info,  Node: mpg-ref-put_byte,  Next: mpg-ref-put_char,  Prev: mpg-ref-public,  Up: mpg-bpr

11.3.171 'put_byte/[1,2]'   ISO
-------------------------------

Synopsis
--------

'put_byte(+BYTE)'

   'put_byte(+STREAM, +BYTE)'

   Writes the byte BYTE to STREAM.

Arguments
---------

STREAM
     "stream_object", must be ground

     A valid output _binary_ stream, defaults to the current output
     stream.

BYTE
     "byte", must be nonvar

Exceptions
----------

Stream errors (*note ref-iou-sfh-est::), plus:

'instantiation_error'
'type_error'
     BYTE is not a "byte".

'permission_error'
     There is an error in the bottom layer of write function of the
     stream.

'type_error'
     BYTE is not a "byte"

See Also
--------

*note ref-iou-cou::.


File: sicstus.info,  Node: mpg-ref-put_char,  Next: mpg-ref-put_code,  Prev: mpg-ref-put_byte,  Up: mpg-bpr

11.3.172 'put_char/[1,2]'   ISO
-------------------------------

Synopsis
--------

'put_char(+CHAR)'

   'put_char(+STREAM, +CHAR)'

   The "char" CHAR is written to STREAM.

Arguments
---------

STREAM
     "stream_object", must be ground

     A valid output _text_ stream, defaults to the current output
     stream.

CHAR
     "char", must be nonvar

Exceptions
----------

Stream errors (*note ref-iou-sfh-est::), plus:

'type_error'
     CHAR is not a "char"

'permission_error'
     There is an error in the bottom layer of write function of the
     stream.

See Also
--------

*note ref-iou-cou::.


File: sicstus.info,  Node: mpg-ref-put_code,  Next: mpg-ref-query_abbreviation,  Prev: mpg-ref-put_char,  Up: mpg-bpr

11.3.173 'put_code/[1,2]'   ISO
-------------------------------

Synopsis
--------

'put_code(+CODE)'

   'put_code(+STREAM, +CODE)'

   The "code" CODE is written to the stream STREAM.

Arguments
---------

STREAM
     "stream_object", must be ground

     A valid output _text_ stream, defaults to the current output
     stream.

CODE
     "code", must be nonvar

Exceptions
----------

Stream errors (*note ref-iou-sfh-est::), plus:

'instantiation_error'
'type_error'
     CODE is not an integer

'permission_error'
     There is an error in the bottom layer of write function of the
     stream.

'representation_error'
     CODE is not a "code"

See Also
--------

*note ref-iou-cou::.


File: sicstus.info,  Node: mpg-ref-query_abbreviation,  Next: mpg-ref-query_class,  Prev: mpg-ref-put_code,  Up: mpg-bpr

11.3.174 'query_abbreviation/3'   extendible
--------------------------------------------

Synopsis
--------

':- multifile 'SU_messages':query_abbreviation/3.'

   ''SU_messages':query_abbreviation(+QUERYCLASS, -PROMPT, -PAIRS)'

   A way to specify one letter abbreviations for responses to queries
from the Prolog System.

Arguments
---------

QUERYCLASS
     "atom"

     The query class being defined.

PROMPT
     "atom"

     The prompt to be used, typically indicating appropriate
     abbreviations.

PAIRS
     "list of pair"

     A list of word-abbreviation pairs, defining the characters accepted
     and the corresponding abstract answers.

Description
-----------

This predicate defines a query class with the given prompt, the 'line'
input method, the 'char(PAIRS)' map method and 'help_query' failure
mode.  The predicate is actually implemented by the first clause of
''SU_messages':query_class/5':

     query_class(QueryClass, Prompt, line, char(Pairs), help_query) :-
             query_abbreviation(QueryClass, Prompt, Pairs), !.

   Prolog only asks for keyboard input in a few different ways.  These
are enumerated in the clauses for ''SU_messages':query_abbreviation/3'.
These clauses specify valid abbreviations for a given key word.  For
example,

     query_abbreviation(yes_or_no, ' (y or n) ', [yes-[-1,0'y,0'Y], no-"nN"]) :- !.

   a French translator might decide that the letters 'O' and 'o' are
reasonable abreviations for 'oui' (yes), and therefore write

     query_abbreviation(yes_or_no, ' (y or n) ', [yes-[-1,0'o,0'O], no-"nN"]) :- !.

Exceptions
----------

'ask_query/4' checks the output arguments.

See Also
--------

*note Query Processing::.


File: sicstus.info,  Node: mpg-ref-query_class,  Next: mpg-ref-query_class_hook,  Prev: mpg-ref-query_abbreviation,  Up: mpg-bpr

11.3.175 'query_class/5'   extendible
-------------------------------------

Synopsis
--------

':- multifile 'SU_messages':query_class/5.'

   ''SU_messages':query_class(+QUERYCLASS, -PROMPT, -INPUTMETHOD,
-MAPMETHOD, -FAILUREMODE)'

   Access the parameters of a given QUERYCLASS.

Arguments
---------

QUERYCLASS
     "term"

     Determines the allowed values for the atom ANSWER.

PROMPT
     "atom"

     The prompt to display at the terminal.

INPUTMETHOD
     "term"

     A ground term, which specifies how to obtain input from the user

MAPMETHOD
     "term"

     A ground term, which specifies how to process the input to get the
     abstract answer to the query.

FAILUREMODE
     "term"

     An atom determining what to print in case of an input error, before
     re-querying the user.  Possible values are:

        - 'help_query' - print the help message and print the query text
          again;

        - 'help' - only print the help message;

        - 'query' - only print the query text;

        - 'none' - do not print anything.

Description
-----------

For the list of default input- and map methods, see the "Default Input
Methods" and "Default Map Methods" subsections in *note Query
Processing::.

Exceptions
----------

'ask_query/4' checks the output arguments.

See Also
--------

*note Query Processing::.


File: sicstus.info,  Node: mpg-ref-query_class_hook,  Next: mpg-ref-query_hook,  Prev: mpg-ref-query_class,  Up: mpg-bpr

11.3.176 'query_class_hook/5'   hook
------------------------------------

Synopsis
--------

':- multifile user:query_class_hook/5.'

   'user:query_class_hook(+QUERYCLASS, -PROMPT, -INPUTMETHOD,
-MAPMETHOD, -FAILUREMODE)'

   Provides the user with a method of overriding the call to
''SU_messages':query_class/5' in the preparation phase of query
processing.  This way the default query class characteristics can be
changed.

Arguments
---------

QUERYCLASS
     "term"

     Determines the allowed values for the atom ANSWER.

PROMPT
     "atom"

     The prompt to display at the terminal.

INPUTMETHOD
     "term"

     The input method to use.

MAPMETHOD
     "term"

     The map method to use.

FAILUREMODE
     "term"

     The failure mode to use.

Exceptions
----------

All error handling is done by the predicates extended by this hook.

See Also
--------

*note Query Processing::.


File: sicstus.info,  Node: mpg-ref-query_hook,  Next: mpg-ref-query_input,  Prev: mpg-ref-query_class_hook,  Up: mpg-bpr

11.3.177 'query_hook/6'   hook
------------------------------

Synopsis
--------

':- multifile 'SU_messages':query_hook/6.'

   ''SU_messages':query_hook(+QUERYCLASS, +PROMPT, +PROMPTLINES, +HELP,
+HELPLINES, -ANSWER)'

   Provides a method of overriding Prolog's default keyboard based input
requests.

Arguments
---------

QUERYCLASS
     "term"

     Determines the allowed values for the atom ANSWER.

PROMPT
     "term"

     A message term.

PROMPTLINES
     "list of pair"

     The message generated from the PROMPT message term.

HELP
     "term"

     A message term.

HELPLINES
     "list of pair"

     The message generated from the HELP message term.

ANSWER
     "term"

     See QUERYCLASS

Description
-----------

This provides a way of overriding Prolog's default method of
interaction.  If this predicate fails, then Prolog's default method of
interaction is invoked.

   The default method first prints out the prompt, then if the response
from the user is not one of the allowed values, then the help message is
printed.

   It is useful to compare this predicate to 'user:message_hook/3',
since this explains how you might use the PROMPT, PROMPTLINES, HELP,
HELPLINES.

Exceptions
----------

An exception raised by this predicate causes an error message to be
printed and then the default method of interation is invoked.  In other
words, exceptions are treated as failures.

See Also
--------

*note Query Processing::.


File: sicstus.info,  Node: mpg-ref-query_input,  Next: mpg-ref-query_input_hook,  Prev: mpg-ref-query_hook,  Up: mpg-bpr

11.3.178 'query_input/3'   extendible
-------------------------------------

Synopsis
--------

':- multifile 'SU_messages':query_input/3.'

   ''SU_messages':query_input(+INPUTMETHOD, +PROMPT, -RAWINPUT)'

   Implements the input phase of query processing.  The user is prompted
with PROMPT, input is read according to INPUTMETHOD, and the result is
returned in RAWINPUT.

Arguments
---------

INPUTMETHOD
     "term"

     The input method to use.

PROMPT
     "atom"

     The prompt to display at the terminal.

RAWINPUT
     "term"

Exceptions
----------

'ask_query/4' checks the output arguments.

See Also
--------

*note Query Processing::.


File: sicstus.info,  Node: mpg-ref-query_input_hook,  Next: mpg-ref-query_map,  Prev: mpg-ref-query_input,  Up: mpg-bpr

11.3.179 'query_input_hook/3'   hook
------------------------------------

Synopsis
--------

':- multifile user:query_input_hook/3.'

   'user:query_input_hook(+INPUTMETHOD, +PROMPT, -RAWINPUT)'

   Provides the user with a method of overriding the call to
''SU_messages':query_input/3' in the input phase of query processing.
This way the implementation of the default input methods can be changed.

Arguments
---------

INPUTMETHOD
     "term"

     The input method to use.

PROMPT
     "atom"

     The prompt to display at the terminal.

RAWINPUT
     "term"

Exceptions
----------

All error handling is done by the predicates extended by this hook.

See Also
--------

*note Query Processing::.


File: sicstus.info,  Node: mpg-ref-query_map,  Next: mpg-ref-query_map_hook,  Prev: mpg-ref-query_input_hook,  Up: mpg-bpr

11.3.180 'query_map/4'   extendible
-----------------------------------

Synopsis
--------

':- multifile 'SU_messages':query_map/4.'

   ''SU_messages':query_map(+MAPMETHOD, +RAWINPUT, -RESULT, -ANSWER)'

   Implements the mapping phase of query processing.  The RAWINPUT,
received from 'query_input/3', is mapped to the abstract answer term
ANSWER.

Arguments
---------

MAPMETHOD
     "term"

     The map method to use.

RAWINPUT
     "atom"

     As received from 'query_input/3'.

RESULT
     "one of '[success,failure,failure(WARNING)]'"

     Result of conversion.

ANSWER
     "one of '[success,failure,failure(WARNING)]'"

     Abstract answer term.

Exceptions
----------

'ask_query/4' checks the output arguments.

See Also
--------

*note Query Processing::.


File: sicstus.info,  Node: mpg-ref-query_map_hook,  Next: mpg-ref-raise_exception,  Prev: mpg-ref-query_map,  Up: mpg-bpr

11.3.181 'query_map_hook/4'   hook
----------------------------------

Synopsis
--------

':- multifile user:query_map_hook/4.'

   'user:query_map_hook(+MAPMETHOD, +RAWINPUT, -RESULT, -ANSWER)'

   Provides the user with a method of overriding the call to
''SU_messages':query_map/4' in the map phase of query processing.  This
way the implementation of the default map methods can be changed.

Arguments
---------

MAPMETHOD
     "term"

     The map method to use.

RAWINPUT
     "atom"

     As received from 'query_input/3'.

RESULT
     "one of '[success,failure,failure(WARNING)]'"

     Result of conversion.

ANSWER
     "one of '[success,failure,failure(WARNING)]'"

     Abstract answer term.

Exceptions
----------

All error handling is done by the predicates extended by this hook.

See Also
--------

*note Query Processing::.


File: sicstus.info,  Node: mpg-ref-raise_exception,  Next: mpg-ref-read,  Prev: mpg-ref-query_map_hook,  Up: mpg-bpr

11.3.182 'raise_exception/1'
----------------------------

Synopsis
--------

'raise_exception(+EXCEPTION)'

   If EXCEPTION matches one of the SICStus error terms listed in *note
ref-ere-err::, then the corresponding error term 'error(ISO_ERROR,
SICSTUS_ERROR)' is thrown.  Otherwise, EXCEPTION is thrown as is.

   New code should prefer the ISO-standard conformant 'throw/1'.

   *Please note*: For backward compatibility reasons, some EXCEPTION
terms are automatically transformed into their corresponding ISO
'error/2' terms.  The standard conformant 'throw/1' does not perform any
such transformation, and is generally preferable.

Arguments
---------

EXCEPTION
     "term", must be nonvar

Exceptions
----------

'instantiation_error'
     EXCEPTION is unbound.

See Also
--------

*note ref-ere::, 'throw/1'.


File: sicstus.info,  Node: mpg-ref-read,  Next: mpg-ref-read_line,  Prev: mpg-ref-raise_exception,  Up: mpg-bpr

11.3.183 'read/[1,2]'   ISO
---------------------------

Synopsis
--------

'read(-TERM)'

   'read(+STREAM, -TERM)'

   Reads the next term from STREAM and unifies it with TERM.  Same as:

   'read_term(TERM, [])'

   'read_term(STREAM, TERM, [])'

Arguments
---------

STREAM
     "stream_object", must be ground

     A valid Prolog input stream.

TERM
     "term"

     The term to be read.

Description
-----------

Term must be followed by a full-stop.  The full-stop is removed from the
input stream and is not a part of the term that is read.  The term is
read with respect to current operator declarations.

   Does not finish until the full-stop is encountered.  Thus, if you
type at top level
     | ?- read(X)

   then you will keep getting prompts (first '|: ', and five spaces
thereafter) every time you type <RET>, but nothing else will happen,
whatever you type, until you type a full-stop.

   If a syntax error is encountered, then the action taken depends on
the current value of the 'syntax_errors' Prolog flag.

   If the end of the current input stream has been reached, then TERM
will be unified with the atom 'end_of_file'.  Further calls to
'read/[1,2]' for the same stream will then raise an exception, unless
the stream is connected to the terminal.  The characters read are
subject to character-conversion.

Exceptions
----------

Stream errors (*note ref-iou-sfh-est::), plus:

'syntax_error'
     A syntax error was found.

Examples
--------

See Also
--------

'read_term/[2,3]', 'char_conversion/2', *note ref-iou-tin-trm::, *note
ref-lps-flg::.


File: sicstus.info,  Node: mpg-ref-read_line,  Next: mpg-ref-read_term,  Prev: mpg-ref-read,  Up: mpg-bpr

11.3.184 'read_line/[1,2]'
--------------------------

Synopsis
--------

'read_line(-LINE)'

   'read_line(+STREAM, -LINE)'

   Reads one line of input from STREAM, and unifies the "codes" with
LINE.  On end of file, LINE is unified with 'end_of_file'.

Arguments
---------

STREAM
     "stream_object", must be ground

     A valid input _text_ stream, defaults to the current input stream.

LINE
     "codes" or "one of ['end_of_file']"

Exceptions
----------

Stream errors (*note ref-iou-sfh-est::), plus:

'permission_error'
     Trying to read beyond end of STREAM

See Also
--------

'at_end_of_line/[0,1]', *note ref-iou-cin::.


File: sicstus.info,  Node: mpg-ref-read_term,  Next: mpg-ref-reconsult,  Prev: mpg-ref-read_line,  Up: mpg-bpr

11.3.185 'read_term/[2,3]'   ISO
--------------------------------

Synopsis
--------

'read_term(-TERM, +OPTIONS)'

   'read_term(+STREAM, -TERM, +OPTIONS)'

   Read a term from STREAM, optionally returning extra information about
the term.

Arguments
---------

STREAM
     "stream_object", must be ground

     A valid Prolog input stream, defaults to the current input stream.

TERM
     "term"

     The term that is read.

OPTIONS
     "list of term", must be ground, except VARS, NAMES, and LAYOUT as
     described below.

     A list of zero or more of the following:

     'syntax_errors(VAL)'
          Controls what action to take on syntax errors.  VAL must be
          one of the values allowed for the 'syntax_errors' Prolog flag.
          The default is set by that flag.  *Note ref-lps-flg::.

     'variables(VARS)'
          VARS is bound to the list of variables in the term input, in
          left-to-right traversal order.

     'variable_names(NAMES)'
          NAMES is bound to a list of 'NAME=VAR' pairs, where each NAME
          is an atom indicating the name of a non-anonymous variable in
          the term, and VAR is the corresponding variable.  The elements
          of the list are in the same order as in TERM, i.e. in
          left-to-right traversal order.

     'singletons(NAMES)'
          NAMES is bound to a list of 'NAME=VAR' pairs, one for each
          non-anonymous variable appearing only once in the term.  The
          elements of the list are in the same order as in TERM, i.e. in
          left-to-right traversal order.

     'cycles(BOOLEAN)'
          BOOLEAN must be 'true' or 'false'.  If selected, then any
          occurrences of '@/2' in the term read in are replaced by the
          potentially cyclic terms they denote as described below.
          Otherwise (the default), TERM is just unified with the term
          read in.

          The notation used when this option is selected is
          '@(TEMPLATE,SUBSTITUTION)' where SUBSTITUTION is a list of
          VAR=TERM pairs where the VAR occurs in TEMPLATE or in one of
          the TERMs.  This notation stands for the instance of TEMPLATE
          obtained by binding each VAR to its corresponding TERM.  The
          purpose of this notation is to provide a finite printed
          representation of cyclic terms.  This notation is not used by
          default, and '@/2' has no special meaning except in this
          context.

          Terms can be written in this notation using 'write_term/[2,3]'
          (*note mpg-ref-write_term::).

     'layout(LAYOUT)'
          LAYOUT is bound to a "layout term" corresponding to TERM
          (*note Glossary::).

     'consume_layout(BOOLEAN)'
          BOOLEAN must be 'true' or 'false'.  If this option is 'true',
          then 'read_term/[2,3]' will consume the LAYOUT-TEXT-ITEM that
          follows the terminating '.' (this LAYOUT-TEXT-ITEM can either
          be a LAYOUT-CHAR or a COMMENT starting with a '%').  If the
          option is 'false', then the LAYOUT-TEXT-ITEM will remain in
          the input stream, so that subsequent character input
          predicates will see it.  The default of the 'consume_layout'
          option is 'false'.

Description
-----------

The characters read are subject to character-conversion.

Exceptions
----------

Stream errors (*note ref-iou-sfh-est::), plus:

'syntax_error'
     A syntax error was found.

'instantiation_error'
'type_error'
'domain_error'
     An illegal option was specified.

Examples
--------

     | ?- read_term(T, [variable_names(L)]).
     |: append([U|X],Y,[U|Z]) :- append(X,Y,Z).
     L = ['U'=_A,'X'=_B,'Y'=_C,'Z'=_D],
     T = (append([_A|_B],_C,[_A|_D]):-append(_B,_C,_D))

     | ?- read_term(T, [layout(L), variable_names(Va), singletons(S)]).
     |: [
          foo(X),
          X = Y
          ].

     L = [35,[36,36],[36,[37,37,37],38]],
     S = ['Y'=_A],
     T = [foo(_B),_B=_A],
     Va = ['X'=_B,'Y'=_A]

     | ?- read_term(T, [consume_layout(false)]), get_code(C).
     |: 1.

     C = 10,
     T = 1

     | ?- read_term(T, [consume_layout(true)]), get_code(C).
     |: 1.
     |: a

     C = 97,
     T = 1


See Also
--------

'read/[1,2]', 'char_conversion/2', *note ref-iou-tin-trm::, *note
ref-lps-flg::.


File: sicstus.info,  Node: mpg-ref-reconsult,  Next: mpg-ref-recorda,  Prev: mpg-ref-read_term,  Up: mpg-bpr

11.3.186 'reconsult/1'
----------------------

Synopsis
--------

'reconsult(+FILES)'

   same as:

   'consult(FILES)'

Arguments
---------

:FILES
     "file_spec" or "list of file_spec", must be ground

     A file specification or a list of file specifications; extensions
     optional.

Exceptions
----------

See 'load_files/[2,3]'.

See Also
--------

*note ref-lod-lod::.


File: sicstus.info,  Node: mpg-ref-recorda,  Next: mpg-ref-recorded,  Prev: mpg-ref-reconsult,  Up: mpg-bpr

11.3.187 'recorda/3'
--------------------

Synopsis
--------

'recorda(+KEY, +TERM, -REF)'

   records the TERM in the internal database as the first item for the
principal functor of KEY; a database reference to the newly-recorded
term is returned in REF.

Arguments
---------

KEY
     "term", must be nonvar

TERM
     "term"

REF
     "db_reference", must be var

Description
-----------

If KEY is a compound term, then only its principal functor is
significant.  That is, 'foo(1)' represents the same key as 'foo(n)'.

   Any uninstantiated variables in the TERM will be replaced by brand
new, unattributed variables (*note ref-sem-sec::).

Exceptions
----------

'instantiation_error'
     KEY is not instantiated

'uninstantiation_error'
     REF is not a variable

Examples
--------

See Also
--------

*note ref-mdb-idb::.


File: sicstus.info,  Node: mpg-ref-recorded,  Next: mpg-ref-recordz,  Prev: mpg-ref-recorda,  Up: mpg-bpr

11.3.188 'recorded/3'
---------------------

Synopsis
--------

'recorded(-KEY, -TERM, +REF)'

   'recorded(?KEY, ?TERM, ?REF)'

   Searches the internal database for a term recorded under the
principal functor of KEY that unifies with TERM, and whose database
reference unifies with REF.

Arguments
---------

KEY
     "term"

TERM
     "term"

REF
     "db_reference"

Description
-----------

If REF is instantiated, then KEY and TERM are unified with the key and
term associated with REF.  Otherwise, If KEY is a compound term, then
only its principal functor is significant.  That is, 'foo(1)' represents
the same key as 'foo(n)'.

Backtracking
------------

Can be used to backtrack through all the matching terms recorded under
the specified key.

Exceptions
----------

'type_error'
     REF is not a database reference

Examples
--------

See Also
--------

*note ref-mdb-idb::.


File: sicstus.info,  Node: mpg-ref-recordz,  Next: mpg-ref-remove_breakpoints,  Prev: mpg-ref-recorded,  Up: mpg-bpr

11.3.189 'recordz/3'
--------------------

Synopsis
--------

'recordz(+KEY, +TERM, -REF)'

   records the TERM in the internal database as the last item for the
principal functor of KEY; a database reference to the newly-recorded
term is returned in REF.

Arguments
---------

KEY
     "term", must be nonvar

TERM
     "term"

REF
     "db_reference", must be var

Description
-----------

If KEY is a compound term, then only its principal functor is
significant.  That is, 'foo(1)' represents the same key as 'foo(n)'.

   Any uninstantiated variables in the TERM will be replaced by brand
new, unattributed variables (*note ref-sem-sec::).

Exceptions
----------

'instantiation_error'
     KEY is not instantiated

'uninstantiation_error'
     REF is not a variable

Examples
--------

See Also
--------

*note ref-mdb-idb::.


File: sicstus.info,  Node: mpg-ref-remove_breakpoints,  Next: mpg-ref-repeat,  Prev: mpg-ref-recordz,  Up: mpg-bpr

11.3.190 'remove_breakpoints/1'   development
---------------------------------------------

Synopsis
--------

'remove_breakpoints(+BIDS)'

   Removes the breakpoints specified by BIDS.

Arguments
---------

BIDS
     "list of integer", must be ground

     Breakpoint identifiers.

Exceptions
----------

'instantiation_error'
'type_error'
     in BIDS

See Also
--------

*note Built-in Predicates for Breakpoint Handling::, *note Breakpoint
Predicates::.


File: sicstus.info,  Node: mpg-ref-repeat,  Next: mpg-ref-restore,  Prev: mpg-ref-remove_breakpoints,  Up: mpg-bpr

11.3.191 'repeat/0'   ISO
-------------------------

Synopsis
--------

'repeat'

   Succeeds immediately when called and whenever reentered by
backtracking.

Description
-----------

Generally used to simulate the looping constructs found in traditional
procedural languages.

   Generates an infinite sequence of backtracking choices.  In sensible
code, 'repeat/0' is hardly ever used except in _repeat loops_.  A repeat
loop has the structure

     HEAD :-
             ...
             SAVE_STATE(OldState),
             repeat,
               GENERATE(Datum),
               ACTION(Datum),
               TEST(Datum),
             !,
             RESTORE_STATE(OldState),
             ...

   The purpose is to repeatedly perform some ACTION on elements that are
somehow GENERATEd, e.g. by reading them from a stream, until some TEST
becomes true.  Usually, GENERATE, ACTION, and TEST are all determinate.
Repeat loops cannot contribute to the logic of the program.  They are
only meaningful if the ACTION involves side-effects.

   The easiest way to understand the effect of 'repeat/0' is to think of
failures as "bouncing" back off them causing re-execution of the later
goals.

   Repeat loops are not often needed; usually recursive procedure calls
will lead to code that is easier to understand as well as more
efficient.  There are certain circumstances, however, in which
'repeat/0' will lead to greater efficiency.  An important property of
SICStus Prolog is that all runtime data is stored in stacks so that any
storage that has been allocated during a proof of a goal is recovered
immediately on backtracking through that goal.  Thus, in the above
example, any space allocated by any of the ACTIONS is very efficiently
reclaimed.  When an iterative construct is implemented using recursion,
storage reclamation will only be done by the garbage collector.

Tips
----

In the most common use of repeat loops, each of the calls succeeds
determinately.  It can be confusing if calls sometimes fail, so that
backtracking starts before the test is reached, or if calls are
nondeterminate, so that backtracking does not always go right back to
'repeat/0'.

   Note that the repeat loop can only be useful if one or more of the
ACTIONS involves a side-effect -- either a change to the data base (such
as an assertion) or an I/O operation.  Otherwise you would do the same
thing each time around the loop (which would never terminate).

Backtracking
------------

Succeeds repeatedly until backtracking is terminated by a cut or an
exception.

Exceptions
----------

None.

See Also
--------

*note ref-sem::.


File: sicstus.info,  Node: mpg-ref-restore,  Next: mpg-ref-retract,  Prev: mpg-ref-repeat,  Up: mpg-bpr

11.3.192 'restore/1'
--------------------

Synopsis
--------

'restore(+FILESPEC)'

   Restores a saved-state.

Arguments
---------

FILESPEC
     "file_spec", must be ground

     The name of a saved state, '.sav' extension optional.

Description
-----------

The system is returned to the program state previously saved to the file
denoted by FILESPEC with start-up goal GOAL.  'restore/1' may succeed,
fail or raise an exception depending on GOAL.

Exceptions
----------

'instantiation_error'
'type_error'
     In FILESPEC.

'existence_error'
     The specified file does not exist.  If the 'fileerrors' Prolog flag
     is 'off', then the predicate fails instead of raising this
     exception.

'permission_error'
     A specified file is not readable.  If the 'fileerrors' Prolog flag
     is 'off', then the predicate fails instead of raising this
     exception.

Examples
--------

     | ?- save_program(state, format('Restored!\n',[])).
     % /home/matsc/sicstus4/Bips/state.sav created in 0 msec
     yes

     | ?- restore(state).
     % restoring /home/matsc/sicstus4/Bips/state.sav...
     % /home/matsc/sicstus4/Bips/state.sav restored in 10 msec 16 bytes
     Restored!
     yes

See Also
--------

'save_program/[1,2]', *note Saving::, *note ref-sls::, *note
ref-sls-sst::, *note ref-lps-flg::.


File: sicstus.info,  Node: mpg-ref-retract,  Next: mpg-ref-retractall,  Prev: mpg-ref-restore,  Up: mpg-bpr

11.3.193 'retract/1'   ISO
--------------------------

Synopsis
--------

'retract(+CLAUSE)'

   Removes the first occurrence of dynamic clause CLAUSE from module M.

Arguments
---------

:CLAUSE
     "callable", must be nonvar

     A valid Prolog clause.

Description
-----------

'retract/1' erases the first clause in the database that matches CLAUSE.
CLAUSE is retracted in module M if specified.  Otherwise, CLAUSE is
retracted in the source module.

   'retract/1' is nondeterminate.  If control backtracks into the call
to 'retract/1', then successive clauses matching CLAUSE are erased.  If
and when no clauses match, then the call to 'retract/1' fails.

   If the predicate did not previously exist, then it is created as a
dynamic predicate and 'retract/1' fails.

   CLAUSE must be of one of the forms:

   * HEAD
   * 'HEAD :- BODY'
   * 'MODULE:CLAUSE'

   where HEAD is of type callable and the principal functor of HEAD is
the name of a dynamic procedure.  If specified, then MODULE must be an
atom.

   'retract(HEAD)' means retract the unit-clause HEAD.  The exact same
effect can be achieved by 'retract((HEAD :- true))'.

   BODY may be uninstantiated, in which case it will match any body.  In
the case of a unit-clause it will be bound to 'true'.  Thus, for
example,

     | ?- retract((foo(X) :- Body)), fail.

   is guaranteed to retract all the clauses for 'foo/1', including any
unit-clauses, providing of course that 'foo/1' is dynamic.

Backtracking
------------

Can be used to retract all matching clauses through backtracking.

Exceptions
----------

'instantiation_error'
     HEAD (in CLAUSE) or M is uninstantiated.

'type_error'
     HEAD is not a callable, or M is not an atom, or BODY is not a valid
     clause body.

'permission_error'
     the procedure corresponding to HEAD is not dynamic

See Also
--------

'retractall/1', *note ref-mdb-rcd::.


File: sicstus.info,  Node: mpg-ref-retractall,  Next: mpg-ref-save_files,  Prev: mpg-ref-retract,  Up: mpg-bpr

11.3.194 'retractall/1'   ISO
-----------------------------

Synopsis
--------

'retractall(+HEAD)'

   Removes every clause in module M whose head matches HEAD.

Arguments
---------

:HEAD
     "callable", must be nonvar

     Head of a Prolog clause.

Description
-----------

HEAD must be instantiated to a term that looks like a call to a dynamic
procedure.  For example, to retract all the clauses of 'foo/3', you
would write
     | ?- retractall(foo(_,_,_)).

   HEAD may be preceded by a M: prefix, in which case the clauses are
retracted from module M instead of the calling module.

   'retractall/1' is useful for erasing all the clauses of a dynamic
procedure without forgetting that it is dynamic; 'abolish/1' will not
only erase all the clauses, but will also forget absolutely everything
about the procedure.  'retractall/1' only erases the clauses.  This is
important if the procedure is called later on.

   Since 'retractall/1' erases _all_ the dynamic clauses whose heads
match HEAD, it has no choices to make, and is determinate.  If there are
no such clauses, then it succeeds trivially.  None of the variables in
HEAD will be instantiated by this command.

   If the predicate did not previously exist, then it is created as a
dynamic predicate and 'retractall/1' succeeds.

Exceptions
----------

'instantiation_error'
     HEAD or MODULE is uninstantiated.

'type_error'
     HEAD is not a callable.

'permission_error'
     the procedure corresponding to HEAD is not dynamic.

See Also
--------

'retract/1', *note ref-mdb-rcd::.


File: sicstus.info,  Node: mpg-ref-save_files,  Next: mpg-ref-save_modules,  Prev: mpg-ref-retractall,  Up: mpg-bpr

11.3.195 'save_files/2'
-----------------------

Synopsis
--------

'save_files(+SOURCEFILES, +FILE)'

   Any code loaded from SOURCEFILES, as well as from any file included
by them, is saved into FILE in PO format.

Arguments
---------

SOURCEFILES
     "file_spec" or "list of file_spec", must be ground

     A file specification or a list of file specifications; extensions
     optional.

FILE
     "file_spec", must be ground

     A file specification, '.po' extension optional.

Description
-----------

Any module declarations, predicates, multifile clauses, or directives
encountered in SOURCEFILES, as well as from any file included by them,
are saved in object format into the file denoted by FILE.  Source file
information as provided by 'source_file/[1,2]' for the relevant
predicates and modules is also saved.

   FILE can later be loaded by 'load_files/[1,2]', at which time any
saved directives will be re-executed.  If any of the SOURCEFILES
declares a module, then FILESPEC too will behave as a module-file and
export the predicates listed in the first module declaration encountered
in SOURCEFILES.  *Note ref-sls::.

Exceptions
----------

'instantiation_error'
     SOURCEFILES or FILE is not bound.

'type_error'
     SOURCEFILES or FILE is not a valid file specification.

'permission_error'
     FILE is not writable.

See Also
--------

'load_files/[1,2]', *note Saving::, *note ref-sls::, *note
ref-sls-ssl::.


File: sicstus.info,  Node: mpg-ref-save_modules,  Next: mpg-ref-save_predicates,  Prev: mpg-ref-save_files,  Up: mpg-bpr

11.3.196 'save_modules/2'
-------------------------

Synopsis
--------

'save_modules(+MODULES, +FILE)'

   Saves all predicates in MODULES in PO format to FILE.

Arguments
---------

MODULES
     "atom" or "list of atom", must be ground

     An atom representing a current module, or a list of such atoms
     representing a list of modules.

FILE
     "file_spec", must be ground

     A file specification, '.po' extension optional.

Description
-----------

The module declarations, predicates, multifile clauses and
initializations belonging to MODULES are saved in object format into the
file denoted by FILE.  Source file information and embedded directives
(except initializations) are _not_ saved.

   The PO file produced can be loaded using 'load_files/[1,2]'.  When
multiple modules are saved into a file, loading that file will import
only the first of those modules into the module in which the load
occurred.

Exceptions
----------

'instantiation_error'
     MODULES or FILE is not bound.

'type_error'
     MODULES is not a valid list of module names, or a single module
     name, or FILE is not a valid file specification.

'permission_error'
     FILE is not writable.

'existence_error'
     A given module is not a current module.

See Also
--------

'load_files/[1,2]', *note Saving::, *note ref-sls::, *note
ref-sls-ssl::.


File: sicstus.info,  Node: mpg-ref-save_predicates,  Next: mpg-ref-save_program,  Prev: mpg-ref-save_modules,  Up: mpg-bpr

11.3.197 'save_predicates/2'
----------------------------

Synopsis
--------

'save_predicates(+PREDSPECS, +FILE)'

   Saves all predicates in PREDSPECS in PO format to FILE.

Arguments
---------

:PREDSPECS
     "pred_spec_tree"

     A predicate specification, or a list of such.

FILE
     "file_spec", must be ground

     A file specification, '.po' extension optional.

Description
-----------

'save_predicates/2' saves the current definitions of all the predicates
specified by the list of predicate specifications in PO format into a
file.  The module of the predicates saved in the PO file is fixed, so it
is not possible to save a predicate from any module 'foo', and reload it
into module 'bar'.  Source file information and embedded directives are
_not_ saved.  A typical use of this would be to take a snapshot of a
table of dynamic facts.

   The PO file that is written out can be loaded using
'load_files/[1,2]'.

   *Please note*: if PREDSPECS contains specifications for which no
matching predicate can be found, then a warning is issued, and the file
is written anyway.  Also, no built-in predicates are saved.

Exceptions
----------

'instantiation_error'
     PREDSPECS is not instantiated enough, or FILE is not bound.

'type_error'
     PREDSPECS is not a valid tree of predicate specifications, or FILE
     is not a valid file specification, or a NAME is not an atom or an
     ARITY is not an integer.

'domain_error'
     if an ARITY is specified as an integer outside the range 0-255.

'permission_error'
     FILE is not writable.

See Also
--------

'load_files/[1,2]', *note Saving::, *note ref-sls::, *note
ref-sls-ssl::.


File: sicstus.info,  Node: mpg-ref-save_program,  Next: mpg-ref-see,  Prev: mpg-ref-save_predicates,  Up: mpg-bpr

11.3.198 'save_program/[1,2]'
-----------------------------

Synopsis
--------

'save_program(+FILE)'

   'save_program(+FILE, +GOAL)'

   Saves the state of the current execution in object format to FILE.  A
goal, GOAL, to be called upon execution/restoring of the saved state,
may be specified.

Arguments
---------

FILE
     "file_spec", must be ground

     A file specification, '.sav' extension optional.

:GOAL
     "callable", must be nonvar

     A goal, defaults to 'true'.

Description
-----------

'save_program/[1,2]' creates a binary representation of all predicates
in all modules existing in the system.  However, it does not save the
user's pre-linked code.  It also saves such states of the system as
operator definitions, Prolog flags, debugging and advice state,
initializations, and dependencies on foreign resources.

   The resulting file can be restored using 'restore/1'.

   Any unbound variables in GOAL with attributes or blocked goals
attached to them will be replaced by plain, brand new variables.  This
is analogous to the way attributed variables are handled in terms that
are written, copied, asserted, gathered as solutions to 'findall/3' and
friends, or raised as exceptions.  To retain the attributes, you can use
'copy_term/3' (*note ref-lte-cpt::).

Exceptions
----------

'instantiation_error'
     FILE or GOAL is not bound.

'type_error'
     FILE is not a valid file specification, or GOAL is not a callable.

'permission_error'
     FILE is not writable.

Examples
--------

     | ?- save_program(state, format('Restored!\n',[])).
     % /home/matsc/sicstus4/Bips/state.sav created in 0 msec
     yes

     | ?- restore(state).
     % restoring /home/matsc/sicstus4/Bips/state.sav...
     % /home/matsc/sicstus4/Bips/state.sav restored in 10 msec 16 bytes
     Restored!
     yes

See Also
--------

'restore/1', *note Saving::, *note ref-sls::, *note ref-sls-sst::.


File: sicstus.info,  Node: mpg-ref-see,  Next: mpg-ref-seeing,  Prev: mpg-ref-save_program,  Up: mpg-bpr

11.3.199 'see/1'
----------------

Synopsis
--------

'see(+FILEORSTREAM)' Makes file FILEORSTREAM the current input stream.

Arguments
---------

FILEORSTREAM
     "file_spec" or "stream_object", must be ground

Description
-----------

If there is an open input stream associated with FILEORSTREAM, and that
stream was opened by 'see/1', then it is made the current input stream.
Otherwise, the specified file is opened for input in text mode with
default options and made the current input stream.

   Different file names (that is, names that do not unify) represent
different streams (even if they correspond to the same file).
Therefore, assuming 'food' and './food' represent the same file, the
following sequence will open two streams, both connected to the same
file.

     see(food)
     ...
     see('./food')

   It is important to remember to close streams when you have finished
with them.  Use 'seen/0' or 'close/[1,2]'.

Exceptions
----------

'instantiation_error'
     FILEORSTREAM is not instantiated enough.

'existence_error'
     FILEORSTREAM specifies a nonexisting file, and the 'fileerrors'
     Prolog flag is 'on'.

'permission_error'
     FILEORSTREAM is a stream not currently open for input, or
     FILEORSTREAM specifies a file with insufficient access permission,
     and the 'fileerrors' Prolog flag is 'on'.

'domain_error'
     FILEORSTREAM is neither a file_spec nor a stream_object.

See Also
--------

'seen/0', 'open/[3,4]', 'current_input/1', *note ref-iou-sfh::, *note
ref-lps-flg::.


File: sicstus.info,  Node: mpg-ref-seeing,  Next: mpg-ref-seek,  Prev: mpg-ref-see,  Up: mpg-bpr

11.3.200 'seeing/1'
-------------------

Synopsis
--------

'seeing(-FILEORSTREAM)'

   Unifies FILEORSTREAM with the current input stream or file.

Arguments
---------

FILEORSTREAM
     "file_spec" or "stream_object"

Description
-----------

Exactly the same as 'current_input(FILEORSTREAM)', except that
FILEORSTREAM will be unified with a filename if the current input stream
was opened by 'see/1' (*note ref-iou-sfh::).

   Can be used to verify that 'FileNameOrStream' is still the current
input stream as follows:

     % nonvar(FileNameOrStream),
     see(FileNameOrStream),
     ...
     seeing(FileNameOrStream)

   If the current input stream has not been changed (or if changed, then
restored), then the above sequence will succeed for all file names and
all stream objects opened by 'open/[3,4]'.  However, it will fail for
all stream objects opened by 'see/1' (since only filename access to
streams opened by 'see/1' is supported).  This includes the stream
object 'user_input' (since the standard input stream is assumed to be
opened by 'see/1', and so 'seeing/1' would return 'user' in this case).

   If FILEORSTREAM is instantiated to a value that is not the identifier
of the current input stream, then 'seeing(FILEORSTREAM)' simply fails.

   Can be followed by 'see/1' to ensure that a section of code leaves
the current input unchanged:

     % var(OldFileNameOrStream),
     seeing(OldFileNameOrStream),
     ...
     see(OldFileNameOrStream)

   The above is analogous to its stream-object-based counterpart,

     % var(OldStream),
     current_input(OldStream),
     ...
     set_input(OldStream)

   Both of these sequences will always succeed regardless of whether the
current input stream was opened by 'see/1' or 'open/[3,4]'.

Exceptions
----------

None.

See Also
--------

'see/1', 'open/[3,4]', 'current_input/1', *note ref-iou-sfh::.


File: sicstus.info,  Node: mpg-ref-seek,  Next: mpg-ref-seen,  Prev: mpg-ref-seeing,  Up: mpg-bpr

11.3.201 'seek/4'
-----------------

Synopsis
--------

'seek(+STREAM, +OFFSET, +METHOD, -NEWLOCATION)'

   Seeks to an arbitrary position in STREAM.

Arguments
---------

STREAM
     "stream_object", must be ground

     A valid Prolog stream.

OFFSET
     "integer", must be nonvar

     The offset, in _items_, to seek relative to the specified METHOD.
     Items are bytes for binary streams, characters for text streams.

METHOD
     "one of '[bof,current,eof]'", must be nonvar

     Where start seeking, one of the following:

     'bof'
          Seek from beginning of the file stream.

     'current'
          Seek from current position of the file stream.

     'eof'
          Seek from end of the file stream.

NEWLOCATION
     "integer"

     The offset from beginning of the file after seeking operation.

Description
-----------

Sets the current position of the file stream STREAM to a new position
according to OFFSET and METHOD.  If METHOD is:

'bof'
     then the new position is set to OFFSET _items_ from beginning of
     the file stream.

'current'
     then the new position is OFFSET plus the current position of
     STREAM.

'eof'
     then the new position is OFFSET, plus the current size of the
     stream.

     Avoid using this METHOD.  Determining the size of the stream may be
     expensive or unsupported for some streams.

   Positions and offsets are measured in _items_, bytes for binary
streams and characters for text streams.  Note that there may not be any
simple relationship between the number of characters read and the byte
offset of a text file.

   After applying this operation on a text stream, the line counts and
line position aspects of the stream position of STREAM will be
undefined.

   The term "file" above is used even though the stream may be connected
to other seekable objects that are not files, e.g. an in-memory buffer.

Exceptions
----------

Stream errors (*note ref-iou-sfh-est::), plus:

'instantiation_error'
     OFFSET or METHOD is not instantiated.

'type_error'

     STREAM is not a stream object, or OFFSET is not an integer, or
     METHOD is not an atom.

'domain_error'
     METHOD is not one of 'bof', 'current' or 'eof', or the resulting
     position would refer to an unsupported location.  Some streams
     supports setting the position past the current end of the stream,
     in this case the stream is padded with zero bytes or characters as
     soon as an item is written to the new location.

'permission_error'
     Seeking was not possible.  Common reasons include: the stream has
     not been opened with 'reposition(true)', the stream is a text
     stream that does not implement seeking, or an I/O error happened
     during seek.

See Also
--------

'stream_position/2', 'set_stream_position/2', 'open/[3,4]',
'byte_count/2', 'character_count/2', 'line_count/2', 'line_position/2',
*note ref-iou-sfh::.


File: sicstus.info,  Node: mpg-ref-seen,  Next: mpg-ref-set_input,  Prev: mpg-ref-seek,  Up: mpg-bpr

11.3.202 'seen/0'
-----------------

Synopsis
--------

'seen'

   Closes the current input stream.

Description
-----------

Current input stream is set to be 'user_input'; that is, the user's
terminal.

   Always succeeds

Exceptions
----------

None.

Examples
--------

See Also
--------

'see/1', 'close/[1,2]', 'current_input/1', *note ref-iou-sfh::.


File: sicstus.info,  Node: mpg-ref-set_input,  Next: mpg-ref-set_module,  Prev: mpg-ref-seen,  Up: mpg-bpr

11.3.203 'set_input/1'   ISO
----------------------------

Synopsis
--------

'set_input(+STREAM)'

   makes STREAM the current input stream.

Arguments
---------

STREAM
     "stream_object", must be ground

     A valid input stream.

Exceptions
----------

Stream errors (*note ref-iou-sfh-est::).

See Also
--------

'see/1', *note ref-iou-sfh::.


File: sicstus.info,  Node: mpg-ref-set_module,  Next: mpg-ref-set_output,  Prev: mpg-ref-set_input,  Up: mpg-bpr

11.3.204 'set_module/1'
-----------------------

Synopsis
--------

'set_module(+MODULENAME)'

   Changes the type-in module (*note ref-mod-tyi::) to MODULENAME.  Thus
subsequent top-level goals use MODULENAME as their source module.

Arguments
---------

MODULENAME
     "atom", must be nonvar

     The name of a module.

Description
-----------

If MODULENAME is not a current module, then a warning message is issued,
but the type-in module is changed nonetheless.

   Calling 'set_module/1' from a command embedded in a file that is
being loaded does not affect the loading of clauses from that file.  It
only affects subsequent goals that are typed at top level.

Exceptions
----------

'instantiation_error'
'type_error'

Examples
--------

See Also
--------

*note ref-mod::, *note ref-mod-tyi::.


File: sicstus.info,  Node: mpg-ref-set_output,  Next: mpg-ref-set_prolog_flag,  Prev: mpg-ref-set_module,  Up: mpg-bpr

11.3.205 'set_output/1'   ISO
-----------------------------

Synopsis
--------

'set_output(+STREAM)'

   makes STREAM the current output stream.

Arguments
---------

STREAM
     "stream_object", must be ground

     A valid output stream.

Exceptions
----------

Stream errors (*note ref-iou-sfh-est::).

See Also
--------

'tell/1', *note ref-iou-sfh::.


File: sicstus.info,  Node: mpg-ref-set_prolog_flag,  Next: mpg-ref-set_stream_position,  Prev: mpg-ref-set_output,  Up: mpg-bpr

11.3.206 'set_prolog_flag/2'   ISO
----------------------------------

Synopsis
--------

'set_prolog_flag(+FLAGNAME, +VALUE)'

   same as:

   'prolog_flag(FLAGNAME, _, VALUE)'

Arguments
---------

FLAGNAME
     "atom", must be nonvar

VALUE
     "term", must be nonvar and belong to proper type/domain

Exceptions
----------

'instantiation_error'
     An argument is unbound.

'type_error'
     FLAGNAME is not an atom, or VALUE has the wrong type.

'domain_error'
     FLAGNAME is not a valid flag name, or VALUE is not a valid value
     for it.

'permission_error'
     The flag is read-only.

See Also
--------

'current_prolog_flag/2', 'prolog_flag/[2,3]', *note ref-lps-flg::.


File: sicstus.info,  Node: mpg-ref-set_stream_position,  Next: mpg-ref-setof,  Prev: mpg-ref-set_prolog_flag,  Up: mpg-bpr

11.3.207 'set_stream_position/2'   ISO
--------------------------------------

Synopsis
--------

'set_stream_position(+STREAM, +POSITION)'

   Sets the current position of STREAM to POSITION.

Arguments
---------

STREAM
     "stream_object", must be ground

     An open stream.

POSITION
     "term"

     Stream position object representing the current position of STREAM.

Description
-----------

'set_stream_position/2' repositions the stream pointer, and also the
other counts, such as byte, character, and line counts and line
position.  It may only be used on streams that have been opened with the
'open/4' option 'reposition(true)'.

   *Please note:* A stream position object is represented by a special
Prolog term.  The only safe way of obtaining such an object is via
'stream_position/2' or 'stream_property/2'.  You should not try to
construct, change, or rely on the form of this object.  It may change in
subsequent releases.

Exceptions
----------

Stream errors (*note ref-iou-sfh-est::), plus:

'instantiation_error'
'domain_error'
     POSITION is not a valid stream position object.

See Also
--------

'stream_position/2', 'stream_property/2', *note ref-iou-sfh::.


File: sicstus.info,  Node: mpg-ref-setof,  Next: mpg-ref-simple,  Prev: mpg-ref-set_stream_position,  Up: mpg-bpr

11.3.208 'setof/3'   ISO
------------------------

Synopsis
--------

'setof(+TEMPLATE, +GENERATOR, -SET)'

   Returns the non-empty set SET of all instances of TEMPLATE such that
GENERATOR is provable.

Arguments
---------

TEMPLATE
     "term"

:GENERATOR
     "callable", must be nonvar

     A goal to be proved as if by 'call/1'.

SET
     "list of term"

Description
-----------

SET is a non-empty set of terms represented as a list of those terms,
without duplicates, in the standard order for terms (*note
ref-lte-cte::).  If there are no instances of TEMPLATE such that
GENERATOR is satisfied, then 'setof/3' simply fails.

   Obviously, the set to be enumerated should be finite, and should be
enumerable by Prolog in finite time.  It is possible for the provable
instances to contain variables, but in this case SET will only provide
an imperfect representation of what is in reality an infinite set.

   If GENERATOR is instantiated, but contains uninstantiated variables
that do not also appear in TEMPLATE, then 'setof/3' can succeed
nondeterminately, generating alternative values for SET corresponding to
different instantiations of the free variables of GENERATOR.  (It is to
allow for such usage that SET is constrained to be non-empty.)

   If GENERATOR is of the form A^B, then all the variables in A are
treated as being existentially quantified.

   *Please note*: If the instances being gathered contain attributed
variables (*note lib-atts::) or suspended goals (*note ref-sem-sec::),
then those variables are replaced by brand new variables, without
attributes, in the SET.  To retain the attributes, you can use
'copy_term/3' (*note ref-lte-cpt::).

Backtracking
------------

'setof/3' can succeed nondeterminately, generating alternative values
for SET corresponding to different instantiations of the free variables
of GENERATOR.

Exceptions
----------

Call errors (*note ref-sem-exc::).

Examples
--------

See 'findall/3' for examples that illustrate the differences among
'findall/3', 'setof/3', and 'bagof/3'.

See Also
--------

'findall/3', 'bagof/3', '^/2', *note ref-all::.


File: sicstus.info,  Node: mpg-ref-simple,  Next: mpg-ref-skip_byte,  Prev: mpg-ref-setof,  Up: mpg-bpr

11.3.209 'simple/1'
-------------------

Synopsis
--------

'simple(+TERM)'

   TERM is currently not instantiated to a compound term.

Arguments
---------

TERM
     "term"

Examples
--------

     | ?- simple(9).

     yes
     | ?- simple(_X).

     yes
     | ?- simple("a").

     no

Exceptions
----------

None.

See Also
--------

*note ref-lte-met-typ::.


File: sicstus.info,  Node: mpg-ref-skip_byte,  Next: mpg-ref-skip_char,  Prev: mpg-ref-simple,  Up: mpg-bpr

11.3.210 'skip_byte/[1,2]'
--------------------------

Synopsis
--------

'skip_byte(+BYTE)'

   'skip_byte(+STREAM, +BYTE)'

   read up to and including the first occurrence of BYTE on the current
input stream or on the input stream STREAM.

Arguments
---------

STREAM
     "stream_object", must be ground

     A valid input _binary_ stream, defaults to the current input
     stream.

BYTE
     "byte"

Exceptions
----------

Stream errors (*note ref-iou-sfh-est::), plus:

'type_error'
     BYTE is an invalid byte.

'permission_error'
     Trying to read beyond end of STREAM

'type_error'
     BYTE is not a "byte"

See Also
--------

*note ref-iou-cin::.


File: sicstus.info,  Node: mpg-ref-skip_char,  Next: mpg-ref-skip_code,  Prev: mpg-ref-skip_byte,  Up: mpg-bpr

11.3.211 'skip_char/[1,2]'
--------------------------

Synopsis
--------

'skip_char(+CHAR)'

   'skip_char(+STREAM, +CHAR)'

   Read up to and including the first occurrence of CHAR on the current
input stream or on the input stream STREAM.

Arguments
---------

STREAM
     "stream_object", must be ground

     A valid input _text_ stream.

CHAR
     "char"

Exceptions
----------

Stream errors (*note ref-iou-sfh-est::), plus:

'permission_error'
     Trying to read beyond end of STREAM

'type_error'
     CHAR is not a "char"

See Also
--------

*note ref-iou-cin::.


File: sicstus.info,  Node: mpg-ref-skip_code,  Next: mpg-ref-skip_line,  Prev: mpg-ref-skip_char,  Up: mpg-bpr

11.3.212 'skip_code/[1,2]'
--------------------------

Synopsis
--------

'skip_code(+CODE)'

   'skip_code(+STREAM, +CODE)'

   read up to and including the first occurrence of CODE on the current
input stream or on the input stream STREAM.

Arguments
---------

STREAM
     "stream_object", must be ground

     A valid input _text_ stream, defaults to the current input stream.

CODE
     "code"

Exceptions
----------

Stream errors (*note ref-iou-sfh-est::), plus:

'permission_error'
     Trying to read beyond end of STREAM

'representation_error'
     CODE is not a "code"

See Also
--------

*note ref-iou-cin::.


File: sicstus.info,  Node: mpg-ref-skip_line,  Next: mpg-ref-sort,  Prev: mpg-ref-skip_code,  Up: mpg-bpr

11.3.213 'skip_line/[0,1]'
--------------------------

Synopsis
--------

'skip_line'

   'skip_line(+STREAM)'

   Skip the remaining input characters on the current line on STREAM.

Arguments
---------

STREAM
     "stream_object", must be ground

     A valid input _text_ stream, defaults to the current input stream.

Exceptions
----------

Stream errors (*note ref-iou-sfh-est::), plus:

'permission_error'
     Trying to read beyond end of STREAM

See Also
--------

'at_end_of_line/[0,1]', *note ref-iou-cin::.


File: sicstus.info,  Node: mpg-ref-sort,  Next: mpg-ref-source_file,  Prev: mpg-ref-skip_line,  Up: mpg-bpr

11.3.214 'sort/2'   ISO
-----------------------

Synopsis
--------

'sort(+LIST, -SORTED)'

   Sorts the elements of the list LIST into the ascending standard
order, and removes any multiple occurrences of an element.  The
resulting sorted list is unified with the list SORTED.

Arguments
---------

LIST
     "list of term", must be a proper list

SORTED
     "list of term"

   SORTED is type checked since release 4.3 for alignment with the ISO
Prolog standard.  Previous releases simply failed instead of reporting
an error for malformed SORTED.

Exceptions
----------

'instatiation_error'
'type_error'
     LIST is not a proper list

'type_error'
     SORTED cannot be unified with a proper list

Examples
--------

     | ?- sort([a,X,1,a(x),a,a(X)], L).
     L = [X,1,a,a(X),a(x)]

   (The time taken to do this is at worst order (N log N) where N is the
length of the list.)

See Also
--------

*note ref-lte-cte-sor::.


File: sicstus.info,  Node: mpg-ref-source_file,  Next: mpg-ref-spy,  Prev: mpg-ref-sort,  Up: mpg-bpr

11.3.215 'source_file/[1,2]'
----------------------------

Synopsis
--------

'source_file(?ABSFILE)'

   'source_file(?PRED, ?ABSFILE)'

   ABSFILE is the absolute name of a loaded file, and PRED is a
predicate with clauses in that file.  ABSFILE will be 'user' if the
special file specification 'user' was loaded, and PRED is a predicate
with clauses from 'user'.

Arguments
---------

:PRED
     "callable"

     Selected predicate specification.

ABSFILE
     "atom"

     Absolute filename.

Description
-----------

Loaded files include compiled, consulted, restored, PO loaded and
pre-linked files.

   If ABSFILE is bound and not the name of a loaded file, or if PRED is
bound and not the name of a loaded predicate, then
'source_file(ABSFILE)' simply fails.

   To find _any_ predicates defined in a given file, use the form:

     source_file(M:P, File)

Examples
--------

Suppose that the startup file '~/.sicstusrc' defines a predicate
'user:cd/1'.  Then upon startup:

     | ?- source_file(F).
     F = '/src/sicstus/matsc/sicstus4/Utils/x86-linux-glibc2.3/bin/sp-4.1.0/sicstus-4.1.0/library/SU_messages.pl' ? <;>
     F = '/home/matsc/.sicstusrc' ? <;>
     no

     | ?- source_file(P,F).
     F = '/home/matsc/.sicstusrc',
     P = cd(_A) ? <;>
     no

     | ?- source_file('SU_messages':P,F).
     F = '/src/sicstus/matsc/sicstus4/Utils/x86-linux-glibc2.3/bin/sp-4.1.0/sicstus-4.1.0/library/SU_messages.pl',
     P = query_class(_A,_B,_C,_D,_E) ? <RET>
     yes

Exceptions
----------

None.

See Also
--------

*note ref-lps-apf::.


File: sicstus.info,  Node: mpg-ref-spy,  Next: mpg-ref-statistics,  Prev: mpg-ref-source_file,  Up: mpg-bpr

11.3.216 'spy/[1,2]'   development
----------------------------------

Synopsis
--------

'spy +PREDSPECS'

   Sets plain spypoints on all the predicates represented by PREDSPECS.

   'spy(+PREDSPECS, +CONDITIONS)'

   Sets conditional spypoints on all the predicates represented by
PREDSPECS.

Arguments
---------

:PREDSPECS
     "pred_spec_tree"

     A predicate specification, or a list of such.

:CONDITIONS
     "term", must be ground

     Spypoint conditions.

Description
-----------

Turns debugger on in debug mode, so that it will stop as soon as it
reaches a spypoint.  Turning off the debugger does not remove spypoints.
Use 'nospy/1' or 'nospyall/0') to explicitly remove them.

   If you use the predicate specification form NAME but there are no
clauses for NAME (of any arity), then a warning message will be
displayed and no spypoint will be set.
     | ?- spy test.
     * spy user:test - no matching predicate

Exceptions
----------

'instantiation_error'
'type_error'
'domain_error'
     if a PREDSPEC is not a valid procedure specification

See Also
--------

*note Basic Debug::, *note Plain Spypoint::, *note Breakpoint
Predicates::.


File: sicstus.info,  Node: mpg-ref-statistics,  Next: mpg-ref-stream_code,  Prev: mpg-ref-spy,  Up: mpg-bpr

11.3.217 'statistics/[0,2]'
---------------------------

Synopsis
--------

'statistics'

   Displays statistics relating to memory usage and execution time.

   'statistics(?KEYWORD, ?LIST)'

   Obtains individual statistics.

Arguments
---------

KEYWORD
     "atom"

     Statistics key (*note ref-mgc-ove-sta::).

LIST
     "list of integer"

     List of statistics.

Description
-----------

'statistics/0' displays various statistics relating to memory usage,
runtime and garbage collection, including information about which areas
of memory have overflowed and how much time has been spent expanding
them.  The printing is handled by 'print_message/2'.

   Garbage collection statistics are initialized to zero when a Prolog
session starts.  The statistics increase until the session is over.

   'statistics/2' is usually used with KEYWORD instantiated to a keyword
such as 'runtime' and LIST unbound.  The predicate then binds LIST to a
list of statistics related to the keyword.  It can be used in programs
that depend on current runtime statistical information for their control
strategy, and in programs that choose to format and write out their own
statistical summaries.

Exceptions
----------

'type_error'
'domain_error'
     Invalid keyword.

Examples
--------

To report information on the runtime of a predicate 'p/0', add the
following to your program:
     :- statistics(runtime, [T0|_]),
        p,
        statistics(runtime, [T1|_]),
        T is T1 - T0,
        format('p/0 took ~3d sec.~n', [T]).

See Also
--------

*note ref-mgc-ove-sta::, *note ref-msg::.


File: sicstus.info,  Node: mpg-ref-stream_code,  Next: mpg-ref-stream_position,  Prev: mpg-ref-statistics,  Up: mpg-bpr

11.3.218 'stream_code/2'
------------------------

Synopsis
--------

'stream_code(-STREAM, +CSTREAM)'

   'stream_code(+STREAM, -CSTREAM)'

   Converts between Prolog representation, STREAM, and C representation,
CSTREAM, of a stream.

Arguments
---------

STREAM
     "stream_object"

     A valid Prolog stream.

CSTREAM
     "integer"

     Representing an 'SP_stream *' pointer.

Description
-----------

At least one argument must be ground.  'stream_code/2' is used when
there are input/output related operations performed on the same stream
in both Prolog code and foreign code.  The CSTREAM value can be used as
the stream argument to any of the SP_* functions taking a stream
argument.

Exceptions
----------

'instantiation_error'
     Both STREAM and CSTREAM unbound.

'type_error'
     STREAM or CSTREAM is not a stream type or CSTREAM is not an integer
     type.

'existence_error'
     STREAM is syntactically valid but does not name an open stream or
     CSTREAM is of integer type but does not name a pointer to a stream.

See Also
--------

*note Prolog Streams::.


File: sicstus.info,  Node: mpg-ref-stream_position,  Next: mpg-ref-stream_position_data,  Prev: mpg-ref-stream_code,  Up: mpg-bpr

11.3.219 'stream_position/2'
----------------------------

Synopsis
--------

'stream_position(+STREAM, -POSITION)'

   True when POSITION represents the current position of STREAM.

Arguments
---------

STREAM
     "stream_object", must be ground

     An open stream.

POSITION
     "term"

     Stream position object representing the current position of STREAM.

Description
-----------

Byte, character, and line counts and line position determine the
position of the pointer in the stream.  Such information is found by
using 'byte_count/2', 'character_count/2', 'line_count/2' and
'line_position/2'.  A stream position object packages this information
as a single Prolog terms.  You can retrieve this information from a
stream position object using 'stream_position_data/3'.  Do not rely on
the form of this object in any other way.

   Standard term comparison of two stream position objects for the same
stream will work as one expects.  When SP1 and SP2 refer to positions in
the same stream, 'SP1 @< SP2' if and only if SP1 is before SP2 in the
stream.

Exceptions
----------

Stream errors (*note ref-iou-sfh-est::).

Examples
--------

See Also
--------

*note ref-iou-sfh::.


File: sicstus.info,  Node: mpg-ref-stream_position_data,  Next: mpg-ref-stream_property,  Prev: mpg-ref-stream_position,  Up: mpg-bpr

11.3.220 'stream_position_data/3'
---------------------------------

Synopsis
--------

stream_position_data(?FIELD, ?POSITION, ?VALUE)

   VALUE is the value of the FIELD field of stream position object
POSITION.

Arguments
---------

FIELD
     "one of '[byte_count,line_count,character_count,line_position]'"

     Note that 'byte_count' is meaningful only for binary streams and
     that the other values are meaningful only for text streams.

POSITION
     "term"

     Stream position object representing the current position of STREAM.

VALUE
     "integer"

Backtracking
------------

Can be used to backtrack over the fields.

Exceptions
----------

None.

See Also
--------

*note ref-iou-sfh::.


File: sicstus.info,  Node: mpg-ref-stream_property,  Next: mpg-ref-sub_atom,  Prev: mpg-ref-stream_position_data,  Up: mpg-bpr

11.3.221 'stream_property/2'   ISO
----------------------------------

Synopsis
--------

stream_property(?STREAM, ?PROPERTY)

   Stream STREAM has stream property PROPERTY.

Arguments
---------

STREAM
     "stream_object"

PROPERTY
     "term"

     A stream property, one of the following:

     'file_name(F)'
          F is the file name associated with the STREAM.

     'mode(M)'
          STREAM has been opened in mode M.

     'id(ID)   since release 4.2'

          STREAM has the unique identity ID.  The identity of a stream
          is a positive integer that is never re-used during the
          life-time of the SICStus process.  This is unlike the compound
          term STREAM which is likely to be re-used for some new stream
          after the original stream denoted by STREAM has been closed.

     'input'
          STREAM is an input stream.  Note that both 'input' and
          'output' stream properties are set for bidirectional streams.

     'output'
          STREAM is an output stream.  Note that both 'input' and
          'output' stream properties are set for bidirectional streams.

     'alias(A)'
          STREAM has an alias A.

     'position(P)'
          P is a term representing the current stream position of
          STREAM.  Only guaranteed to be available if the stream has
          been opened with the 'open/4' option 'reposition(true)'.

          Same as 'stream_position(Stream, P)' except that the latter
          can be called on any stream, regardless of the value of the
          'reposition/1' 'open/4' option.

     'end_of_stream(E)'
          E describes the position of the input stream STREAM, with
          respect to the end of stream.  If not all characters have been
          read, or if peeking ahead to determine this fact would block,
          then E is unified with 'not'; otherwise, (all characters read)
          but no end of stream indicator (-1 or 'end_of_file') was
          reported yet, then E is unified with 'at'; otherwise, E is
          unified with 'past'.

     'eof_action(A)'
          A is the end-of-file action applicable to STREAM, cf. the
          'eof_action' option of 'open/4'.

     'type(T)'
          STREAM is of type T, one of 'text', 'binary', cf. the 'type'
          option of 'open/4'.

     'input_encoding(CS)   since release 4.3'
     'output_encoding(CS)   since release 4.3'
          STREAM is a text stream with encoding CS in the input
          direction, cf. the 'encoding' option of 'open/4'.  Note that
          the encoding used may be different from the 'encoding' option
          passed to 'open/4' if a byte order mark or other information
          was used to determine the real encoding of the file, cf. the
          'encoding_signature' option of 'open/4'.

     'encoding(CS)'

          STREAM is a text stream open in direction input, with input
          encoding CS or STREAM is a text stream open in direction
          output but not in direction input, with output encoding CS.

          Note that, for bi-directional streams, the 'encoding/1'
          property reflects the 'input_encoding/1'.

     'eol(EOL)'
          STREAM is a text stream with end of line convention EOL, cf.
          the 'eol' option of 'open/4'.

     'encoding_signature(ES)'

          If STREAM is a text stream, then ES is determined as follows:

          If the file contents was used to determine the character
          encoding, then ES will be true.  Typically this is the result
          of opening, in mode 'read', a text file that contains a byte
          order mark or some other information that lets 'open/[3,4]'
          determine a suitable encoding, cf. the 'encoding_signature'
          option of 'open/4'.

          Otherwise, if the stream is open in direction output, then ES
          will be as specified when the file was opened.

     'reposition(REPOSITION)'

          REPOSITION is true if it is possible to set the position of
          the stream with 'set_stream_position/2', cf. the 'reposition'
          option of 'open/4'.

     'interactive   since release 4.1'
          STREAM is an interactive stream.

     Most streams have only a subset of these properties set.

     More properties may be added in the future.

Backtracking
------------

Can be used to backtrack over all currently open streams, including the
standard input/output/error streams, and all their properties.  *Note
ref-iou-sfh-bos::.

Exceptions
----------

Stream errors (*note ref-iou-sfh-est::), plus:

'domain_error'
     STREAM is not a valid stream object, or PROPERTY is not a valid
     stream property.

See Also
--------

*note ref-iou-sfh::.


File: sicstus.info,  Node: mpg-ref-sub_atom,  Next: mpg-ref-subsumes_term,  Prev: mpg-ref-stream_property,  Up: mpg-bpr

11.3.222 'sub_atom/5'   ISO
---------------------------

Synopsis
--------

'sub_atom(+ATOM,-BEFORE,-LENGTH,-AFTER,-SUBATOM)'

   The characters of SUBATOM form a sublist of the characters of ATOM,
such that the number of characters preceding SUBATOM is BEFORE, the
number of characters after SUBATOM is AFTER, and the length of SUBATOM
is LENGTH.

Arguments
---------

ATOM
     "atom", must be nonvar

     The atom from which a part is selected.

BEFORE
     "integer"

     The number of characters preceding SUBATOM.

LENGTH
     "integer"

     The number of characters of SUBATOM.

AFTER
     "integer"

     The number of characters following SUBATOM.

SUBATOM
     "atom"

     The selected part of ATOM.

Description
-----------

Capable of nondeterminately enumerating all sub-atoms and their all
possible placements, e.g.:

     | ?- sub_atom(abrakadabra, Before, _, After, ab).

     After = 9,
     Before = 0 ? ;

     After = 2,
     Before = 7 ? ;

     no

Exceptions
----------

'instantiation_error'
     ATOM is uninstantiated.

'type_error'
     ATOM is not an atom.  BEFORE, LENGTH, or AFTER, if instantiated, is
     not an integer.  SUBATOM, if instantiated, is not an atom.

'domain_error'
     BEFORE, LENGTH, or AFTER, if instantiated, is negative.

See Also
--------

'atom_length/2', 'atom_concat/3'.


File: sicstus.info,  Node: mpg-ref-subsumes_term,  Next: mpg-ref-tell,  Prev: mpg-ref-sub_atom,  Up: mpg-bpr

11.3.223 'subsumes_term/2'   ISO
--------------------------------

Synopsis
--------

'subsumes_term(+GENERAL, +SPECIFIC)'

   is true when SPECIFIC is an instance of GENERAL.  It does not bind
any variables.

Arguments
---------

GENERAL
     any term.

SPECIFIC
     any term.

Description
-----------

True iff there is a substitution that makes GENERAL identical to
SPECIFIC and that does not affect SPECIFIC.

   The predicate is determinate and either succeeds or fails.  It never
binds variables.

   The predicate does not take any constraints, variable attributes, or
blocked goals into account when determining whether a substitution
exists.  This can be seen in the last two examples.

Examples
--------


     | ?- subsumes_term(a, a).
     yes

     | ?- subsumes_term(f(X,Y), f(Z,Z)).
     yes

     | ?- subsumes_term(f(Z,Z), f(X,Y)).
     no

     | ?- subsumes_term(g(X), g(f(X))).
     no

     | ?- subsumes_term(X, f(X)).
     no

     | ?- subsumes_term(X, Y), subsumes_term(Y, f(X)).
     yes

     | ?- when(nonvar(X), X=a), subsumes_term(X, b), X = a.
     X = a ?
     yes

     | ?- when(nonvar(X), X=a), subsumes_term(X, b), X = b.
     no


Exceptions
----------

None.

See Also
--------

*note ref-lte-met-usu::.


File: sicstus.info,  Node: mpg-ref-tell,  Next: mpg-ref-telling,  Prev: mpg-ref-subsumes_term,  Up: mpg-bpr

11.3.224 'tell/1'
-----------------

Synopsis
--------

'tell(+FILEORSTREAM)'

   Makes file FILEORSTREAM the current output stream.

Arguments
---------

FILEORSTREAM
     "file_spec" or "stream_object", must be ground

Description
-----------

If there is an open output stream associated with FILEORSTREAM, and that
stream was opened by 'tell/1', then it is made the current output
stream.  Otherwise, the specified file is opened for output in text mode
with default options and made the current output stream.

   Different file names (that is, names that do not unify) represent
different streams (even if they correspond to the same file).
Therefore, assuming 'food' and './food' represent the same file, the
following sequence will open two streams, both connected to the same
file.

     tell(food)
     ...
     tell('./food')

   It is important to remember to close streams when you have finished
with them.  Use 'told/0' or 'close/[1,2]'.

Exceptions
----------

'instantiation_error'
     FILEORSTREAM is not instantiated enough.

'existence_error'
     FILEORSTREAM specifies a nonexisting file, and the 'fileerrors'
     Prolog flag is 'on'.

'permission_error'
     FILEORSTREAM is a stream not currently open for output, or
     FILEORSTREAM specifies a file with insufficient access permission,
     and the 'fileerrors' Prolog flag is 'on'.

'domain_error'
     FILEORSTREAM is neither a file_spec nor a stream_object.

See Also
--------

'told/0', 'open/[3,4]', 'current_output/1', *note ref-iou-sfh::, *note
ref-lps-flg::.


File: sicstus.info,  Node: mpg-ref-telling,  Next: mpg-ref-term_equal_to,  Prev: mpg-ref-tell,  Up: mpg-bpr

11.3.225 'telling/1'
--------------------

Synopsis
--------

'telling(-FILEORSTREAM)'

   Unifies FILEORSTREAM with the current output stream or file.

Arguments
---------

FILEORSTREAM
     "file_spec" or "stream_object"

Description
-----------

Exactly the same as 'current_output(FILEORSTREAM)', except that
FILEORSTREAM will be unified with a filename if the current output
stream was opened by 'tell/1' (*note ref-iou-sfh::).

   Can be used to verify that 'FileNameOrStream' is still the current
output stream as follows:

     % nonvar(FileNameOrStream),
     tell(FileNameOrStream),
     ...
     telling(FileNameOrStream)

   If the current output stream has not been changed (or if changed,
then restored), then the above sequence will succeed for all file names
and all stream objects opened by 'open/[3,4]'.  However, it will fail
for all stream objects opened by 'tell/1' (since only filename access to
streams opened by 'tell/1' is supported).  This includes the stream
object 'user_output' (since the standard output stream is assumed to be
opened by 'tell/1', and so 'telling/1' would return 'user' in this
case).

   If FILEORSTREAM is instantiated to a value that is not the identifier
of the current output stream, then 'telling(FILEORSTREAM)' simply fails.

   Can be followed by 'tell/1' to ensure that a section of code leaves
the current output unchanged:

     % var(OldFileNameOrStream),
     telling(OldFileNameOrStream),
     ...
     tell(OldFileNameOrStream)

   The above is analogous to its stream-object-based counterpart,

     % var(OldStream),
     current_output(OldStream),
     ...
     set_output(OldStream)

   Both of these sequences will always succeed regardless of whether the
current output stream was opened by 'tell/1' or 'open/[3,4]'.

Exceptions
----------

None.

See Also
--------

'tell/1', 'open/[3,4]', 'current_input/1', *note ref-iou-sfh::.


File: sicstus.info,  Node: mpg-ref-term_equal_to,  Next: mpg-ref-term_expansion,  Prev: mpg-ref-telling,  Up: mpg-bpr

11.3.226 '==/2'   ISO
---------------------

Synopsis
--------

+TERM1 '==' +TERM2

   Succeeds if TERM1 and TERM2 are _identical terms_.

Arguments
---------

TERM1
     "term"
TERM2
     "term"

Examples
--------

For example, the query

     | ?- X == Y.

fails (answers 'no') because X and Y are distinct uninstantiated
variables.  However, the query

     | ?- X = Y, X == Y.

succeeds because the first goal unifies the two.  variables

Exceptions
----------

None.

See Also
--------

*note ref-lte-cte::.


File: sicstus.info,  Node: mpg-ref-term_expansion,  Next: mpg-ref-term_greater_than,  Prev: mpg-ref-term_equal_to,  Up: mpg-bpr

11.3.227 'term_expansion/6'   hook
----------------------------------

Synopsis
--------

':- multifile user:term_expansion/6.'

   'user:term_expansion(+TERM1, +LAYOUT1, +TOKENS1, -TERM2, -LAYOUT2,
-TOKENS2)'

   Overrides or complements the standard transformations to be done by
'expand_term/2'.

Arguments
---------

TERM1
     "term"

     Term to transform.

LAYOUT1
     "term"

     Layout term of TERM1.

TOKENS1
     "list of atom"

TERM2
     "term"

     Transformed term.

LAYOUT2
     "term"

     Layout term of TERM2.

TOKENS2
     "list of atom"

Description
-----------

'expand_term/2' calls this hook predicate first; if it succeeds, then
the standard grammar rule expansion is not tried.

   TOKENS1 is a list of atoms, each atom uniquely identifying an
expansion.  It is used to look up what expansions have already been
applied to the clause or goal.  The tokens are defined by the user, and
should simply be added to the input list, before expansions recursively
are applied.  This token list can for instance be used to avoid cyclic
expansions.  The token 'dcg' is reserved and denotes grammar rule
expansion.  TOKENS2 should be unified with [TOKEN|TOKENS1].

   LAYOUT1 and LAYOUT2 are for supporting source-linked debugging in the
context of clause expansion.  The predicate should construct a suitable
LAYOUT2 compatible with TERM2 that contains the line number information
from LAYOUT1.  If source-linked debugging of TERM2 is not important,
then LAYOUT2 should be '[]'.  The recording of source info is affected
by the 'source_info' prolog flag (*note ref-lps-flg::).

   A clause of this predicate should conform to the following template,
where 'convert(Term1, Layout1, Expansion, Layout)' should be a goal that
performs the actual transformation.  TOKEN should be the atom uniquely
identifying this particular transformation rule.  TOKENS2 should be
unified with [TOKEN|TOKENS1].

     user:term_expansion(Term1, Layout1, Tokens1, Term2, Layout2, Tokens2) :-
             nonmember(TOKEN, Tokens1),
             convert(Term1, Layout1, Expansion, Layout),
             !, % commit to this expansion
             Term2 = Expansion,
             Layout2 = Layout,
             Tokens2 = [TOKEN|Tokens1].

   This hook predicate may return a list of terms rather than a single
term.  Each of the terms in the list is then treated as a separate
clause (or directive).

   This hook predicate may also be used to transform queries entered at
the terminal in response to the '| ?- ' prompt.  In this case, it will
be called with TERM1 = '?-(QUERY)' and should succeed with TERM2 =
'?-(EXPANDEDQUERY)'.

   For accessing aspects of the load context, e.g. the name of the file
being compiled, the predicate 'prolog_load_context/2' (*note
ref-lps-lco::) can be used.

Exceptions
----------

Exceptions are treated as failures, except an error message is printed
also.

See Also
--------

*note ref-lod-exp::, *note Glossary::.


File: sicstus.info,  Node: mpg-ref-term_greater_than,  Next: mpg-ref-term_less_than,  Prev: mpg-ref-term_expansion,  Up: mpg-bpr

11.3.228 '@>/2'   ISO
---------------------

Synopsis
--------

+TERM1 '@>' +TERM2

   Succeeds if TERM1 is _after_ TERM2 in the standard order.

Arguments
---------

TERM1
     "term"
TERM2
     "term"

Exceptions
----------

None.

See Also
--------

*note ref-lte-cte::.


File: sicstus.info,  Node: mpg-ref-term_less_than,  Next: mpg-ref-term_not_equal_to,  Prev: mpg-ref-term_greater_than,  Up: mpg-bpr

11.3.229 '@</2'   ISO
---------------------

Synopsis
--------

+TERM1 '@<' +TERM2

   Succeeds if TERM1 is _before_ TERM2 in the standard order.

Arguments
---------

TERM1
     "term"
TERM2
     "term"

Exceptions
----------

None.

See Also
--------

*note ref-lte-cte::.


File: sicstus.info,  Node: mpg-ref-term_not_equal_to,  Next: mpg-ref-term_not_greater_than,  Prev: mpg-ref-term_less_than,  Up: mpg-bpr

11.3.230 '\==/2'   ISO
----------------------

Synopsis
--------

+TERM1 '\==' +TERM2

   Succeeds if TERM1 and TERM2 are _non-identical terms_.

Arguments
---------

TERM1
     "term"
TERM2
     "term"

Exceptions
----------

None.

See Also
--------

*note ref-lte-cte::.


File: sicstus.info,  Node: mpg-ref-term_not_greater_than,  Next: mpg-ref-term_not_less_than,  Prev: mpg-ref-term_not_equal_to,  Up: mpg-bpr

11.3.231 '@=</2'   ISO
----------------------

Synopsis
--------

+TERM1 '@=<' +TERM2

   Succeeds if TERM1 is _not after_ TERM2 in the standard order.

Arguments
---------

TERM1
     "term"
TERM2
     "term"

Exceptions
----------

None.

See Also
--------

*note ref-lte-cte::.


File: sicstus.info,  Node: mpg-ref-term_not_less_than,  Next: mpg-ref-term_unify_decided,  Prev: mpg-ref-term_not_greater_than,  Up: mpg-bpr

11.3.232 '@>=/2'   ISO
----------------------

Synopsis
--------

+TERM1 '@>=' +TERM2

   Succeeds if TERM1 is _not before_ TERM2 in the standard order.

Arguments
---------

TERM1
     "term"
TERM2
     "term"

Exceptions
----------

None.

See Also
--------

*note ref-lte-cte::.


File: sicstus.info,  Node: mpg-ref-term_unify_decided,  Next: mpg-ref-term_variables,  Prev: mpg-ref-term_not_less_than,  Up: mpg-bpr

11.3.233 '?=/2'
---------------

Synopsis
--------

'?=(+TERM1,+TERM2)'

   Succeeds if TERM1 and TERM2 are _identical terms_, or if they are
syntactically non-unifiable.

Arguments
---------

TERM1
     "term"
TERM2
     "term"

Comments
--------

Succeeds if and only if 'dif(TERM1,TERM2)' does not block.

Exceptions
----------

None.

See Also
--------

*note ref-lte-met-usu::.


File: sicstus.info,  Node: mpg-ref-term_variables,  Next: mpg-ref-throw,  Prev: mpg-ref-term_unify_decided,  Up: mpg-bpr

11.3.234 'term_variables/2'   ISO
---------------------------------

Synopsis
--------

'term_variables(+TERM, -VARIABLES)'   since release 4.3 True if
VARIABLES is the list of variables occurring in TERM, without
duplicates, in first occurrence order.

Arguments
---------

TERM
     Any "term", a cyclic term is also accepted.

-VARIABLES
     The variables in the term.  Must be a variable or a list.

Exceptions
----------

'type_error'
     VARIABLES is not a variable or a list.

Examples
--------

     | ?- term_variables(f(A, B, A), Vs).
     Vs = [A,B] ?
     yes
     | ?- term_variables(f(a, b, a), Vs).
     Vs = [] ?
     yes
     | ?- T=[A,B|T], term_variables(f(C,T), Vs).
     T = [A,B,A,B,A,B,A,B,A,B|...],
     Vs = [C,A,B] ?
     yes

See Also
--------

*note ref-lte-act::.


File: sicstus.info,  Node: mpg-ref-throw,  Next: mpg-ref-told,  Prev: mpg-ref-term_variables,  Up: mpg-bpr

11.3.235 'throw/1'   ISO
------------------------

Synopsis
--------

'throw(+EXCEPTION)'

   EXCEPTION is thrown as an exception.

Arguments
---------

EXCEPTION
     "term", must be nonvar

Exceptions
----------

'instantiation_error'
     EXCEPTION is unbound.

See Also
--------

*note ref-ere::, 'on_exception/1'.


File: sicstus.info,  Node: mpg-ref-told,  Next: mpg-ref-trace,  Prev: mpg-ref-throw,  Up: mpg-bpr

11.3.236 'told/0'
-----------------

Synopsis
--------

'told'

   Closes the current output stream.

Description
-----------

Current output stream is set to be 'user_output'; that is, the user's
terminal.

   Always succeeds

Exceptions
----------

None.

Examples
--------

See Also
--------

'tell/1', 'close/[1,2]', 'current_output/1', *note ref-iou-sfh::.


File: sicstus.info,  Node: mpg-ref-trace,  Next: mpg-ref-trimcore,  Prev: mpg-ref-told,  Up: mpg-bpr

11.3.237 'trace/0'   development
--------------------------------

Synopsis
--------

'trace'

   Turns on the debugger in trace mode.

Description
-----------

The debugger will start showing goals as soon as the first call is
reached, and it will stop to allow you to interact as soon as it reaches
a leashed port (see 'leash/1').  Setting the debugger to trace mode
means that every time you type a query, the debugger will start by
creeping.

   The effect of this predicate can also be achieved by typing the
letter 't' after a '^C' interrupt (*note Execution::).

Exceptions
----------

None.

See Also
--------

*note Basic Debug::.


File: sicstus.info,  Node: mpg-ref-trimcore,  Next: mpg-ref-true,  Prev: mpg-ref-trace,  Up: mpg-bpr

11.3.238 'trimcore/0'
---------------------

Synopsis
--------

'trimcore'

   Force reclamation of memory in all of Prolog's data areas.

Description
-----------

Trims the stacks, reclaims any dead clauses and predicates,
defragmentizes Prolog's free memory, and endeavors to return any unused
memory to the operating system.

   The system property 'PROLOGKEEPSIZE' can be used to define a lower
bound on the amount of memory to be retained.  Also, the system property
'PROLOGINITSIZE' can be used to request that an initial amount of memory
be allocated.  This initially allocated memory will not be touched by
'trimcore/0'.

   When trimming a given stacks, 'trimcore/0' will retain at least the
amount of space initially allocated for that stack.

   'trimcore/0' is called each time Prolog returns to the top level or
the top of a break level, except it does not trim the stacks then.

Exceptions
----------

None.

See Also
--------

*note ref-mgc-ove-rsp::, *note System Properties and Environment
Variables::.


File: sicstus.info,  Node: mpg-ref-true,  Next: mpg-ref-unify,  Prev: mpg-ref-trimcore,  Up: mpg-bpr

11.3.239 'true/0'   ISO
-----------------------

Synopsis
--------

'true'

   Always succeeds.

Exceptions
----------

None.

See Also
--------

*note ref-sem::.


File: sicstus.info,  Node: mpg-ref-unify,  Next: mpg-ref-unify_with_occurs_check,  Prev: mpg-ref-true,  Up: mpg-bpr

11.3.240 '=/2'   ISO
--------------------

Synopsis
--------

+TERM1 '=' +TERM2

   _unifies_ TERM1 and TERM2.

Arguments
---------

TERM1
     "term"
TERM2
     "term"

Description
-----------

This is defined as if by the clause 'Z = Z.'.

   If '=/2' is not able to unify TERM1 and TERM2, then it will simply
fail.

Exceptions
----------

None.

See Also
--------

*note Glossary::, *note ref-sem-occ::.


File: sicstus.info,  Node: mpg-ref-unify_with_occurs_check,  Next: mpg-ref-univ,  Prev: mpg-ref-unify,  Up: mpg-bpr

11.3.241 'unify_with_occurs_check/2'   ISO
------------------------------------------

Synopsis
--------

'unify_with_occurs_check(+TERM1, +TERM2)'

   TERM1 and TERM2 unify to a finite (acyclic) term.

Arguments
---------

TERM1
     "term"
TERM2
     "term"

Description
-----------

Runs in almost linear time.

Exceptions
----------

None.

See Also
--------

*note Glossary::.


File: sicstus.info,  Node: mpg-ref-univ,  Next: mpg-ref-unknown,  Prev: mpg-ref-unify_with_occurs_check,  Up: mpg-bpr

11.3.242 '=../2'   ISO
----------------------

Synopsis
--------

+TERM '=..'  -LIST

   -TERM '=..'  +LIST

   Unifies LIST with a list whose head is the atomic term corresponding
to the principal functor of TERM and whose tail is a list of the
arguments of TERM.

Arguments
---------

TERM
     "term" any term

LIST
     "list of term" and not empty

Description
-----------

If TERM is uninstantiated, then LIST must be instantiated either to a
proper list whose head is an atom, or to a list of length 1 whose head
is a number.

   This predicate is not strictly necessary, since its functionality can
be provided by 'arg/3' and 'functor/3', and using the latter two is
usually more efficient.

Examples
--------

     | ?- product(0, n, n-1) =.. L.

     L = [product,0,n,n-1]

     | ?- n-1 =.. L.

     L = [-,n,1]

     | ?- product =.. L.

     L = [product]

Exceptions
----------

'instantiation_error'
     TERM is unbound and LIST is not instantiated enough.

'type_error'
     LIST is not a proper list, or the head of LIST is not atomic, or
     the head of LIST is a number and the tail of LIST is not empty.

'domain_error'
     LIST is the empty list.

'representation_error'
     TERM is uninstantiated and LIST is longer than 256.

See Also
--------

'functor/3', 'arg/3', *note ref-lte-act::.


File: sicstus.info,  Node: mpg-ref-unknown,  Next: mpg-ref-unknown_predicate_handler,  Prev: mpg-ref-univ,  Up: mpg-bpr

11.3.243 'unknown/2'   development
----------------------------------

Synopsis
--------

'unknown(-OLDACTION, +NEWACTION)'

   Unifies OLDACTION with the current action on unknown procedures, i.e.
the current value of the 'unknown' Prolog flag, sets the current action
to NEWACTION, and prints a message about the change.

Arguments
---------

OLDACTION
     "one of '[error,fail,trace,warning]'"

NEWACTION
     "one of '[error,fail,trace,warning]'", must be nonvar

Description
-----------

This is merely a front-end to the 'unknown' Prolog flag, which see.

   Note that:

     | ?- unknown(ACTION, ACTION).

just returns ACTION without changing it.

   Procedures that are known to be dynamic just fail when there are no
clauses for them.

Exceptions
----------

'instantiation_error'
'type_error'
'domain_error'
     Invalid NEWACTION.

See Also
--------

*note Undefined Predicates::, *note ref-ere::, *note ref-lps-flg::.


File: sicstus.info,  Node: mpg-ref-unknown_predicate_handler,  Next: mpg-ref-unload_foreign_resource,  Prev: mpg-ref-unknown,  Up: mpg-bpr

11.3.244 'unknown_predicate_handler/3'   hook
---------------------------------------------

Synopsis
--------

':- multifile user:unknown_predicate_handler/3.'

   'user:unknown_predicate_handler(+GOAL, +MODULE, -NEWGOAL)'

   User definable hook to trap calls to unknown predicates.

Arguments
---------

GOAL
     "callable"

     The goal to trap.

MODULE
     "atom"

     Any atom that is a current module

NEWGOAL
     "callable"

     The goal to call instead.

Description
-----------

When Prolog comes across a call to an unknown predicate, Prolog makes a
call to 'user:unknown_predicate_handler/3' with the first two arguments
bound.  GOAL is bound to the call to the undefined predicate and MODULE
is the module in which that predicate is supposed to be defined.  If the
call to 'user:unknown_predicate_handler/3' succeeds, then Prolog
replaces the call to the undefined predicate with the call to
MODULE:NEWGOAL.  Otherwise, the action taken is governed by the
'unknown' Prolog flag.

Exceptions
----------

Exceptions are treated as failures, except an error message is printed.

Examples
--------

The following clause gives the same behavior as setting
'unknown(_,fail)':

     unknown_predicate_handler(_, _, fail).

   The following clause causes calls to undefined predicates whose names
begin with 'xyz_' in module 'm' to be trapped to 'my_handler/1' in
module 'n'.  Predicates with names not beginning with this character
sequence are not affected.

     unknown_predicate_handler(G, m, n:my_handler(G)) :-
         functor(G,N,_),
         atom_concat(xyz_, _, N).

See Also
--------

*note Undefined Predicates::, *note ref-ere::, *note ref-lps-flg::.


File: sicstus.info,  Node: mpg-ref-unload_foreign_resource,  Next: mpg-ref-update_mutable,  Prev: mpg-ref-unknown_predicate_handler,  Up: mpg-bpr

11.3.245 'unload_foreign_resource/1'   hookable
-----------------------------------------------

Synopsis
--------

'unload_foreign_resource(:RESOURCE)'

   Unload the foreign resource RESOURCE from Prolog.  Relies on the hook
predicates 'foreign_resource/2' and 'foreign/[2,3]'.

Arguments
---------

:RESOURCE
     "file_spec", must be ground

     The foreign resource to be unloaded.  The file extension can be
     omitted.

Exceptions
----------

'instantiation_error'
     RESOURCE not ground.

'type_error'
     RESOURCE not an atom.

'existence_error'
     RESOURCE does not exist as a foreign resource.

See Also
--------

'load_foreign_resource/1', 'foreign_resource/2', 'foreign/[2,3]', *note
Foreign Resources::, *note Calling C from Prolog::.


File: sicstus.info,  Node: mpg-ref-update_mutable,  Next: mpg-ref-use_module,  Prev: mpg-ref-unload_foreign_resource,  Up: mpg-bpr

11.3.246 'update_mutable/2'
---------------------------

Synopsis
--------

'update_mutable(+DATUM, +MUTABLE)'

   Updates the current value of the mutable term MUTABLE to become
DATUM.

Arguments
---------

DATUM
     "term", must be nonvar

MUTABLE
     "mutable", must be nonvar

Exceptions
----------

'instantiation_error'
     DATUM or MUTABLE is uninstantiated.

'type_error'
     MUTABLE is not a mutable.

See Also
--------

*note ref-lte-mut::.


File: sicstus.info,  Node: mpg-ref-use_module,  Next: mpg-ref-var,  Prev: mpg-ref-update_mutable,  Up: mpg-bpr

11.3.247 'use_module/[1,2,3]'
-----------------------------

Synopsis
--------

'use_module(+FILE)'

   Loads the module-file(s) FILE, if not already loaded and up-to-date
imports all exported predicates.

   'use_module(+FILE, +IMPORTS)'

   Loads module-file FILE, if not already loaded and up-to-date imports
according to IMPORTS.

   'use_module(+MODULE, -FILE, +IMPORTS)'

   MODULE is already loaded and up-to-date.  Imports according to
IMPORTS.

   'use_module(-MODULE, +FILE, +IMPORTS)'

   MODULE has not been loaded, or is out-of-date.  Loads MODULE from
FILE and imports according to IMPORTS.

Arguments
---------

:FILE
     "file_spec" or "list of file_spec", must be ground Any legal file
     specification.  Only 'use_module/1' accepts a list of file
     specifications, file extensions optional.

IMPORTS
     "list of simple_pred_spec" or "one of '[all]'", must be ground
     Either a list of predicate specifications in the NAME/ARITY form to
     import into the calling module, or the atom 'all', meaning all
     predicates exported by the module are to be imported.

MODULE
     "atom" The module name in FILE, or a variable, in which case the
     module name is returned.

Description
-----------

Loads each specified file except the previously loaded files that have
not been changed since last loaded.  All files should be module-files;
if they are not, then warnings are issued.  All the exported predicates
of the modules are imported into the calling module (or module M if
specified).

   'use_module/2' imports only the predicates in IMPORTS when loading
FILE.  If an attempt is made to import a predicate that is not public,
then a warning is issued.  If FILE is not a module-file, then nothing is
imported.

   'use_module/3' allows MODULE to be imported into another module
without requiring that its source file (FILE) be known, as long as the
MODULE already exists in the system.

   Generally, 'use_module/3' is similar to 'use_module/[1,2]', except
that if MODULE is already in the system, then MODULE, or predicates from
MODULE, are simply imported into the calling module, and FILE is not
loaded again.  If MODULE does not already exist in the system, then FILE
is loaded, and 'use_module/3' behaves like 'use_module/2', except that
MODULE is unified, after the file has been loaded, with the actual name
of the module in FILE.  If MODULE is a variable, then FILE must exist,
and the module name in FILE is returned.

   'use_module/1' is similar to 'ensure_loaded/1' except that all files
should be module-files; if they are not, then warnings are issued.

   An attempt to import a predicate may fail or require intervention by
the user because a predicate with the same name and arity has already
been defined in, or imported into, the loading module (or module M if
specified).  Details of what happens in the event of such a "name clash"
are given in *note ref-mod-bas::.

   After loading the module-file, the source module will attempt to
import all the predicates in IMPORTS.  IMPORTS must be a list of
predicate specifications in NAME/ARITY form.  If the file is not a
module-file, then nothing is imported.  If any of the predicates in
IMPORTS are not public predicates, then a warning is issued, but the
predicates are imported nonetheless.  This lack of strictness is for
convenience; if you forget to declare a predicate to be public, then you
can supply the necessary declaration and reload its module, without
having to reload the module that has imported the predicate.

   While 'use_module/1' may be more convenient at the top level,
'use_module/2' is recommended in files because it helps document the
interface between modules by making the list of imported predicates
explicit.

   For consistency, 'use_module/2' has also been extended so that the
IMPORTS may be specified as the term 'all', in which case it behaves the
same as 'use_module/1', importing the entire module into the caller.

Exceptions
----------

See also 'load_files/[2,3]'.

'instantiation_error'
     FILE or IMPORTS is not ground.

'type_error'
     In FILE or IMPORTS.

Examples
--------

'use_module/[1,2]' could be defined as:

     use_module(Files) :-
         load_files(Files, [if(changed)]).

     use_module(File, Imports) :-
         load_files([File], [if(changed),imports(Imports)]).

   'use_module/3' can be used to access the (primary) module name of a
module-file:

     | ?- use_module(Module, library(clpfd), all).
     % loading /src/sicstus/matsc/sicstus4/Utils/x86-linux-glibc2.3/bin/sp-4.1.0/sicstus-4.1.0/library/clpfd.po...
     [...]
     % loaded /src/sicstus/matsc/sicstus4/Utils/x86-linux-glibc2.3/bin/sp-4.1.0/sicstus-4.1.0/library/clpfd.po in module clpfd, 830 msec 496796 bytes
     Module = clpfd ?
     yes

See Also
--------

*note ref-lod-lod::.


File: sicstus.info,  Node: mpg-ref-var,  Next: mpg-ref-volatile,  Prev: mpg-ref-use_module,  Up: mpg-bpr

11.3.248 'var/1'   ISO
----------------------

Synopsis
--------

'var(+TERM)'

   TERM is currently uninstantiated.

Arguments
---------

TERM
     "term"

Examples
--------

     | ?- var(foo(X,Y)).

     no
     | ?- var([X,Y]).

     no
     | ?- var(X).

     true ;

     no
     | ?- Term = foo(X,Y), var(Term).

     no

Exceptions
----------

None.

See Also
--------

*note ref-lte-met-typ::.


File: sicstus.info,  Node: mpg-ref-volatile,  Next: mpg-ref-when,  Prev: mpg-ref-var,  Up: mpg-bpr

11.3.249 'volatile/1'   declaration
-----------------------------------

Synopsis
--------

':- volatile +PREDSPECS'

   Declares PREDSPECS to be volatile.  Clauses of volatile predicates
are not saved by the 'save_*' predicates.

Arguments
---------

:PREDSPECS
     "pred_spec_forest", must be ground

     A predicate specification, or a list of such, or a sequence of such
     separated by commas.

Exceptions
----------

Exceptions in the context of loading code are printed as error messages.

'instantiation_error'
     PREDSPECS not ground.

'type_error'
     PREDSPECS not a valid "pred_spec_forest".

'domain_error'
     Some arity is an integer < 0.

'representation_error'
     Some arity is an integer > 255.

'context_error'
     Declaration appeared in a goal.

'permission_error'
     Declaration appeared as a clause.

See Also
--------

*note Volatile Declarations::.


File: sicstus.info,  Node: mpg-ref-when,  Next: mpg-ref-write,  Prev: mpg-ref-volatile,  Up: mpg-bpr

11.3.250 'when/2'
-----------------

Synopsis
--------

'when(+CONDITION,+GOAL)'

   Blocks GOAL until the CONDITION is true.

Arguments
---------

CONDITION
     "callable", must be nonvar and one of:
     'nonvar(X)'
          False until X is nonvar.

     'ground(X)'
          False until X is ground.

     '?=(X,Y)'
          False while 'dif(X,Y)' would block.

     'CONDITION,CONDITION'
          True if both conditions are true.

     'CONDITION;CONDITION'
          True if at least one condition is true.

:GOAL
     "callable", must be nonvar

Backtracking
------------

Depends on GOAL.

Examples
--------

     | ?- when(((nonvar(X);?=(X,Y)),ground(T)), process(X,Y,T)).

Exceptions
----------

Call errors (*note ref-sem-exc::).

See Also
--------

*note ref-sem-sec::.


File: sicstus.info,  Node: mpg-ref-write,  Next: mpg-ref-write_canonical,  Prev: mpg-ref-when,  Up: mpg-bpr

11.3.251 'write/[1,2]'   ISO
----------------------------

Synopsis
--------

'write(+STREAM, +TERM)'

   'write(+TERM)'

   Writes TERM on the standard output stream, without quoting atoms.

Arguments
---------

STREAM
     "stream_object", must be ground

     A valid open Prolog stream, defaults to the current output stream.

TERM
     "term"

Description
-----------

'write(Term)' is equivalent to:

     write_term(Term, [numbervars(true)])

Exceptions
----------

Stream errors (*note ref-iou-sfh-est::).

See Also
--------

*note ref-iou-tou::.


File: sicstus.info,  Node: mpg-ref-write_canonical,  Next: mpg-ref-write_term,  Prev: mpg-ref-write,  Up: mpg-bpr

11.3.252 'write_canonical/[1,2]'   ISO
--------------------------------------

Synopsis
--------

'write_canonical(+STREAM, +TERM)'

   'write_canonical(+TERM)'

   Writes TERM on the standard output stream, quoting atoms, in
functional notation, without treating ''$VAR'/1' terms specially.

Arguments
---------

STREAM
     "stream_object", must be ground

     A valid open Prolog stream, defaults to the current output stream.

TERM
     "term"

Description
-----------

This predicate is provided so that TERM, if written to a file, can be
read back by 'read/[1,2]' regardless of special characters in TERM or
prevailing operator declarations.

   'write_canonical(Term)' is equivalent to:

     write_term(Term, [quoted(true),ignore_ops(true),quoted_charset(portable)])

Exceptions
----------

Stream errors (*note ref-iou-sfh-est::).

Examples
--------

To contrast 'write/[1,2]' and 'write_canonical/[1,2]':
     | ?- write({'A' + '$VAR'(0) + [a]}).

     {A+A+[a]}

     | ?- write_canonical({'A' + '$VAR'(0) + [a]}).

     {}(+(+('A','$VAR'(0)),.(a,[])))

See Also
--------

*note ref-iou-tou::.


File: sicstus.info,  Node: mpg-ref-write_term,  Next: mpg-ref-writeq,  Prev: mpg-ref-write_canonical,  Up: mpg-bpr

11.3.253 'write_term/[2,3]'   hookable, ISO
-------------------------------------------

Synopsis
--------

'write_term(+STREAM, +TERM, +OPTIONS)'

   'write_term(+TERM, +OPTIONS)'

   Writes TERM on the standard output stream, subject to +OPTIONS.

Arguments
---------

STREAM
     "stream_object", must be ground

     A valid open Prolog stream, defaults to the current output stream.

TERM
     "term"

OPTIONS
     "list of term".

     A list of zero or more of the following, where BOOLEAN must be
     'true' or 'false' ('false' is the default).

     'quoted(BOOLEAN)'
          If selected, then atoms and functors are quoted where
          necessary to make the result acceptable as input to 'read/1'.
          'write_canonical/1', 'writeq/1', and 'portray_clause/1' select
          this.

          Any output produced by 'write_term/2' with the option
          'quoted(true)' will be in Normal Form C, as defined by
          Unicode.  *Note ref-syn-syn-tok::.  for further details.

     'ignore_ops(BOOLEAN)'
          If selected, then TERM is written in standard functional
          notation instead of using operators.  'write_canonical/1' and
          'display/1' select this.

     'portrayed(BOOLEAN)'
          If selected, then 'user:portray/1' is called for each
          non-variable subterm.  'print/1' selects this.

     'variable_names(NAMES)   since release 4.3'
          NAMES should be a list of 'NAME=VAR' pairs, where each NAME is
          an atom indicating the name to be used if VAR is a variable
          occurring in the written term.

          This argument has the same form as the corresponding
          'read_term/[2,3]' option and provides a convenient and safe
          way to preserve variable names when writing a previously read
          term.

     'numbervars(BOOLEAN)'
          If selected, then terms of the form ''$VAR'(N)' where N is an
          integer >= 0 are treated specially (see 'numbervars/3').
          'print/1', 'write/1', 'writeq/1', and 'portray_clause/1'
          select this.

     'legacy_numbervars(BOOLEAN)   since release 4.3'
          If selected, then terms of the form ''$VAR'(N)' where N is an
          integer >= 0, an atom, or a code-list, are treated specially,
          in a way consistent with versions prior to release 4.3, as
          follows.

          If N is an integer >= 0, then the behavior is as for the
          'numbervars/1' option.  Otherwise the characters of the atom
          or code-list are written instead of the term.

          The preferred way to specify variable names is with the
          'variable_names/1' option.

     'cycles(BOOLEAN)'
          If selected, then the potentially cyclic term is printed in
          finite '@/2' notation, as discussed for 'read_term/[2,3]'
          (*note mpg-ref-read_term::).

     'indented(BOOLEAN)'
          If selected, then the term is printed with the same
          indentation as is used by 'portray_clause/1' and
          'listing/[0,1]'.

     'max_depth(DEPTH)'
          Depth limit on printing.  DEPTH is an integer.  0 (the
          default) means no limit.

     'quoted_charset(CHARSET)'
          Only relevant if 'quoted(true)' holds.  CHARSET should be a
          legal value of the 'quoted_charset' Prolog flag, where it
          takes its default value from.  'write_canonical/1' selects the
          value 'portable'.  *Note ref-lps-flg::.

     'float_format(SPEC)'
          How to print floats.  SPEC should be an atom of the form
          '~NC', like one of the 'format/[2,3]' character sequences for
          printing floats.  The default is '~H'.

     'priority(PRIO)'
          The term is printed as if in the context of an associative
          operator of precedence PRIO, where PRIO is an integer.  The
          default is 1200.  *Note ref-syn-ops::.

Description
-----------

This predicate subsumes the predicates that output terms except
'portray_clause/[1,2]', which additionally prints a period and a
newline, and removes module prefixes that are redundant wrt. the current
type-in module.

   During debugging, goals are written out by this predicate with
options given by the 'debugger_print_options' Prolog flag.

   Top-level variable bindings are written out by this predicate with
options given by the 'toplevel_print_options' Prolog flag.

Exceptions
----------

Stream errors (*note ref-iou-sfh-est::), plus:

'instantiation_error'
'type_error'
'domain_error'
     in OPTIONS.

Examples
--------

How certain options affect the output of 'write_term/2':
     | ?- write_term('a b', [quoted(true)]).
     'a b'

     | ?- write_term(a+b, [ignore_ops(true)]).
     +(a,b)

     | ?- write_term(f('$VAR'(2)),
                        [numbervars(true)].)
     f(C)


     | ?- write_term(A+B,
                           [variable_names(['Hello'=A, 'World'=B])]).
     Hello+World


   If your intention is to name variables such as that generated by
'read_term/2' with the 'variable_names' option, then this can be done by
simply passing on the 'variable_names' option to 'write_term/2':

     | ?- read_term(T, [variable_names(Names)]),
          write_term(T, [variable_names(Names),quoted(true)]),
          nl,
          fail.
     |: a(X, Y).
     a(X, Y)
     no

   There is, currently, no documented way to write single-occurrence
variables as '_', e.g.  as done by 'portray_clause/1' (*note
mpg-ref-portray_clause::).

See Also
--------

*note ref-iou-tou::, *note ref-lps-flg::, 'user:portray/1'.


File: sicstus.info,  Node: mpg-ref-writeq,  Next: mpg-ref-zip,  Prev: mpg-ref-write_term,  Up: mpg-bpr

11.3.254 'writeq/[1,2]'   ISO
-----------------------------

Synopsis
--------

'writeq(+STREAM, +TERM)'

   'writeq(+TERM)'

   Writes TERM on the standard output stream, quoting atoms.

Arguments
---------

STREAM
     "stream_object", must be ground

     A valid open Prolog stream, defaults to the current output stream.

TERM
     "term"

Description
-----------

'writeq(Term)' is equivalent to:

     write_term(Term, [quoted(true),numbervars(true)])

Exceptions
----------

Stream errors (*note ref-iou-sfh-est::).

See Also
--------

*note ref-iou-tou::.


File: sicstus.info,  Node: mpg-ref-zip,  Prev: mpg-ref-writeq,  Up: mpg-bpr

11.3.255 'zip/0'   development
------------------------------

Synopsis
--------

'zip'

   Turns on the debugger in zip mode.

Description
-----------

'zip/0' turns the debugger on and sets it to zip mode.  Turning the
debugger on in zip mode means that it will stop at the next spypoint
encountered in the current execution.  Until the spypoint is reached, it
does not keep any information of the execution of the goal, and hence
you will not be able to see the ancestors of the goal when you reach the
spypoint.

   The effect of this predicate can also be achieved by typing the
letter 'z' after a '^C' interrupt (*note Execution::).

Exceptions
----------

None.

See Also
--------

*note Basic Debug::.


File: sicstus.info,  Node: C Reference Pages,  Next: Command Reference Pages,  Prev: Prolog Reference Pages,  Up: Top

12 C Reference Pages
********************

* Menu:

* cpg-rve::                             Return Values and Errors
* cpg-top::                             Topical List of C Functions
* cpg-bif::                             C Functions


File: sicstus.info,  Node: cpg-rve,  Next: cpg-top,  Up: C Reference Pages

12.1 Return Values and Errors
=============================

Many, but not all, C functions return one of the codes 'SP_SUCCESS' for
success, 'SP_FAILURE' for failure, 'SP_ERROR' if an error condition
occurred, or if an uncaught exception was raised during a call from C to
Prolog.  If the value is 'SP_ERROR', then the macro 'SP_errno' will
return a value (an integer) describing the error condition.

   The function 'SP_error_message()' returns a pointer to the diagnostic
message corresponding to a specified error number.

   See *note mpg-ref-ove:: for a description of the conventions observed
in the Reference Pages for Prolog predicates.  C function Reference
Pages differ primarily in the synopsis.  Also, the Reference Page for
each C function documents its return values.

   The following function annotations are used in the Reference Pages:

"hook"
     The function is user defined and is called in some specific
     context.

"macro"
     The function is defined as a C macro.

"preinit"
     It is only meaningful to call the function before initializing the
     Prolog engine


File: sicstus.info,  Node: cpg-top,  Next: cpg-bif,  Prev: cpg-rve,  Up: C Reference Pages

12.2 Topical List of C Functions
================================

* Menu:

* cpg-top-err::                         C Errors
* cpg-top-cio::                         I/O
* cpg-top-exc::                         Exceptions
* cpg-top-fst::                         Files and Streams
* cpg-top-fin::                         Foreign Interface
* cpg-top-main::                        Initialization
* cpg-top-mem::                         Memory Management
* cpg-top-sig::                         Signal Handling
* cpg-top-tic::                         Terms in C
* cpg-top-typ::                         Type Tests


File: sicstus.info,  Node: cpg-top-err,  Next: cpg-top-cio,  Up: cpg-top

12.2.1 C Errors
---------------

'SP_error_message()'
     gets the corresponding error message from an error number obtained
     from 'SP_error'


File: sicstus.info,  Node: cpg-top-cio,  Next: cpg-top-exc,  Prev: cpg-top-err,  Up: cpg-top

12.2.2 I/O
----------

'SP_get_byte()'
     gets a byte from a Prolog binary input stream

'SP_get_code()'
     gets a character code from a Prolog input text stream

'SP_unget_byte()'
'SP_unget_code()'
     Ungets a byte or character, respectively.

'SP_fprintf()'
'SP_printf()'
     prints formatted output on a Prolog output text stream

'SP_put_byte()'
'SP_put_bytes()'
     Writes one or more bytes to a Prolog output binary stream.

'SP_put_code()'
'SP_put_codes()'
'SP_put_encoded_string()'
     Writes one or more characters to a Prolog output text stream.


File: sicstus.info,  Node: cpg-top-exc,  Next: cpg-top-fst,  Prev: cpg-top-cio,  Up: cpg-top

12.2.3 Exceptions
-----------------

'SP_exception_term()'
     fetches the Prolog term representing the most recently raised
     exception

'SP_fail()'
     propagates failure to Prolog

'SP_on_fault()   macro'
     provide a scope for faults

'SP_raise_exception()'
     propagates an exception to Prolog

'SP_raise_fault()'
     raise a fault


File: sicstus.info,  Node: cpg-top-fst,  Next: cpg-top-fin,  Prev: cpg-top-exc,  Up: cpg-top

12.2.4 Files and Streams
------------------------

'SP_fopen()'
     opens a file as a Prolog stream

'SP_fclose()'
     closes a Prolog stream

'SP_flush_output()'
     flushes output on a Prolog output stream

'SP_load()'
     same as 'load_files/1'

'SP_create_stream()'
     makes a new Prolog stream

'SP_restore()'
     same as 'restore/1'

'SP_set_user_stream_hook()   preinit'
'SP_set_user_stream_post_hook()   preinit'
     provide hooks for setting up standard streams


File: sicstus.info,  Node: cpg-top-fin,  Next: cpg-top-main,  Prev: cpg-top-fst,  Up: cpg-top

12.2.5 Foreign Interface
------------------------

'SP_atom_from_string()'
     returns the encoded string representing a Prolog atom

'SP_atom_length()'
     returns the length of the encoded string representing a Prolog atom

'SP_close_query()'
     closes a Prolog query opened from C by 'SP_open_query()'

'SP_cons_functor()'
'SP_cons_functor_array()'
     creates a Prolog compound term from C

'SP_cons_list()'
     creates a Prolog list from C

'SP_cut_query()'
     terminates a nondeterminate Prolog query opened from C

'SP_define_c_predicate()'
     defines a Prolog predicate linked to a C function

'SP_exception_term()'
     returns the Prolog term to C corresponding to the most recent
     Prolog error

'SP_get_address()'
     fetches an integer representing a pointer in an SP_term_ref

'SP_get_arg()'
     fetches a specified argument of a compound term in an SP_term_ref

'SP_get_atom()'
     fetches an atom from an SP_term_ref

'SP_get_current_dir()'
     obtain name of current working directory

'SP_get_float()'
     fetches a floating point number from an SP_term_ref

'SP_get_functor()'
     fetches the name and arity of a term in an SP_term_ref

'SP_get_integer()'
     fetches an integer in an SP_term_ref

'SP_get_integer_bytes()'
     fetches an arbitrarily sized integer in an SP_term_ref

'SP_get_list()'
     fetches the head and tail of a list in an SP_term_ref

'SP_get_list_codes()'
     fetches a code-list in an SP_term_ref

'SP_get_list_n_codes()'
     fetches the first part of a code-list in an SP_term_ref

'SP_get_list_n_bytes()'
     fetches the first part of a byte-list in an SP_term_ref

'SP_get_number_codes()'
     fetches a number encoded as a code-list in an SP_term_ref

'SP_get_string()'
     fetches the encoded string representing a Prolog atom in an
     SP_term_ref

'SP_next_solution()'
     gets the next solution, if any, to an open Prolog query

'SP_open_query()'
     opens a Prolog query from C

'SP_pred()'
     fetches an identifier for a Prolog predicate

'SP_predicate()'
     fetches an identifier a Prolog predicate

'SP_put_address()'
     assigns a pointer to an SP_term_ref

'SP_put_atom()'
     assigns an atom to an SP_term_ref

'SP_put_float()'
     assigns a floating point number to an SP_term_ref

'SP_put_functor()'
     assigns a new compound term to an SP_term_ref

'SP_put_integer()'
     assigns an integer to an SP_term_ref

'SP_put_integer_bytes()'
     assigns an arbitrarily sized integer to an SP_term_ref

'SP_put_list()'
     assigns a new list to an SP_term_ref

'SP_put_list_codes()'
     assigns a code-list to an SP_term_ref

'SP_put_list_n_codes()'
     assigns the first part of a code-list to an SP_term_ref

'SP_put_list_n_bytes()'
     assigns the first part of a byte-list to an SP_term_ref

'SP_put_number_codes()'
     assigns a number encoded as a code-list to an SP_term_ref

'SP_put_string()'
     assigns the atom represented by an encoded string to an SP_term_ref

'SP_put_term()'
     assigns the value of an SP_term_ref to another SP_term_ref

'SP_put_variable()'
     assigns a Prolog variable to an SP_term_ref

'SP_query()'
     makes a determinate query to a Prolog predicate, committing to the
     solution

'SP_query_cut_fail()'
     makes a determinate query to a Prolog predicate for side-effects
     only

'SP_read_from_string()'
     assigns a Prolog term read from a string to an SP_term_ref

'SP_set_current_dir()'
     set name of current working directory

'SP_string_from_atom()'
     returns a null-terminated string corresponding to a Prolog atom


File: sicstus.info,  Node: cpg-top-main,  Next: cpg-top-mem,  Prev: cpg-top-fin,  Up: cpg-top

12.2.6 Initialization
---------------------

'SP_deinitialize()'
     shuts down the Prolog engine

'SP_force_interactive()   preinit'
     consider standard streams to be interactive streams, even if they
     appear not to be TTY streams

'SP_initialize()   macro'
     initializes the Prolog engine

'SP_set_argv()'
     sets the 'argv' Prolog flag.

'SP_set_memalloc_hooks()   preinit'
     provide the memory management bottom layer

'SP_set_user_stream_hook()   preinit'
'SP_set_user_stream_post_hook()   preinit'
     provide hooks for setting up standard streams

'SU_initialize()   hook'
     called before initializing the Prolog engine in applications built
     with '--userhook'


File: sicstus.info,  Node: cpg-top-mem,  Next: cpg-top-sig,  Prev: cpg-top-main,  Up: cpg-top

12.2.7 Memory Management
------------------------

'SP_calloc()'
     Allocates memory for an array of elements, and clears the allocated
     memory.

'SP_foreign_stash()   macro'
     provide a memory location unique to the current foreign resource
     instance

'SP_free()'
     Deallocates a piece of memory.

'SP_malloc()'
     Allocates a piece of memory.

'SP_mutex_lock()'
     Locks a mutex.

'SP_mutex_unlock()'
     Unlocks a mutex.

'SP_realloc()'
     Changes the size of an allocated piece of memory.

'SP_register_atom()'
     prevents an atom from being discarded by atom garbage collection
     even if not referenced by Prolog code

'SP_set_memalloc_hooks()   preinit'
     provide the memory management bottom layer

'SP_strdup()'
     Makes a copy of a string in allocated memory.

'SP_unregister_atom()'
     enables an atom to be discarded during atom garbage collection if
     not referenced by Prolog code


File: sicstus.info,  Node: cpg-top-sig,  Next: cpg-top-tic,  Prev: cpg-top-mem,  Up: cpg-top

12.2.8 Signal Handling
----------------------

'SP_signal()'
     install a signal handler

'SP_event()'
     Schedules a function for execution in the main thread in contexts
     where queries cannot be issued.


File: sicstus.info,  Node: cpg-top-tic,  Next: cpg-top-typ,  Prev: cpg-top-sig,  Up: cpg-top

12.2.9 Terms in C
-----------------

'SP_compare()'
     compares two terms using Prolog's standard term order

'SP_new_term_ref()'
     returns an SP_term_ref, which can be used to hold a Prolog term in
     C

'SP_unify()'
     unifies two Prolog terms


File: sicstus.info,  Node: cpg-top-typ,  Prev: cpg-top-tic,  Up: cpg-top

12.2.10 Type Tests
------------------

'SP_is_atom()'
     tests whether an SP_term_ref contains an atom

'SP_is_atomic()'
     tests whether an SP_term_ref contains an atomic term

'SP_is_compound()'
     tests whether an SP_term_ref contains a compound term

'SP_is_float()'
     tests whether an SP_term_ref contains a floating point number

'SP_is_integer()'
     tests whether an SP_term_ref contains a Prolog integer

'SP_is_list()'
     tests whether an SP_term_ref contains a list cell

'SP_is_number()'
     tests whether an SP_term_ref contains an integer or a floating
     point number

'SP_is_variable()'
     tests whether an SP_term_ref contains a Prolog variable

'SP_term_type()'
     returns the type of the term in an SP_term_ref


File: sicstus.info,  Node: cpg-bif,  Prev: cpg-top,  Up: C Reference Pages

12.3 API Functions
==================

The following reference pages, alphabetically arranged, describe the
SICStus Prolog API functions.

* Menu:

* cpg-ref-SP_atom_from_string:: SP_atom_from_string()
* cpg-ref-SP_atom_length:: SP_atom_length()
* cpg-ref-SP_calloc:: SP_calloc()
* cpg-ref-SP_close_query:: SP_close_query()
* cpg-ref-SP_compare:: SP_compare()
* cpg-ref-SP_cons_functor:: SP_cons_functor()
* cpg-ref-SP_cons_functor_array:: SP_cons_functor_array()
* cpg-ref-SP_cons_list:: SP_cons_list()
* cpg-ref-SP_create_stream:: SP_create_stream()
* cpg-ref-SP_cut_query:: SP_cut_query()
* cpg-ref-SP_define_c_predicate:: SP_define_c_predicate()
* cpg-ref-SP_deinitialize:: SP_deinitialize()
* cpg-ref-SP_error_message:: SP_error_message()
* cpg-ref-SP_event:: SP_event()
* cpg-ref-SP_exception_term:: SP_exception_term()
* cpg-ref-SP_expand_file_name:: SP_expand_file_name()
* cpg-ref-SP_fail:: SP_fail()
* cpg-ref-SP_fclose:: SP_fclose()
* cpg-ref-SP_flush_output:: SP_flush_output()
* cpg-ref-SP_fopen:: SP_fopen()
* cpg-ref-SP_foreign_stash:: SP_foreign_stash()
* cpg-ref-SP_fprintf:: SP_fprintf()
* cpg-ref-SP_free:: SP_free()
* cpg-ref-SP_get_address:: SP_get_address()
* cpg-ref-SP_get_arg:: SP_get_arg()
* cpg-ref-SP_get_atom:: SP_get_atom()
* cpg-ref-SP_get_byte:: SP_get_byte()
* cpg-ref-SP_get_code:: SP_get_code()
* cpg-ref-SP_get_current_dir:: SP_get_current_dir()
* cpg-ref-SP_get_dispatch:: SP_get_dispatch()
* cpg-ref-SP_get_float:: SP_get_float()
* cpg-ref-SP_get_functor:: SP_get_functor()
* cpg-ref-SP_get_integer:: SP_get_integer()
* cpg-ref-SP_get_integer_bytes:: SP_get_integer_bytes()
* cpg-ref-SP_get_list:: SP_get_list()
* cpg-ref-SP_get_list_codes:: SP_get_list_codes()
* cpg-ref-SP_get_list_n_bytes:: SP_get_list_n_bytes()
* cpg-ref-SP_get_list_n_codes:: SP_get_list_n_codes()
* cpg-ref-SP_get_number_codes:: SP_get_number_codes()
* cpg-ref-SP_get_stream_counts:: SP_get_stream_counts()
* cpg-ref-SP_get_stream_user_data:: SP_get_stream_user_data()
* cpg-ref-SP_get_string:: SP_get_string()
* cpg-ref-SP_getenv:: SP_getenv()
* cpg-ref-SP_initialize:: SP_initialize()
* cpg-ref-SP_is_atom:: SP_is_atom()
* cpg-ref-SP_is_atomic:: SP_is_atomic()
* cpg-ref-SP_is_compound:: SP_is_compound()
* cpg-ref-SP_is_float:: SP_is_float()
* cpg-ref-SP_is_integer:: SP_is_integer()
* cpg-ref-SP_is_list:: SP_is_list()
* cpg-ref-SP_is_number:: SP_is_number()
* cpg-ref-SP_is_variable:: SP_is_variable()
* cpg-ref-SP_load:: SP_load()
* cpg-ref-SP_load_sicstus_run_time:: SP_load_sicstus_run_time()
* cpg-ref-SP_malloc:: SP_malloc()
* cpg-ref-SP_mutex_lock:: SP_mutex_lock()
* cpg-ref-SP_mutex_unlock:: SP_mutex_unlock()
* cpg-ref-SP_new_term_ref:: SP_new_term_ref()
* cpg-ref-SP_next_solution:: SP_next_solution()
* cpg-ref-SP_next_stream:: SP_next_stream()
* cpg-ref-SP_open_query:: SP_open_query()
* cpg-ref-SP_pred:: SP_pred()
* cpg-ref-SP_predicate:: SP_predicate()
* cpg-ref-SP_printf:: SP_printf()
* cpg-ref-SP_put_address:: SP_put_address()
* cpg-ref-SP_put_atom:: SP_put_atom()
* cpg-ref-SP_put_byte:: SP_put_byte()
* cpg-ref-SP_put_bytes:: SP_put_bytes()
* cpg-ref-SP_put_code:: SP_put_code()
* cpg-ref-SP_put_codes:: SP_put_codes()
* cpg-ref-SP_put_encoded_string:: SP_put_encoded_string()
* cpg-ref-SP_put_float:: SP_put_float()
* cpg-ref-SP_put_functor:: SP_put_functor()
* cpg-ref-SP_put_integer:: SP_put_integer()
* cpg-ref-SP_put_integer_bytes:: SP_put_integer_bytes()
* cpg-ref-SP_put_list:: SP_put_list()
* cpg-ref-SP_put_list_codes:: SP_put_list_codes()
* cpg-ref-SP_put_list_n_bytes:: SP_put_list_n_bytes()
* cpg-ref-SP_put_list_n_codes:: SP_put_list_n_codes()
* cpg-ref-SP_put_number_codes:: SP_put_number_codes()
* cpg-ref-SP_put_string:: SP_put_string()
* cpg-ref-SP_put_term:: SP_put_term()
* cpg-ref-SP_put_variable:: SP_put_variable()
* cpg-ref-SP_query:: SP_query()
* cpg-ref-SP_query_cut_fail:: SP_query_cut_fail()
* cpg-ref-SP_raise_exception:: SP_raise_exception()
* cpg-ref-SP_read_from_string:: SP_read_from_string()
* cpg-ref-SP_realloc:: SP_realloc()
* cpg-ref-SP_register_atom:: SP_register_atom()
* cpg-ref-SP_restore:: SP_restore()
* cpg-ref-SP_set_argv:: SP_set_argv()
* cpg-ref-SP_set_current_dir:: SP_set_current_dir()
* cpg-ref-SP_set_memalloc_hooks:: SP_set_memalloc_hooks()
* cpg-ref-SP_set_user_stream_hook:: SP_set_user_stream_hook()
* cpg-ref-SP_set_user_stream_post_hook:: SP_set_user_stream_post_hook()
* cpg-ref-SP_signal:: SP_signal()
* cpg-ref-SP_strdup:: SP_strdup()
* cpg-ref-SP_string_from_atom:: SP_string_from_atom()
* cpg-ref-SP_term_type:: SP_term_type()
* cpg-ref-SP_unget_byte:: SP_unget_byte()
* cpg-ref-SP_unget_code:: SP_unget_code()
* cpg-ref-SP_unify:: SP_unify()
* cpg-ref-SP_unregister_atom:: SP_unregister_atom()
* cpg-ref-SU_initialize:: SU_initialize()
* cpg-ref-user_close:: user_close()
* cpg-ref-user_flush_output:: user_flush_output()
* cpg-ref-user_read:: user_read()
* cpg-ref-user_write:: user_write()


File: sicstus.info,  Node: cpg-ref-SP_atom_from_string,  Next: cpg-ref-SP_atom_length,  Up: cpg-bif

12.3.1 'SP_atom_from_string()'
------------------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     SP_atom
     SP_atom_from_string(char const *str);

   Finds the Prolog atom whose characters are encoded by 'str'.

Arguments
---------

STR
     The characters comprising the atom.

Return Value
------------

The SP_atom, if 'str' is a valid internal character encoding, and 0
otherwise.

See Also
--------

*note Creating and Manipulating SP_term_refs::.


File: sicstus.info,  Node: cpg-ref-SP_atom_length,  Next: cpg-ref-SP_calloc,  Prev: cpg-ref-SP_atom_from_string,  Up: cpg-bif

12.3.2 'SP_atom_length()'
-------------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     size_t
     SP_atom_length(SP_atom atom);

   Obtains the length of the encoded string representing a Prolog atom.

Arguments
---------

ATOM
     The atom to inspect.

Return Value
------------

The length if 'atom' is valid, and 0 otherwise.

Description
-----------

Same as 'strlen(SP_string_from_atom(a)', but runs in O(1) time.

See Also
--------

*note Creating and Manipulating SP_term_refs::.


File: sicstus.info,  Node: cpg-ref-SP_calloc,  Next: cpg-ref-SP_close_query,  Prev: cpg-ref-SP_atom_length,  Up: cpg-bif

12.3.3 'SP_calloc()'
--------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     void *
     SP_calloc(size_t nmemb,
               size_t size);

   Allocates a block of at least 'size * nemb'.  The first 'size *
nmemb' bytes are set to zero.

Arguments
---------

NMEMB
     How many items to allocate.

SIZE
     Size of each item.

Return Value
------------

The pointer, if allocation was successful, otherwise 'NULL'.

See Also
--------

*note OS Memory Management::.


File: sicstus.info,  Node: cpg-ref-SP_close_query,  Next: cpg-ref-SP_compare,  Prev: cpg-ref-SP_calloc,  Up: cpg-bif

12.3.4 'SP_close_query()'
-------------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     int
     SP_close_query(SP_qid query);

   Discard the current solution to the given query, and close it.

Arguments
---------

QUERY
     The query, created by 'SP_open_query()'.

Return Value
------------

'SP_SUCCESS' for success, 'SP_ERROR' if an error condition occurred.

Description
-----------

This will discard the choices created since the corresponding
'SP_open_query()', and then backtrack into the query, throwing away any
current solution, like the goal '!, fail'.  The given argument does not
have to be the innermost open query; any open queries in its scope will
also be closed.

See Also
--------

*note Finding Multiple Solutions of a Call::.


File: sicstus.info,  Node: cpg-ref-SP_compare,  Next: cpg-ref-SP_cons_functor,  Prev: cpg-ref-SP_close_query,  Up: cpg-bif

12.3.5 'SP_compare()'
---------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     int
     SP_compare(SP_term_ref x,
                SP_term_ref y)

   Compares two terms.

Arguments
---------

X
     The one term to compare

Y
     The other term to compare

Return Value
------------

-1 if 'x' @< 'y', 0 if 'x' == 'y', and 1 if 'x' @> 'y'.

See Also
--------

*note ref-lte-cte::, *note Unifying and Comparing Terms::.


File: sicstus.info,  Node: cpg-ref-SP_cons_functor,  Next: cpg-ref-SP_cons_functor_array,  Prev: cpg-ref-SP_compare,  Up: cpg-bif

12.3.6 'SP_cons_functor()'
--------------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     int
     SP_cons_functor(SP_term_ref term,
                     SP_atom name,
                     int arity,
                     SP_term_ref arg, ...);

   Assigns to 'term' a reference to a compound term whose arguments are
the values of 'arg'....  If 'arity' is 0, assigns the Prolog atom whose
canonical representation is 'name'.  This is similar to calling '=../2'
with the first argument unbound and the second argument bound.

Arguments
---------

TERM
     The SP_term_ref to be assigned

NAME
     The name of the functor

ARITY
     The arity of the functor

ARG ...
     The arguments

Return Value
------------

Zero if the conversion fails (as far as failure can be detected), and a
nonzero value otherwise.

See Also
--------

*note Creating Prolog Terms::.


File: sicstus.info,  Node: cpg-ref-SP_cons_functor_array,  Next: cpg-ref-SP_cons_list,  Prev: cpg-ref-SP_cons_functor,  Up: cpg-bif

12.3.7 'SP_cons_functor_array()'
--------------------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     int
     SP_cons_functor_array(SP_term_ref term,
     		      SP_atom name,
     		      int arity,
     		      SP_term_ref *arg);

   Assigns to 'term' a reference to a compound term whose arguments are
the elements of 'arg'.  If 'arity' is 0, assigns the Prolog atom whose
canonical representation is 'name'.  This is similar to calling '=../2'
with the first argument unbound and the second argument bound.

Arguments
---------

TERM
     The SP_term_ref to be assigned

NAME
     The name of the functor

ARITY
     The arity of the functor

ARG
     The argument array

Return Value
------------

Zero if the conversion fails (as far as failure can be detected), and a
nonzero value otherwise.

See Also
--------

*note Creating Prolog Terms::.


File: sicstus.info,  Node: cpg-ref-SP_cons_list,  Next: cpg-ref-SP_create_stream,  Prev: cpg-ref-SP_cons_functor_array,  Up: cpg-bif

12.3.8 'SP_cons_list()'
-----------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     int
     SP_cons_list(SP_term_ref term,
                  SP_term_ref head,
                  SP_term_ref tail);

   Assigns to 'term' a reference to a Prolog list whose head and tail
are the values of 'head' and 'tail'.

Arguments
---------

TERM
     The SP_term_ref to be assigned

HEAD
     The head of the new list

TAIL
     The tail of the new list

Return Value
------------

Zero if the conversion fails (as far as failure can be detected), and a
nonzero value otherwise.

See Also
--------

*note Creating Prolog Terms::.


File: sicstus.info,  Node: cpg-ref-SP_create_stream,  Next: cpg-ref-SP_cut_query,  Prev: cpg-ref-SP_cons_list,  Up: cpg-bif

12.3.9 'SP_create_stream()'
---------------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     spio_t_error_code
     SP_create_stream(
        void *user_data,
        void const *user_class,
        spio_t_simple_device_read *user_read,
        spio_t_simple_device_write *user_write,
        spio_t_simple_device_flush_output *user_flush_output,
        spio_t_simple_device_seek *user_seek,
        spio_t_simple_device_close *user_close,
        spio_t_simple_device_interrupt *user_interrupt,
        spio_t_simple_device_ioctl *user_ioctl,
        spio_t_bits create_stream_options,
        SP_stream **pstream);

   Create a Prolog stream that will call user defined functions to
perform stream operations.

Arguments
---------

USER_DATA
     This is a pointer to arbitrary user specified data.  It is passed
     to all user defined stream methods.  It must not be 'NULL'.

USER_CLASS
     Arbitrary pointer.  This is used with 'SP_get_stream_user_data()',
     which see.

USER_READ
     If non-NULL then this is an input stream.  *Note
     cpg-ref-user_read::.  for details.

USER_WRITE
     If non-NULL then this is an output stream.  *Note
     cpg-ref-user_write::.  for details.

     Note that both 'user_read' and 'user_write' can be specified,
     signifying a bidirectional stream.

USER_FLUSH_OUTPUT
     Will be called to flush output on the stream.  Ignored if
     'user_write' is 'NULL'.  Can be 'NULL' if the stream need not be
     flushed, e.g. if 'user_write' always ensures that any output
     reaches its destination immediately.  *Note
     cpg-ref-user_flush_output::.  for details.

USER_SEEK
     Reserved, should be 'NULL'.

USER_CLOSE
     Closes the stream.  *Note cpg-ref-user_close::.  for details.

USER_INTERRUPT
     Reserved, should be 'NULL'.

USER_IOCTL
     Reserved, should be 'NULL'.

ARGS
     Reserved, should be 'NULL'.

CREATE_STREAM_OPTIONS
     The following bits can be set:

     'SP_CREATE_STREAM_OPTION_BINARY'
          This is a binary stream.  The 'user_read' and 'user_write'
          methods transfer bytes.

     'SP_CREATE_STREAM_OPTION_TEXT'
          This is a TEXT stream.  The 'user_read' and 'user_write'
          methods transfer wide characters.

     'SP_CREATE_STREAM_OPTION_AUTOFLUSH'
          After writing to this stream prolog predicates will do a
          'flush_output/1'.  In essence this ensures that the stream
          behaves as if it were unbuffered.

     'SP_CREATE_STREAM_OPTION_INTERACTIVE'
          Treat this stream as an interactive stream.  Implies
          'SP_CREATE_STREAM_OPTION_AUTOFLUSH'.

     'SP_CREATE_STREAM_OPTION_EOF_ON_EOF'
     'SP_CREATE_STREAM_OPTION_RESET_ON_EOF'
          These correspond to the 'open/4' options 'eof_action(eof)' and
          'eof_action(reset)' respectively.  The default is to give an
          error if reading after reaching end of file.

     Exactly one of 'SP_CREATE_STREAM_OPTION_BINARY' and
     'SP_CREATE_STREAM_OPTION_TEXT' must be set.

PSTREAM
     This is assigned to the created SICStus stream on success.  It
     should be closed with 'SP_fclose()' or 'close/[1,2]'.

Return Value
------------

On success, '*pstream' is assigned, and 'SPIO_S_NOERR' or some other
success code is returned.  You should use the 'SPIO_FAILED()' macro to
determine if the return value signifies failure or success.

See Also
--------

*note Defining a New Stream::.


File: sicstus.info,  Node: cpg-ref-SP_cut_query,  Next: cpg-ref-SP_define_c_predicate,  Prev: cpg-ref-SP_create_stream,  Up: cpg-bif

12.3.10 'SP_cut_query()'
------------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     int
     SP_cut_query(SP_qid query);

   Commit to the current solution to the given query, and close it.

Arguments
---------

QUERY
     The query, created by 'SP_open_query()'.

Return Value
------------

'SP_SUCCESS' for success, 'SP_FAILURE' for failure, 'SP_ERROR' if an
error condition occurred.

Description
-----------

This will discard the choices created since the corresponding
'SP_open_query()', like the goal '!'.  The current solution is retained
in the arguments until backtracking into any enclosing query.  The given
argument does not have to be the innermost open query; any open queries
in its scope will also be cut.

See Also
--------

*note Finding Multiple Solutions of a Call::.


File: sicstus.info,  Node: cpg-ref-SP_define_c_predicate,  Next: cpg-ref-SP_deinitialize,  Prev: cpg-ref-SP_cut_query,  Up: cpg-bif

12.3.11 'SP_define_c_predicate()'
---------------------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     typedef int
     SP_CPredFun(SP_term_ref goal,
                 void *stash);

     int
     SP_define_c_predicate(char *name,
                           int arity,
                           char *module,
                           SP_CPredFun *proc,
                           void *stash);

   Defines a Prolog predicate such that when the Prolog predicate is
called it will call a C function with a term corresponding to the Prolog
goal.

Arguments
---------

NAME
     The predicate name.

ARITY
     The predicate arity.

MODULE
     The predicate module name.

PROC
     The function.

STASH
     See below.

Return Value
------------

Nonzero on success, and 0 otherwise.

Description
-----------

The Prolog predicate MODULE:NAME/ARITY will be defined (the module
MODULE must already exist).  The 'stash' argument can be anything and is
simply passed as the second argument to the C function PROC.

   The C function should return 'SP_SUCCESS' for success and
'SP_FAILURE' for failure.  The C function may also call 'SP_fail()' or
'SP_raise_exception()' in which case the return value will be ignored.

Examples
--------

Here is an end-to-end example of the above:

                                                          _% square.pl_
     foreign_resource(square, [init(square_init)]).

     :- load_foreign_resource(square).
                                                          _// square.c_
     #include <sicstus/sicstus.h>

     static int square_it(SP_term_ref goal, void *stash)
     {
       SP_integer arg1;
       SP_term_ref tmp = SP_new_term_ref();
       SP_term_ref square_term = SP_new_term_ref();

       // goal will be a term like square(42,X)
       SP_get_arg(1,goal,tmp); // extract first arg
       if (!SP_get_integer(tmp,&arg1))
         return SP_FAILURE;   // type check first arg

       SP_put_integer(square_term, arg1*arg1);
       SP_get_arg(2,goal,tmp); // extract second arg

       // Unify output argument.
       // SP_put_integer(tmp,...) would *not* work!
       return (SP_unify(tmp, square_term) ? SP_SUCCESS : SP_FAILURE);
     }

     void square_init(int when)
     {
       (void)when;                   // unused
       // Install square_it as user:square/2
       SP_define_c_predicate("square", 2, "user", square_it, NULL);
     }
                                                           _# terminal_
     % splfr square.pl square.c
     % sicstus -f -l square
     % compiling /home/matsc/tmp/square.pl...
     %  loading foreign resource /home/matsc/tmp/square.so in module user
     % compiled /home/matsc/tmp/square.pl in module user, 0 msec 816 bytes
     SICStus 4.4.1 ...
     Licensed to SICS
     | ?- square(4711, X).
     X = 22193521 ?
     yes
     | ?- square(not_an_int, X).
     no

See Also
--------

*Note Calling C from Prolog::.


File: sicstus.info,  Node: cpg-ref-SP_deinitialize,  Next: cpg-ref-SP_error_message,  Prev: cpg-ref-SP_define_c_predicate,  Up: cpg-bif

12.3.12 'SP_deinitialize()'
---------------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     void
     SP_deinitialize(void);

   Shuts down the Prolog engine.

Description
-----------

'SP_deinitialize()' will make a best effort to restore the system to the
state it was in at the time of calling 'SP_initialize()'.  This involves
unloading foreign resources, shutting down the emulator, and
deallocating memory used by Prolog.

   'SP_deinitialize()' is idempotent i.e. it is a no-op unless SICStus
has actually been initialized.

See Also
--------

*note Initializing the Prolog Engine::.


File: sicstus.info,  Node: cpg-ref-SP_error_message,  Next: cpg-ref-SP_event,  Prev: cpg-ref-SP_deinitialize,  Up: cpg-bif

12.3.13 'SP_error_message()'
----------------------------

Synopsis
--------

     #include <sicstus/sicstus.h>
     char const *
     SP_error_message(int errnum);

   Obtains a pointer to the diagnostic message corresponding to a
specified error number.

Arguments
---------

ERRNUM
     The error number.

Return Value
------------

A pointer to the diagnostic message.

See Also
--------

*note CPL Notes::.


File: sicstus.info,  Node: cpg-ref-SP_event,  Next: cpg-ref-SP_exception_term,  Prev: cpg-ref-SP_error_message,  Up: cpg-bif

12.3.14 'SP_event()'
--------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     int
     SP_event(int (*func)(void*), void *arg)

   Schedules a function for execution in the main thread in contexts
where queries cannot be issued.

Arguments
---------

FUNC
     The function to schedule for execution.

ARG
     Its argument.

Return Value
------------

Nonzero on success, and 0 otherwise.

Description
-----------

If you wish to call Prolog back from a signal handler that has been
installed with 'SP_signal' or a thread other than the thread that called
'SP_initialize()', that is, the "main thread", you cannot use
'SP_query()' etc. directly.  The call to Prolog has to be delayed until
such time that the Prolog execution can accept an interrupt and the call
has to be performed from the main thread (the Prolog execution thread).
This function serves this purpose, and installs 'func' to be called from
Prolog (in the main thread) when the execution can accept a callback.

   A queue of functions, with corresponding arguments, is maintained;
that is, if several calls to 'SP_event()' occur before Prolog can accept
an interrupt, the functions are queued and executed in turn at the next
possible opportunity.  A 'func' installed with 'SP_event()' will not be
called until SICStus is actually running.  One way of ensuring that all
pending functions installed with 'SP_event()' are run is to call, from
the main thread, some dummy goal, such as,

     SP_query_cut_fail(SP_predicate("true",0,"user"));

   While 'SP_event()' is safe to call from any thread, it is not safe to
call from arbitrary signal handlers.  If you want to call 'SP_event()'
when a signal is delivered, you need to install your signal handler with
'SP_signal()'.

   Note that 'SP_event()' is one of the _very_ few functions in the
SICStus API that can safely be called from another thread than the main
thread.

   Depending on the value returned from 'func', the interrupted Prolog
execution will just continue ('SP_SUCCESS') or backtrack ('SP_FAILURE'
or 'SP_ERROR').  An exception raised by 'func', using
'SP_raise_exception()', will be processed in the interrupted Prolog
execution.  If 'func' calls 'SP_fail()' or 'SP_raise_exception()' the
return value from 'func' is ignored and handled as if 'func' returned
'SP_FAILURE' or 'SP_ERROR', respectively.  In case of failure or
exception, the event queue is flushed.

   It is generally not robust to let 'func' raise an exception or (even
worse) fail.  The reason is that not all Prolog code is written such
that it gracefully handles being interrupted.  If you want to interrupt
some long-running Prolog code, it is better to let the event handler set
a flag (in C) and let your Prolog code test the flag (using a foreign
predicate) in some part of your code that is executed repeatedly.

Examples
--------

How to install the predicate 'user:event_pred/1' as the signal handler
for 'SIGUSR1' and 'SIGUSR2' signals.

   The function 'signal_init()' installs the function 'signal_handler()'
as the primary signal handler for the signals 'SIGUSR1' and 'SIGUSR2'.
That function invokes the predicate as the actual signal handler,
passing the signal number as an argument to the predicate.

     SP_pred_ref event_pred;

     static int signal_event(void *handle)
     {
       int signal_no = (int) handle;
       SP_term_ref x=SP_new_term_ref();
       int rc;

       SP_put_integer(x, signal_no); // Should not give an error
       rc = SP_query_cut_fail(event_pred, x);
       if (rc == SP_ERROR && SP_exception_term(x))
         SP_raise_exception(x);        // Propagate any raised exception
       return rc;
     }

     static void signal_handler(int signal_no)
     {
       SP_event(signal_event, (void *)signal_no);
     }

     void signal_init(void)
     {
       event_pred = SP_predicate("prolog_handler",1,"user");

       SP_signal(SIGUSR1, signal_handler);
       SP_signal(SIGUSR2, signal_handler);
     }


See Also
--------

*note Calling Prolog Asynchronously::, 'SP_signal()', 'SP_fail()',
'SP_raise_exception()'.


File: sicstus.info,  Node: cpg-ref-SP_exception_term,  Next: cpg-ref-SP_expand_file_name,  Prev: cpg-ref-SP_event,  Up: cpg-bif

12.3.15 'SP_exception_term()'
-----------------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     int
     SP_exception_term(SP_term_ref term);

   Retracts the current pending exception term, if it exists, and
assigns it to 'term'.

Arguments
---------

TERM
     The SP_term_ref to assign.

Return Value
------------

1 if an exception term was retracted and assigned, and 0 otherwise.

See Also
--------

*note Exception Handling in C::.


File: sicstus.info,  Node: cpg-ref-SP_expand_file_name,  Next: cpg-ref-SP_fail,  Prev: cpg-ref-SP_exception_term,  Up: cpg-bif

12.3.16 'SP_expand_file_name()'
-------------------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     spio_t_error_code
     SP_expand_file_name(
        char const *relpath,
        char const *cwd,
        spio_t_bits options,
        char **pabspath);

   Expand a file name into an absolute path.

Arguments
---------

RELPATH

     The relative path to expand.  It should be an encoded string.  The
     path is subject to syntactic rewriting, as if by
     'absolute_file_name/2'.

CWD
     If the 'relpath' is a relative path, it is expanded relative to
     'cwd', unless 'cwd' is 'NULL'.  If 'cwd' is 'NULL', a relative
     'relpath' is expanded relative to the SICStus working directory (as
     returned by 'SP_get_current_dir()').

OPTIONS

     The following option bits can be set:

     'SP_EXPAND_FILE_NAME_OPTION_DIR'
          The 'relpath' is expanded as a directory, i.e. '*pabspath'
          will be slash terminated.

     'SP_EXPAND_FILE_NAME_OPTION_NO_CWD'
          An error is returned if the 'relpath' is not an absolute path
          after syntactic rewriting.

     'SP_EXPAND_FILE_NAME_OPTION_NO_ENV'
          Do not expand system properties and environment variables
          during syntactic rewriting.

     'SP_EXPAND_FILE_NAME_OPTION_NO_HOME'
          Do not expand '~' and '~user' during syntactic rewriting.

     'SP_EXPAND_FILE_NAME_OPTION_ROOT_SLASH'
          If the expanded value would refer to the root directory,
          return a slash terminated absolute path, as if
          'SP_EXPAND_FILE_NAME_OPTION_DIR' had been set.  By default, an
          error is returned if the expanded absolute path would refer to
          a root directory and 'SP_EXPAND_FILE_NAME_OPTION_DIR' is not
          set.

     'SP_EXPAND_FILE_NAME_OPTION_ROOT_DOT'
          If the expanded value would refer to the root directory,
          return an absolute path terminated with '/.'.  By default, an
          error is returned if the expanded absolute path would refer to
          a root directory and 'SP_EXPAND_FILE_NAME_OPTION_DIR' is not
          set.

PABSPATH
     On success, '*pabspath' is set to the expanded path.  This value is
     allocated with 'SP_malloc()' and should be freed with 'SP_free()'.

Return Value
------------

On success, '*pabspath' is set to the expanded path and 'SPIO_S_NOERR'
or some other success code is returned.

   On failure, an error code is returned.

See Also
--------

*note cpg-ref-SP_get_current_dir::.  *Note ref-fdi-syn::, for a
description of syntactic rewriting.  *note OS File System::.


File: sicstus.info,  Node: cpg-ref-SP_fail,  Next: cpg-ref-SP_fclose,  Prev: cpg-ref-SP_expand_file_name,  Up: cpg-bif

12.3.17 'SP_fail()'
-------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     void
     SP_fail(SP_term_ref term);

   Fails in the scope of Prolog calling C.

Arguments
---------

TERM
     The SP_term_ref whose value will be the exception term.

Description
-----------

This function is normally used in the context of a call from Prolog to
C, and will cause Prolog to backtrack on return from the call.

   *Please note*: this should only be called right before returning to
Prolog.

See Also
--------

*note Exception Handling in C::.


File: sicstus.info,  Node: cpg-ref-SP_fclose,  Next: cpg-ref-SP_flush_output,  Prev: cpg-ref-SP_fail,  Up: cpg-bif

12.3.18 'SP_fclose()'
---------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     spio_t_error_code
     SP_fclose(
       SP_stream *stream,
       spio_t_bits close_options);

   Close the stream.

Arguments
---------

STREAM
     The stream to close unless the 'SP_FCLOSE_OPTION_USER_STREAMS' is
     set, see below.

CLOSE_OPTIONS
     The following bits can be set:

     'SP_FCLOSE_OPTION_READ'
     'SP_FCLOSE_OPTION_WRITE'
          Close the specified directions.  If neither of these options
          is specified, the stream is closed in all opened directions,
          i.e. as if both options were specified.  If the stream is not
          opened in a direction specified by an option, that option is
          ignored.

          Note that it is possible to close only one direction of a
          bidirectional stream.  The return value will tell whether the
          stream is still open; see below.

     'SP_FCLOSE_OPTION_FORCE'
          Close the specified direction forcibly, i.e. without flushing
          buffers etc.  This also ensures that the close finishes
          "quickly", i.e. does not block.

     'SP_FCLOSE_OPTION_NONBLOCKING'
          You should avoid using this option.

          Pass non-blocking option to lower level routines, including
          the call to 'SP_flush_output()' that is issued when
          non-forcibly closing write direction.

          One possible use for this option is to perform a "best effort"
          close, which falls back to using 'SP_FCLOSE_OPTION_FORCE' only
          if ordinary close would block.

     'SP_FCLOSE_OPTION_USER_STREAMS'
          In this case the STREAM should not be a stream but instead be
          the 'user_class' of a user defined stream.  When this option
          is passed, all currently opened streams of that class is
          closed, using the remaining option flags.  E.g. to close all
          user defined streams of class my_class in the read direction
          only do:
          'SP_fclose((SP_stream*)my_class,SP_FCLOSE_OPTION_USER_STREAMS|SP_FCLOSE_OPTION_READ)'.

Return Value
------------

On success, all specified directions has been closed.  Since some
direction may still be open, there are two possible return values on
success:

'SPIO_S_NOERR'
     The stream is still valid, some direction is still not closed.

'SPIO_S_DEALLOCATED'
     The stream has been deallocated and cannot be used further.  All
     directions have been closed.

   On failure, returns a SPIO error code.  Error codes with special
meaning for 'SP_fclose()' are the same as for 'SP_flush_output()', which
see.  Other error codes may also be returned.

See Also
--------

*note cpg-ref-SP_flush_output::.  *note Prolog Streams::.


File: sicstus.info,  Node: cpg-ref-SP_flush_output,  Next: cpg-ref-SP_fopen,  Prev: cpg-ref-SP_fclose,  Up: cpg-bif

12.3.19 'SP_flush_output()'
---------------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     spio_t_error_code
     SP_flush_output(
       SP_stream *stream,
       spio_t_bits flush_options);

   Ensure that all buffered data reaches its destination.

Arguments
---------

STREAM
     The stream to flush.  This stream should be open for writing.

FLUSH_OPTIONS
     The following bits can be set:

     'SP_FLUSH_OUTPUT_OPTION_NONBLOCKING'

          If this is set, the function should return "quickly" or with a
          'SPIO_E_WOULD_BLOCK' code.

          Can return 'SPIO_E_NOT_SUPPORTED' if the stream cannot support
          non-blocking flush.

     'SP_FLUSH_OUTPUT_OPTION_AUTOFLUSH'
          Only flush stream if it has AUTOFLUSH enabled.

Return Value
------------

On success, all buffered data should have been written and
'SPIO_S_NOERR' or some other success code returned.

   On failure, returns a SPIO error code.  Error codes with special
meaning for 'SP_flush_output()':

'SPIO_E_END_OF_FILE'
     Returned if it is not possible to write more data onto the stream,
     e.g. some underlying device has been closed.

'SPIO_E_WOULD_BLOCK'
     'SP_FLUSH_OUTPUT_OPTION_NONBLOCKING' was set but the operation
     would block.

'SPIO_E_NOT_SUPPORTED'
     Some unsupported option, e.g. 'SP_FLUSH_OUTPUT_OPTION_NONBLOCKING',
     was passed.

Other error codes may also be returned.

See Also
--------

*note Prolog Streams::.


File: sicstus.info,  Node: cpg-ref-SP_fopen,  Next: cpg-ref-SP_foreign_stash,  Prev: cpg-ref-SP_flush_output,  Up: cpg-bif

12.3.20 'SP_fopen()'
--------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     spio_t_error_code
     SP_fopen(
       char const *pathname,
       void *reserved,
       spio_t_bits options,
       SP_stream **pstream);

   Opens a file and creates a SICStus stream reading and/or writing to
it.

Arguments
---------

PATHNAME
     The path to the file as an encoded string.  It is expanded by
     'SP_expand_file_name()' unless the option
     'SP_FOPEN_OPTION_NOEXPAND' is specified, in which case the path
     must already have been expanded by 'SP_expand_file_name()'.

RESERVED
     Reserved, should be 'NULL'.

READ_OPTIONS
     The following bits can be set:

     'SP_FOPEN_OPTION_READ'
          Open the file for reading.  The file must exist.

     'SP_FOPEN_OPTION_WRITE'
          Open the file for writing.  The file is overwritten if it
          exists.  The file is created if it does not exist.

     'SP_FOPEN_OPTION_APPEND'
          Open the file for writing but start writing at the end of the
          file if it exists.  The file is created if it does not exist.

     'SP_FOPEN_OPTION_BINARY'
          Open the file as a binary (byte) stream.

     'SP_FOPEN_OPTION_TEXT'
          Open the file as a text stream.  The default character
          encoding is "Latin 1" (i.e. the 8 bit subset of Unicode).  The
          default end of line convention is OS specific.

     'SP_FOPEN_OPTION_AUTOFLUSH'
          After writing to this stream, Prolog predicates will do a
          'flush_output/1'.  In essence this ensures that the stream
          behaves as if it were unbuffered.

     'SP_FOPEN_OPTION_INTERACTIVE'
          Treat this stream as an interactive stream.  Implies
          SP_CREATE_STREAM_OPTION_AUTOFLUSH.

     'SP_FOPEN_OPTION_NOEXPAND'
          The 'pathname' has already been expanded with
          'SP_expand_file_name()' or something similar.  This implies
          that 'pathname' is an absolute path.  If this option is not
          specified, 'pathname' is expanded with 'SP_expand_file_name()'
          before use.

PSTREAM
     On successful return, '*pstream' will be set to the created stream.

Return Value
------------

On success, '*pstream' will be set to the created stream and
'SPIO_S_NOERR' or some other success code returned.

   On failure, some SPIO failure code will be returned.  Error codes
with special meaning for 'SP_fopen()':

'SPIO_E_FILE_NOT_FOUND'
     The file does not exist.

'SPIO_E_FILE_ACCESS'
     Insufficient permissions to open or create the file.

'SPIO_E_OPEN_ERROR'
     Generic error during open.

Other error codes may also be returned.

See Also
--------

*note Prolog Streams::.


File: sicstus.info,  Node: cpg-ref-SP_foreign_stash,  Next: cpg-ref-SP_fprintf,  Prev: cpg-ref-SP_fopen,  Up: cpg-bif

12.3.21 'SP_foreign_stash()'   macro
------------------------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     void *
     SP_foreign_stash();

   Obtains a storage location that is unique to the calling foreign
resource.

Return Value
------------

The location, initially set to 'NULL'.

Description
-----------

A dynamic foreign resource that is used by multiple SICStus runtimes in
the same process may need to maintain a global state that is kept
separate for each SICStus runtime.  Each SICStus runtime maintains a
location (containing a 'void*') for each foreign resource.  A foreign
resource can then access this location to store any data that is
specific to the calling SICStus runtime.

   You can use 'SP_foreign_stash()' to get access to a location, where
the foreign resource can store a 'void*'.  Typically this would be a
pointer to a C struct that holds all information that need to be stored
in global variables.  This struct can be allocated and initialized by
the foreign resource init function, it should be deallocated by the
foreign resource deinit function.

   'SP_foreign_stash()' is only available for use in dynamic foreign
resources.

Examples
--------

The value returned by 'SP_foreign_stash()' is only valid until the next
SICStus API call.  The correct way to initialize the location pointed at
by 'SP_foreign_stash()' is therefore:
     struct my_state {...};

     init_my_foreign_resource(...)
     {
        struct my_state *p = SP_malloc(sizeof(struct my_state));
        (*SP_foreign_stash()) = (void*)p;
     }

The following example is incorrect; 'SP_malloc()' may be called between
the time 'SP_foreign_stash()' is called and the time its return value is
used:
     // WRONG
     (*SP_foreign_stash()) = SP_malloc(sizeof(struct my_state));

See Also
--------

*note OS Threads::.


File: sicstus.info,  Node: cpg-ref-SP_fprintf,  Next: cpg-ref-SP_free,  Prev: cpg-ref-SP_foreign_stash,  Up: cpg-bif

12.3.22 'SP_fprintf()'
----------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     spio_t_error_code
     SP_fprintf(
        SP_stream *stream,
        char const *fmt, ...);

   Formatted output on the Prolog stream 'stream'.

Arguments
---------

STREAM
     The stream.  Must be a text stream open for output.

FMT
     The format string.  This uses the same syntax as the C library
     'printf' functions.

...
     The data to format.

Return Value
------------

On success, all data has been written and 'SPIO_S_NOERR' or some other
success code returned.

   On failure, returns an error code without transferring any data.
Error codes with special meaning for 'SP_fprintf()':

'SPIO_E_PARAMETER_ERROR'
     The underlying C library function reported an error while
     formatting the string.

Other error codes may also be returned.

Description
-----------

First the formatting operation will be performed.  The resulting string
will be assumed to be in internal encoding, and will then be output
using the 'SP_put_encoded_string()' function.  This means e.g. that the
'%c' printf conversion specification can only be used for ASCII
characters, and the strings included using a '%s' specification should
also be encoded strings.

See Also
--------

*note Prolog Streams::.
