This is sicstus.info, produced by makeinfo version 5.2 from
sicstus.texi.

INFO-DIR-SECTION SICStus Prolog
START-INFO-DIR-ENTRY
* SICStus Prolog Manual: (sicstus).			SICStus Prolog User's Manual.
END-INFO-DIR-ENTRY

Generated March 15, 2018.


File: sicstus.info,  Node: Breakpoint Actions,  Next: Advice-points,  Prev: Specific and Generic Breakpoints,  Up: Advanced Debugging

5.6.5 Breakpoint Actions
------------------------

The action part of a breakpoint spec supplies information to the
debugger as to what should be done when the breakpoint is activated.
This is achieved by setting the three so called "debugger action
variables".  These are listed below, together with their most important
values.

   * The 'show' variable prescribes how the debugged goal should be
     displayed:

     'print'
          write the goal according to the 'debugger_print_options'
          Prolog flag.
     'silent'
          do not display the goal.

   * The 'command' variable prescribes what the debugger should do:

     'ask'
          ask the user.
     'proceed'
          continue the execution without stopping, creating a procedure
          box for the current goal at the Call port,
     'flit'
          continue the execution without stopping, without creating a
          procedure box for the current goal at the Call port.

   * The 'mode' variable prescribes in what mode the debugger should
     continue the execution:

     'trace'
          creeping.
     'debug'
          leaping.
     'zip'
          zipping.
     'off'
          without debugging.

   For example, the breakpoint below specifies that whenever the Exit
port of 'foo/2' is reached, no trace message should be output, no
interaction should take place and the debugger should be switched off.

     | ?- add_breakpoint([pred(foo/2),port(exit)]-
                         [show(silent),command(proceed),mode(off)], _).

   Here, the action part consists of three actions, setting the three
action variables.  This breakpoint spec can be simplified by omitting
the wrappers around the variable values, as the sets of possible values
of the variables are all disjoint.  If we use 'spy/2', then the 'pred'
wrapper goes away, too, resulting in a much more concise, equivalent
formulation of the above breakpoint:

     | ?- spy(foo/2,exit-[silent,proceed,off]).

   Let us now revisit the process of breakpoint selection.  When the
debugger arrives at a port it first initializes the action variables
according to the current debugging and leashing modes, as shown below:

     debugging    leashing           |        Action variables
     mode         mode               |  show        command     mode
     --------------------------------|-------------------------------
     trace        at leashed port    |  print       ask         trace
                                     |
     trace        at unleashed port  |  print       proceed     trace
                                     |
     debug        -                  |  silent      proceed     debug
                                     |
     zip          -                  |  silent      flit        zip

   It then considers each breakpoint, most recent first, until it finds
a breakpoint whose test part succeeds.  If such a breakpoint is found,
then its action part is evaluated, normally changing the action variable
settings.  A failure of the action part is ignored, in the sense that
the breakpoint is still treated as the selected one.  However, as a
side-effect, a procedure box will always be built in such cases.  More
precisely, the failure of the action part causes the 'flit' command
value to be changed to 'proceed', all other command values being left
unchanged.  This is to facilitate the creation of breakpoints that stop
at non-Call ports (see below for an example).

   If no applicable breakpoint is found, then the action variables
remain unchanged.

   The debugger then executes the actions specified by the action
variables.  This process, referred to as the "action execution", means
the following:
   * The current debugging mode is set to the value of the 'mode' action
     variable.
   * A trace message is displayed according to the 'show' variable.
   * The program continues according to the 'command' variable.

   Specifically, if 'command' is 'ask', then the user is prompted for a
debugger command, which in turn is converted to new assignments to the
action variables.  The debugger will then repeat the action execution
process, described above.  For example, the 'c' (creep) interactive
command is converted to '[silent,proceed,trace]', the 'd' (display)
command to '[display,ask]' (when command is 'ask', the mode is
irrelevant), etc.

   The default values of the action variables correspond to the standard
debugger behavior described in *note Basic Debug::.  For example, when
an unleashed port is reached in trace mode, a trace message is printed
and the execution proceeds in trace mode, without stopping.  In zip
mode, no trace message is shown, and execution continues in zip mode,
without building procedure boxes at Call ports.

   Note that a spypoint action part that is empty ('[]' or not present)
is actually treated as '[print,ask]'.  Again, this is the standard
behavior of spypoints, as described in *note Basic Debug::.

   If an action part is nonempty, but it does not set the action
variables, then the only effect it will have is to hide the remaining
older spypoints, as the debugger will behave in the standard way,
according to the debugging mode.  Still, such breakpoints may be useful
if they have side-effects, for example:

     | ?- spy(foo/2, -[parent_pred(P),
                       goal(G),
                       true(format('~q called from:~w~n',[G,P]))]).
     % The debugger will first zip -- showing spypoints (zip)
     % Conditional spypoint for user:foo/2 added, BID=1
     true
     % zip
     | ?- foo(3,X).
     foo(2,_701) called from:bar/3
     foo(1,_1108) called from:bar/3
     foo(0,_1109) called from:bar/3
     foo(1,_702) called from:bar/3
     X = 2 ? ;
     no

   This spypoint produces some output at ports of 'foo/2', but otherwise
will not influence the debugger.  Notice that a breakpoint spec with an
empty test part can be written '-'ACTIONS.

   Let us look at some simple examples of what other effects can be
achieved by appropriate action variable settings:

     | ?- spy(foo/2, -[print,proceed]).

   This is an example of an unleashed spypoint: it will print a trace
message passing each port of 'foo/2', but will not stop there.  Note
that because of the 'proceed' command a procedure box will be built,
even in zip mode, and so the debugger will be activated at non-Call
ports of 'foo/2'.

   The next example is a variant of the above:

     | ?- spy(foo/2, -[print,flit]).

   This will print a trace message at the Call port of 'foo/2' and will
then continue the execution in the current debugging mode, without
building a procedure box for this call.  This means that the debugger
will not be able to notice any other ports of 'foo/2'.

   Now let us address the task of stopping at a specific non-Call port
of a predicate.  For this to work in zip mode, one has to ensure that a
procedure box is built at the Call port.  In the following example, the
first spypoint causes a box to be built for each call of 'foo/2', while
the second one makes the debugger stop when the Fail port of 'foo/2' is
reached.

     | ?- spy(foo/2, call-proceed), spy(foo/2, fail).
     % Conditional spypoint for user:foo/2 added, BID=1
     % Conditional spypoint for user:foo/2 added, BID=2

   You can achieve the same effect with a single spypoint, by putting
the 'fail' condition (which is a shortcut for 'port(fail)') in the
_action_ part, rather than in the _test_ part.

     | ?- spy(foo/2, -[fail,print,ask]).

   Here, when the execution reaches the Call port of 'foo/2', the test
part (which contains the 'pred(foo/2)' condition only) succeeds, so the
breakpoint is found applicable.  However, the action part fails at the
Call port.  This has a side-effect in zip mode, as the default 'flit'
command value is changed to 'proceed'.  In other modes the action
variables are unaffected.  The net result is that a procedure box is
always built for 'foo/2', which means that the debugger will actually
reach the Fail port of this predicate.  When this happens, the action
part succeeds, and executing the actions 'print,ask' will cause the
debugger to stop.

   Note that we have to explicitly mention the 'print,ask' actions here,
because the action part is otherwise nonempty (contains the 'fail'
condition).  It is only the empty or missing action part, which is
replaced by the default '[print,ask]'.  If you want to include a
condition in the action part, then you have to explicitly mention all
action variable settings you need.

   To make this simpler, the debugger handles breakpoint condition
macros, which expand to other conditions.  For example 'leash' is a
macro that expands to '[print,ask]'.  Consequently, the last example can
be simplified to:

     | ?- spy(foo/2, -[fail,leash]).

   Similarly, the macro 'unleash' expands to '[print,proceed]', while
'hide' to '[silent,proceed]'.

   We now briefly describe further possible settings to the action
variables.

   The 'mode' variable can be assigned the values 'skip(INV)' and
'qskip(INV)', meaning skipping and quasi-skipping until a port is
reached whose invocation number is less or equal to INV.  When the
debugger arrives at this port it sets the 'mode' variable to 'trace'.

   It may be surprising that 'skip(...)' is a mode, rather than a
command.  This is because commands are executed and immediately
forgotten, but skipping has a lasting effect: the program is to be run
with no debugging until a specific point, without creating new procedure
boxes, and ignoring the existing ones in the meantime.

   Here is an example using the 'skip' mode:

     | ?- spy(foo/2,call-[print,proceed,inv(Inv),skip(Inv)]).

   This breakpoint will be found applicable at Call ports of 'foo/2'.
It will print a trace message there and will skip over to the Exit or
Fail port without stopping.  Notice that the number of the current
invocation is obtained in the action part, using the 'inv' condition
with a variable argument.  A variant of this example follows:

     | ?- spy(foo/2,-[silent,proceed,
                            (   call -> inv(Inv), skip(Inv)
                            ;   true
                            )]).

   This spypoint makes 'foo/2' invisible in the output of the debugger:
at all ports we silently proceed (i.e. display nothing and do not stop).
Furthermore, at the Call port we perform a skip, so neither 'foo/2'
itself, nor any predicate called within it will be shown by the
debugger.

   Notice the use of the 'true/0' test in the above conditional!  This
is a breakpoint test that always succeeds.  The debugger also recognizes
'false' as a test that always fails.  Note that while 'false' and 'fail'
are synonyms as built-in predicates, they are completely different as
breakpoint conditions: the latter is a shortcut for 'port(fail)'.

   The 'show' variable has four additional value patterns.  Setting it
to 'display', 'write', or 'write_term(OPTIONS)' will result in the
debugged goal G being shown using 'display(G)', 'writeq(G)', or
'write_term(G, OPTIONS)', respectively.  The fourth pattern,
'METHOD-SEL', can be used for replacing the goal in the trace message by
one of its subterms, the one pointed to by the selector SEL.

   For example, the following spypoint instructs the debugger to stop at
each port of 'foo/2', and to only display the first argument of 'foo/2'
in the trace message, instead of the complete goal.

     | ?- spy(foo/2, -[print-[1],ask]).
     % Conditional spypoint for user:foo/2 added, BID=1
     | ?- foo(5,X).
      *      1      1 Call: ^1 5 ?

   The 'command' variable has several further value patterns.  The
variable can be set to 'proceed(OLDGOAL,NEWGOAL)'.  At a Call port this
instructs the debugger to first build a procedure box for the current
goal, then to unify it with OLDGOAL and finally execute NEWGOAL in its
place (cf. the 'u' (unify) interactive debugger command).  At non-Call
ports this command first goes back to the Call port (cf. the 'r' (retry)
command), and then does the above activities.

   A variant of the 'proceed/2' command is 'flit(OLDGOAL,NEWGOAL)'.
This has the same effect, except for not building a procedure box for
OLDGOAL.

   We now just briefly list further command values (for the details, see
*note Action Variables::).  Setting 'command' to 'raise(E)' will raise
an exception E, 'abort' will abort the execution.  The values
'retry(INV)', 'reexit(INV)', 'redo(INV)', 'fail(INV)' will cause the
debugger to go back to an earlier Call, Exit, Redo, or Fail port with
invocation number INV (cf. the 'j' (jump) interactive debugger command).

   Sometimes it may be useful to access the value of an action variable.
This can be done with the 'get' condition: e.g. 'get(mode(M))' will
unify 'M' with the current execution mode.  The 'get(...)' wrapper can
be omitted in the test part, but not in the action part (since there a
'mode(M)' action will set, rather than read, the mode action variable).
For example:

     | ?- spy(foo/2, mode(trace)-show(print-[1])).

   This spypoint will be found applicable only in trace mode (and will
cause the first argument of 'foo/2' to appear in the trace message).
(The 'mode' and 'show' wrappers can also be omitted in the above
example, they are used only to help with interpreting the breakpoint
spec.)


File: sicstus.info,  Node: Advice-points,  Next: Built-in Predicates for Breakpoint Handling,  Prev: Breakpoint Actions,  Up: Advanced Debugging

5.6.6 Advice-points
-------------------

As mentioned earlier, there are two kinds of breakpoints: spypoints and
advice-points.  The main purpose of spypoints is to support interactive
debugging.  In contrast with this, advice-points can help you to perform
non-interactive debugging activities.  For example, the following
advice-point will check a program invariant: whether the condition
'Y-X<3' always holds at exit from 'foo(X,Y)'.

     | ?- add_breakpoint([pred(foo/2),advice] 
                         -[exit,goal(foo(X,Y)),\+true(Y-X<3),trace], _).
     % Conditional advice point for user:foo/2 added, BID=1
     % advice
     | ?- foo(4, Y).
     Y = 3
     % advice
     | ?- foo(9, Y).
             3      3 Exit: foo(7,13) ? n
             2      2 Exit: foo(8,21) ?

   The test part of the above breakpoint contains a 'pred' test, and the
'advice' condition, making it an advice-point.  (You can also include
the 'debugger' condition in spypoint specs, although this is the default
interpretation.)

   The action part starts with the 'exit' port condition.  Because of
this the rest of the action part is evaluated only at Exit ports.  By
placing the port condition in the action part, we ensure the creation of
a procedure box at the Call port, as explained earlier.

   Next, we get hold of the goal arguments using the 'goal' condition,
and use the '\+true(Y-X<3)' test to check if the invariant is violated.
If this happens, then the last condition sets the 'mode' action variable
to 'trace', switching on the interactive debugger.

   Following the 'add_breakpoint/2' call the above example shows two
top-level calls to 'foo/2'.  The invariant holds within the first goal,
but is violated within the second.  Notice that the advice mechanism
works with the interactive debugger switched off.

   You can ask the question, why do we need advice-points?  The same
task could be implemented using a spypoint.  For example:

     | ?- add_breakpoint(pred(foo/2)
                         -[exit,goal(foo(X,Y)),\+true(Y-X<3),leash], _).
     % The debugger will first zip -- showing spypoints (zip)
     % Conditional spypoint for user:foo/2 added, BID=1
     % zip
     | ?- foo(4, X).
     X = 3
     % zip
     | ?- foo(9, X).
      *      3      3 Exit: foo(7,13) ? z
      *      2      2 Exit: foo(8,21) ?

   The main reason to have a separate advice mechanism is to be able to
perform checks independently of the interactive debugging.  With the
second solution, if you happen to start some interactive debugging, then
you cannot be sure that the invariant is always checked.  For example,
no spypoints will be activated during a skip.  In contrast with this,
the advice mechanism is watching the program execution all the time,
independently of the debugging mode.

   Advice-points are handled in very much the same way as spypoints are.
When arriving at a port, advice-point selection takes place first,
followed by spypoint selection.  This can be viewed as the debugger
making two passes over the current breakpoints, considering
advice-points only in the first pass, and spypoints only in the second.

   In both passes the debugger tries to find a breakpoint that can be
activated, checking the test and action parts, as described earlier.
However, there are some differences between the two passes:

   * Advice processing is performed if there are any (non-disabled)
     advice-points.  Spypoint processing is only done if the debugger is
     switched on, and is not doing a skip.
   * For advice-points, the action variables are initialized as follows:
     'mode' is set to current debugging mode, 'command = proceed', 'show
     = silent'.  Note that this is done independently of the debugging
     mode (in contrast with the spypoint search initialization).
   * The default action part for advice-points is '[]'.  This means that
     if no action part is given, then the only effect of the
     advice-point will be to build a procedure box (because of the
     'command = proceed' initialization).
   * If no advice-point was found applicable, then 'command' is set to
     'flit'.

   Having performed advice processing, the debugger inspects the
'command' variable.  The command values different from 'proceed' and
'flit' are called "divertive", as they alter the normal flow of control
(e.g. 'proceed(...,...)'), or involve user interaction ('ask').  If the
'command' value is divertive, then the prescribed action is performed
immediately, without executing the spypoint selection process.
Otherwise, if 'command = proceed', then it is noted that the advice part
requests the building of a procedure box.  Next, the second, spypoint
processing pass is carried out, and possible user interaction takes
place, as described earlier.  A procedure box is built if either the
advice-point or the spypoint search requests this.

   Let us conclude this section by another example, a generic
advice-point for collecting branch coverage information:

     | ?- add_breakpoint(
           (advice,call) -
               (   line(F,L) -> true(assert(line_reached(F,L))), flit
               ;   flit
               ), _).
     % Generic advice point added, BID=1
     % advice,source_info
     | ?- foo(4,X).
     X = 3 ? ;
     no
     % advice,source_info
     | ?- setof(X, line_reached(F,X), S).
     F = '/home/bob/myprog.pl',
     S = [31,33,34,35,36]

   This advice-point will be applicable at every Call port.  It will
then assert a fact with the file name and the line number if source
information is available.  Finally, it will set the 'command' variable
to 'flit' on both branches of execution.  This is to communicate the
fact that the advice-point does not request the building of a procedure
box.

   It is important to note that this recording of the line numbers
reached is performed independently of the interactive debugging.

   In this example we used the '','/2' operator, rather than list
notation, for describing the conjunction of conditions, as this seems to
better fit the if-then-else expression used in the action part.  We
could have still used lists in the tests part, and in the "then" part of
the actions.  Note that if we omit the "else" branch, then the action
part will fail if no source information is available for the given call.
This will cause a procedure box to be built, which is an unnecessary
overhead.  An alternative solution, using the 'line/2' test twice, is
the following:

     | ?- add_breakpoint([advice,call,line(_,_)]-
                         [line(F,L),true(assert(line_reached(F,L))),flit], _).

   Further examples of advice-points are available in
'library(debugger_examples)'.


File: sicstus.info,  Node: Built-in Predicates for Breakpoint Handling,  Next: Accessing Past Debugger States,  Prev: Advice-points,  Up: Advanced Debugging

5.6.7 Built-in Predicates for Breakpoint Handling
-------------------------------------------------

This section introduces built-in predicates for evaluating breakpoint
conditions, and for retrieving, deleting, disabling and enabling
breakpoints.

   The breakpoint spec of the last advice-point example was quite
complex.  And, to be practical, it should be improved to assert only
line numbers not recorded so far.  For this you will write a Prolog
predicate for the conditional assertion of file/line information,
'assert_line_reached(File,Line)', and use it instead of the
'assert(line_reached(F,L))' condition.

   Because of the complexity of the breakpoint spec, it looks like a
good idea to move the if-then-else condition into Prolog code.  This
requires that we test the 'line(F,L)' condition from Prolog.  The
built-in predicate 'execution_state/1' serves for this purpose.  It
takes a simple or a composite breakpoint condition as its argument and
evaluates it, as if in the test part of a breakpoint spec.  The
predicate will succeed if and only if the breakpoint condition evaluates
successfully.  Thus 'execution_state/1' allows you to access debugging
information from within Prolog code.  For example, you can write a
Prolog predicate, 'assert_line_reached/0', which queries the debugger
for the current line information and then processes the line number:

     assert_line_reached :-
             (   execution_state(line(F,L)) -> assert_line_reached(F,L).
             ;   true
             ).

     | ?- add_breakpoint([advice,call]-[true(assert_line_reached),flit], _).

   Arbitrary tests can be used in 'execution_state/1', if it is called
from within a 'true' condition.  It can also be called from outside the
debugger, but then only a subset of conditions is available.
Furthermore, the built-in predicate 'execution_state/2' allows accessing
information from past debugger states (*note Accessing Past Debugger
States::).  *Note mpg-ref-execution_state::.

   The built-in predicates 'remove_breakpoints(BIDS)',
'disable_breakpoints(BIDS)' and 'enable_breakpoints(BIDS)' serve for
removing, disabling and enabling the given breakpoints.  Here BIDS can
be a single breakpoint identifier, a list of these, or one of the atoms
'all', 'advice', 'debugger'.

   We now show an application of 'remove_breakpoints/1' for implementing
one-off breakpoints, i.e. breakpoints that are removed when first
activated.

   For this we need to get hold of the currently selected breakpoint
identifier.  The 'bid(BID)' condition serves for this purpose: it
unifies its argument with the identifier of the breakpoint being
processed.  The following is an example of a one-off breakpoint.

     | ?- spy(foo/2, -[bid(BID),true(remove_breakpoints(BID)),leash]).
     % Conditional spypoint for user:foo/2 added, BID=1
     % zip
     | ?- foo(2, X).
     % Conditional spypoint for user:foo/2, BID=1, removed (last)
             1      1 Call: foo(2,_402) ? z
     X = 1

   The action part of the above breakpoint calls the 'bid' test to
obtain the breakpoint identifier.  It then uses this number as the
argument to the built-in predicate 'remove_breakpoints/1', which removes
the activated breakpoint.  *Note mpg-ref-remove_breakpoints::.

   The built-in predicate 'current_breakpoint(SPEC, BID, STATUS, KIND,
TYPE)' enumerates all breakpoints present in the debugger.  For example,
if we call 'current_breakpoint/5' before the invocation of 'foo/2' in
the last example, then we get this:

     | ?- current_breakpoint(Spec, BID, Status, Kind, Type).
     Spec = [pred(user:foo/2)]-[bid(_A),true(remove_breakpoints(_A)),leash],
     BID = 1,
     Status = on,
     Kind = conditional(user:foo/2),
     Type = debugger

   Here SPEC is the breakpoint spec of the breakpoint with identifier
BID.  STATUS is 'on' for enabled breakpoints and 'off' for disabled
ones.  KIND is one of 'plain(MFUNC)', 'conditional(MFUNC)' or 'generic',
where MFUNC is the module qualified functor of the specific breakpoint.
Finally TYPE is the breakpoint type: 'debugger' or 'advice'.

   The SPEC returned by 'current_breakpoint/5' is exactly the same as
the one given in 'add_breakpoint/2'.  If the breakpoint was created by
'spy/2', then the test part is extended by a 'pred' condition, as
exemplified above.  Earlier we described some preprocessing steps that
the spec goes through, such as moving the module qualification of the
spec to certain conditions.  These transformations are performed on the
copy of the breakpoint used for testing.  Independently of this, the
debugger also stores the original breakpoint, which is returned by
'current_breakpoint/5'.  *Note mpg-ref-current_breakpoint::.


File: sicstus.info,  Node: Accessing Past Debugger States,  Next: Storing User Information in the Backtrace,  Prev: Built-in Predicates for Breakpoint Handling,  Up: Advanced Debugging

5.6.8 Accessing Past Debugger States
------------------------------------

In this section we introduce the built-in predicates for accessing past
debugger states, and the breakpoint conditions related to these.

   The debugger collects control flow information about the goals being
executed, more precisely about those goals, for which a procedure box is
built.  This collection of information, the backtrace, includes the
invocations that were called but not exited yet, as well as those that
exited nondeterminately.  For each invocation, the main data items
present in the backtrace are the following: the goal, the module, the
invocation number, the depth and the source information, if any.

   Furthermore, as you can enter a new break level from within the
debugger, there can be multiple backtraces, one for each active break
level.

   You can access all the information collected by the debugger using
the built-in predicate 'execution_state(FOCUS, TESTS)'.  Here FOCUS is a
ground term specifying which break level and which invocation to access.
It can be one of the following:

   * 'break_level(BL)' selects the _current_ invocation within the break
     level BL.
   * 'inv(INV)' selects the invocation number INV within the current
     break level.
   * A list containing the above two elements, selects the invocation
     with number INV within break level BL.

   Note that the top-level counts as break level 0, while the
invocations are numbered from 1 upwards.

   The second argument of 'execution_state/2', TESTS, is a simple or
composite breakpoint condition.  Most simple tests can appear inside
TESTS, with the exception of the 'port', 'bid', 'advice', 'debugger',
and 'get' tests.  These tests will be interpreted in the context of the
specified past debugger state.  Specifically, if a 'true/1' condition is
used, then any 'execution_state/1' queries appearing in it will be
evaluated in the past context.

   To illustrate the use of 'execution_state/2', we now define a
predicate 'last_call_arg(ArgNo, Arg)', which is to be called from within
a break, and which will look at the last debugged goal of the previous
break level, and return in 'Arg' the 'ArgNo'th argument of this goal.

     last_call_arg(ArgNo, Arg) :-
             execution_state(break_level(BL1)),
             BL is BL1-1,
             execution_state(break_level(BL), goal(Goal)),
             arg(ArgNo, Goal, Arg).

   We see two occurrences of the term 'break_level(...)' in the above
example.  Although these look very similar, they have different roles.
The first one, in 'execution_state/1', is a breakpoint test, which
unifies the current break level with its argument.  Here it is used to
obtain the current break level and store it in 'BL1'.  The second use of
'break_level(...)', in the first argument of 'execution_state/2', is a
focus condition, whose argument has to be instantiated, and which
prescribes the break level to focus on.  Here we use it to obtain the
goal of the current invocation of the previous break level.

   Note that the goal retrieved from the backtrace is always in its
latest instantiation state.  For example, it is not possible to get hold
of the goal instantiation at the Call port, if the invocation in
question is at the Exit port.

   Here is an example run, showing how 'last_call_arg/2' can be used:

             5      2 Call: _937 is 13+8 ? b
     % Break level 1
     % 1
     | ?- last_call_arg(2, A).
     A = 13+8

   There are some further breakpoint tests that are primarily used in
looking at past execution states.

   The test 'max_inv(MAXINV)' returns the maximal invocation number
within the current (or selected) break level.  The test
'exited(BOOLEAN)' unifies BOOLEAN with 'true' if the invocation has
exited, and with 'false' otherwise.

   The following example predicate lists those goals in the backtrace,
together with their invocation numbers, that have exited.  These are the
invocations that are listed by the 't' interactive debugger command
(print backtrace), but not by the 'g' command (print ancestor goals).
Note that the predicate 'between(N,M,I)' enumerates all integers such
that N \leq I \leq M.

     exited_goals :-
          execution_state(max_inv(Max)),
          between(1, Max, Inv),
          execution_state(inv(Inv), [exited(true),goal(G)]),
          format('~t~d~6| ~p\n', [Inv,G]),
          fail.
     exited_goals.
     (...)

     ?*     41     11 Exit: foo(2,1) ? @
     | :- exited_goals.
         26 foo(3,2)
         28 bar(3,1,1)
         31 foo(2,1)
         33 bar(2,1,0)
         36 foo(1,1)
         37 foo(0,0)
         39 foo(1,1)
         41 foo(2,1)
         43 bar(2,1,0)
         46 foo(1,1)
         47 foo(0,0)
     ?*     41     11 Exit: foo(2,1) ?

   Note that similar output can be obtained by entering a new break
level and calling 'exited_goals' from within an 'execution_state/2':

     % 1
     | ?- execution_state(break_level(0), true(exited_goals)).

   The remaining two breakpoint tests allow you to find parent and
ancestor invocations in the backtrace.  The 'parent_inv(INV)' test
unifies INV with the invocation number of the youngest ancestor present
in the backtrace, called "debugger-parent" for short.  The test
'ancestor(ANCGOAL,INV)' looks for the youngest ancestor in the backtrace
that is an instance of ANCGOAL.  It then unifies the ancestor goal with
ANCGOAL and its invocation number with INV.

   Assume you would like to stop at all invocations of 'foo/2' that are
somewhere within 'bar/1', possibly deeply nested.  The following two
breakpoints achieve this effect:

     | ?- spy(bar/1, advice), spy(foo/2, ancestor(bar(_),_)).
     % Plain advice point for user:bar/1 added, BID=3
     % Conditional spypoint for user:foo/2 added, BID=4

   We added an advice-point for 'bar/1' to ensure that all calls to it
will have procedure boxes built, and so become part of the backtrace.
Advice-points are a better choice than spypoints for this purpose, as
with '?- spy(bar/1, -proceed)' the debugger will not stop at the call
port of 'bar/1' in trace mode.  Note that it is perfectly all right to
create an advice-point using 'spy/2', although this is a bit of
terminological inconsistency.

   *Note mpg-ref-execution_state::.  Further examples of accessing past
debugger states can be found in 'library(debugger_examples)'.


File: sicstus.info,  Node: Storing User Information in the Backtrace,  Next: Hooks Related to Breakpoints,  Prev: Accessing Past Debugger States,  Up: Advanced Debugging

5.6.9 Storing User Information in the Backtrace
-----------------------------------------------

The debugger allows the user to store some private information in the
backtrace.  It allocates a Prolog variable in each break level and in
each invocation.  The breakpoint test 'private(PRIV)' unifies PRIV with
the private information associated with the break level, while the test
'goal_private(GPRIV)' unifies GPRIV with the Prolog variable stored in
the invocation.

   Both variables are initially unbound, and behave as if they were
passed around the program being debugged in additional arguments.  This
implies that any variable assignments done within these variables are
undone on backtracking.

   In practice, the 'private' condition gives you access to a Prolog
variable shared by all invocations of a break level.  This makes it
possible to remember a term and look at it later, in a possibly more
instantiated form, as shown by the following example.

     memory(Term) :-
             execution_state(private(P)),
             memberchk(myterm(Term), P).

     | ?- trace, append([1,2,3,4], [5,6], L).
             1      1 Call: append([1,2,3,4],[5,6],_514) ? @
     | :- append(_,_,L)^memory(L).
             1      1 Call: append([1,2,3,4],[5,6],_514) ? c
             2      2 Call: append([2,3,4],[5,6],_2064) ? c
             3      3 Call: append([3,4],[5,6],_2422) ? c
             4      4 Call: append([4],[5,6],_2780) ? @
     | :- memory(L), write(L), nl.
     [1,2,3|_2780]
             4      4 Call: append([4],[5,6],_2780) ?

   The predicate 'memory/1' receives the term to be remembered in its
argument.  It gets hold of the private field associated with the break
level in variable 'P', and calls 'memberchk/2' (*note lib-lists::), with
the term to be remembered, wrapped in 'myterm', as the list element, and
the private field, as the list.  Thus the latter, initially unbound
variable, is used as an open-ended list.  For example, when 'memory/1'
is called for the first time, the private field gets instantiated to
'[myterm(Term)|_]'.  If later you call 'memory/1' with an uninstantiated
argument, then it will retrieve the term remembered earlier and unify it
with the argument.

   The above trace excerpt shows how this utility predicate can be used
to remember an interesting Prolog term.  Within invocation number 1 we
call 'memory/1' with the third, output argument of 'append/3', using the
'@' command (*note Debug Commands::).  A few tracing steps later, we
retrieve the term remembered and print it, showing its current
instantiation.  Being able to access the instantiation status of some
terms of interest can be very useful in debugging.  In
'library(debugger_examples)' we describe new debugger commands for
naming Prolog variables and providing name-based access to these
variables, based on the above technique.

   We could have avoided the use of 'memberchk/2' in the example by
simply storing the term to be remembered in the private field itself
('memory(Term) :- execution_state(private(Term)).').  But this would
have made the private field unusable for other purposes.  For example,
the finite domain constraint debugger (*note lib-fdbg::) would stop
working, as it relies on the private fields.

   There is only a single private variable of both kinds within the
given scope.  Therefore the convention of using an open ended list for
storing information in private fields, as shown in the above example, is
very much recommended.  The different users of the private field are
distinguished by the wrapper they use (e.g. 'myterm/1' above, 'fdbg/1'
for the constraint debugger, etc.).  Future releases may enforce this
convention by providing appropriate breakpoint tests.

   We now present an example of using the goal private field.  Earlier
we have shown a spypoint definition that made a predicate invisible in
the sense that its ports are silently passed through and it is
automatically skipped over.  However, with that earlier solution,
execution always continues in trace mode after skipping.  We now improve
the spypoint definition: the mode in which the Call port was reached is
remembered in the goal private field, and the mode action variable is
reset to this value at the Exit port.

     mode_memory(Mode) :-
             execution_state(goal_private(GP)),
             memberchk(mymode(Mode), GP).

     | ?- spy(foo/2, -[silent,proceed,
                      true(mode_memory(MM)),
                     (   call -> get(mode(MM)), inv(Inv), skip(Inv)
                     ;   exit -> mode(MM)
                     ;   true
                     )]).

   Here, we first define an auxiliary predicate 'mode_memory/1', which
uses the open list convention for storing information in the goal
private field, applying the 'mymode/1' wrapper.  We then create a
spypoint for 'foo/2', whose action part first sets the 'print' and
'command' action variables.  Next, the 'mode_memory/1' predicate is
called, unifying the mode memory with the 'MM' variable.  We then branch
in the action part: at Call ports the uninstantiated 'MM' is unified
with the current mode, and a 'skip' command is issued.  At Exit ports
'MM' holds the mode saved at the Call port, so the 'mode(MM)' action
re-activates this mode.  At all other ports we just silently proceed
without changing the debugger mode.


File: sicstus.info,  Node: Hooks Related to Breakpoints,  Next: Programming Breakpoints,  Prev: Storing User Information in the Backtrace,  Up: Advanced Debugging

5.6.10 Hooks Related to Breakpoints
-----------------------------------

There are two hooks related to breakpoints.

   The hook 'breakpoint_expansion(MACRO,BODY)' makes it possible for the
user to extend the set of allowed conditions.  This hook is called, at
breakpoint addition time, with each simple test or action within the
breakpoint spec, as the MACRO argument.  If the hook succeeds, then the
term returned in the BODY argument is substituted for the original test
or action.  Note that BODY cannot span both the test and the action
part, i.e. it cannot contain the '- /2' operator.  The whole BODY will
be interpreted either as a test or as an action, depending on the
context of the original condition.  *Note
mpg-ref-breakpoint_expansion::.

   We now give a few examples for breakpoint macros.  The last example
defines a condition making a predicate invisible, a reformulation of the
last example of the previous subsection.

     :- multifile user:breakpoint_expansion/2.
     user:breakpoint_expansion(
                 skip, [inv(I),skip(I)]).

     user:breakpoint_expansion(
                 gpriv(Value),
                 [goal_private(GP),true(memberchk(Value,GP))]).

     user:breakpoint_expansion(
                 invisible,
                 [silent,proceed,
                     (   call -> get(mode(M)), gpriv(mymode(M)), skip
                     ;   exit -> gpriv(mymode(MM)), mode(MM)
                     ;   true
                     )]).

     | ?- spy(foo/2, -invisible).

   We first define the 'skip' macro, instructing the debugger to skip
the current invocation.  This macro is only meaningful in the action
part.

   The second clause defines the 'gpriv/2' macro, a generalization of
the earlier 'mode_memory/1' predicate.  For example, 'gpriv(mymode(M))'
expands to 'goal_private(GP),true(memberchk(mymode(M),GP))'.  This
embodies the convention of using open-ended lists for the goal private
field.

   Finally, the last clause implements the action macro 'invisible/0',
which makes the predicate in question disappear from the trace.  The
last line shows how this macro can be used to make 'foo/2' invisible.

   Below is an alternative implementation of the same macro.  Here we
use a Prolog predicate that returns the list of action variable settings
to be applied at the given port.  Notice that a variable can be used as
a breakpoint condition, as long as this variable gets instantiated to a
(simple or composite) breakpoint condition by the time it is reached in
the process of breakpoint evaluation.

     user:breakpoint_expansion(invisible,
                               [true(invisible(Settings)),Settings]).

     invisible([proceed,silent,NewMode]) :-
             execution_state([mode(M),port(P),inv(Inv),goal_private(GP)]),
             memberchk(mymode(MM), GP),
             (   P == call -> MM = M, NewMode = skip(Inv)
             ;   P = exit(_) -> NewMode = MM
             ;   NewMode = M
             ).

   The second hook related to breakpoints is
'debugger_command_hook(DCOMMAND, ACTIONS)'.  This hook serves for
customizing the behavior of the interactive debugger, i.e. for
introducing new interactive debugger commands.  The hook is called for
each debugger command read in by the debugger.  DCOMMAND contains the
abstract format of the debugger command read in, as returned by the
query facility (*note Query Processing::).  If the hook succeeds, then
it should return in ACTIONS an action part to be evaluated as the result
of the command.

   If you want to redefine an existing debugger command, then you should
study 'library('SU_messages')' to learn the abstract format of this
command, as returned by the query facility.  If you want to add a new
command, then it suffices to know that unrecognized debugger commands
are returned as 'unknown(Line,Warning)'.  Here, 'Line' is the code-list
typed in, with any leading whitespace removed, and 'Warning' is a
warning message.

   The following example defines the 'S' interactive debugger command to
behave as skip at Call and Redo ports, and as creep otherwise:

     :- multifile user:debugger_command_hook/2.
     user:debugger_command_hook(unknown([0'S|_],_), Actions) :-
             execution_state([port(P),inv(I)]),
             Actions = [Mode,proceed,silent],
             (   P = call -> Mode = skip(I)
             ;   P = redo -> Mode = skip(I)
             ;   Mode = trace
             ).

   Note that the 'silent' action is needed above; otherwise, the trace
message will be printed a second time, before continuing the execution.

   *Note mpg-ref-debugger_command_hook::.  'library(debugger_examples)'
contains some of the above hooks, as well as several others.


File: sicstus.info,  Node: Programming Breakpoints,  Prev: Hooks Related to Breakpoints,  Up: Advanced Debugging

5.6.11 Programming Breakpoints
------------------------------

We will show two examples using the advanced features of the debugger.

   The first example defines a 'hide_exit(Pred)' predicate, which will
hide the Exit port for 'Pred' (i.e. it will silently proceed), provided
the current goal was already ground at the Call port, and nothing was
traced inside the given invocation.  The 'hide_exit(Pred)' goal creates
two spypoints for predicate 'Pred':

     :- meta_predicate hide_exit(:).
     hide_exit(Pred) :-
             add_breakpoint([pred(Pred),call]-
                              true(save_groundness), _),
             add_breakpoint([pred(Pred),exit,true(hide_exit)]-hide, _).

   The first spypoint is applicable at the Call port, and it calls
'save_groundness' to check if the given invocation was ground, and if
so, then it stores a term 'hide_exit(ground)' in the 'goal_private'
attribute of the invocation.

     save_groundness :-
             execution_state([goal(_:G),goal_private(Priv)]),
             ground(G), !, memberchk(hide_exit(ground), Priv).
     save_groundness.

   The second spypoint created by 'hide_exit/1' is applicable at the
Exit port and it checks whether the 'hide_exit/0' condition is true.  If
so, then it issues a 'hide' action, which is a breakpoint macro
expanding to '[silent,proceed]'.

     hide_exit :-
             execution_state([inv(I),max_inv(I),goal_private(Priv)]),
             memberchk(hide_exit(Ground), Priv), Ground == ground.

   Here, 'hide_exit' encapsulates the tests that the invocation number
be the same as the last invocation number used ('max_inv'), and that the
'goal_private' attribute of the invocation be identical to 'ground'.
The first test ensures that nothing was traced inside the current
invocation.

   If we load the above code, as well as the small example below, then
the following interaction, discussed below, can take place.  Note that
the 'hide_exit' predicate is called with the '_:_' argument, resulting
in generic spypoints being created.

     | ?- consult(user).
     | cnt(0) :- !.
     | cnt(N) :-
             N > 0, N1 is N-1, cnt(N1).
     | ^D
     % consulted user in module user, 0 msec 424 bytes

     | ?- hide_exit(_:_), trace, cnt(1).
     % The debugger will first zip -- showing spypoints (zip)
     % Generic spypoint added, BID=1
     % Generic spypoint added, BID=2
     % The debugger will first creep -- showing everything (trace)
      #      1      1 Call: cnt(1) ? c
      #      2      2 Call: 1>0 ? c
      #      3      2 Call: _2019 is 1-1 ? c
             3      2 Exit: 0 is 1-1 ? c
      #      4      2 Call: cnt(0) ? c
             1      1 Exit: cnt(1) ? c

     % trace
     | ?-

   Invocation 1 is ground, its Exit port is not hidden, because further
goals were traced inside it.  On the other hand, Exit ports of ground
invocations 2 and 4 are hidden.

   Our second example defines a predicate 'call_backtrace(Goal,
BTrace)', which will execute 'Goal' and build a backtrace showing the
successful invocations executed during the solution of 'Goal'.

   The advantages of such a special backtrace over the one incorporated
in the debugger are the following:

   * it has much lower space consumption;
   * the user can control what is put on and removed from the backtrace
     (e.g. in this example all goals are kept, even the ones that exited
     determinately);
   * the interactive debugger can be switched on and off without
     affecting the "private" backtrace being built.

   The 'call_backtrace/2' predicate is based on the advice facility.  It
uses the variable accessible via the 'private(_)' condition to store a
mutable (*note ref-lte-mut::) holding the backtrace.  Outside the
'call_backtrace' predicate the mutable will have the value 'off'.

   The example is a module-file, so that internal invocations can be
identified by the module name.  We load the 'lists' library, because
'memberchk/2' will be used in the handling of the private field.

     :- module(backtrace, [call_backtrace/2]).
     :- use_module(library(lists)).

     :- meta_predicate call_backtrace(0, ?).
     call_backtrace(Goal, BTrace) :-
             Spec = [advice,call]
                    -[true((goal(M:G),store_goal(M,G))),flit],
             (   current_breakpoint(Spec, _, on, _, _) -> B = []
             ;   add_breakpoint(Spec, B)
             ),
             call_cleanup(call_backtrace1(Goal, BTrace),
                          remove_breakpoints(B)).

   'call_backtrace(Goal, BTrace)' is a meta-predicate, which first sets
up an appropriate advice-point for building the backtrace.  The
advice-point will be activated at each Call port and will call the
'store_goal/2' predicate with arguments containing the module and the
goal in question.  Note that the advice-point will not build a procedure
box (cf. the 'flit' command in the action part).

   The advice-point will be added just once: any further (recursive)
calls to 'call_backtrace/2' will notice the existence of the breakpoint
and will skip the 'add_breakpoint/2' call.

   Having ensured the appropriate advice-point exists,
'call_backtrace/2' calls 'call_backtrace1/2' with a cleanup operation
that removes the breakpoint added, if any.

     :- meta_predicate call_backtrace1(0, ?).
     call_backtrace1(Goal, BTrace) :-
             execution_state(private(Priv)),
             memberchk(backtrace_mutable(Mut), Priv),
             (   mutable(Mut) -> get_mutable(Old, Mut),
                 update_mutable([], Mut)
             ;   create_mutable([], Mut), Old = off
             ),
             call(Goal),
             get_mutable(BTrace, Mut), update_mutable(Old, Mut).

   The predicate 'call_backtrace1/2' retrieves the private field of the
execution state and uses it to store a mutable, wrapped in
'backtrace_mutable'.  When first called within a top-level the mutable
is created with the value '[]'.  In later calls the mutable is
re-initialized to '[]'.  Having set up the mutable, 'Goal' is called.
In the course of the execution of the 'Goal' the debugger will
accumulate the backtrace in the mutable.  Finally, the mutable is read,
its value is returned in 'BTrace', and it is restored to its old value
(or 'off').

     store_goal(M, G) :-
             M \== backtrace,
             G \= call(_),
             execution_state(private(Priv)),
             memberchk(backtrace_mutable(Mut), Priv),
             mutable(Mut),
             get_mutable(BTrace, Mut),
             BTrace \== off, !,
             update_mutable([M:G|BTrace], Mut).
     store_goal(_, _).

   'store_goal/2' is the predicate called by the advice-point, with the
module and the goal as arguments.  We first ensure that calls from
within the 'backtrace' module and those of 'call/1' get ignored.  Next,
the module qualified goal term is prepended to the mutable value
retrieved from the private field, provided the mutable exists and its
value is not 'off'.

   Below is an example run, using a small program:

     | ?- consult(user).
     | cnt(N):- N =< 0, !.
     | cnt(N) :-
          N > 0, N1 is N-1, cnt(N1).
     | ^D
     % consulted user in module user, 0 msec 424 bytes

     | ?- call_backtrace(cnt(1), B).
     % Generic advice point added, BID=1
     % Generic advice point, BID=1, removed (last)

     B = [user:(0=<0),user:cnt(0),user:(0 is 1-1),user:(1>0),user:cnt(1)]

     | ?-

   Note that the backtrace produced by 'call_backtrace/2' can not
contain any information regarding failed branches.  For example, the
very first invocation within the above execution, '1 =< 0', is first put
on the backtrace at its Call port, but this is immediately undone
because the goal fails.  If you would like to build a backtrace that
preserves failed branches, then you have to use side-effects, e.g.
dynamic predicates.

   Further examples of complex breakpoint handling are contained in
'library(debugger_examples)'.

   This concludes the tutorial introduction of the advanced debugger
features.


File: sicstus.info,  Node: Breakpoint Predicates,  Next: Breakpoint Processing,  Prev: Advanced Debugging,  Up: Debug Intro

5.7 Breakpoint Handling Predicates
==================================

This section describes the advanced built-in predicates for creating and
removing breakpoints.

'add_breakpoint(:SPEC, ?BID)   development'

     Adds a breakpoint with a spec SPEC, the breakpoint identifier
     assigned is unified with BID.  SPEC is one of the following:

     TESTS'-'ACTIONS
     TESTS
          standing for TESTS'-[]'
     '-'ACTIONS
          standing for '[]-'ACTIONS

     Here, both TESTS and ACTIONS are either a simple CONDITION, *note
     Breakpoint Conditions::, or a composite Condition.  Conditions can
     be composed by forming lists, or by using the ',', ';', '->', and
     '\+' operators, with the usual meaning of conjunction, disjunction,
     if-then-else, and negation, respectively.  A list of conditions is
     equivalent to a conjunction of the same conditions ('[A|B]' is
     treated as '(A,B)').

     The 'add_breakpoint/2' predicate performs some transformations and
     checks before adding the breakpoint.  All condition macros invoked
     are expanded into their bodies, and this process is repeated for
     the newly introduced bodies.  The 'goal' and 'pred' conditions are
     then extracted from the outermost conjunctions of the _test_ part
     and moved to the beginning of the conjunction.  If these are
     inconsistent, then a consistency error is signalled.  Module name
     expansion is performed for certain tests, as described below.

     Both the original and the transformed breakpoint spec is recorded
     by the debugger.  The original is returned in
     'current_breakpoint/5', while the transformed spec is used in
     determining the applicability of breakpoints.

     There can only be a single plain spypoint for each predicate.  If a
     plain spypoint is added, and there is already a plain spypoint for
     the given predicate, then:

       a. the old spypoint is deleted and a new added as the most recent
          breakpoint, if this change affects the breakpoint selection
          mechanism.
       b. otherwise, the old spypoint is kept and enabled if needed.
     *Note mpg-ref-add_breakpoint::.

'spy(:PREDSPEC, :SPEC)   development'

     Adds a conditional spypoint with a breakpoint spec formed by adding
     'pred(PRED)' to the test part of SPEC, for each predicate PRED
     designated by the generalized predicate spec PREDSPEC.  *Note
     mpg-ref-spy::.

'current_breakpoint(:SPEC, ?BID, ?STATUS, ?KIND, ?TYPE)   development'

     There is a breakpoint with breakpoint spec SPEC, identifier BID,
     status STATUS, kind KIND, and type TYPE.  STATUS is one of 'on' or
     'off', referring to enabled and disabled breakpoints.  KIND is one
     of 'plain(MFUNC)', 'conditional(MFUNC)' or 'generic', where MFUNC
     is the module qualified functor of the specific breakpoint.  TYPE
     is the breakpoint type: 'debugger' or 'advice'.

     'current_breakpoint/5' enumerates all breakpoints on backtracking.

     The SPEC as returned by 'current_breakpoint/5' is exactly the same
     as supplied at the creation of the breakpoint.  *Note
     mpg-ref-current_breakpoint::.

'remove_breakpoints(+BIDS)   development'
'disable_breakpoints(+BIDS)   development'
'enable_breakpoints(+BIDS)   development'

     Removes, disables or enables the breakpoints with identifiers
     specified by BIDS.  BIDS can be a number, a list of numbers or one
     of the atoms: 'all', 'debugger', 'advice'.  The atoms specify all
     breakpoints, debugger type breakpoints and advice type breakpoints,
     respectively.

'execution_state(:TESTS)   development'

     TESTS are satisfied in the current state of the execution.
     Arbitrary tests can be used in this predicate, if it is called from
     inside the debugger, i.e. from within a 'true' condition.
     Otherwise only those tests can be used, which query the data stored
     in the backtrace.  An exception is raised if the latter condition
     is violated, i.e. a non-backtraced test (*note Breakpoint
     Conditions::) occurs in a call of 'execution_state/1' from outside
     the debugger.

'execution_state(+FOCUSCONDITIONS, :TESTS)   development'
     TESTS are satisfied in the state of the execution pointed to by
     FOCUSCONDITIONS (*note Past States::).  An exception is raised if
     there is a non-backtraced test among TESTS.

   Note that the predicate arguments holding a breakpoint spec (SPEC or
TESTS above) are subject to module name expansion.  The first argument
within simple tests 'goal(_)', 'pred(_)', 'parent_pred(_)',
'parent_pred(_,_)', 'ancestor(_,_)', and 'true(_)' will inherit the
module name from the (module name expanded) breakpoint spec/tests
predicate argument, if there is no explicit module qualification within
the simple test.  Within the 'proceed(OLD,NEW)' and 'flit(OLD,NEW)'
command value settings, OLD will get the module name from the 'goal' or
'pred' condition by default, while NEW from the whole breakpoint spec
argument.  *Note mpg-ref-execution_state::.

   The following hook predicate can be used to customize the behavior of
the interactive debugger.

'debugger_command_hook(+DCOMMAND,?ACTIONS)   hook,development'
'user:debugger_command_hook(+DCOMMAND,?ACTIONS)'

     This predicate is called for each debugger command that SICStus
     Prolog reads.  The first argument is the abstract format of the
     debugger command DCOMMAND, as returned by the query facility (*note
     Query Processing::).  If it succeeds, then ACTIONS is taken as the
     list of actions (*note Action Conditions::) to be done for the
     given debugger command.  If it fails, then the debugger command is
     interpreted in the standard way.

     Note that if a line typed in response to the debugger prompt cannot
     be parsed as a debugger command, then 'debugger_command_hook/2' is
     called with the term 'unknown(Line,Warning)'.  Here, 'Line' is the
     code-list typed in, with any leading whitespace removed, and
     'Warning' is a warning message.  This allows the user to define new
     debugger commands, *note Hooks Related to Breakpoints:: for an
     example.  *Note mpg-ref-debugger_command_hook::.


File: sicstus.info,  Node: Breakpoint Processing,  Next: Breakpoint Conditions,  Prev: Breakpoint Predicates,  Up: Debug Intro

5.8 The Processing of Breakpoints
=================================

This section describes in detail how the debugger handles the
breakpoints.  For the purpose of this section disabled breakpoints are
not taken into account: whenever we refer to the existence of some
breakpoint(s), we always mean the existence of _enabled_ breakpoint(s).

   The Prolog engine can be in one of the following three states with
respect to the debugger:

_no debugging_
     if there are no advice-points and the debugger is either switched
     off, or doing a skip;
_full debugging_
     if the debugger is in trace or debug mode (creeping or leaping), or
     there are any generic breakpoints;
_selective debugging_
     in all other cases.

   In the _selective debugging_ state only those predicate invocations
are examined, for which there exists a specific breakpoint.  In the
_full debugging_ state all invocations are examined, except those
calling a predicate of a hidden module (but even these will be examined,
if there is a specific breakpoint for them).  In the _no debugging_
state the debugger is not entered at predicate invocations.

   Now we describe what the debugger does when examining an invocation
of a predicate, i.e. executing its Call port.  The debugger activities
can be divided into three stages: advice-point processing, spypoint
processing and interaction with the user.  The last stage may be
repeated several times before program execution continues.

   The first two stages are similar, as they both search for an
applicable breakpoint (spypoint or advice-point).  This common
breakpoint search is carried out as follows.  The debugger considers all
breakpoints of the given type, most recent first.  For each breakpoint,
the test part of the spec is evaluated, until one successful is found.
Any variable bindings created in this successful evaluation are then
discarded (this is implemented by enclosing it in double negation).  The
first breakpoint, for which the evaluation of the test part succeeds is
selected.  If such a breakpoint can be found, then the breakpoint search
is said to have completed successfully, otherwise it is said to have
failed.

   If a breakpoint has been selected, then its action part is evaluated,
normally setting some debugger action variables.  If the action part
fails, then as a side-effect, it is ensured that a procedure box will be
built.  This is achieved by changing the value of the 'command' action
variable from 'flit' to 'proceed'.

   Having described the common breakpoint search, let us look at the
details of the first stage, advice-point processing.  This stage is
executed only if there are any advice-points set.  First, the debugger
action variables are initialized: 'mode' is set to the current debugger
mode, 'command' to 'proceed' and 'show' to 'silent'.  Next, advice-point
search takes place.  If this fails, then 'command' is set to 'flit',
otherwise its value is unchanged.

   After completing the advice-point search the 'command' variable is
examined.  If its value is divertive, i.e. different from 'proceed' and
'flit', then the spypoint search stage is omitted, and the debugger
continues with the third stage.  Otherwise, it is noted that the
advice-point processing has requested the building of a procedure box
(i.e. 'command = proceed'), and the debugger continues with the second
stage.

   The second stage is spypoint processing.  This stage is skipped if
the debugger is switched off or doing a skip ('mode' is 'off' or
'skip(_)').  First the 'show' and 'command' variables are re-assigned,
based on the hiddenness of the predicate being invoked, the debugger
mode, and the leashing status of the port.  If the predicate is both
defined in, and called from a hidden module, then their values will be
'silent' and 'flit'.  An example of this is when a built-in predicate is
called from a hidden module, e.g. from a library.  Otherwise, in trace
mode, their values are 'print' and 'ask' for leashed ports, and 'print'
and 'proceed' for unleashed ports.  In debug mode, the variables are set
to 'silent' and 'proceed', while in zip mode to 'silent' and 'flit'
(*note Breakpoint Actions:: contains a tabulated listing of these
initialization values).

   Having initialized the debugger action variables, the spypoint search
phase is performed.  If an empty action part has been selected in a
successful search, then 'show' and 'command' are set to 'print' and
'ask'.  The failure of the search is ignored.

   The third stage is the interactive part.  First, the goal in question
is displayed according to the value of 'show'.  Next, the value of
'command' is checked: if it is other than 'ask', then the interactive
stage ends.  Otherwise, (it is 'ask'), the variable 'show' is
re-initialized to 'print', or to 'print-SEL', if its value was of form
'METHOD-SEL'.  Next, the debugger prompts the user for a command, which
is interpreted either in the standard way, or through
'user:debugger_command_hook/2'.  In both cases the debugger action
variables are modified as requested, and the interactive part is
repeated.

   After the debugger went through all the three stages, it decides
whether to build a procedure box.  This will happen if either the
advice-point stage or the other two stages require it.  The latter is
decided by checking the 'command' variable: if that is 'flit' or
'flit(OLD,NEW)', then no procedure box is required by the spypoint part.
If the advice-point does require the building of a procedure box, then
the above 'command' values are replaced by 'proceed' and
'proceed(OLD,NEW)', respectively.

   At the end of the process the value of 'mode' will be the new
debugging mode, and 'command' will determine what the debugger will do;
*note Action Variables::.

   A similar three-stage process is carried out when the debugger
arrives at a non-Call port of a predicate.  The only difference is that
the building of a procedure box is not considered ('flit' is equivalent
to 'proceed'), and the hiddenness of the predicate is not taken into
account.

   While the Prolog system is executing the above three-stage process
for any of the ports, it is said to be _inside the debugger_.  This is
relevant, because some of the conditions can only be evaluated in this
context.


File: sicstus.info,  Node: Breakpoint Conditions,  Next: Consult,  Prev: Breakpoint Processing,  Up: Debug Intro

5.9 Breakpoint Conditions
=========================

This section describes the format of simple breakpoint conditions.  We
first list the tests that can be used to enquire the state of execution.
We then proceed to describe the conditions usable in the action part and
the options for focusing on past execution states.  Finally, we describe
condition macros and the format of the values of the debugger action
variables.

   We distinguish between two kinds of tests, based on whether they
refer to information stored in the backtrace or not.  The latter
category, the "non-backtraced tests", contains the conditions related to
the current port ('port', 'bid', 'mode', 'show', 'command', 'get') and
the breakpoint type selection conditions ('advice' and 'debug').  All
remaining tests refer to information stored in the backtrace.

   Non-backtraced tests will raise an exception, if they appear in calls
to 'execution_state/1' from outside the debugger, or in queries about
past execution state, in 'execution_state/2'.

   Backtraced tests are allowed both inside and outside the debugger.
However such tests can fail if the given query is not meaningful in the
given context, e.g. if 'execution_state(goal(G))' is queried before any
breakpoints were encountered.

   Note that if a test is used in the second argument of
'execution_state/2', then the term _current_, in the following
descriptions, should be interpreted as referring to the execution state
focused on (described by the first argument of 'execution_state/2').

* Menu:

* Goal Tests:: Tests Related to the Current Goal
* Source Tests:: Tests Related to Source Information
* Port Tests:: Tests Related to the Current Port
* Break Tests:: Tests Related to the Break Level
* Other Tests:: Other Conditions
* Action Conditions:: Conditions Usable in the Action Part
* Past States:: Options for Focusing on a Past State
* Condition Macros:: Condition Macros
* Action Variables:: The Action Variables


File: sicstus.info,  Node: Goal Tests,  Next: Source Tests,  Up: Breakpoint Conditions

5.9.1 Tests Related to the Current Goal
---------------------------------------

The following tests give access to basic information about the current
invocation.

'inv(INV)'
     The invocation number of the current goal is INV.  Invocation
     numbers start from 1.
'depth(DEPTH)'
     The current execution depth is DEPTH.
'goal(MGOAL)'
     The current goal is an instance of the module name expanded MGOAL
     template.  The current goal and MGOAL are unified.  This condition
     is equivalent to 'subsumes(MGOAL,CURRENTGOAL)' ('subsumes/2' is
     defined in 'library(terms)', *note lib-terms::).
'pred(MFUNC)'
     The module name expanded MFUNC template matches (see notes below)
     the functor (M':'F'/'N) of the current goal.  The unification
     required for matching is carried out.
'module(MODULE)'
     The current goal is invoked from module MODULE.  For compiled calls
     to built-in predicates MODULE will always be 'prolog'.
'goal_private(GOALPRIV)'
     The private information associated with the current goal is
     GOALPRIV.  This is initialized to an unbound variable at the Call
     port.  It is strongly recommended that GOALPRIV be used as an open
     ended list, *note Storing User Information in the Backtrace::.
'exited(BOOLEAN)'
     BOOLEAN is 'true' if the current invocation has exited, and 'false'
     otherwise.  This condition is mainly used for looking at past
     execution states.
'parent_inv(INV)'
     The invocation number of the _debugger-parent_ (see notes below) of
     the current goal is INV.
'ancestor(ANCGOAL,INV)'
     The youngest debugger-ancestor of the current goal, which is an
     instance of the module name expanded ANCGOAL template, is at
     invocation number INV.  The unification required for matching is
     carried out.

   Notes:

   The "debugger-parent" of a goal is the youngest ancestor of the goal
present on the backtrace.  This will differ from the ordinary parent if
not all goals are traced, e.g. if the goal in question is reached in zip
mode.  A "debugger-ancestor" of a goal is any of its ancestors on the
backtrace.

   In the 'goal' and 'ancestor' tests above, there is a given module
qualified goal template, say MODT':'GOALT, and it is matched against a
concrete goal term MOD':'GOAL in the execution state.  This matching is
carried out as follows:

  a. It is checked that GOAL is an instance of GOALT.
  b. GOAL and GOALT are unified.
  c. It is checked that MOD and MODT are either unifiable (and are
     unified), or name such modules in which GOAL has the same meaning,
     i.e. either one of MOD':'GOAL and MODT':'GOAL is an exported
     variant of the other, or both are imported from the same module.

   Similar matching rules apply for predicate functors, in the 'pred'
condition.  In this test the argument holds a module qualified functor
template, say MODT':'NAME'/'ARITY, and this is matched against a
concrete goal term MOD':'GOAL in the execution state.

  a. It is checked that the functor of GOAL unifies with NAME'/'ARITY,
     and this unification is carried out.
  b. It is checked that MOD and MODT are either unifiable (and are
     unified), or name such modules in which GOAL has the same meaning.


File: sicstus.info,  Node: Source Tests,  Next: Port Tests,  Prev: Goal Tests,  Up: Breakpoint Conditions

5.9.2 Tests Related to Source Information
-----------------------------------------

These tests provide access to source related information.  The 'file'
and 'line' tests will fail if no source information is present.  The
'parent_clause' and 'parent_pred' tests are available for interpreted
code only, they will fail in compiled code.

'file(FILE)'
     The current goal is invoked from a file whose absolute name is
     FILE.
'line(FILE,LINE)'
     The current goal is invoked from line LINE, from within a file
     whose absolute name is FILE.
'line(LINE)'
     The current goal is invoked from line LINE.
'parent_clause(CL)'
     The current goal is invoked from clause CL.
'parent_clause(CL,SEL)'
     The current goal is invoked from clause CL and within its body it
     is pointed to by the subterm selector SEL.
'parent_clause(CL,SEL,I)'
     The current goal is invoked from clause CL, it is pointed to by the
     subterm selector SEL within its body, and it is the Ith goal within
     it.  The goals in the body are counted following their textual
     occurrence.
'parent_pred(PRED)'
     The current goal is invoked from predicate PRED.
'parent_pred(PRED,N)'
     The current goal is invoked from predicate PRED, clause number N.

   The 'parent_pred' tests match their first argument against the
functor of the parent predicate in the same way as the 'pred' test does;
see the notes in the previous section (*note Goal Tests::).


File: sicstus.info,  Node: Port Tests,  Next: Break Tests,  Prev: Source Tests,  Up: Breakpoint Conditions

5.9.3 Tests Related to the Current Port
---------------------------------------

These tests can only be used inside the debugger and only when focused
on the current invocation.  If they appear in 'execution_state/2' or in
'execution_state/1' called from outside the debugger, then an exception
will be raised.

   The notion of port in breakpoint handling is more general than
outlined earlier in *note Procedure Box::.  Here, the following terms
are used to describe a port:

     call, exit(nondet), exit(det), redo, fail,
     exception(EXCEPTION), block, unblock

   Furthermore, the atoms 'exit' and 'exception' can be used in the
'port' condition (see below), to denote either of the two exit ports and
an arbitrary exception port, respectively.

'port(PORT)'
     The current execution port matches PORT in the following sense:
     either PORT and the current port unify, or PORT is the functor of
     the current port (e.g. 'port(exit)' holds for both 'exit(det)' and
     'exit(nondet)' ports).

     As explained earlier, the port condition for a non Call port is
     best placed in the action part.  This is because the failure of the
     action part will cause the debugger to pass through the Call port
     silently, and to build a procedure box, even in zip mode.  The
     following idiom is suggested for creating breakpoints at non Call
     ports:

          add_breakpoint(TESTS-[port(PORT),ACTIONS], BID).

'bid(BID)'
     The breakpoint being examined has a breakpoint identifier BID.
     (BID = 'off' if no breakpoint was selected.)
'mode(MODE)'
     MODE is the value of the 'mode' variable, which normally reflects
     the current debugger mode.
'command(COMMAND)'
     COMMAND is the value of the 'command' variable, which is the
     command to be executed by default, if the breakpoint is selected.
'show(SHOW)'
     SHOW is the value of the 'show' variable, i.e. the default show
     method (the method for displaying the goal in the trace message).

   The last three of the above tests access the _debugger action
variables_.  These breakpoint conditions have a different meaning in the
action part.  For example, the condition 'mode(trace)', if it occurs in
the tests, _checks_ if the current debugger mode is 'trace'.  On the
other hand, if the same term occurs within the action part, then it
_sets_ the debugger mode to 'trace'.

   To support the querying of the action variables in the action part,
the following breakpoint condition is provided:

'get(ACTVAR)'
     Equivalent to ACTVAR, where this is an action variable test, i.e.
     one of the terms 'mode(MODE)', 'command(COMMAND)', 'show(SHOW)'.
     It has this meaning in the action part as well.

   For the 'port', 'mode', 'command' and 'show' conditions, the
condition can be replaced by its argument, if that is not a variable.
For example the condition 'call' can be used instead of 'port(call)'.
Conditions matching the terms listed above as valid port values will be
converted to a 'port' condition.  Similarly, any valid value for the
three debugger action variables is converted to an appropriate
condition.  These valid values are described in *note Action
Variables::.


File: sicstus.info,  Node: Break Tests,  Next: Other Tests,  Prev: Port Tests,  Up: Breakpoint Conditions

5.9.4 Tests Related to the Break Level
--------------------------------------

These tests can be used both inside and outside the condition evaluation
process, and also can be used in queries about past break levels.

'break_level(N)'
     We are at (or focused on) break level N (N = 0 for the outermost
     break level).
'max_inv(MAXINV)'
     The last invocation number used within the current break level is
     MAXINV.  Note that this invocation number may not be present in the
     backtrace (because the corresponding call exited determinately).
'private(PRIV)'
     The private information associated with the break level is PRIV.
     Similarly to 'goal_private/1', this condition refers initially to
     an unbound variable and can be used to store an arbitrary Prolog
     term.  However, it is strongly recommended that PRIV be used as an
     open ended list, *note Storing User Information in the Backtrace::.


File: sicstus.info,  Node: Other Tests,  Next: Action Conditions,  Prev: Break Tests,  Up: Breakpoint Conditions

5.9.5 Other Conditions
----------------------

The following conditions are for prescribing or checking the breakpoint
type.  They cause an exception if used outside the debugger or in
'execution_state/2'.

'advice'
     The breakpoint in question is of advice type.
'debugger'
     The breakpoint in question is of debugger type.

   The following construct converts an arbitrary Prolog goal into a
condition.

'true(COND)'
     The Prolog goal COND is true, i.e. 'once(COND)' is executed and the
     condition is satisfied if and only if this completes successfully.
     If an exception is raised during execution, then an error message
     is printed and the condition fails.

     The substitutions done on executing COND are carried out.  COND is
     subject to module name expansion.  If used in the test part of
     spypoint conditions, then the goal should not have any
     side-effects, as the test part may be evaluated several times.

   The following conditions represent the Boolean constants.

'true'
'[]'
     A condition that is always true.  Useful e.g. in conditionals.
'false'
     A condition that is always false.


File: sicstus.info,  Node: Action Conditions,  Next: Past States,  Prev: Other Tests,  Up: Breakpoint Conditions

5.9.6 Conditions Usable in the Action Part
------------------------------------------

The meaning of the following conditions, if they appear in the action
part, is different from their meaning in the test part.

'mode(MODE)'
     Set the debugger mode to MODE.
'command(COMMAND)'
     Set the command to be executed to COMMAND.
'show(SHOW)'
     Set the show method to SHOW.

   The values admissible for MODE, COMMAND and SHOW are described in
*note Action Variables::.

   Furthermore, any other condition can be used in the action part,
except for the ones specifying the breakpoint type ('advice' and
'debugger').  Specifically, the 'get' condition can be used to access
the value of an action variable.


File: sicstus.info,  Node: Past States,  Next: Condition Macros,  Prev: Action Conditions,  Up: Breakpoint Conditions

5.9.7 Options for Focusing on a Past State
------------------------------------------

The following ground terms can be used in the first argument of
'execution_state/2' (*note Breakpoint Predicates::).  Alternatively, a
list containing such terms can be used.  If a given condition occurs
multiple times, then only the last one is considered.  The order of
conditions within the list does not matter.

'break_level(BL)'
     Focus on the current invocation of break level BL.  BL is the break
     level number, the top-level being 'break_level(0)'.  For past break
     levels, the current invocation is the one from which the next break
     level was entered.

'inv(INV)'
     Focus on the invocation number INV of the currently focused break
     level.


File: sicstus.info,  Node: Condition Macros,  Next: Action Variables,  Prev: Past States,  Up: Breakpoint Conditions

5.9.8 Condition Macros
----------------------

There are a few condition macros expanding to a list of other
conditions:

'unleash'
     Expands to '[show(print),command(proceed)]'
'hide'
     Expands to '[show(silent),command(proceed)]'
'leash'
     Expands to '[show(print),command(ask)]'

   The user can also define condition macros using the hook predicate
below.

'breakpoint_expansion(+MACRO, -BODY)   hook,development'
'user:breakpoint_expansion(+MACRO, -BODY)'

     This predicate is called with each (non-composite) breakpoint test
     or action, as its first argument.  If it succeeds, then the term
     returned in the second argument ('Body') is substituted for the
     original condition.  The expansion is done at the time the
     breakpoint is added.

     Note that BODY can be composite, but it cannot be of form
     'TESTS-ACTIONS'.  This means that the whole BODY will be
     interpreted as being in either the test or the action part,
     depending on the context.

     The built-in breakpoint conditions cannot be redefined using this
     predicate.  *Note mpg-ref-breakpoint_expansion::.


File: sicstus.info,  Node: Action Variables,  Prev: Condition Macros,  Up: Breakpoint Conditions

5.9.9 The Action Variables
--------------------------

In this section we list the possible values of the debugger action
variables, and their meaning.

   Note that the Prolog terms, supplied as values, are copied when a
variable is set.  This is relevant primarily in the case of the
'proceed/2' and 'flit/2' values.

   Values allowed in the 'show' condition:

'print'
     Write using options stored in the 'debugger_print_options' Prolog
     flag.
'silent'
     Display nothing.
'display'
     Write using 'display'.
'write'
     Write using 'writeq'.
'write_term(OPTIONS)'
     Write using options OPTIONS.
'METHOD-SEL'
     Display only the subterm selected by SEL, using METHOD.  Here,
     METHOD is one of the methods above, and SEL is a subterm selector.

   Values allowed in the 'command' condition:

'ask'
     Ask the user what to do next.
'proceed'
     Continue the execution without interacting with the user (cf.
     unleashing).
'flit'
     Continue the execution without building a procedure box for the
     current goal (and consequently not encountering any other ports for
     this invocation).  Only meaningful at Call ports, at other ports it
     is equivalent to 'proceed'.
'proceed(GOAL,NEW)'
     Unless at call port, first go back to the call port (retry the
     current invocation; see the 'retry(INV)' command value below).
     Next, unify the current goal with GOAL and execute the goal NEW in
     its place.  Create (or keep) a procedure box for the current goal.

     This construct is used by the 'u' (unify) interactive debugger
     command.

     Both the GOAL and NEW arguments are module name expanded when the
     breakpoint is added: the module of GOAL defaults to the module of
     the current goal, while that of NEW to the module name of the
     breakpoint spec.  If the command value is created during run time,
     then the module name of both arguments defaults to the module of
     the current goal.

     The term 'proceed(GOAL,NEW)' will be copied when the 'command'
     action variable is set.  Therefore breakpoint specs of form
          Tests - [goal(foo(X)),...,proceed(_,bar(X))]

     should be avoided, and

          Tests - [goal(foo(X)),...,proceed(foo(Y),bar(Y))
     should be used instead.  The first variant will not work as
     expected if 'X' is non-ground, as the variables in the 'bar/1' call
     will be detached from the original ones in 'foo/1'.  Even if 'X' is
     ground, the first variant may be much less efficient, as it will
     copy the possibly huge term 'X'.

'flit(GOAL,NEW)'

     Same as 'proceed(GOAL,NEW)', but do not create (or discard) a
     procedure box for the current goal.  (Consequently no other ports
     will be encountered for this invocation.)

     Notes for 'proceed/2', on module name expansion and copying, also
     apply to 'flit/2'.

'raise(E)'
     Raise the exception E.
'abort'
     Abort the execution.
'retry(INV)'
     Retry the most recent goal in the backtrace with an invocation
     number less or equal to INV (go back to the Call port of the goal).
     This is used by the interactive debugger command 'r', retry; *note
     Debug Commands::.
'reexit(INV)'
     Re-exit the invocation with number INV (go back to the Exit port of
     the goal).  INV must be an exact reference to an exited invocation
     present in the backtrace (exited nondeterminately, or currently
     being exited).  This is used by the interactive debugger command
     'je', jump to Exit port; *note Debug Commands::.
'redo(INV)'
     Redo the invocation with number INV (go back to the Redo port of
     the goal).  INV must be an exact reference to an exited invocation
     present in the backtrace.  This is used by the interactive debugger
     command 'jr', jump to Redo port; *note Debug Commands::.
'fail(INV)'
     Fail the most recent goal in the backtrace with an invocation
     number less or equal to INV (transfer control back to the Fail port
     of the goal).  This is used by the interactive debugger command
     'f', fail; *note Debug Commands::.

   Values allowed in the 'mode' condition:

'qskip(INV)'
     Quasi-skip until the first port with invocation number less or
     equal to INV is reached.  Having reached that point, 'mode' is set
     to 'trace'.  Valid only if \Inv \geq 1 and furthermore \Inv \leq
     \CurrInv for entry ports (Call, Redo), and \Inv < \CurrInv for all
     other ports, where CURRINV is the invocation number of the current
     port.
'skip(INV)'
     Skip until the first port with invocation number less or equal to
     INV is reached, and set 'mode' to 'trace' there.  INV should obey
     the same rules as for 'qskip'.
'trace'
     Creep.
'debug'
     Leap.
'zip'
     Zip.
'off'
     Continue without debugging.


File: sicstus.info,  Node: Consult,  Next: Exceptions Debug,  Prev: Breakpoint Conditions,  Up: Debug Intro

5.10 Consulting during Debugging
================================

It is possible, and sometimes useful, to consult a file whilst in the
middle of program execution.  Predicates that have been successfully
executed and are subsequently redefined by a consult and are later
reactivated by backtracking, will not notice the change of their
definitions.  In other words, it is as if every predicate, when called,
creates a copy of its definition for backtracking purposes.


File: sicstus.info,  Node: Exceptions Debug,  Next: Debug Summary,  Prev: Consult,  Up: Debug Intro

5.11 Catching Exceptions
========================

Usually, exceptions that occur during debugging sessions are displayed
only in trace mode and for invocation boxes for predicates with
spypoints on them, and not during skips.  However, it is sometimes
useful to make exceptions trap to the debugger at the earliest
opportunity instead.  The hook predicate 'user:error_exception/1'
provides such a possibility:

'error_exception(+EXCEPTION)   hook'
'user:error_exception(+EXCEPTION)'

     This predicate is called at all Exception ports.  If it succeeds,
     then the debugger enters trace mode and prints an exception port
     message.  Otherwise, the debugger mode is unchanged and a message
     is printed only in trace mode or if a spypoint is reached, and not
     during skips.  *Note mpg-ref-error_exception::.

   Note that this hook takes effect when the debugger arrives at an
Exception port.  For this to happen, procedure boxes have to be built,
e.g. by running (the relevant parts of) the program in debug mode.

   A useful definition that ensures that all standard error exceptions
causes the debugger to enter trace mode, is as follows:
     :- multifile user:error_exception/1.
     user:error_exception(error(_,_)).
(this example would not have worked prior to release 4.0.5).


File: sicstus.info,  Node: Debug Summary,  Prev: Exceptions Debug,  Up: Debug Intro

5.12 Predicate Summary
======================

'add_breakpoint(+CONDITIONS, -BID)   development'
     Creates a breakpoint with CONDITIONS and with identifier BID.

'user:breakpoint_expansion(+MACRO, -BODY)   hook,development'
     defines debugger condition macros

'coverage_data(?DATA)   since release 4.2,development'
     DATA is the coverage data accumulated so far

'current_breakpoint(?CONDITIONS, ?BID, ?STATUS, ?KIND, ?TYPE)   development'
     There is a breakpoint with conditions CONDITIONS, identifier BID,
     enabledness STATUS, kind KIND, and type TYPE.

'debug   development'
     switch on debugging

'user:debugger_command_hook(+DCOMMAND,-ACTIONS)   hook,development'
     Allows the interactive debugger to be extended with user-defined
     commands.

'debugging   development'
     display debugging status information

'disable_breakpoints(+BIDS)   development'
     Disables the breakpoints specified by BIDS.

'enable_breakpoints(+BIDS)   development'
     Enables the breakpoints specified by BIDS.

'user:error_exception(+EXCEPTION)   hook'
     EXCEPTION is an exception that traps to the debugger if it is
     switched on.

'execution_state(+TESTS)   development'
     TESTS are satisfied in the current state of the execution.

'execution_state(+FOCUSCONDITIONS, +TESTS)   development'
     TESTS are satisfied in the state of the execution pointed to by
     FOCUSCONDITIONS.

'leash(+M)   development'
     set the debugger's leashing mode to M

'nodebug   development'
     switch off debugging

'nospy(:P)   development'
     remove spypoints from the procedure(s) specified by P

'nospyall   development'
     remove all spypoints

'notrace   development'
     switch off debugging (same as 'nodebug/0')

'nozip   development'
     switch off debugging (same as 'nodebug/0')

'print_coverage   since release 4.2,development'
'print_coverage(?DATA)   since release 4.2,development'
     The coverage data DATA is displayed in a hierarchical format.  DATA
     defaults to the coverage data accumulated so far.

'print_profile   since release 4.2,development'
'print_profile(?DATA)   since release 4.2,development'
     The profiling data DATA is displayed in a format similar to
     'gprof(1)'.  DATA defaults to the profiling data accumulated so
     far.

'profile_data(?DATA)   since release 4.2,development'
     DATA is the profiling data accumulated so far

'profile_reset   since release 4.2,development'
     All profiling data is reset.

'remove_breakpoints(+BIDS)   development'
     Removes the breakpoints specified by BIDS.

'spy(:P)   development'
'spy(:P,:C)'
     set spypoints on the procedure(s) specified by P with conditions C

'trace   development'
     switch on debugging and start tracing immediately

'unknown(-O,+N)   development'
     Changes action on undefined predicates from O to N.

'user:unknown_predicate_handler(+G,+M,-N)   hook'
     handle for unknown predicates.

'zip   development'
     switch on debugging in zip mode


File: sicstus.info,  Node: Mixing C and Prolog,  Next: Interfacing .NET and Java,  Prev: Debug Intro,  Up: Top

6 Mixing C/C++ and Prolog
*************************

SICStus Prolog provides a bi-directional, procedural interface for
program parts written in C and Prolog.  The C side of the interface
defines a number of functions and macros for various operations.  On the
Prolog side, you have to supply declarations specifying the names and
argument/value types of C functions being called as predicates.  These
declarations are used by the predicate 'load_foreign_resource/1', which
performs the actual binding of functions to predicates.  They are also
needed when the functions are unloaded, for example when SICStus is
halted.

   In most cases, the argument/value type declarations suffice for
making the necessary conversions of data automatically as they are
passed between C and Prolog.  However, it is possible to declare the
type of an argument to be a Prolog term, in which case the receiving
function will see it as a "handle" object, called an "SP_term_ref", for
which access functions are provided.

   The C support routines are available in a development system as well
as in runtime systems.  The support routines include:

   * Static and dynamic linking of C code into the Prolog environment.

   * Automatic conversion between Prolog terms and C data with
     'foreign/[2,3]' declarations.

   * Functions for accessing and creating Prolog terms, and for creating
     and manipulating SP_term_refs.

   * The Prolog system may call C predicates, which may call Prolog back
     without limits on recursion.  Predicates that call C may be defined
     dynamically from C.

   * Support for creating stand-alone executables.

   * Support for creating user defined Prolog streams.

   * Functions to read and write on Prolog streams from C.

   * Functions to install interrupt handlers that can safely call
     Prolog.

   * Functions for manipulating mutual exclusion locks.

   * User hooks that can be used to perform user defined actions e.g.
     for customizing the memory management bottom layer.

   In addition to the interface described in this chapter,
'library(structs)' and 'library(objects)' (see *note lib-structs:: and
*note lib-objects::) allow Prolog to hold pointers to C data structures
and arrays and access and store into fields in those data structures in
a very efficient way, allowing the programmer to stay completely inside
Prolog.

* Menu:

* CPL Notes:: Notes
* Calling C from Prolog:: Calling C from Prolog
* Calling C++ from Prolog:: Calling C++ from Prolog
* Support Functions:: Support Functions
* Calling Prolog from C:: Calling Prolog from C
* SICStus Streams:: SICStus Streams
* Stand-Alone Executables:: Stand-Alone Executables
* Mixing C and Prolog Examples:: Mixing C and Prolog Examples
* Debugging Runtime Systems:: Debugging Runtime Systems


File: sicstus.info,  Node: CPL Notes,  Next: Calling C from Prolog,  Up: Mixing C and Prolog

6.1 Notes
=========

_The SP_PATH variable_
     It is normally not necessary, nor desirable, to set this system
     property (or environment variable), but its value will be used, as
     a fall-back, at runtime if it cannot be determined automatically
     during initialization of a runtime or development system.  In this
     chapter, 'SP_PATH' is used as a shorthand, as follows.

     On Windows, 'SP_PATH' is a shorthand for the SICStus Prolog
     installation directory, whose default location for SICStus 4.4.1 is
     'C:\Program Files\SICStus Prolog 4.4.1\'.

     On UNIX, the default installation directory for SICStus 4.4.1 is
     '/usr/local/sicstus4.4.1/' and 'SP_PATH' is a shorthand for the
     subdirectory 'lib/sicstus-4.4.1/' of the installation directory,
     e.g.: '/usr/local/sicstus4.4.1/lib/sicstus-4.4.1/'.

     *Note System Properties and Environment Variables::.  for more
     information.

_Definitions and declarations_
     Type definitions and function declarations for the interface are
     found in the header file '<sicstus/sicstus.h>'.

_Error Codes_

     The value of many support functions is a return code, namely:
     'SP_SUCCESS' for success, 'SP_FAILURE' for failure, 'SP_ERROR' if
     an error condition occurred, or if an uncaught exception was raised
     during a call from C to Prolog.  If the value is 'SP_ERROR', then
     the macro 'SP_errno' will return a value describing the error
     condition:

          int SP_errno

     The function 'SP_error_message()' returns a pointer to the
     diagnostic message corresponding to a specified error number.

_Wide Characters_
     The foreign interface supports wide characters.  Whenever a
     sequence of possibly wide character codes is to be passed to or
     from a C function it is encoded as a sequence of bytes, using the
     UTF-8 encoding.  Unless noted otherwise the encoded form is
     terminated by a NUL byte.  This sequence of bytes will be called an
     "encoded string", representing the given sequence of character
     codes.  Note that it is a property of the UTF-8 encoding that it
     does not change ASCII character code sequences.

     If a foreign function is specified to return an encoded string,
     then an exception will be raised if, on return to Prolog, the
     actual string is malformed (is not a valid sequence of UTF-8
     encoded characters).  The exception raised is
     'error(representation_error(mis_encoded_string),representation_error(...,...,mis_encoded_string))'.


File: sicstus.info,  Node: Calling C from Prolog,  Next: Calling C++ from Prolog,  Prev: CPL Notes,  Up: Mixing C and Prolog

6.2 Calling C from Prolog
=========================

Functions written in the C language may be called from Prolog using an
interface in which automatic type conversions between Prolog terms and
common C types are declared as Prolog facts.  Calling without type
conversion can also be specified, in which case the arguments and values
are passed as SP_term_refs.  This interface is partly modeled after
Quintus Prolog.

   The functions installed using this foreign language interface may
invoke Prolog code and use the support functions described in the other
sections of this chapter.

   Functions, or their equivalent, in any other language having C
compatible calling conventions may also be interfaced using this
interface.  When referring to C functions in the following, we also
include such other language functions.  Note however that a C compiler
is needed since a small amount of glue code (in C) must be generated for
interfacing purposes.

   As an alternative to this interface, 'SP_define_c_predicate()'
defines a Prolog predicate such that when the Prolog predicate is called
it will call a C function with a term corresponding to the Prolog goal.
For details, *note cpg-ref-SP_define_c_predicate::.

* Menu:

* Foreign Resources:: Foreign Resources
* Conversion Declarations:: Conversion Declarations
* Conversions between Prolog Arguments and C Types:: Conversions between Prolog Arguments and C Types
* Interface Predicates:: Interface Predicates
* The Foreign Resource Linker:: The Foreign Resource Linker
* Init and Deinit Functions:: Init and Deinit Functions
* Creating the Linked Foreign Resource:: Creating the Linked Foreign Resource
* Foreign Code Examples:: Foreign Code Examples


File: sicstus.info,  Node: Foreign Resources,  Next: Conversion Declarations,  Up: Calling C from Prolog

6.2.1 Foreign Resources
-----------------------

A "foreign resource" is a set of C functions, defined in one or more
files, installed as an atomic operation.  The name of a foreign
resource, the "resource name", is an atom, which should uniquely
identify the resource.  Thus, two foreign resources with the same name
cannot be installed at the same time, even if they correspond to
different files.

   The resource name of a foreign resource is derived from its file name
by deleting any leading path and the suffix.  Therefore the resource
name is not the same as the absolute file name.  For example, the
resource name of both '~john/foo/bar.so' and '~ringo/blip/bar.so' is
'bar'.  If 'load_foreign_resource('~john/foo/bar')' has been done, then
'~john/foo/bar.so' will be unloaded if either
'load_foreign_resource('~john/foo/bar')' or
'load_foreign_resource('~ringo/blip/bar')' is subsequently called.

   It is recommended that a resource name be all lowercase, starting
with 'a' to 'z' followed by a sequence consisting of 'a' to 'z',
underscore ('_'), and digits.  The resource name is used to construct
the file name containing the foreign resource.

   For each foreign resource, a 'foreign_resource/2' fact is used to
declare the interfaced functions.  For each of these functions, a
'foreign/[2,3]' fact is used to specify conversions between predicate
arguments and C-types.  These conversion declarations are used for
creating the necessary interface between Prolog and C.

   The functions making up the foreign resource, the automatically
generated glue code, and any libraries, are compiled and linked, using
the 'splfr' tool (*note The Foreign Resource Linker::), to form a
"linked foreign resource".  A linked foreign resource can be either
"static" or "dynamic".  A static resource is simply a relocatable object
file containing the foreign code.  A dynamic resource is a shared
library ('.so' under most UNIX dialects, '.dll' under Windows), which is
loaded into the Prolog executable at runtime.

   Foreign resources can be linked into the Prolog executable either
when the executable is built ("prelinked"), or at runtime.  Prelinking
can only be done using static resources.  Runtime-linking can only be
done using dynamic resources.  Dynamic resources can also be unlinked.

   In all cases, the declared predicates are installed by the built-in
predicate 'load_foreign_resource/1'.  If the resource was prelinked,
then only the predicate names are bound; otherwise, runtime-linking is
attempted (using 'dlopen()', 'LoadLibrary()', or similar).


File: sicstus.info,  Node: Conversion Declarations,  Next: Conversions between Prolog Arguments and C Types,  Prev: Foreign Resources,  Up: Calling C from Prolog

6.2.2 Conversion Declarations
-----------------------------

Conversion declaration predicates:

'foreign_resource(+RESOURCENAME,+FUNCTIONS)   hook'

     Specifies that a set of foreign functions, to be called from
     Prolog, are to be found in the resource named by RESOURCENAME.
     FUNCTIONS is a list of functions exported by the resource.  Only
     functions that are to be called from Prolog and optionally one
     "init function" and one "deinit function" should be listed.  The
     init and deinit functions are specified as 'init(FUNCTION)' and
     'deinit(FUNCTION)' respectively (*note Init and Deinit
     Functions::).  This predicate should be defined entirely in terms
     of facts (unit clauses) and will be called in the relevant module,
     i.e. not necessarily in the 'user' module.  For example:

          foreign_resource('terminal', [scroll,pos_cursor,ask]).

     specifies that functions 'scroll()', 'pos_cursor()' and 'ask()' are
     to be found in the resource 'terminal'.  *Note
     mpg-ref-foreign_resource::.

'foreign(+CFUNCTIONNAME, +PREDICATE)   hook'
'foreign(+CFUNCTIONNAME, +LANGUAGE, +PREDICATE)   hook'

     Specify the Prolog interface to a C function.  LANGUAGE is at
     present constrained to the atom 'c', so there is no advantage in
     using 'foreign/3' over 'foreign/2'.  CFUNCTIONNAME is the name of a
     C function.  PREDICATE specifies the name of the Prolog predicate
     that will be used to call CFUNCTION().  PREDICATE also specifies
     how the predicate arguments are to be translated to and from the
     corresponding C arguments.  These predicates should be defined
     entirely in terms of facts (unit clauses) and will be called in the
     relevant module, i.e. not necessarily in the 'user' module.  For
     example:

          foreign(pos_cursor, c, move_cursor(+integer, +integer)).

     The above example says that the C function 'pos_cursor()' has two
     integer value arguments and that we will use the predicate
     'move_cursor/2' to call this function.  A goal 'move_cursor(5, 23)'
     would translate into the C call 'pos_cursor(5,23);'.

     The third argument of the predicate 'foreign/3' specifies how to
     translate between Prolog arguments and C arguments.  A call to a
     foreign predicate will throw an Instantiation Error if an input
     arguments is uninstantiated, a Type Error if an input arguments has
     the wrong type, or a Domain Error if an input arguments is in the
     wrong domain.  The call will fail upon return from the function if
     the output arguments do not unify with the actual arguments.

     The available conversions are listed in the next subsection.  *Note
     mpg-ref-foreign::.


File: sicstus.info,  Node: Conversions between Prolog Arguments and C Types,  Next: Interface Predicates,  Prev: Conversion Declarations,  Up: Calling C from Prolog

6.2.3 Conversions between Prolog Arguments and C Types
------------------------------------------------------

The following table lists the possible values for the arguments in the
predicate specification of 'foreign/[2,3]'.  The value declares which
conversion between corresponding Prolog argument and C type will take
place.

'Prolog: +integer'
'C: SP_integer'
     The argument should be a number.  It is converted to a C
     'SP_integer' and passed to the C function.  If the number does not
     fit in a 'SP_integer', an exception is thrown.
'Prolog: +float'
'C: double'
     The argument should be a number.  It is converted to a C 'double'
     and passed to the C function.  If the number is a large integer
     that does not fit in a 'double', then an exception is thrown.

'Prolog: +atom'
'C: SP_atom'
     The argument should be an atom.  Its canonical representation is
     passed to the C function.

'Prolog: +codes'
'C: char const *'
     The argument should be a code-list.  The C function will be passed
     the address of an array with the encoded string representation of
     these characters.  The array is subject to reuse by other support
     functions, so if the value is going to be used on a more than
     temporary basis, then it must be moved elsewhere.

'Prolog: +string'
'C: char const *'
     The argument should be an atom.  The C function will be passed the
     address of an encoded string representing the characters of the
     atom.  *Please note*: The C function must not overwrite the string.
'Prolog: +address'
'C: void *'
     The value passed will be a 'void *' pointer.

'Prolog: +address(TYPENAME)'
'C: TYPENAME *'
     The value passed will be a 'TYPENAME *' pointer.
'Prolog: +term'
'C: SP_term_ref'
     The argument could be any term.  The value passed will be the
     internal representation of the term.
'Prolog: -integer'
'C: SP_integer *'
     The C function is passed a reference to an uninitialized
     'SP_integer'.  The value returned will be converted to a Prolog
     integer.
'Prolog: -float'
'C: double *'
     The C function is passed a reference to an uninitialized 'double'.
     The value returned will be converted to a Prolog float.  If the
     value returned is not finite, i.e.  it is infinite or NaN, then an
     exception is thrown.
'Prolog: -atom'
'C: SP_atom *'
     The C function is passed a reference to an uninitialized 'SP_atom'.
     The value returned should be the canonical representation of a
     Prolog atom.
'Prolog: -codes'
'C: char const **'
     The C function is passed the address of an uninitialized 'char *'.
     The returned encoded string will be converted to a Prolog
     code-list.
'Prolog: -string'
'C: char const **'
     The C function is passed the address of an uninitialized 'char *'.
     The returned encoded string will be converted to a Prolog atom.
     Prolog will copy the string to a safe place, so the memory occupied
     by the returned string may be reused during subsequent calls to
     foreign code.

'Prolog: -address'
'C: void **'
     The C function is passed the address of an uninitialized 'void *'.

'Prolog: -address(TYPENAME)'
'C: TYPENAME **'
     The C function is passed the address of an uninitialized 'TYPENAME
     *'.

'Prolog: -term'
'C: SP_term_ref'
     The C function is passed a new SP_term_ref, and is expected to set
     its value to a suitable Prolog term.  Prolog will try to unify the
     value with the actual argument.
'Prolog: [-integer]'
'C: SP_integer F()'
     The C function should return an 'SP_integer'.  The value returned
     will be converted to a Prolog integer.
'Prolog: [-float]'
'C: double F()'
     The C function should return a 'double'.  The value returned will
     be converted to a Prolog float.  If the value returned is not
     finite, i.e.  it is infinite or NaN, then an exception is thrown.
'Prolog: [-atom]'
'C: SP_atom F()'
     The C function should return an 'SP_atom'.  The value returned must
     be the canonical representation of a Prolog atom.
'Prolog: [-codes]'
'C: char const *F()'
     The C function should return a 'char *'.  The returned encoded
     string will be converted to a Prolog code-list.
'Prolog: [-string]'
'C: char const *F()'
     The C function should return a 'char *'.  The returned encoded
     string will be converted to a Prolog atom.  Prolog will copy the
     string to a safe place, so the memory occupied by the returned
     string may be reused during subsequent calls to foreign code.
'Prolog: [-address]'
'C: void *F()'
     The C function should return a 'void *', which will be converted to
     a Prolog integer.
'Prolog: [-address(TYPENAME)]'
'C: TYPENAME *F()'
     The C function should return a 'TYPENAME *'.

'Prolog: [-term]'
'C: SP_term_ref F()'
     The C function should return an SP_term_ref.  Prolog will try to
     unify its value with the actual argument.


File: sicstus.info,  Node: Interface Predicates,  Next: The Foreign Resource Linker,  Prev: Conversions between Prolog Arguments and C Types,  Up: Calling C from Prolog

6.2.4 Interface Predicates
--------------------------

'load_foreign_resource(:RESOURCE)'

     Unless a foreign resource with the same name as RESOURCE has been
     statically linked, the linked foreign resource specified by
     RESOURCE is linked into the Prolog load image.  In both cases, the
     predicates defined by RESOURCE are installed, and any init function
     is called.  Dynamic linking is not possible if the foreign resource
     was linked using the '--static' option.

     If a resource with the same name has been previously loaded, then
     it will be unloaded, as if 'unload_foreign_resource(RESOURCE)' were
     called, before RESOURCE is loaded.

     An example of usage of 'load_foreign_resource/1' can be found in
     its reference page, *note mpg-ref-load_foreign_resource::.

'unload_foreign_resource(:RESOURCENAME)'

     Any deinit function associated with RESOURCENAME, a resource name,
     is called, and the predicates defined by RESOURCENAME are
     uninstalled.  If RESOURCENAME has been dynamically linked, then it
     is unlinked from the Prolog load image.

     If no resource named 'RESOURCENAME' is currently loaded, then an
     existence error is raised.

     For backward compatibility, RESOURCENAME can also be of the same
     type as the argument to 'load_foreign_resource/1'.  In that case
     the resource name will be derived from the absolute file name in
     the same manner as for 'load_foreign_resource/1'.  Also for
     backward compatibility, 'unload_foreign_resource/1' is a
     meta-predicate, but the module is ignored.  *Note
     mpg-ref-unload_foreign_resource::.

          *Please note*: all foreign resources are unloaded before
          Prolog exits.  This implies that the C library function
          'atexit(FUNC)' cannot be used if FUNC is defined in a
          dynamically linked foreign resource.


File: sicstus.info,  Node: The Foreign Resource Linker,  Next: Init and Deinit Functions,  Prev: Interface Predicates,  Up: Calling C from Prolog

6.2.5 The Foreign Resource Linker
---------------------------------

The foreign resource linker, 'splfr', is used for creating foreign
resources (*note Foreign Resources::).  'splfr' reads terms from a
Prolog file extracting any 'foreign_resource/2' fact with first argument
matching the resource name and all 'foreign/[2,3]' facts.  Based on this
information, it generates the necessary glue code, including a header
file that the user code should include, and combines it with any
additional C or object files provided by the user into a linked foreign
resource.  The output file name will be the resource name with a
suitable extension.

   Note that no pathnames passed to 'splfr' should contain spaces.
Under Windows, this can be avoided by using the short version of
pathnames as necessary.

   *Note too-splfr::.  for detailed information about 'splfr' options
etc..

* Menu:

* Customizing splfr:: Customizing 'splfr'
* Manual splfr:: Creating Linked Foreign Resources Manually under UNIX
* Windows-specific splfr issues:: Windows-specific splfr issues


File: sicstus.info,  Node: Customizing splfr,  Next: Manual splfr,  Up: The Foreign Resource Linker

6.2.5.1 Customizing 'splfr'.
............................

The 'splfr' tool reads a configuration file at start-up that contains
default values for many configurable parameters.  It is sometimes useful
to modify these in order to adapt to local variations.

   Both 'splfr' and 'spld' use the same configuration file and use the
same options for changing the default parameters.  *Note Customizing
spld::.  for details.


File: sicstus.info,  Node: Manual splfr,  Next: Windows-specific splfr issues,  Prev: Customizing splfr,  Up: The Foreign Resource Linker

6.2.5.2 Creating Linked Foreign Resources Manually under UNIX
.............................................................

The only supported method for building foreign resources is by compiling
and linking them with 'splfr'.  However, this is sometimes inconvenient,
for instance when writing a Makefile for use with 'make'.  To figure out
what needs to be done to build a foreign resource, you should build it
once with 'splfr --verbose --keep ...', note what compiler and linker
flags are used, and save away any generated files.  You can then mimic
the build commands used by 'splfr' in your 'Makefile'.  You should
repeat this process each time you upgrade SICStus Prolog.


File: sicstus.info,  Node: Windows-specific splfr issues,  Prev: Manual splfr,  Up: The Foreign Resource Linker

6.2.5.3 Windows-specific splfr issues
.....................................

'splfr' needs to be able to invoke the C compiler from the command line.
On Windows, this will only work if the command line environment has been
properly set up.  *Note Setting up the C compiler on Windows::.  for
Windows-specific information about getting the C compiler to work.


File: sicstus.info,  Node: Init and Deinit Functions,  Next: Creating the Linked Foreign Resource,  Prev: The Foreign Resource Linker,  Up: Calling C from Prolog

6.2.6 Init and Deinit Functions
-------------------------------

An init function and/or a deinit function can be declared by
'foreign_resource/2'.  If this is the case, then these functions should
have the prototype:

'void FUNCTIONNAME (int when)'

   The init function is called by 'load_foreign_resource/1' after the
resource has been loaded and the interfaced predicates have been
installed.  If the init function fails (using 'SP_fail()') or raises an
exception (using 'SP_raise_exception()'), then the failure or exception
is propagated by 'load_foreign_resource/1' and the foreign resource is
unloaded (without calling any deinit function).  However, using
'SP_fail()' is not recommended, and operations that may require
'SP_raise_exception()' are probably better done in an init function that
is called explicitly after the foreign resource has been loaded.

   The deinit function is called by 'unload_foreign_resource/1' before
the interfaced predicates have been uninstalled and the resource has
been unloaded.  If the deinit function fails or raises an exception,
then the failure or exception is propagated by
'unload_foreign_resource/1', but the foreign resource is still unloaded.
However, neither 'SP_fail()' nor 'SP_raise_exception()' should be called
in a deinit function.  Complex deinitialization should be done in an
explicitly called deinit function instead.

   The init and deinit functions may use the C-interface to call Prolog
etc.

   Foreign resources are unloaded when the saved-state is restored;
*note Saving::.  Foreign resources are also unloaded when exiting Prolog
execution.  The parameter 'when' reflects the context of the
'(un)load_foreign_resource/1' and is set as follows for init functions:

'SP_WHEN_EXPLICIT'
     Explicit call to 'load_foreign_resource/1'.
'SP_WHEN_RESTORE'
     Resource is reloaded after restore.

   For deinit functions:

'SP_WHEN_EXPLICIT'
     Explicit call to 'unload_foreign_resource/1' or a call to
     'load_foreign_resource/1' with the name of an already loaded
     resource.
'SP_WHEN_EXIT'
     Resource is unloaded before exiting Prolog.


File: sicstus.info,  Node: Creating the Linked Foreign Resource,  Next: Foreign Code Examples,  Prev: Init and Deinit Functions,  Up: Calling C from Prolog

6.2.7 Creating the Linked Foreign Resource
------------------------------------------

Suppose we have a Prolog source file 'ex.pl' containing:

                                                              _% ex.pl_
     foreign(f1, p1(+integer,[-integer])).
     foreign(f2, p2(+integer,[-integer])).
     foreign_resource(ex, [f1,f2]).
     :- load_foreign_resource(ex).

and a C source file 'ex.c' with definitions of the functions 'f1' and
'f2', both returning 'SP_integer' and having an 'SP_integer' as the only
parameter.  The conversion declarations in 'ex.pl' state that these
functions form the foreign resource 'ex'.  Normally, the C source file
should contain the following two line near the beginning (modulo the
resource name):

     #include <sicstus/sicstus.h>
     /* ex_glue.h is generated by splfr from the foreign/[2,3] facts.
        Always include the glue header in your foreign resource code.
     */
     #include "ex_glue.h"

   To create the linked foreign resource, simply type (to the Shell):

     % splfr ex.pl ex.c

   The linked foreign resource 'ex.so' (file suffix '.so' is system
dependent) has been created.  It will be dynamically linked by the
directive ':- load_foreign_resource(ex).' when the file 'ex.pl' is
loaded.  For a full example, *note Foreign Code Examples::.

   Dynamic linking of foreign resources can also be used by runtime
systems.


File: sicstus.info,  Node: Foreign Code Examples,  Prev: Creating the Linked Foreign Resource,  Up: Calling C from Prolog

6.2.8 Foreign Code Examples
---------------------------

Given: a Prolog file 'ex.pl' and a C file 'ex.c' shown below.

                                                                _ex.pl_
     foreign_resource(ex, [c1, c2, c11, c21, c3, c4, c5, c6]).

     foreign(c1,  c, c1(+integer, [-integer])).
     foreign(c2,  c, c2(-integer)).
     foreign(c11, c, c11(+atom, [-atom])).
     foreign(c21, c, c21(+atom, -atom)).
     foreign(c3,  c, c3(+float, [-float])).
     foreign(c4,  c, c4(-float)).
     foreign(c5,  c, c5(+string,[-string])).
     foreign(c6,  c, c6(-string)).

     :- load_foreign_resource(ex).

                                                                 _ex.c_
     #include <sicstus/sicstus.h>
     /* ex_glue.h is generated by splfr from the foreign/[2,3] facts.
        Always include the glue header in your foreign resource code.
     */
     #include "ex_glue.h"

     /* c1(+integer, [-integer]) */
     SP_integer c1(a)
     SP_integer a;
     {
        return(a+9);
     }

     /* c2(-integer) */
     void c2(a)
     SP_integer *a;
     {
        *a = 99;
     }

     /* c11(+atom, [-atom]) */
     SP_atom c11(a)
     SP_atom a;
     {
        return(a);
     }

     /* c21(+atom, -atom) */
     void c21(a,b)
     SP_atom a;
     SP_atom *b;
     {
        *b = a;
     }

     /* c3(+float, [-float]) */
     double c3(a)
     double a;
     {
        return(a+9.0);
     }
     /* c4(-float) */
     void c4(a)
     double *a;
     {
        *a = 9.9;
     }
     /* c5(string, [-string]) */
     char const * c5(a)
     char const * a;
     {
        return(a);
     }
     /* c6(-string) */
     void c6(a)
     char const * *a;
     {
        *a = "99";
     }

   Dialog at the command level:

     % splfr ex.pl ex.c
     % sicstus -l ex
     % compiling /home/matsc/sicstus4/ex.pl...
     %  loading foreign resource /home/matsc/sicstus4/ex.so in module user
     % compiled /home/matsc/sicstus4/ex.pl in module user, 0 msec 3184 bytes
     SICStus 4.4.1 ...
     Licensed to SICS
     | ?- c1(1,X1), c2(X2), c11(foo,X11), c21(foo,X21),
          c3(1.5,X3), c4(X4), c5(foo,X5), c6(X6).
     X1 = 10,
     X2 = 99,
     X3 = 10.5,
     X4 = 9.9,
     X5 = foo,
     X6 = '99',
     X11 = foo,
     X21 = foo ? <RET>
     yes


File: sicstus.info,  Node: Calling C++ from Prolog,  Next: Support Functions,  Prev: Calling C from Prolog,  Up: Mixing C and Prolog

6.3 Calling C++ from Prolog
===========================

Functions in C++ files that should be called from Prolog must use C
linkage, e.g.

     extern "C" {
     void myfun(SP_integer i)
     {...};
     };

   On Windows, C++ is a first class citizen and no special steps are
needed in order to mix C++ and C code.

   On other platforms, to build a dynamically linked foreign resource
with C++ code, you may have to explicitly include certain libraries and
you may need to use an executable compiled and linked with a C++
compiler.  The details are platform and C++ compiler dependent and
outside the scope of this manual.


File: sicstus.info,  Node: Support Functions,  Next: Calling Prolog from C,  Prev: Calling C++ from Prolog,  Up: Mixing C and Prolog

6.4 Support Functions
=====================

The support functions include functions to manipulate SP_term_refs,
functions to convert data between the basic C types and Prolog terms,
functions to test whether a term can be converted to a specific C type,
and functions to unify or compare two terms.

* Menu:

* Creating and Manipulating SP_term_refs:: Creating and Manipulating SP_term_refs
* Atoms in C:: Atoms in C
* Creating Prolog Terms:: Creating Prolog Terms
* Accessing Prolog Terms:: Accessing Prolog Terms
* Testing Prolog Terms:: Testing Prolog Terms
* Unifying and Comparing Terms:: Unifying and Comparing Terms
* Operating System Services:: Operating System Services


File: sicstus.info,  Node: Creating and Manipulating SP_term_refs,  Next: Atoms in C,  Up: Support Functions

6.4.1 Creating and Manipulating SP_term_refs
--------------------------------------------

Normally, C functions only have indirect access to Prolog terms via
SP_term_refs.  C functions may receive arguments as unconverted Prolog
terms, in which case the actual arguments received will have the type
'SP_term_ref'.  Also, a C function may return an unconverted Prolog
term, in which case it must create an SP_term_ref.  Finally, any
temporary Prolog terms created by C code must be handled as
SP_term_refs.

   SP_term_refs are motivated by the fact that SICStus Prolog's memory
manager must have a means of reaching all live Prolog terms for memory
management purposes, including such terms that are being manipulated by
the user's C code.  Previous releases provided direct access to Prolog
terms and the ability to tell the memory manager that a given memory
address points to a Prolog term, but this approach was too low level and
highly error-prone.  The current design is modeled after and largely
compatible with Quintus Prolog release 3.

   SP_term_refs are created dynamically.  At any given time, an
SP_term_ref has a value (a Prolog term, initially '[]').  This value can
be examined, accessed, and updated by the support functions described in
this section.

   A new SP_term_ref is created by calling 'SP_new_term_ref()'.

   An SP_term_ref can be assigned the value of another SP_term_ref by
calling 'SP_put_term()'.

   It is important to understand the rules governing the scope of
SP_term_refs, and the terms they hold, in conjunction with calls from
Prolog to C and vice versa.  This is explained in *note Finding Multiple
Solutions of a Call::.


File: sicstus.info,  Node: Atoms in C,  Next: Creating Prolog Terms,  Prev: Creating and Manipulating SP_term_refs,  Up: Support Functions

6.4.2 Atoms in C
----------------

Each Prolog atom is represented internally by a unique integer, its
"canonical representation", with the corresponding C type 'SP_atom'.
This mapping between atoms and integers depends on the execution
history.  Certain functions require this representation as opposed to an
SP_term_ref.  It can be obtained by a special argument type declaration
when calling C from Prolog, by calling 'SP_get_atom()', or by looking up
an encoded string 's' in the Prolog symbol table by calling
'SP_atom_from_string(s)' which returns the atom, or zero if the given
string is malformed (is not a valid sequence of UTF-8 encoded
characters).

   The encoded string containing the characters of a Prolog atom 'a' can
be obtained by calling 'SP_string_from_atom()'.

   The length of the encoded string representing a Prolog atom 'a' can
be obtained by calling 'SP_atom_length()'.

   Prolog atoms, and the space occupied by their print names, are
subject to garbage collection when the number of atoms has reached a
certain threshold, under the control of the 'agc_margin' Prolog flag, or
when the atom garbage collector is called explicitly.  The atom garbage
collector will find all references to atoms from the Prolog specific
memory areas, including SP_term_refs and arguments passed from Prolog to
foreign language functions.  However, atoms created by
'SP_atom_from_string()' and merely stored in a local variable are
endangered by garbage collection.  The functions 'SP_register_atom()'
and 'SP_unregister_atom()' make it possible to protect an atom while it
is in use.  The operations are implemented using reference counters to
support multiple, independent use of the same atom in different foreign
resources.


File: sicstus.info,  Node: Creating Prolog Terms,  Next: Accessing Prolog Terms,  Prev: Atoms in C,  Up: Support Functions

6.4.3 Creating Prolog Terms
---------------------------

The following functions create a term and store it as the value of an
SP_term_ref, which must exist prior to the call.  They return zero if
the conversion fails (as far as failure can be detected), and a nonzero
value otherwise, assigning to 't' the converted value.

'SP_put_variable()'
     Creates a variable.
'SP_put_integer()'
     Creates an integer.
'SP_put_float()'
     Creates a float.
'SP_put_atom()'
     Creates an atom.
'SP_put_string()'
     Creates an atom.
'SP_put_address()'
     Creates an integer representing a pointer.
'SP_put_list_codes()'
     Creates a char-list.
'SP_put_list_n_codes()'
     Creates a char-list.
'SP_put_list_n_bytes()'
     Creates a byte-list.
'SP_put_integer_bytes()'
     Creates an arbitrarily sized integer.
'SP_put_number_codes()'
     Creates a char-list denoting a number.
'SP_put_functor()'
     Creates a compound term.
'SP_put_list()'
     Creates a list.
'SP_cons_functor()'
     Creates a compound term with arguments filled in.
'SP_cons_list()'
     Creates a list with arguments filled in.
'SP_read_from_string() (C function)'
     Reads a term from its textual representation, replacing variables
     by specified terms.


File: sicstus.info,  Node: Accessing Prolog Terms,  Next: Testing Prolog Terms,  Prev: Creating Prolog Terms,  Up: Support Functions

6.4.4 Accessing Prolog Terms
----------------------------

The following functions will take an SP_term_ref and convert it to C
data.  They return zero if the conversion fails, and a nonzero value
otherwise, and store the C data in output arguments, except the last
two, which merely decompose compound terms.

'SP_get_integer()'
     Accesses an integer.
'SP_get_float()'
     Accesses a float.
'SP_get_atom()'
     Accesses an atom.
'SP_get_string()'
     Accesses an atom.
'SP_get_address()'
     Accesses an integer representing a pointer.
'SP_get_list_codes()'
     Accesses a code-list.
'SP_get_list_n_codes()'
     Accesses a code-list.
'SP_get_list_n_bytes()'
     Accesses a byte-list.
'SP_get_number_codes()'
     Accesses a code-list denoting a number.
'SP_get_integer_bytes()'
     Accesses an arbitrarily sized integer.
'SP_get_functor()'
     Accesses a compound term.
'SP_get_list()'
     Accesses a list.
'SP_get_arg()'
     Accesses an argument of a compound term.


File: sicstus.info,  Node: Testing Prolog Terms,  Next: Unifying and Comparing Terms,  Prev: Accessing Prolog Terms,  Up: Support Functions

6.4.5 Testing Prolog Terms
--------------------------

There is one general function for type testing of Prolog terms as well
as a set of specialized, more efficient, functions--one for each term
type:

'SP_term_type()'
     Accesses term type.
'SP_is_variable()'
     Checks whether term is a variable.
'SP_is_integer()'
     Checks whether term is an integer.
'SP_is_float()'
     Checks whether term is a float.
'SP_is_atom()'
     Checks whether term is an atom.
'SP_is_compound()'
     Checks whether term is compound.
'SP_is_list()'
     Checks whether term is a list cell.
'SP_is_atomic()'
     Checks whether term is atomic.
'SP_is_number()'
     Checks whether term is a number.


File: sicstus.info,  Node: Unifying and Comparing Terms,  Next: Operating System Services,  Prev: Testing Prolog Terms,  Up: Support Functions

6.4.6 Unifying and Comparing Terms
----------------------------------

The two functions are:

'SP_unify()'
     Unify terms.
'SP_compare()'
     Compare terms.


File: sicstus.info,  Node: Operating System Services,  Prev: Unifying and Comparing Terms,  Up: Support Functions

6.4.7 Operating System Services
-------------------------------

* Menu:

* OS Memory Management:: Memory Management
* OS File System:: File System
* OS Threads:: Threads


File: sicstus.info,  Node: OS Memory Management,  Next: OS File System,  Up: Operating System Services

6.4.7.1 Memory Management
.........................

The standard C library memory allocation functions ('malloc', 'calloc',
'realloc', and 'free') are available in foreign code, but cannot reuse
any free memory that SICStus Prolog's memory manager may have available,
and so may contribute to memory fragmentation.

   The following functions provide the same services via SICStus
Prolog's memory manager.

'SP_malloc()'
     Allocates a piece of memory.
'SP_calloc()'
     Allocates memory for an array of elements, and clears the allocated
     memory.
'SP_realloc()'
     Changes the size of an allocated piece of memory.
'SP_free()'
     Deallocates a piece of memory.
'SP_strdup()'
     Makes a copy of a string in allocated memory.


File: sicstus.info,  Node: OS File System,  Next: OS Threads,  Prev: OS Memory Management,  Up: Operating System Services

6.4.7.2 File System
...................

SICStus Prolog caches the name of the current working directory.  To
take advantage of the cache and to keep it consistent, foreign code
should call the following interface functions instead of calling
'chdir()' and 'getcwd()' directly:

'SP_set_current_dir()'
     Obtains the absolute name of the current working directory.
'SP_get_current_dir()'
     Sets the current working directory.


File: sicstus.info,  Node: OS Threads,  Prev: OS File System,  Up: Operating System Services

6.4.7.3 Threads
...............

When running more that one SICStus runtime in the same process it is
often necessary to protect data with mutual exclusion locks.  The
following functions implement recursive mutual exclusion locks, which
only need static initialization.

'SP_mutex_lock()'
     Locks the mutex.
'SP_mutex_unlock()'
     Unlocks the mutex.

   A (recursive) mutual exclusion lock is declared as type 'SP_mutex'.
It should be initialized to (the static initializer)
'SP_MUTEX_INITIALIZER' before use.

   Note that the SICStus runtime is not thread safe in general.

   A dynamic foreign resource that is used by multiple SICStus runtimes
in the same process may need to maintain a global state that is kept
separate for each SICStus runtime.  Each SICStus runtime maintains a
location (containing a 'void*') for each foreign resource.  By calling
'SP_foreign_stash()', a foreign resource can then access this location
to store any data that is specific to the calling SICStus runtime.


File: sicstus.info,  Node: Calling Prolog from C,  Next: SICStus Streams,  Prev: Support Functions,  Up: Mixing C and Prolog

6.5 Calling Prolog from C
=========================

In development and runtime systems alike, Prolog and C code may call
each other to arbitrary depths.

   Before calling a predicate from C you must look up the predicate
definition by module, name, and arity.  The function 'SP_predicate()'
will return a pointer to this definition or return 'NULL' if the
predicate is not visible in the module.  This definition can be used in
more than one call to the same predicate.

   The function 'SP_pred()' may be used as an alternative to the above.
The only difference is that the name and module arguments are passed as
Prolog atoms rather than strings, and the module argument is mandatory.
This saves the cost of looking up the two arguments in the Prolog symbol
table.  This cost dominates the cost of the operation.

* Menu:

* Finding One Solution of a Call:: Finding One Solution of a Call
* Finding Multiple Solutions of a Call:: Finding Multiple Solutions of a Call
* Backtracking Loops:: Backtracking Loops
* Calling Prolog Asynchronously:: Calling Prolog Asynchronously
* Exception Handling in C:: Exception Handling in C
* Reading a goal from a string:: Reading a goal from a string


File: sicstus.info,  Node: Finding One Solution of a Call,  Next: Finding Multiple Solutions of a Call,  Up: Calling Prolog from C

6.5.1 Finding One Solution of a Call
------------------------------------

The easiest way to call a predicate if you are only interested in the
first solution is to call the function 'SP_query()'.  It will create a
goal from the predicate definition and the arguments, call it, and
commit to the first solution found, if any.

   If you are only interested in the side-effects of a predicate, then
you can call 'SP_query_cut_fail()'.  It will try to prove the predicate,
cut away the rest of the solutions, and finally fail.  This will reclaim
any memory used after the call, and throw away any solution found.


File: sicstus.info,  Node: Finding Multiple Solutions of a Call,  Next: Backtracking Loops,  Prev: Finding One Solution of a Call,  Up: Calling Prolog from C

6.5.2 Finding Multiple Solutions of a Call
------------------------------------------

If you are interested in more than one solution, then a more complicated
scheme is used.  You find the predicate definition as above, but you do
not call the predicate directly.

  1. Set up a call with 'SP_open_query()'
  2. Call 'SP_next_solution()' to find a solution.  Call this predicate
     again to find more solutions if there are any.
  3. Terminate the call with 'SP_close_query()' or 'SP_cut_query()'

   The function 'SP_open_query()' will return an identifier of type
'SP_qid' that you use in successive calls.  Note that if a new query is
opened while another is already open, then the new query must be
terminated before exploring the solutions of the old one.  That is,
queries must be strictly nested.

   The function 'SP_next_solution()' will cause the Prolog engine to
backtrack over any current solution of an open query and look for a new
one.

   A query must be terminated in either of two ways.  The function
'SP_cut_query()' will discard the choices created since the
corresponding 'SP_open_query()', like the goal '!'.  The current
solution is retained in the arguments until backtracking into any
enclosing query.

   Alternatively, the function 'SP_close_query()' will discard the
choices created since the corresponding 'SP_open_query()', and then
backtrack into the query, throwing away any current solution, like the
goal '!, fail'.

   A simple way to call arbitrary Prolog code, whether for one solution
or for multiple solutions, is to use 'SP_read_from_string()' (*note
Creating Prolog Terms::) to create an argument to 'call/1'.  It is a
good idea to always explicitly specify the module context when using
'call/1' or other meta-predicates from C.

   It is important to understand the rules governing the scope of
SP_term_refs, and the terms they hold, in conjunction with calls from
Prolog to C and vice versa.  SP_term_refs are internally stored on a
stack, which is manipulated by the various API functions as follows:

'SP_new_term_ref()'
     The new SP_term_ref is pushed onto the stack.

_calling C from Prolog_
'SP_query()'
'SP_query_cut_fail()'
     The top of the stack is saved on call and restored upon return.

'SP_open_query()'
     The top of the stack is saved in the new query.

'SP_close_query()'
'SP_cut_query()'
'SP_next_solution()'
     The top of the stack is restored from the query argument.

   Among other things, this means that an SP_term_ref cannot be saved
across multiple calls from Prolog to C. Thus it makes no sense to
declare an SP_term_ref as a static C variable.

   Prolog terms are also generally stored on a stack, which keeps
growing until the execution backtracks, either spontaneously or by
calling 'SP_close_query()' or 'SP_next_solution()'.  It is an abuse of
the 'SP_open_query()' API to assign a term to an SP_term_ref, and then
backtrack over the term while the SP_term_ref is still live.  Such abuse
results in a dangling pointer that can potentially crash SICStus Prolog.
The API typically follows the pattern:

       ...
       SP_pred_ref pred = SP_predicate(...);
       SP_term_ref ref1 = SP_new_term_ref();
       SP_qid goal = SP_open_query(pred,ref1,...);
       /*
        * PART A: perform some initializations, and
        * loop through all solutions.
        */
       while (SP_next_solution(goal)==SP_SUCCESS) {
         /*
          * PART B: perform some action on the current solution.
          */
       }

       SP_close_query(goal);
       ...

   In order to avoid dangling pointer hazards, we recommend some simple
coding rules:

PART A
     In this part of the code, do not call 'SP_new_term_ref()' or the
     functions in *note Creating Prolog Terms:: at all.

PART B
     In this part of the code, do not call 'SP_new_term_ref()' except to
     initialize any SP_term_refs declared locally to Part B. Do Not call
     the functions in *note Creating Prolog Terms::, except to set
     SP_term_refs declared locally to Part B.


File: sicstus.info,  Node: Backtracking Loops,  Next: Calling Prolog Asynchronously,  Prev: Finding Multiple Solutions of a Call,  Up: Calling Prolog from C

6.5.3 Backtracking Loops
------------------------

If you want to call Prolog multiple times in a loop for side-effect, for
example over the elements of a list, then some care is required in order
not to cause a memory leak by creating more and more SP_term_refs.  The
recommended coding scheme is to use a backtracking loop (*note
Terminating a Backtracking Loop::).  For example, suppose that you want
the C equivalent of the following code:

     process_list(L) :-
             member(X, L),
             once(process(X)),
             fail.
     process_list(_).

     process(X) :- ...

   That can be encoded as follows, where 'refL' is the SP_term_ref that
holds 'L':

       ...
       SP_qid goal;
       SP_pred_ref member2 = SP_predicate("member", 2, "user");
       SP_pred_ref process1 = SP_predicate("process", 1, "user");
       SP_term_ref refX = SP_new_term_ref();
       SP_put_variable(refX);
       goal = SP_open_query(member2, refX, refL);
       while (SP_next_solution(goal)==SP_SUCCESS)
         SP_query_cut_fail(process1, refX);
       SP_close_query(goal);
       ...

   This programming style is particularly relevant in a stand-alone
executable, where the top level iterates over some transactions to be
processed.


File: sicstus.info,  Node: Calling Prolog Asynchronously,  Next: Exception Handling in C,  Prev: Backtracking Loops,  Up: Calling Prolog from C

6.5.4 Calling Prolog Asynchronously
-----------------------------------

* Menu:

* Signal Handling:: Signal Handling

If you wish to call Prolog back from a signal handler or a thread other
than the thread that called 'SP_initialize()', that is, the "main
thread", then you cannot use 'SP_query()' etc. directly.  The call to
Prolog has to be delayed until such time that the Prolog execution can
accept an interrupt and the call has to be performed from the main
thread (the Prolog execution thread).  The function 'SP_event()' serves
this purpose, and installs the function 'func' to be called from Prolog
(in the main thread) when the execution can accept a callback.

   A queue of functions, with corresponding arguments, is maintained;
that is, if several calls to 'SP_event()' occur before Prolog can accept
an interrupt, then the functions are queued and executed in turn at the
next possible opportunity.  A 'func' installed with 'SP_event()' will
not be called until SICStus is actually running.  One way of ensuring
that all pending functions installed with 'SP_event()' are run is to
call, from the main thread, some dummy goal, such as,
'SP_query_cut_fail(SP_predicate("true",0,"user"))'.

   While 'SP_event()' is safe to call from any thread, it is not safe to
call from arbitrary signal handlers.  If you want to call 'SP_event()'
when a signal is delivered, then you need to install your signal handler
with 'SP_signal()' (see below).

   Note that 'SP_event()' is one of the _very_ few functions in the
SICStus API that can safely be called from another thread than the main
thread.


File: sicstus.info,  Node: Signal Handling,  Up: Calling Prolog Asynchronously

6.5.4.1 Signal Handling
.......................

As noted above it is not possible to call e.g. 'SP_query()' or even
'SP_event()' from an arbitrary signal handler.  That is, from signal
handlers installed with 'signal' or 'sigaction'.  Instead you need to
install the signal handler using 'SP_signal()'.

   When the OS delivers a signal 'sig' for which
'SP_signal(sig,func,user_data)' has been called SICStus will _not_ call
'func' immediately.  Instead the call to 'func' will be delayed until it
is safe for Prolog to do so, in much the same way that functions
installed by 'SP_event()' are handled (this is an incompatible change as
of release 3.9).

   Since the signal handling function 'func' will not be called
immediately upon delivery of the signal to the process it only makes
sense to use 'SP_signal()' to handle certain asynchronous signals such
as 'SIGINT', 'SIGUSR1', 'SIGUSR2'.  Other asynchronous signals handled
specially by the OS, such as 'SIGCHLD' are not suitable for handling via
'SP_signal()'.  Note that the development system installs a handler for
'SIGINT', and, under Windows, 'SIGBREAK', to catch keyboard interrupts.
As of release 4.4, 'library(timeout)' no longer uses any signals.

   When 'func' is called, it cannot call any SICStus API functions
except 'SP_event()'.  Note that 'func' will be called in the main
thread.


File: sicstus.info,  Node: Exception Handling in C,  Next: Reading a goal from a string,  Prev: Calling Prolog Asynchronously,  Up: Calling Prolog from C

6.5.5 Exception Handling in C
-----------------------------

When an exception has been raised, the functions 'SP_query()',
'SP_query_cut_fail()' and 'SP_next_solution()' return 'SP_ERROR'.  To
access the "exception term" (the argument of the call to
'raise_exception/1'), which is asserted when the exception is raised,
the function 'SP_exception_term()' is used.  As a side-effect, the
exception term is retracted, so if your code wants to pass the exception
term back to Prolog, then use 'SP_raise_exception()'.

   To raise an exception from a C function called from Prolog, just call
'SP_raise_exception()'.  Upon return, Prolog will detect that an
exception has been raised, any value returned from the function will be
ignored, and the exception will be passed back to Prolog.  *Please
note*: this should only be called right before returning to Prolog.

   To propagate failure to Prolog, call 'SP_fail()'.  Upon return,
Prolog will backtrack.  *Please note*: this should only be called right
before returning to Prolog.

   Prolog error handling is mostly done by raising and catching
exceptions.  However, some "faults" are of a nature such that when they
occur, the internal program state may be corrupted, and it is not safe
to merely raise an exception.  In runtime systems, the C macro
'SP_on_fault()' provides an environment for handling faults.

   The function 'SP_raise_fault()' can be used to raise a fault with an
encoded string explaining the reason.


File: sicstus.info,  Node: Reading a goal from a string,  Prev: Exception Handling in C,  Up: Calling Prolog from C

6.5.6 Reading a goal from a string
----------------------------------

A simple way to call arbitrary Prolog code is to use
'SP_read_from_string()' (*note Creating Prolog Terms::) to create an
argument to 'call/1'.  It is a good idea to always explicitly specify
the module context when using 'call/1' or other meta-predicates from C.

   This example calls a compound goal (without error checking):
     SP_pred_ref call_pred = SP_predicate("call", 1, "prolog");
     SP_term_ref x = SP_new_term_ref();
     SP_term_ref goal = SP_new_term_ref();
     SP_term_ref vals[] = {x, 0 /* zero termination */};
     SP_integer len;

     SP_put_variable(x);
     /* The X=_ is a trick to ensure that X is the first variable
        in the depth-first order and thus corresponds to vals[0] (x).
        There are no entries in vals for _,L1,L2.
     */
     SP_read_from_string(goal,
        "user:(X=_, length([0,1,2],L1), length([3,4],L2), X is L1+L2).", vals);

     SP_query(call_pred, goal);
     SP_get_integer(x, &len);
     /* here len is 5 */


File: sicstus.info,  Node: SICStus Streams,  Next: Stand-Alone Executables,  Prev: Calling Prolog from C,  Up: Mixing C and Prolog

6.6 SICStus Streams
===================

With the SICStus Prolog C interface, the user can define his/her own
streams as well as from C read or write on the predefined streams.  The
stream interface provides:

   * C functions to perform I/O on Prolog streams.  This way you can use
     the same stream from Prolog and C code.

   * User defined streams.  You can define your own Prolog streams in C.

   * Bidirectional streams.  A SICStus stream supports reading or
     writing or both.

   * Hookable standard input/output/error streams.

* Menu:

* Prolog Streams:: Prolog Streams
* Defining a New Stream:: Defining a New Stream
* Hookable Standard Streams:: Hookable Standard Streams


File: sicstus.info,  Node: Prolog Streams,  Next: Defining a New Stream,  Up: SICStus Streams

6.6.1 Prolog Streams
--------------------

From the Prolog level there is a unique number that identifies a stream.
This identifier can be converted from/to a Prolog stream:

'stream_code(?STREAM,?STREAMCODE)'

     STREAMCODE is the C stream identifier (an integer) corresponding to
     the Prolog stream STREAM.  This predicate is only useful when
     streams are passed between Prolog and C. *Note
     mpg-ref-stream_code::.

   The 'STREAMCODE' is a Prolog integer representing an 'SP_stream *'
pointer.

   To read or write on a Prolog stream from C, the following functions
and macros can be used:
'SP_get_byte()'
     Read one byte from a binary stream.
'SP_get_code()'
     Read one character code from a text stream.
'SP_put_byte()'
     Write one byte to a binary stream.
'SP_put_code()'
     Write one character code to a text stream.
'SP_put_bytes()'
     Write multiple bytes to a binary stream.
'SP_put_codes()'
     Write multiple character codes to a text stream.
'SP_put_encoded_string()'
     Write a 'NUL' terminated encoded string to a text stream.

'SP_printf()'
'SP_fprintf()'
     Perform formatted output.
'SP_flush_output()'
     Flush buffered data of an output stream.
'SP_fclose()'
     Close a stream.

   The following predefined streams are accessible from C:

'SP_stdin'
     Standard input.  Refers to the same stream as 'user_input' in
     Prolog.  Which stream is referenced by 'user_input' is controlled
     by the Prolog flag 'user_input'.

'SP_stdout'
     Standard output.  Refers to the same stream as 'user_output' in
     Prolog.  Which stream is referenced by 'user_output' is controlled
     by the Prolog flag 'user_output'.

'SP_stderr'
     Standard error.  Refers to the same stream as 'user_error' in
     Prolog.  Which stream is referenced by 'user_error' is controlled
     by the flag 'user_error'.

'SP_curin'
     Current input.  It is initially set equal to 'SP_stdin'.  It can be
     changed with the predicates 'see/1' and 'set_input/1'.

'SP_curout'
     Current output.  It is initially set equal to 'SP_stdout'.  It can
     be changed with the predicates 'tell/1' and 'set_output/1'.

   Note that these variables are read only.


File: sicstus.info,  Node: Defining a New Stream,  Next: Hookable Standard Streams,  Prev: Prolog Streams,  Up: SICStus Streams

6.6.2 Defining a New Stream
---------------------------

The following steps are required to define a new stream in C:

   * Define low level functions (byte or character reading, writing
     etc).

   * Initialize and open your stream.

   * Allocate memory needed for your particular stream.

   * Initialize and install a Prolog stream with 'SP_create_stream()'.

   The following sample makes it possible to create read-only binary
streams that use the C 'FILE*' API.

     #include <sicstus/sicstus.h>
     #include <stdio.h>
     #include <string.h>
     #include <errno.h>

     struct stdio_t_stream {
       FILE *f;
     };
     typedef struct stdio_t_stream stdio_t_stream;

     static spio_t_error_code SPCDECL stdio_read(void *user_data,
                                                 void *buf,
                                                 size_t *pbuf_size,
                                                 spio_t_bits read_options)
     {
       spio_t_error_code ecode = SPIO_E_ERROR;
       stdio_t_stream *s;
       size_t res;

       if (read_options & SPIO_DEVICE_READ_OPTION_NONBLOCKING) {
         ecode = SPIO_E_NOT_SUPPORTED;
         goto barf;
       }

       s = (stdio_t_stream *)user_data;

       res = fread(buf, 1, *pbuf_size, s->f);
       if (res == 0) {                 /* error */
         if (feof(s->f)) {
           ecode = SPIO_E_END_OF_FILE;
         } else {                      /* some other error */
           ecode = SPIO_E_OS_ERROR;
         }
         goto barf;
       }
       *pbuf_size = res;             /* number of bytes read */

       return SPIO_S_NOERR;

      barf:
       return ecode;
     }

     static spio_t_error_code SPCDECL stdio_close(void **puser_data, spio_t_bits close_options)
     {
       stdio_t_stream *s;

       s = (stdio_t_stream *)*puser_data;
       /* we can ignore SPIO_DEVICE_CLOSE_OPTION_FORCE */

       if (close_options & SPIO_DEVICE_CLOSE_OPTION_READ) {
         *puser_data = NULL;       /* tell caller we are gone */
         if (fclose(s->f) != 0) {
           ;          /* ignore errors */
         }
       }
       return SPIO_S_NOERR;
     }

     /* Identify our streams with (an arbitrary) pointer that is unique to us */
     #define STDIO_STREAM_CLASS ((void*)&stdio_open_c)

     int stdio_open_c(char const *path,
                      char const *direction,
                      SP_stream **pstream)
     {
       spio_t_error_code ecode = SPIO_E_ERROR;
       stdio_t_stream *s = NULL;
       SP_stream *stream = NULL;

       if (strcmp(direction, "read") != 0) goto not_supported;

       /* read */
       s = (stdio_t_stream*)SP_malloc(sizeof *s);
       if (s == NULL) goto out_of_memory;

       /* open binary */
       s->f = fopen(path, "rb");
       if (s->f == NULL) {
         ecode = SPIO_E_OPEN_ERROR;
         goto barf;
       }
       ecode = SP_create_stream((void*)s,
                                STDIO_STREAM_CLASS,
                                stdio_read,
                                NULL, /* write */ NULL, /* flush_output */ NULL, /* seek */
                                stdio_close,
                                NULL, /* interrupt */ NULL, /* ioctl */ NULL, /* args */
                                SP_CREATE_STREAM_OPTION_BINARY,
                                &stream);
       if (SPIO_FAILED(ecode)) goto barf;

       *pstream = stream;
       return 0;                     /* success */

      barf:
       if (s != NULL) {
         if (s->f != NULL) fclose(s->f);
         SP_free(s);
       }
       return ecode;
      out_of_memory:
       ecode = SPIO_E_OUT_OF_MEMORY;
       goto barf;
      not_supported:
       ecode = SPIO_E_NOT_IMPLEMENTED;
       goto barf;
     }

   Calling 'stdio_open_c("foo", "read", &stream)' will open the file
'foo' as binary stream that can be read by all SICStus stream
operations.

   There are several stream implementions in the SICStus Prolog library
that can serve as sample, e.g. 'library(codesio)' and 'library(tcltk)'.

   *Note cpg-ref-SP_create_stream::.  for details.

* Menu:

* Low Level I/O Functions:: Low Level I/O Functions


File: sicstus.info,  Node: Low Level I/O Functions,  Up: Defining a New Stream

6.6.2.1 Low Level I/O Functions
...............................

For each new stream the appropriate low level I/O functions have to be
defined.  Error handling, prompt handling and character counting is
handled in a layer above these functions.  They all operate on a user
defined private data structure specified when the stream is created.

USER_READ()
     Should fill a buffer with data available from the stream.  *Note
     cpg-ref-user_read::.

USER_WRITE()
     Should write data from a buffer to the stream.  *Note
     cpg-ref-user_write::.

USER_FLUSH_OUTPUT()
     Should flush the (output) stream.

USER_CLOSE()
     Should close the stream in the specified directions.  Note that
     bi-directional streams can be closed one direction at a time.

   *Please note:* A foreign resource that defines user defined streams
must ensure that all its streams are closed when the foreign resource is
unloaded.  Failure to do this will lead to crashes when SICStus tries to
close the stream using a 'user_close' method that is no longer present.

   The easiest way to ensure that all user defined streams of a
particular class is closed is to use 'SP_fclose' with the
'SP_FCLOSE_OPTION_USER_STREAMS'.  Another way is to use 'SP_next_stream'
and 'SP_get_stream_user_data' to find all your streams and close them
one by one.  *Note cpg-ref-SP_fclose::, *note cpg-ref-SP_next_stream::
and *note cpg-ref-SP_get_stream_user_data::.


File: sicstus.info,  Node: Hookable Standard Streams,  Prev: Defining a New Stream,  Up: SICStus Streams

6.6.3 Hookable Standard Streams
-------------------------------

The standard I/O streams (input, output, and error) are hookable, i.e.
the streams can be redefined by the user by calling
'SP_set_user_stream_hook()' and/or 'SP_set_user_stream_post_hook()'.
These hook functions must be called before 'SP_initialize()' (*note
Initializing the Prolog Engine::).  In custom built systems, they may be
called in the hook function 'SU_initialize()'.  *Note The Application
Builder::.

* Menu:

* Writing User-stream Hooks:: Writing User-stream Hooks
* Writing User-stream Post-hooks:: Writing User-stream Post-hooks


File: sicstus.info,  Node: Writing User-stream Hooks,  Next: Writing User-stream Post-hooks,  Up: Hookable Standard Streams

6.6.3.1 Writing User-stream Hooks
.................................

The user-stream hook is, if defined, called during 'SP_initialize()'.
It has the following prototype:

     SP_stream *user_stream_hook(void *user_data, int which)

   If the hook is not defined, then SICStus will attempt to open the
standard TTY/console versions of these streams.  If they are unavailable
(such as for non-console executables under Windows), then the result is
undefined.

   It is called once for each stream.  The 'which' argument indicates
which stream it is called for.  The value of 'which' is one of the
following:

'SP_STREAMHOOK_STDIN'
     Create stream for standard input.
'SP_STREAMHOOK_STDOUT'
     Create stream for standard output.
'SP_STREAMHOOK_STDERR'
     Create stream for standard error.

   The set of possible values for 'which' may be expanded in the future.

   The hook should return a standard SICStus I/O stream, as described in
*note Defining a New Stream::.

   *Note cpg-ref-SP_set_user_stream_hook::.  for details.


File: sicstus.info,  Node: Writing User-stream Post-hooks,  Prev: Writing User-stream Hooks,  Up: Hookable Standard Streams

6.6.3.2 Writing User-stream Post-hooks
......................................

If defined, then the user-stream post-hook is called after all the
streams have been defined, once for each of the standard streams.  It
has a slightly different prototype:

     void user_stream_post_hook(void *user_data, int which, SP_stream *str)

where 'str' is a pointer to the corresponding 'SP_stream' structure.
There are no requirements as to what this hook must do; the default
behavior is to do nothing at all.

   The post-hook is intended to be used to do things that may require
that all streams have been created.

   *Note cpg-ref-SP_set_user_stream_post_hook::.  for details.


File: sicstus.info,  Node: Stand-Alone Executables,  Next: Mixing C and Prolog Examples,  Prev: SICStus Streams,  Up: Mixing C and Prolog

6.7 Stand-Alone Executables
===========================

So far, we have only discussed foreign code as pieces of code loaded
into a Prolog executable.  This is often not the desired situation.
Instead, one often wants to create "stand-alone executables", i.e. an
application where Prolog is used as a component, accessed through the
API described in the previous sections.

* Menu:

* Runtime Systems:: Runtime Systems
* Runtime Systems on Target Machines:: Runtime Systems on Target Machines
* The Application Builder:: The Application Builder
* User-defined Main Programs:: User-defined Main Programs
* Generic Runtime Systems:: Generic Runtime Systems


File: sicstus.info,  Node: Runtime Systems,  Next: Runtime Systems on Target Machines,  Up: Stand-Alone Executables

6.7.1 Runtime Systems
---------------------

Stand-alone applications containing debugged Prolog code and destined
for end-users are typically packaged as runtime systems.  No SICStus
license is needed by a runtime system.  A runtime system has the
following limitations:

   * No top-level.  The executable will restore a saved-state and/or
     load code, and call 'user:runtime_entry(start)'.  Alternatively,
     you may supply a main program and explicitly initialize the Prolog
     engine with 'SP_initialize()'.  'break/0' and 'require/1' are
     unavailable.

   * No debugger.  'debugging', 'debug' and 'debugger_print_options'
     have no effect.  Predicates annotated as "[development]" in the
     reference pages are unavailable.

   * Except in extended runtime systems: no compiler; compiling is
     replaced by consulting.  Extended runtime systems do provide the
     compiler.

   * The 'discontiguous_warnings', 'single_var_warnings',
     'redefine_warnings', and 'informational' Prolog flags are off by
     default, suppressing warnings about clauses not being together,
     singleton variables, queries and warnings about name clashes and
     redefinitions, and informational messages.  Note that they can be
     switched on though, to enable such warnings, queries and messages.

   * No profiler or coverage analysis.  The predicates
     'profile_reset/0', 'profile_data/1', 'print_profile/[0,1]'
     'coverage_data/1', and 'print_coverage/[0,1]' are unavailable.  The
     Prolog flag 'profiling' is unavailable.

   * No signal handling except as installed by 'SP_signal()'.

   It is possible to tell a runtime system to start a development system
instead, for debugging purposes.  *Note Debugging Runtime Systems::.
for details.


File: sicstus.info,  Node: Runtime Systems on Target Machines,  Next: The Application Builder,  Prev: Runtime Systems,  Up: Stand-Alone Executables

6.7.2 Runtime Systems on Target Machines
----------------------------------------

When a runtime system is delivered to the end user, chances are that the
user does not have an existing SICStus installation.  To deliver such an
executable, you need:

the executable
     This is your executable program, usually created by 'spld' (*note
     The Application Builder::).

the runtime kernel
     This is a shared object or a DLL, usually 'libsprt4-4-1.so' under
     UNIX, or 'sprt4-4-1.dll' under Windows.

the (extended) runtime library
     The saved-state 'sprt.sav' contains the built-in predicates written
     in Prolog.  It is restored into the program at runtime by the
     function 'SP_initialize()'.  Extended runtime systems restore
     'spre.sav' instead, which requires a license, available from SICS
     as an add-on product.  See also *note Managing Extended Runtime
     License Information: (relnotes)REX.

your Prolog code
     As a saved-state, '.po' files, or source code ('.pl' files).  They
     must be explicitly loaded by the program at runtime (*note Loading
     Prolog Code::).

your linked foreign resources
     Any dynamically linked foreign resources, including any linked
     foreign resources for library modules located in
     '$SP_PATH/library'.

   The following two sections describe how to package the above
components for UNIX and Windows "target machines", i.e. machines that do
not have SICStus Prolog installed, respectively.  It is also possible to
package all the above components into a single executable file, an
all-in-one executable.  *Note All-in-one Executables::.

* Menu:

* Runtime Systems on UNIX Target Machines:: Runtime Systems on UNIX Target Machines
* Runtime Systems on Windows Target Machines:: Runtime Systems on Windows Target Machines


File: sicstus.info,  Node: Runtime Systems on UNIX Target Machines,  Next: Runtime Systems on Windows Target Machines,  Up: Runtime Systems on Target Machines

6.7.2.1 Runtime Systems on UNIX Target Machines
...............................................

In order to build a runtime system for distribution on a target machine,
the option '--moveable' must be passed to 'spld'.  This option prevents
'spld' from hardcoding any (absolute) paths into the executable.  As of
release 4.2, '--moveable' is the default on most platforms, including
Linux, Mac OS X and Solaris.

   Next, in order for SICStus to be able to locate all relevant files,
the following directory structure should be used.

     myapp.exe
     sp-4.4.1/
     +--- libsprt4-4-1.so
     +--- sicstus-4.4.1/
          +--- bin/
          |    +--- sprt.sav
          +--- library/
               +--- <files from $SP_PATH/library>

   If support for multiple SICStus instances is needed, then the
runtimes named e.g. 'libsprt4-4-1_instance_01_.so' need to be available
as well, in the same place as 'libsprt4-4-1.so'.

   If SICStus Prolog is installed on the target machine, then a symbolic
link named 'sp-4.4.1' can be used, in which case it should point to the
directory of the SICStus installation that contains the
'libsprt4-4-1.so' (or equivalent).

   If the runtime system needs to be debugged, then the above file
system layout should be complemented as follows: The file 'spds.sav'
from the development system should be copied and placed in the same
folder as 'sprt.sav' and the license information must be made available.
*Note Debugging Runtime Systems::.  for details.

   'myapp.exe' is typically created by a call to 'spld':

     % spld --main=user --moveable [...] -o ./myapp.exe

   On most platforms, the above directory layout will enable the
executable to find the SICStus runtime (e.q., 'libsprt4-4-1.so') as well
as the boot file 'sprt.sav' ('spre.sav').  In addition, application
specific files, e.g. a '.sav' file, can be found using the automatically
set system properties 'SP_APP_DIR' or 'SP_RT_DIR'.  On some platforms a
wrapper script, generated by 'spld', is needed to ensure that the files
are found.

   Unless the '--static' option is passed to 'spld', it might also be
necessary to set 'LD_LIBRARY_PATH' (or equivalent) to '/home/joe/lib'
(in the example above) in order for the dynamic linker to find
'libsprt4-4-1.so'.  If the '--static' option is used, then this is not
necessary.  Setting 'LD_LIBRARY_PATH' is not recommended unless it is
really needed.

   When a runtime system is redistributed to third parties, only the
following files may be included in the distribution.  All filenames are
relative to '<prefix>/lib/sicstus-4.4.1':

'../*.{a,so,sl,dylib}'
'bin/sprt.sav'
'bin/spre.sav'
'bin/jasper.jar'
'bin/prologbeans.jar'
'library/*.{tcl,po,pl}'
     Except 'license.pl'!
'library/*/*.{s.o,so,sl,dylib}'
'library/*/*.{po,pl}'
'sp_platform'
     (Located with 'InstallSICStus')

   *Please note*: you cannot redistribute 'spds.sav' or 'license.pl'.


File: sicstus.info,  Node: Runtime Systems on Windows Target Machines,  Prev: Runtime Systems on UNIX Target Machines,  Up: Runtime Systems on Target Machines

6.7.2.2 Runtime Systems on Windows Target Machines
..................................................

In order to locate all relevant files, the following directory structure
should be used:

     myapp.exe
     sprt4-4-1.dll
     sp-4.4.1\
     +--- bin\
     |    +--- sprt.sav
     +--- library\
          +--- <files from %SP_PATH%\library>

   If support for multiple SICStus instances is needed, then the
runtimes named e.g. 'sprt4-4-1_instance_01_.dll' need to be available as
well, in the same place as 'sprt4-4-1.dll'.

   If the runtime system needs to be debugged, then the above file
system layout should be complemented as follows: The file 'spds.sav'
from the development system should be copied and placed in the same
folder as 'sprt.sav' and the license information must be made available.
*Note Debugging Runtime Systems::.  for details.

   'myapp.exe' is typically created by a call to 'spld':

     % spld --main=user [...] -o ./myapp.exe

   If the directory containing 'sprt4-4-1.dll' contains a directory
called 'sp-4.4.1', then SICStus assumes that it is part of a runtime
system as described in the picture below.  The (extended) runtime
library, 'sprt.sav' ('spre.sav'), is then looked up in the directory
('sp-4.4.1/bin'), as in the picture.  Furthermore, the initial
'library_directory/1' fact will be set to the same directory with
'sp-4.4.1/library' appended.

   The directory structure under 'library/' should look like in a
regularly installed SICStus, including the platform-specific
subdirectory ('x86-win32-nt-4' in this case).  If your application needs
to use 'library(timeout)'(1) and 'library(random)', then your directory
structure may look like:

     myapp.exe
     sprt4-4-1.dll
     sp-4.4.1\
     +--- bin\
     |    +--- sprt.sav
     +--- library\
          +--- random.po
          +--- timeout.po
          +--- x86-win32-nt-4 \
               +--- random.dll

   The 'sp*' files can also be put somewhere else in order to be shared
by several applications provided the 'sprt4-4-1.dll' can be located by
the DLL search.

   Naming the files with version number enables applications using
different SICStus versions to install the 'sp*' files in the same
directory.

   When a runtime system is redistributed to third parties, only the
following files may be included in the distribution.  All filenames are
relative to '%SP_PATH%':

'bin\sprt.sav'
'bin\spre.sav'
'bin\jasper.jar'
'bin\prologbeans.jar'
'bin\*.dll'
'bin\*.po'
'library\*.{tcl,po,pl,bas}'
     Except 'license.pl'!
'library\*\*.dll'
'library\*\*.{po,pl}'

   *Please note*: you cannot redistribute 'spds.sav' or 'license.pl'.

   ---------- Footnotes ----------

   (1) Prior to release 4.4, 'library(timeout)' also used a foreign
resource.  This is no longer the case.


File: sicstus.info,  Node: The Application Builder,  Next: User-defined Main Programs,  Prev: Runtime Systems on Target Machines,  Up: Stand-Alone Executables

6.7.3 The Application Builder
-----------------------------

* Menu:

* Customizing spld:: Customizing spld
* All-in-one Executables:: All-in-one Executables
* Setting up the C compiler on Windows:: Setting up the C compiler on Windows
* Extended Runtime Systems:: Extended Runtime Systems
* spld Examples:: Examples

The application builder, 'spld', is used for creating stand-alone
executables.  'spld' takes the files specified on the command line and
combines them into an executable file, much like the UNIX 'ld' or the
Windows 'link' commands.

   Note that no pathnames passed to 'spld' should contain spaces.  Under
Windows, this can be avoided by using the short version of pathnames as
necessary.

   *Note too-spld::.  for detailed information about 'spld' options etc.


File: sicstus.info,  Node: Customizing spld,  Next: All-in-one Executables,  Up: The Application Builder

6.7.3.1 Customizing 'spld'
..........................

The 'spld' tool reads a configuration file at start-up that contains
default values for many configurable parameters.  It is sometimes useful
to modify these in order to adapt to local variations.

   The following methods can be used also with the 'splfr' command,
*note The Foreign Resource Linker::.

   There are two methods
   * Override some parameters with '--conf' VAR=VALUE.

     This is useful when only a few parameters need to be changed, e.g.
     the C compiler.  You can override multiple parameters by specified
     '--conf' more than once.

     For instance, to use a non-default C compiler you can pass '--conf
     CC=/home/joe/bin/mycc'.

     The option '--conf' was introduced in release 4.0.3.

   * Use a modified configuration file with '--config'=FILE.

     It may sometimes be convenient to use a separate, possibly
     modified, configuration file.  This should seldom be needed, use
     '--conf' instead.

     To use a modified configuration file, follow these instructions:

       1. Locate the configuration file 'spconfig-VERSION'.  It should
          be located in the same directory as 'spld'.
       2. Make a copy for 'spconfig-VERSION'; let us call it
          'hacked_spld.config'.  Do Not edit the original file.
       3. The configuration file contains lines on the form 'CFLAGS=-g
          -O2'.  Edit these according to your needs.  Do Not add or
          remove any options.
       4. You may now use the modified 'spconfig-VERSION' together with
          'spld' like this:
               % spld [...] --config=/path/to/hacked_spld.config
       5. Replace '/path/to' with the actual path to the hacked
          configuration file.


File: sicstus.info,  Node: All-in-one Executables,  Next: Setting up the C compiler on Windows,  Prev: Customizing spld,  Up: The Application Builder

6.7.3.2 All-in-one Executables
..............................

It is possible to embed saved-states into an executable.  Together with
static linking, this gives an all-in-one executable, an executable that
does not depend on external SICStus files.

   In the simplest case, creating an all-in-one executable 'main.exe'
from a saved-state 'main.sav' can be done with a command like:
     % spld --output=main.exe --static main.sav

   This will automatically embed the saved-state, any foreign resources
needed by the saved-state as well the SICStus runtime and its runtime
saved-state.

   The keys to this feature are:
   * Static linking.  By linking an application with a static version of
     the SICStus runtime, you avoid any dependency on e.g.
     'sprt4-4-1.dll' (Windows) or 'libsprt4-4-1.so' (UNIX).

     If the application needs foreign resources (predicates written in C
     code), as used for example by 'library(random)' and
     'library(clpfd)', then these foreign resources can be linked
     statically with the application as well.

     The remaining component is the Prolog code itself; see the next
     item.

   * Data Resources (in-memory files).  It is possible to link an
     application with data resources that can be read directly from
     memory.  In particular, saved-states can be embedded in an
     application and used when restoring the saved-state of the
     application.

     An application needs two saved-states:
       1. The SICStus runtime system ('sprt.sav').

          This is added automatically when 'spld' is invoked with the
          '--static' (or '-S') option unless the 'spld'-option
          '--no-embed-rt-sav' is specified.  It can also be added
          explicitly with the option '--embed-rt-sav'.

       2. The user written code of the application as well as any
          SICStus libraries.

          This saved-state is typically created by loading all
          application code using 'compile/1' and then creating the
          saved-state with 'save_program/2'.

   Data resources are added by specifying their internal name and the
path to a file as part of the comma separated list of resources passed
with the 'spld' option '--resources'.  Each data resource is specified
as FILE=NAME where FILE is the path to the file containing the data (it
must exist during the call to 'spld') and NAME is the name used to
access the content of FILE during runtime.  A typical choice of NAME
would be the base name, i.e. without directories, of FILE, preceded by a
slash ('/').  NAME should begin with a slash ('/') and look like an
ordinary lowercase file path made up of '/'-separated, non-empty, names
consisting of 'a' to 'z', underscore ('_', period ('.'), and digits.

   Typically, you would use 'spld --main=restore', which will
automatically restore the first '.sav' argument.  To manually restore an
embedded saved-state you should use the syntax
'URL:x-sicstus-resource:NAME', e.g.
'SP_restore("URL:x-sicstus-resource:/main.sav")'.

   An example will make this clearer.  Suppose we create a runtime
system that consists of a single file 'main.pl' that looks like:
                                                            _% main.pl_
     :- use_module(library(random)).
     :- use_module(library(clpfd)).

     % This will be called when the application starts:
     user:runtime_entry(start) :-
        %% You may consider putting some other code here...
        write('hello world'),nl,
        write('Getting a random value:'),nl,
        random(1,10,R),                  % from random
        write(R),nl,
        ( all_different([3,9]) ->        % from clpfd
            write('3 != 9'),nl
        ; otherwise ->
            write('3 = 9!?'),nl
        ).

   Then create the saved-state 'main.sav', which will contain the
compiled code of 'main.pl' as well as the Prolog code of
'library(random)' and 'library(clpfd)' and other Prolog libraries needed
by 'library(clpfd)':

     % sicstus -i -f
     SICStus 4.4.1 ...
     Licensed to SICS
     | ?- compile(main).
     % compiling .../main.pl...
     % ... loading several library modules
     | ?- save_program('main.sav').
     % .../main.sav created in 201 msec

     | ?- halt.


   Finally, tell 'spld' to build an executable statically linked with
the SICStus runtime and the foreign resources needed by
'library(random)' and 'library(clpfd)'.  Also, embed the Prolog runtime
saved-state and the application specific saved-state just created.

   As noted above, it is possible to build the all-in-one executable
with the command line:
     % spld --output=main.exe --static main.sav
but for completeness the example below uses all options as if no options
were added automatically.

   The example is using Cygwin 'bash' (<http://www.cygwin.com>) under
Windows but would look much the same on other platforms.  The command
should be given on a single line; it is broken up here for better
layout:

     % spld
       --output=main.exe
       --static
       --embed-rt-sav
       --main=restore
       --resources=main.sav=/main.sav,clpfd,random

   The arguments are as follows:
'--output=main.exe'
     This tells 'spld' where to put the resulting executable.

'--static'
     Link statically with the SICStus runtime and foreign resources
     ('clpfd' and 'random', in this case).

'--embed-rt-sav'
     This option embeds the SICStus runtime '.sav' file ('sprt.sav').
     This option is not needed since it is added automatically by
     '--static'.

'--main=restore'
     Start the application by restoring the saved-state and calling
     'user:runtime_entry(start)'.  This is not strictly needed in the
     above example since it is the default if any file with extension
     '.sav' or a data resource with a _name_ where the extension is
     '.sav' is specified.

'--resources=...'

     This is followed by comma-separated resource specifications:

     'main.sav=/main.sav'
          This tells 'spld' to make the content (at the time 'spld' is
          invoked) of the file 'main.sav' available at runtime in a data
          resource named '/main.sav'.  That is, the data resource name
          corresponding to '"URL:x-sicstus-resource:/main.sav"'.

          Alternatively, 'spld' can create a default data resource
          specification when passed a '.sav' file argument and the
          option '--embed-sav-file' (which is the default with
          '--static').

     'clpfd'
     'random'
          These tell 'spld' to link with the foreign resources (that is,
          C-code) associated with 'library(clpfd)' and
          'library(random)'.  Since '--static' was specified the static
          versions of these foreign resources will be used.

          Alternatively, 'spld' can extract the information about the
          required foreign resources from the saved-state ('main.sav').
          This feature is enabled by adding the option
          '--resources-from-sav' (which is the default with '--static').
          Using '--resources-from-sav' instead of an explicit list of
          foreign resources is preferred since it is hard to know what
          foreign resources are used by the SICStus libraries.

     Since both '--embed-sav-file' and '--resources-from-sav' are the
     default when '--static' is used the example can be built simply by
     doing:
          % spld --output=main.exe --static main.sav

   Finally, we may run this executable on any machine, even if SICStus
is not installed:

     bash-2.04$ ./main.exe
     hello world
     Getting a random value:
     4
     3 != 9
     bash-2.04$


File: sicstus.info,  Node: Setting up the C compiler on Windows,  Next: Extended Runtime Systems,  Prev: All-in-one Executables,  Up: The Application Builder

6.7.3.3 Setting up the C compiler on Windows
............................................

'spld' (and 'splfr') are command line tools and need to have access to a
working C compiler and linker.  This is typically not a problem on
UNIX-like systems but on Windows there are some special steps needed in
order to set up the environment so that the C compiler can be used.

   The easiest way to get a command prompt where the C compiler works is
to open the 'Visual Studio 2005 Command Prompt' from the Start menu.  On
Windows Vista this is located under 'All Programs/Microsoft Visual
Studio 2005/Visual Studio Tools/'.  This opens up a command prompt where
'cl.exe' (the C compiler) can be found via the 'PATH' environment
variable.

   An alternative is to run the Visual Studio set up script from the
command prompt, something like:
     C:\>"C:\Program Files\Microsoft Visual Studio 8\VC\vcvarsall.bat" x86

   This is in fact what the 'Visual Studio 2005 Command Prompt' shortcut
does.

   Similar steps will work for other versions of Visual Studio.  Note
that there are different versions of SICStus Prolog for different
versions of Visual Studio.  This is necessary since each version of
Visual Studio comes with its own version of the C library.

   Once the environment is set up for using the C compiler you should be
able to use the 'spld' (and 'splfr') tools without problem.


File: sicstus.info,  Node: Extended Runtime Systems,  Next: spld Examples,  Prev: Setting up the C compiler on Windows,  Up: The Application Builder

6.7.3.4 Extended Runtime Systems
................................

An extended runtime system is a variant of a runtime system with
additional capabilities, including the presence of the Prolog compiler.
Extended runtime systems are created with 'spld' in a way similar to how
ordinary runtime systems are created.  An extended runtime system
requires a license; see *note Managing Extended Runtime License
Information: (relnotes)REX. for details about managing such license
information.


File: sicstus.info,  Node: spld Examples,  Prev: Extended Runtime Systems,  Up: The Application Builder

6.7.3.5 Examples
................

  1. The character-based SICStus development system executable
     ('sicstus') can be created using:

          % spld --main=prolog -o sicstus

     This will create a development system that is dynamically linked
     and has no prelinked foreign resources.

  2.      % spld --static -D --resources=random -o main

     This will create a statically linked executable called 'main' that
     has the resource 'random' prelinked (statically).

  3. An all-in-one executable with a home-built foreign resource.

     This example is similar to the example in *note All-in-one
     Executables::, with the addition of a foreign resource of our own.

                                                             _% bar.pl_
          :- use_module(library(random)).
          :- use_module(library(clpfd)).


          % This will be called when the application starts:
          user:runtime_entry(start) :-
             %% You may consider putting some other code here...
             write('hello world'),nl,
             write('Getting a random value:'),nl,
             random(1, 10, R),                % from random
             write(R),nl,
             ( all_different([3,9]) ->        % from clpfd
                 write('3 != 9'),nl
             ; otherwise ->
                 write('3 = 9!?'),nl
             ),
             '$pint'(4711).                   % from our own foreign resource 'bar'

          foreign(print_int, '$pint'(+integer)).
          foreign_resource(bar, [print_int]).
          :- load_foreign_resource(bar).

                                                          _/* bar.c */_
          #include <sicstus/sicstus.h>
          #include <stdio.h>
          /* bar_glue.h is generated by splfr from the foreign/[2,3] facts.
             Always include the glue header in your foreign resource code.
          */
          #include "bar_glue.h"

          extern void print_int(SP_integer a);

          void print_int(SP_integer a)
          {
            /* Note the use of SPRIdINTEGER to get a format specifier corresponding
               to the SP_integer type. For most platforms this corresponds
               to "ld" and long, respectively. */
            printf("a=%" SPRIdINTEGER "\n", (SP_integer)a);
          }

     To create the saved-state 'bar.sav' we will compile the file
     'bar.pl' and save it with 'save_program('bar.sav').' When compiling
     the file the directive ':- load_foreign_resource(bar).' is called
     so a dynamic foreign resource must be present.

     Thus, first we build a dynamic foreign resource.

          % splfr bar.c bar.pl

     Then, we create the saved-state.

          % sicstus --goal "compile(bar), save_program('bar.sav'), halt."

     We also need a static foreign resource to embed in our all-in-one
     executable.

          % splfr --static bar.c bar.pl

     Finally, we build the all-in-one executable with 'spld'.  We do not
     need to list the foreign resources needed.  'spld' will extract
     their names from the '.sav' file.  Adding the '--verbose' option
     will make 'spld' output lots of progress information, among which
     are the names of the foreign resources that are needed.  Look for
     "Found resource name" in the output.

          % spld --verbose --static --main=restore --respath=. --resources=bar.sav=/mystuff/bar.sav --output=bar

     In this case four foreign resource names are extracted from the
     '.sav' file: 'bar', 'clpfd', and 'random'.  The source file
     'bar.pl' loads the foreign resource named 'bar'.  It also uses the
     'library(random)' module, which loads the foreign resource named
     'random', and the 'library(clpfd)' module, which loads the foreign
     resource named 'clpfd'.

     By not listing foreign resources when running 'spld', we avoid the
     risk of omitting a required resource.


File: sicstus.info,  Node: User-defined Main Programs,  Next: Generic Runtime Systems,  Prev: The Application Builder,  Up: Stand-Alone Executables

6.7.4 User-defined Main Programs
--------------------------------

Runtime systems may or may not have an automatically generated main
program.  This is controlled by the '--main' option to 'spld'.  If
'--main=user' is given, then a function 'user_main()' must be supplied:

     int user_main(int argc, char *argv[])

   'user_main()' is responsible for initializing the Prolog engine,
loading code, and issuing any Prolog queries.  An alternative is to use
'--main=none' and write your own 'main()' function.

* Menu:

* Initializing the Prolog Engine:: Initializing the Prolog Engine
* Loading Prolog Code:: Loading Prolog Code


File: sicstus.info,  Node: Initializing the Prolog Engine,  Next: Loading Prolog Code,  Up: User-defined Main Programs

6.7.4.1 Initializing the Prolog Engine
......................................

The Prolog Engine is initialized by calling 'SP_initialize()'.  This
must be done before any interface functions are called, except those
marked 'preinit' in this manual.

   The function will allocate data areas used by Prolog and load the
Runtime Library.

   It will also initialize command line arguments so that they can be
accessed by the 'argv' Prolog flag but it may be preferable to use
'SP_set_argv()' for this.

   To unload the SICStus emulator, 'SP_deinitalize()' can be called.

   You may also call 'SP_force_interactive()' before calling
'SP_initialize()'.  This will force the I/O built-in predicates to treat
the standard streams as a interactive, even if they do not appear to be
connected to a terminal or console.  Same as the '-i' option in
development systems (*note Start::).

   You may also call 'SP_set_memalloc_hooks()' before calling
'SP_initialize()'.  This will define one layer of Prolog's memory
manager, in case your application has special requirements.

   The SICStus Prolog memory manager has a two-layer structure.  The top
layer has roughly the same functionality as the standard UNIX functions
'malloc' and 'free', whereas the bottom layer is an interface to the
operating system.  It is the bottom layer that can be customized by
setting these hooks.


File: sicstus.info,  Node: Loading Prolog Code,  Prev: Initializing the Prolog Engine,  Up: User-defined Main Programs

6.7.4.2 Loading Prolog Code
...........................

You can load your Prolog code with the call 'SP_load()'.  This is the C
equivalent of the Prolog predicate 'load_files/1'.

   Alternatively, you can restore a saved-state with the call
'SP_restore()', which is the C equivalent of the Prolog predicate
'restore/1'.


File: sicstus.info,  Node: Generic Runtime Systems,  Prev: User-defined Main Programs,  Up: Stand-Alone Executables

6.7.5 Generic Runtime Systems
-----------------------------

There are three ready-made runtime systems provided with the
distributions, 'sprt.exe', 'sprti.exe', and (only on Windows)
'sprtw.exe'.  These have been created using 'spld':

     $ spld --main=restore '$SP_APP_DIR/main.sav' -o sprt.exe
     $ spld --main=restore '$SP_APP_DIR/main.sav' -i -o sprti.exe
     $ spld --main=restore '$SP_APP_DIR/main.sav' --window -o sprtw.exe

   These are provided for users who do not have a C-compiler available.
Each program launches a runtime system by restoring the saved-state
'main.sav' (located in the same folder as the program).

   The saved-state is created by 'save_program/[1,2]'.  If it was
created by 'save_program/2', then the given startup goal is run.  Then,
'user:runtime_entry(start)' is run.  The program exits with 0 upon
normal temination and with 1 on failure or exception.

   The program 'sprti.exe' assumes that the standard streams are
connected to a terminal, even if they do not seem to be (useful under
Emacs, for example).  On Windows only, 'sprtw.exe' is a windowed
executable, corresponding to 'spwin.exe'.


File: sicstus.info,  Node: Mixing C and Prolog Examples,  Next: Debugging Runtime Systems,  Prev: Stand-Alone Executables,  Up: Mixing C and Prolog

6.8 Mixing C and Prolog Examples
================================

* Menu:

* Train Example:: Train Example (connections)
* Building for a Target Machine:: Building for a Target Machine
* Exceptions from C:: Exceptions from C
* Stream Example:: Stream Example


File: sicstus.info,  Node: Train Example,  Next: Building for a Target Machine,  Up: Mixing C and Prolog Examples

6.8.1 Train Example (connections)
---------------------------------

This is an example of how to create a runtime system.  The Prolog
program 'train.pl' will display a route from one train station to
another.  The C program 'train.c' calls the Prolog code and writes out
all the routes found between two stations:

                                                           _% train.pl_
     connected(From, From, [From], _):- !.
     connected(From, To, [From| Way], Been):-
             (   no_stop(From, Through)
             ;
                 no_stop(Through, From)
             ),
             not_been_before(Been, Through),
             connected(Through, To, Way, Been).

     no_stop('Stockholm', 'Katrineholm').
     no_stop('Stockholm', 'Vasteras').
     no_stop('Katrineholm', 'Hallsberg').
     no_stop('Katrineholm', 'Linkoping').
     no_stop('Hallsberg', 'Kumla').
     no_stop('Hallsberg', 'Goteborg').
     no_stop('Orebro', 'Vasteras').
     no_stop('Orebro', 'Kumla').

     not_been_before(Way, _) :- var(Way),!.
     not_been_before([Been| Way], Am) :-
             Been \== Am,
             not_been_before(Way, Am).

                                                        _/* train.c */_
     #include <stdio.h>
     #include <stdlib.h>
     #include <sicstus/sicstus.h>

     static void write_path(SP_term_ref path)
     {
       char const *text = NULL;
       SP_term_ref
         tail = SP_new_term_ref(),
         via = SP_new_term_ref();

       SP_put_term(tail,path);

       while (SP_get_list(tail,via,tail)) {
         if (text)
           printf(" -> ");

         SP_get_string(via, &text);
         printf("%s",text);
       }
       printf("\n");
     }

     int user_main(int argc, char **argv)
     {
       int rval;
       SP_pred_ref pred;
       SP_qid goal;
       SP_term_ref from, to, path;

       /* Initialize Prolog engine. The third arg to SP_initialize is
          an option block and can be NULL, for default options. */
       if (SP_FAILURE == SP_initialize(argc, argv, NULL)) {
         fprintf(stderr, "SP_initialize failed: %s\n",
                 SP_error_message(SP_errno));
         exit(1);
       }

       rval = SP_restore("train.sav");

       if (rval == SP_ERROR || rval == SP_FAILURE) {
         fprintf(stderr, "Could not restore \"train.sav\".\n");
         exit(1);
       }
                                                        _/* train.c */_
       /* Look up connected/4. */
       if (!(pred = SP_predicate("connected",4,"user"))) {
         fprintf(stderr, "Could not find connected/4.\n");
         exit(1);
       }

       /* Create the three arguments to connected/4. */
       SP_put_string(from = SP_new_term_ref(), "Stockholm");
       SP_put_string(to = SP_new_term_ref(), "Orebro");
       SP_put_variable(path = SP_new_term_ref());

       /* Open the query. In a development system, the query would look like:
        *
        * | ?- connected('Stockholm','Orebro',X).
        */
       if (!(goal = SP_open_query(pred,from,to,path,path))) {
         fprintf(stderr, "Failed to open query.\n");
         exit(1);
       }

       /*
        * Loop through all the solutions.
        */
       while (SP_next_solution(goal)==SP_SUCCESS) {
         printf("Path: ");
         write_path(path);
       }

       SP_close_query(goal);

       exit(0);
     }

   Create the saved-state containing the Prolog code:
     % sicstus
     SICStus 4.4.1 ...
     Licensed to SICS
     | ?- compile(train),save_program('train.sav').
     % compiling [...]/train.pl...
     % compiled [...]/train.pl in module user, 10 msec 2848 bytes
     % [...]/train.sav created in 0 msec

     | ?- halt.

   Create the executable using the application builder:

     % spld --main=user train.c -o train.exe

   And finally, run the executable:

     % ./train
     Path: Stockholm -> Katrineholm -> Hallsberg -> Kumla -> Orebro
     Path: Stockholm -> Vasteras -> Orebro


File: sicstus.info,  Node: Building for a Target Machine,  Next: Exceptions from C,  Prev: Train Example,  Up: Mixing C and Prolog Examples

6.8.2 Building for a Target Machine
-----------------------------------

The following example shows how to build an application with a
dynamically loaded foreign resource in such a way that it can be
deployed into an arbitrary folder on a target system that does not have
SICStus installed.  The example is run on Linux but it would be very
similar on other platforms.

   The example consists of three source files, one toplevel file
('main.pl') which in turn loads a module-file ('b.pl').  The latter also
loads a foreign resource ('b.c').

   The initial directory structure, and the contents of the source files
can be seen from the following transcript:
     $ find build/
     build/
     build/myfiles
     build/myfiles/main.pl
     build/myfiles/b.pl
     build/myfiles/b.c
     $ cat build/myfiles/main.pl
     :- module(main, [main/0]).

     :- use_module(b,
                   [b_foreign/1]).

     main :-
       b_foreign(X),
       write(X), nl.

     user:runtime_entry(start) :-
       main.

     $ cat build/myfiles/b.pl
     :- module(b, [b_foreign/1]).

     foreign(b_foreign_c, b_foreign([-string])).

     foreign_resource(b, [
             b_foreign_c]).

     :- load_foreign_resource(b).

     $ cat build/myfiles/b.c
     #include <sicstus/sicstus.h>
     /* b_glue.h is generated by splfr from the foreign/[2,3] facts.
        Always include the glue header in your foreign resource code.
     */
     #include "b_glue.h"

     char const * SPCDECL b_foreign_c(void)
     {
       return "Hello World!";
     }

   The following transcript shows how the foreign resource and the
SICStus runtime executable is built:

     $ cd build/myfiles/
     $ splfr b.pl b.c
     $ cd ..
     $ sicstus --nologo
     % optional step for embedding source info in saved-state.
     | ?- set_prolog_flag(source_info, on).
     yes
     % source_info
     | ?- compile('myfiles/main.pl').
     % compiling .../build/myfiles/main.pl...
     %  module main imported into user
     %  compiling .../build/myfiles/b.pl...
     %   module b imported into main
     %   loading foreign resource .../build/myfiles/b.so in module b
     %  compiled .../build/myfiles/b.pl in module b, 0 msec 3104 bytes
     % compiled .../build/myfiles/main.pl in module main, 0 msec 5344 bytes
     yes
     % source_info
     | ?- save_program('main.sav').
     % .../build/main.sav created in 20 msec
     yes
     % source_info
     | ?- halt.
     $ spld '$SP_APP_DIR/main.sav' -o main.exe
     Created "main.exe"
(instead of creating 'main.exe' you could use the generic runtime system
'sprt.exe' provided as part of the installation (*note Generic Runtime
Systems::)).

   *Please note*: it is important that 'main.sav' be saved to a folder
that is the "root" of the folder tree.  The folder in which the
saved-state is created ('.../build/' above) is treated specially by
'save_program/[1,2]' and by 'restore/1'.  This special handling ensures
that 'myfiles/b.so' will be found relative to the location of 'main.sav'
when 'main.sav' is restored on the target system.  *Note Saving::.  for
details.

   Next, the necessary runtime files must be copied from the SICStus
installation:

     $ mkdir -p sp-4.4.1/sicstus-4.4.1/bin
     $ cp /usr/local/sicstus4.4.1/lib/libsprt4-4-1.so sp-4.4.1/
     $ cp /usr/local/sicstus4.4.1/lib/sicstus-4.4.1/bin/sprt.sav \
          sp-4.4.1/sicstus-4.4.1/bin/sprt.sav

   The resulting folder contents can be seen by running the 'find'
command:

     $ find . -print
     .
     ./sp-4.4.1
     ./sp-4.4.1/libsprt4-4-1.so
     ./sp-4.4.1/sicstus-4.4.1
     ./sp-4.4.1/sicstus-4.4.1/bin
     ./sp-4.4.1/sicstus-4.4.1/bin/sprt.sav
     ./myfiles
     ./myfiles/b.so
     ./myfiles/main.pl
     ./myfiles/b.pl
     ./myfiles/b.c
     ./main.sav
     ./main.exe

   It is possible to run the program from its current location:

     $ ./main.exe
     Hello World!

   The folder 'build/myfiles/' contains some files that do not need to
be present on the target machine, i.e. the source files.  The following
transcript shows how a new folder, 'target/', is created that contains
only the files that need to be present on the target system.

     $ cd ..
     $ mkdir target
     $ mkdir target/myfiles
     $ cp build/main.sav target
     $ cp build/main.exe target
     $ cp build/myfiles/b.so target/myfiles/
     $ cp -R build/sp-4.4.1 target
     $ find target/ -print
     target/
     target/myfiles
     target/myfiles/b.so
     target/main.sav
     target/main.exe
     target/sp-4.4.1
     target/sp-4.4.1/sicstus-4.4.1
     target/sp-4.4.1/sicstus-4.4.1/bin
     target/sp-4.4.1/sicstus-4.4.1/bin/sprt.sav
     target/sp-4.4.1/libsprt4-4-1.so
     $ target/main.exe
     Hello World!

   Note that 'target/myfiles/b.so' was found since its location relative
the directory containing the saved-state ('main.sav') is the same on the
target system as on the build system.

   The folder 'target/' can now be moved to some other system and
'target/main.exe' will not depend on any files of the build machine.

   As a final example, the following transcripts show how the runtime
system can be debugged on the build machine.  It is possible to do this
on the target system as well, if the necessary files are made available.
*Note Debugging Runtime Systems::.  for more information.

   First, the development system files and the license file must be made
available:

     $ mkdir sp-4.4.1/sicstus-4.4.1/library
     $ cp /usr/local/sicstus4.4.1/lib/sicstus-4.4.1/library/SU_messages.po \
          sp-4.4.1/sicstus-4.4.1/library/
     $ cp /usr/local/sicstus4.4.1/lib/sicstus-4.4.1/bin/spds.sav \
          sp-4.4.1/sicstus-4.4.1/bin/
     $ cp /usr/local/sicstus4.4.1/lib/sicstus-4.4.1/library/license.pl \
          sp-4.4.1/sicstus-4.4.1/library/

   As before, the resulting folder contents can be seen by running the
'find' command:

     $ find . -print
     .
     ./sp-4.4.1
     ./sp-4.4.1/libsprt4-4-1.so
     ./sp-4.4.1/sicstus-4.4.1
     ./sp-4.4.1/sicstus-4.4.1/library
     ./sp-4.4.1/sicstus-4.4.1/library/SU_messages.po
     ./sp-4.4.1/sicstus-4.4.1/library/license.pl
     ./sp-4.4.1/sicstus-4.4.1/bin
     ./sp-4.4.1/sicstus-4.4.1/bin/spds.sav
     ./sp-4.4.1/sicstus-4.4.1/bin/sprt.sav
     ./myfiles
     ./myfiles/b.so
     ./myfiles/main.pl
     ./myfiles/b.pl
     ./myfiles/b.c
     ./main.sav
     ./main.exe
     $

   To tell the runtime system to start a development system.  you can
set the 'SP_USE_DEVSYS' environment variable as shown below.  You could
also set 'SP_ATTACH_SPIDER' and debug in the SICStus IDE (*note
Debugging Runtime Systems::).

     $ SP_USE_DEVSYS=yes
     $ export SP_USE_DEVSYS
     $ ./main.exe
     % The debugger will first creep -- showing everything (trace)
             1      1 Call: restore('$SP_APP_DIR/main.sav') ? <RET>
     % restoring .../build/main.sav...
     % .../build/main.sav restored in 10 msec 5600 bytes
             1      1 Exit: restore('$SP_APP_DIR/main.sav') ? <RET>
             2      1 Call: runtime_entry(start) ? <RET>
     in scope of a goal at line 12 in .../build/myfiles/main.pl
             3      2 Call: main:main ? <RET>
     in scope of a goal at line 7 in .../build/myfiles/main.pl
             4      3 Call: main:b_foreign(_2056) ? <RET>
     in scope of a goal at line 7 in .../build/myfiles/main.pl
             4      3 Exit: main:b_foreign('Hello World!') ? v
     Local variables (hit RET to return to debugger)
     X = 'Hello World!' ? <RET>
     in scope of a goal at line 7 in .../build/myfiles/main.pl
             4      3 Exit: main:b_foreign('Hello World!') ? n
     Hello World!
     $

   *Please note*: source info is available, since we used
'set_prolog_flag(source_info, on)' before we compiled 'main.pl' and
created the saved-state 'main.sav'.


File: sicstus.info,  Node: Exceptions from C,  Next: Stream Example,  Prev: Building for a Target Machine,  Up: Mixing C and Prolog Examples

6.8.3 Exceptions from C
-----------------------

Consider, for example, a function returning the square root of its
argument after checking that the argument is valid.  If the argument is
invalid, then the function should raise an exception instead.

                                                         _/* math.c */_
     #include <math.h>
     #include <stdio.h>
     #include <sicstus/sicstus.h>
     /* math_glue.h is generated by splfr from the foreign/[2,3] facts.
        Always include the glue header in your foreign resource code.
     */
     #include "math_glue.h"

     extern double sqrt_check(double d);
     double sqrt_check(double d)
     {
       if (d < 0.0) {    /* build a domain_error/4 exception term */
         SP_term_ref culprit=SP_new_term_ref();
         SP_term_ref argno=SP_new_term_ref();
         SP_term_ref expdomain=SP_new_term_ref();
         SP_term_ref t1=SP_new_term_ref();

         SP_put_float(culprit, d);
         SP_put_integer(argno, 1);
         SP_put_string(expdomain, ">=0.0");
         SP_cons_functor(t1, SP_atom_from_string("sqrt"), 1, culprit);
         SP_cons_functor(t1, SP_atom_from_string("domain_error"), 4,
                         t1, argno, expdomain, culprit);
         SP_raise_exception(t1);    /* raise the exception */
         return 0.0;
       }
       return sqrt(d);
     }

   The Prolog interface to this function is defined in a file 'math.pl'.
The function uses the 'sqrt()' library function, and so the math library
'-lm' has to be included:

                                                            _% math.pl_
     foreign_resource(math, [sqrt_check]).

     foreign(sqrt_check, c, sqrt(+float, [-float])).

     :- load_foreign_resource(math).

   A linked foreign resource is created:
     % splfr math.pl math.c -lm

   A simple session using this function could be:

     $ sicstus
     SICStus 4.4.1 ...
     Licensed to SICS
     | ?- [math].
     % compiling .../math.pl...
     %  loading foreign resource .../math.so in module user
     % compiled .../math.pl in module user, 0 msec 2400 bytes
     yes
     | ?- sqrt(5.0,X).
     X = 2.23606797749979 ?
     yes
     | ?- sqrt(a,X).
     ! Type error in argument 1 of user:sqrt/2
     ! expected a number, but found a
     ! goal:  user:sqrt(a,_110)
     | ?- sqrt(-5,X).
     ! Domain error in argument 1 of user:sqrt/1
     ! expected '>=0.0', but found -5.0
     ! goal:  sqrt(-5.0)


File: sicstus.info,  Node: Stream Example,  Prev: Exceptions from C,  Up: Mixing C and Prolog Examples

6.8.4 Stream Example
--------------------

*Note Defining a New Stream::.  for a simple example of defining a
stream that reads from a C 'FILE' stream.

   For a more realistic example, 'library(codesio)' implements a stream
that can return a list of all characters written to it.  The source code
for this library is located in 'library/codesio.pl' and
'library/codesio.c' and can serve as a useful sample for user defined
streams both for input and output.  That code also illustrates other
important features of user defined streams, for instance ensuring that
all the streams have been closed when the foreign resource is unloaded.


File: sicstus.info,  Node: Debugging Runtime Systems,  Prev: Mixing C and Prolog Examples,  Up: Mixing C and Prolog

6.9 Debugging Runtime Systems
=============================

A runtime system does not contain the Prolog debugger by default.  This
makes it hard to troubleshoot problems that only occur when the code is
embedded in some other application.

   As of release 4.2, it is possible to tell a runtime system to start
the full development system instead.  This way, the Prolog debugger,
compiler etc. can be used to debug the application, either from the
command line or by attaching to the SICStus Prolog IDE (SPIDER). In the
simplest case, this feature is enabled by setting the system property
(or environment variable) 'SP_USE_DEVSYS' to 'yes' before starting the
runtime system.  This will cause the runtime system to become a
development system and it will start the debugger, as if by a call to
'trace/0'.  *Note Building for a Target Machine::.  for a complete
example.

   For best effect, you should ensure that any compiled prolog code
('.sav' and '.po' files) has been compiled with the Prolog flag
'source_info' enabled, i.e. with 'set_prolog_flag(source_info, on)'.

   When the runtime system is started as a development system in this
way, it needs to be able to find the file that makes up an ordinary
development system, i.e. 'spds.sav'; see *note Runtime Systems on UNIX
Target Machines:: and *note Runtime Systems on Windows Target
Machines::, above.  It also needs to find the license information for
the development system; see *note Locating the License Information::,
below.

* Menu:

* Locating the License Information:: Locating the License Information
* Customizing the Debugged Runtime System:: Customizing the Debugged Runtime System
* Examples of Debugging Runtime Systems:: Examples of Debugging Runtime Systems


File: sicstus.info,  Node: Locating the License Information,  Next: Customizing the Debugged Runtime System,  Up: Debugging Runtime Systems

6.9.1 Locating the License Information
--------------------------------------

The license information for debugged runtime systems can be provided in
several ways.  Most of them can also be used as alternative ways for
providing the license information to extended runtime systems (*note
Managing Extended Runtime License Information: (relnotes)REX.).

   On Windows only, if you have installed the SICStus Prolog development
system on the machine where the runtime system is to be debugged, then
the license information will be found in the Windows registry and no
extra steps need to be performed.  This method cannot be used for
providing an extended runtime system license since the license
information for the full development system is not the same as for an
extended runtime system.

   If you have the license in a file 'license.pl', i.e. you are using a
UNIX platform or have manually created a 'license.pl' file on Windows,
then you can make this file available to the debugged runtime system in
one of two ways:

   * Set the system property or environment variable 'SP_LICENSE_FILE'
     to the absolute path of the 'license.pl' file of a SICStus Prolog
     installation, or
   * Copy the 'license.pl' file into the appropriate location relative
     to the runtime system executable, i.e. to
     'sp-4.4.1/sicstus-4.4.1/library/license.pl' on UNIX or
     'sp-4.4.1\library\license.pl' on Windows.

   *Please note*: you cannot redistribute 'license.pl'.

   The final alternative, available on all platforms, is to set the
following system properties or environment variables

'SP_LICENSE_SITE'
     Set to the site name part of your license.
'SP_LICENSE_CODE'
     Set to the code part of your license, e.g. something like
     'a111-b222-c333-d444-e444'.
'SP_LICENSE_EXPIRATION'
     Set to the expiration part of your license, e.g. 'permanent' if you
     have a permanent (non-evaluation) license.


File: sicstus.info,  Node: Customizing the Debugged Runtime System,  Next: Examples of Debugging Runtime Systems,  Prev: Locating the License Information,  Up: Debugging Runtime Systems

6.9.2 Customizing the Debugged Runtime System
---------------------------------------------

It is possible to fine-tune the behavior of the debugged runtime system
in various ways, both at compile time (setting C preprocessor symbols
and passing system properties to 'SP_initialize()') and at runtime
(passing system properties as environment variables).

   The system properties and environment variables that affect the
debugged runtime system are:

'SP_USE_DEVSYS'
     if set to 'yes', then the runtime system will try to start a
     development system, as described above.
'SP_ATTACH_SPIDER'
     if set to 'yes', then this has the same effect as
     'SP_USE_DEVSYS=yes' and in addition tries to attach to the SICStus
     Prolog IDE (SPIDER). You have to tell SPIDER to 'Attach to Prolog
     Process', i.e. listen for an incoming connection.  This command is
     available from the SICStus top-level view menu in SPIDER.
'SP_DEVSYS_NO_TRACE'
     if set to 'yes', then this will prevent the runtime system from
     calling 'trace/0' at initialization.  This is useful if you prefer
     to manually enable the debugger later from your C or Prolog code.
'SP_ALLOW_DEVSYS'
     if set to 'no', then this will prevent the runtime system from
     starting as a development system.  This may be useful in order to
     prevent inheriting 'SP_USE_DEVSYS' or 'SP_ATTACH_SPIDER' from the
     environment.  The same effect can be obtained by passing the option
     '--no-allow-devsys' to 'spld' when building the runtime system.
'SP_LICENSE_FILE'
'SP_LICENSE_SITE'
'SP_LICENSE_CODE'
'SP_LICENSE_EXPIRATION'
     These are described in *note Locating the License Information::,
     above.

   If your C code calls 'SP_initialize()', then you can pass these
system properties in the call to 'SP_initialize()' (*note SP_initialize:
cpg-ref-SP_initialize.).  You can also pass these options to
'SP_initialize()' by setting the 'SPLD_DSP' C macro.  See the definition
of 'SP_initialize()' in the header file 'sictus/sicstus.h' for details.


File: sicstus.info,  Node: Examples of Debugging Runtime Systems,  Prev: Customizing the Debugged Runtime System,  Up: Debugging Runtime Systems

6.9.3 Examples of Debugging Runtime Systems
-------------------------------------------

The following examples show how to start Prolog debugging when SICStus
is run from within Java via Jasper.  The examples assume that the
SICStus files are part of a development system installation.

   The first example initializes the SICStus system property
'SP_USE_DEVSYS' by setting the environment variable with the same name.
This method of passing SICStus system properties also works well when
SICStus is embedded in some other, non-Java, program.

     $ SP=/usr/local/sicstus4.4.1
     $ SP_USE_DEVSYS=yes
     $ export SP_USE_DEVSYS
     $ java -jar \
            "$SP/lib/sicstus-4.4.1/bin/jasper.jar"
     Trying to load SICStus.
     % The debugger will first creep -- showing everything (trace)
             1      1 Call: write('If you see this message, you have successfully') ? <RET>
     If you see this message, then you have successfully
             1      1 Exit: write('If you see this message, you have successfully') ? n

     initialized the SICStus Prolog engine.
     $ unset SP_USE_DEVSYS

   The second example initializes the SICStus system property
'SP_USE_DEVSYS' by setting the Java system property
'se.sics.sicstus.property.SP_USE_DEVSYS'.  This method of passing
SICStus system properties is specific to Jasper.

     $ SP='/usr/local/sicstus4.4.1'
     $ java -Dse.sics.sicstus.property.SP_USE_DEVSYS=yes \
            -jar "$SP/lib/sicstus-4.4.1/bin/jasper.jar"
     Trying to load SICStus.
     % The debugger will first creep -- showing everything (trace)
             1      1 Call: write('If you see this message, you have successfully') ? n
     If you see this message, then you have successfully
     initialized the SICStus Prolog engine.
     $


File: sicstus.info,  Node: Interfacing .NET and Java,  Next: Multiple SICStus Runtimes,  Prev: Mixing C and Prolog,  Up: Top

7 Interfacing .NET and Java
***************************

SICStus Prolog supports two different ways of interfacing a Prolog
program with a Java client, and one for interfacing with a .NET client.

   SICStus Prolog provides a uniform way of interfacing to Java and .NET
clients via the "PrologBeans" (*note lib-prologbeans::) interface.  This
is a loosely coupled interface, which means that the client code runs in
a different process from the Prolog code.  In fact, the client program
and the Prolog program can run on separate machines, since the
communication is done via TCP/IP sockets.  This design has the following
advantages over a tightly coupled interface, where they run in the same
process:

   * There is no competition for memory or other process-wide resources
     between the virtual machines of the client (.NET or JVM) and of
     Prolog.

   * Distribution over a network is trivial when using PrologBeans.  The
     application is distributable from the beginning.

   * PrologBeans has support for user session handling both at the Java
     level (with support for HTTP sessions and JNDI lookup) and at the
     Prolog level.  This makes it easy to integrate Prolog applications
     into applications based on Java servers.

   The main limitation of the design is that callbacks from Prolog to
the client is not provided for.

   "PrologBeans" is the recommended package unless you have special
needs and are interfacing with Java in which case you may consider using
"Jasper".

   For interfacing to Java clients SICStus Prolog also provides "Jasper"
(*note lib-jasper::), a "tightly coupled" interface.  This means that
everything runs in the same process (the necessary code is loaded at
runtime via dynamic linking).

   Advantages of Jasper:
   * Jasper is bi-directional.  Callbacks are possible (limited in
     levels only by memory), and queries can backtrack.


File: sicstus.info,  Node: Multiple SICStus Runtimes,  Next: Writing Efficient Programs,  Prev: Interfacing .NET and Java,  Up: Top

8 Multiple SICStus Runtimes in a Process
****************************************

* Menu:

* Multiple SICStus Runtimes in Java:: Multiple SICStus Runtimes in Java
* Multiple SICStus Runtimes in C:: Multiple SICStus Runtimes in C
* Foreign Resources and Multiple SICStus Runtimes:: Foreign Resources and Multiple SICStus Runtimes
* Threads:: Multiple Runtimes and Threads

It is possible to have more than one SICStus runtime in a single
process.  These are completely independent (except that they dynamically
load the same foreign resources; see *note Foreign Resources and
Multiple SICStus Runtimes::).

   Even though the SICStus runtime can only be run in a single thread,
it is now possible to start several SICStus runtimes, optionally each in
its own thread.

   SICStus runtimes are rather heavy weight and you should not expect to
be able to run more than a handful.


File: sicstus.info,  Node: Multiple SICStus Runtimes in Java,  Next: Multiple SICStus Runtimes in C,  Up: Multiple SICStus Runtimes

8.1 Multiple SICStus Runtimes in Java
=====================================

In Java, you can now create more than one 'se.sics.jasper.SICStus'
object.  Each will correspond to a completely independent copy of the
SICStus runtime.  Note that a SICStus runtime is not deallocated when
the corresponding SICStus object is no longer used.  Thus, the best way
to use multiple SICStus objects is to create them early and then re-use
them as needed.

   It is probably useful to create each in its own separate thread.  One
reason would be to gain speed on a multi-processor machine.


File: sicstus.info,  Node: Multiple SICStus Runtimes in C,  Next: Foreign Resources and Multiple SICStus Runtimes,  Prev: Multiple SICStus Runtimes in Java,  Up: Multiple SICStus Runtimes

8.2 Multiple SICStus Runtimes in C
==================================

Unless otherwise noted, this section documents the behavior when using
dynamic linking to access a SICStus runtime.

   The key implementation feature that makes it possible to use multiple
runtimes is that all calls from C to the SICStus API ('SP_query()',
etc.)  go through a dispatch vector.  Two runtimes can be loaded at the
same time since their APIs are accessed through different dispatch
vectors.

   By default, there will be a single dispatch vector, referenced from a
global variable ('sp_GlobalSICStus').  A SICStus API functions, such as
'SP_query()', is then defined as a macro that expands to something
similar to 'sp_GlobalSICStus->SP_query_pointer'.  The name of the global
dispatch vector is subject to change without notice; it should not be
referenced directly.  If you need to access the dispatch vector, then
use the C macro 'SICStusDISPATCHVAR' instead; see below.

* Menu:

* MT Single:: Using a Single SICStus Runtime
* MT Multiple:: Using More than One SICStus Runtime


File: sicstus.info,  Node: MT Single,  Next: MT Multiple,  Up: Multiple SICStus Runtimes in C

8.2.1 Using a Single SICStus Runtime
------------------------------------

When building an application with 'spld', by default only one SICStus
runtime can be loaded in the process.  This is similar to what was the
case before release 3.9.  For most applications built with 'spld', the
changes necessary to support multiple SICStus runtimes should be
invisible, and old code should only need to be rebuilt with 'spld'.

   In order to maintain backward compatibility, the global dispatch
vector is automatically set up implicitly by 'SP_initialize()' and
explicitly by 'SP_setup_dispatch()'.  Other SICStus API functions will
not set up the dispatch vector, and will therefore lead to memory access
errors if called before 'SP_initialize()'.  Currently, hook functions
such as 'SP_set_memalloc_hooks()' also set up the dispatch vector to
allow them to be called before 'SP_initialize()'.  However, only
'SP_initialize()' and 'SP_setup_dispatch()' are guaranteed to set up the
dispatch vector.  The hook installation functions may change to use a
different mechanism in the future.  The SICStus API functions that
perform automatic setup of the dispatch vector are marked with
'SPEXPFLAG_PREINIT' in 'sicstus.h'.


File: sicstus.info,  Node: MT Multiple,  Prev: MT Single,  Up: Multiple SICStus Runtimes in C

8.2.2 Using More than One SICStus Runtime
-----------------------------------------

Using more than one SICStus runtime in a process is only supported when
the dynamic library version of the SICStus runtime is used (e.g.
'sprt4-4-1.dll', 'libsprt4-4-1.so').

   An application that wants to use more than one SICStus runtime needs
to be built using the '--multi-sp-aware' option to 'spld'.  C-code
compiled by 'spld --multi-sp-aware' will have the C preprocessor macro
'MULTI_SP_AWARE' defined and non-zero.

   Unlike the single runtime case described above, an application built
with '--multi-sp-aware' will not have a global variable that holds the
dispatch vector.  Instead, your code will have to take steps to ensure
that the appropriate dispatch vector is used when switching between
SICStus runtimes.

   There are several steps needed to access a SICStus runtime from an
application built with '--multi-sp-aware'.

  1. You must obtain the dispatch vector of the initial SICStus runtime
     using 'SP_get_dispatch()'.  Note that this function is special in
     that it is not accessed through the dispatch vector; instead, it is
     exported in the ordinary manner from the SICStus runtime dynamic
     library ('sprt4-4-1.dll' under Windows and, typically,
     'libsprt4-4-1.so' under UNIX).

  2. You must ensure that 'SICStusDISPATCHVAR' expands to something that
     references the dispatch vector obtained in step 1.

     The C preprocessor macro 'SICStusDISPATCHVAR' should expand to a
     'SICSTUS_API_STRUCT_TYPE *', that is, a pointer to the dispatch
     vector that should be used.  When '--multi-sp-aware' is not used
     'SICStusDISPATCHVAR' expands to 'sp_GlobalSICStus' as described
     above.  When using '--multi-sp-aware' it is probably best to let
     'SICStusDISPATCHVAR' expand to a local variable.

  3. Once you have access to the SICStus API of the initial SICStus
     runtime you can call the SICStus API function
     'SP_load_sicstus_run_time()' to load additional runtimes.

     SICSTUS_API_STRUCT_TYPE *SP_get_dispatch(void *reserved);

   'SP_get_dispatch()' returns the dispatch vector of the SICStus
runtime.  The argument 'reserved' should be 'NULL'.  This function can
be called from any thread.

     typedef SICSTUS_API_STRUCT_TYPE *SP_get_dispatch_type(void *);

     int SP_load_sicstus_run_time(SP_get_dispatch_type **ppfunc, void *reserved);

   'SP_load_sicstus_run_time()' loads a new SICStus runtime.  If a new
runtime could be loaded, then a positive value is returned and the
address of the 'SP_get_dispatch()' function of the newly loaded SICStus
runtime is stored at the address 'ppfunc'.  The second argument,
'phandle', is reserved and should be 'NULL'.

   As a special case, if 'SP_load_sicstus_run_time()' is called from a
SICStus runtime that has not been initialized (with 'SP_initialize()')
and that has not previously been loaded as the result of calling
'SP_load_sicstus_run_time()', then no new runtime is loaded.  Instead,
the 'SP_get_dispatch()' of the runtime itself is returned.  In
particular, the first time 'SP_load_sicstus_run_time()' is called on the
initial SICStus runtime, and if this happens before the initial SICStus
runtime is initialized, then no new runtime is loaded.

   Calling 'SP_load_sicstus_run_time()' from a particular runtime can be
done from any thread.

   An application that links statically with the SICStus runtime should
not call 'SP_load_sicstus_run_time()'.

   You should not use prelinked foreign resources when using multiple
SICStus runtimes in the same process.

   For an example of loading and using multiple SICStus runtimes, see
'library/jasper/spnative.c' that implements this functionality for the
Java interface Jasper.


File: sicstus.info,  Node: Foreign Resources and Multiple SICStus Runtimes,  Next: Threads,  Prev: Multiple SICStus Runtimes in C,  Up: Multiple SICStus Runtimes

8.3 Foreign Resources and Multiple SICStus Runtimes
===================================================

Foreign resources access the SICStus C API in the same way as an
embedding application, that is, through a dispatch vector.  As for
applications, the default and backward compatible mode is to only
support a single SICStus runtime.  An alternative mode makes it possible
for a foreign resource to be shared between several SICStus runtimes in
the same process.

   Unless otherwise noted, this section documents the behavior when
using dynamically linked foreign resources.  That is, shared objects
(e.g.: .so-files) under UNIX, dynamic libraries (DLLs) under Windows.

* Menu:

* MT Foreign Single:: Foreign Resources Supporting Only One SICStus Runtime
* MT Foreign Multiple:: Foreign Resources Supporting Multiple SICStus Runtimes


File: sicstus.info,  Node: MT Foreign Single,  Next: MT Foreign Multiple,  Up: Foreign Resources and Multiple SICStus Runtimes

8.3.1 Foreign Resources Supporting Only One SICStus Runtime
-----------------------------------------------------------

A process will only contain one instance of the code and data of a
(dynamic) foreign resource even if the foreign resource is loaded and
used from more than one SICStus runtime.

   This presents a problem in the likely event that the foreign resource
maintains some state, e.g. global variables, between invocations of
functions in the foreign resource.  The global state will probably need
to be separate between SICStus runtimes.  Requiring a foreign resource
to maintain its global state on a per SICStus runtime basis would be an
incompatible change.  Instead, by default, only the first SICStus
runtime that loads a foreign resource will be allowed to use it.  If a
subsequent SICStus runtime (in the same process) tries to load the
foreign resource, then an error will be reported to the second SICStus
runtime.

   When 'splfr' builds a foreign resource, it will also generate glue
code.  When the foreign resource is loaded, the glue code will set up a
global variable pointing to the dispatch vector used in the foreign
resource to access the SICStus API. This is similar to how an embedding
application accesses the SICStus API.

   The glue code will also detect if a subsequent SICStus runtime in the
same process tries to initialize the foreign resource.  In this case, an
error will be reported.

   This means that pre 3.9 foreign code should only need to be rebuilt
with 'splfr' to work with the latest version of SICStus.  However, a
recommended change is that all C files of a foreign resource include the
header file generated by 'splfr'.  Inclusion of this generated header
file may become mandatory in a future release.  *Note The Foreign
Resource Linker::.


File: sicstus.info,  Node: MT Foreign Multiple,  Prev: MT Foreign Single,  Up: Foreign Resources and Multiple SICStus Runtimes

8.3.2 Foreign Resources Supporting Multiple SICStus Runtimes
------------------------------------------------------------

A foreign resource that wants to be shared between several SICStus
runtimes must somehow know which SICStus runtime is calling it so that
it can make callbacks using the SICStus API into the right SICStus
runtime.  In addition, the foreign resource may have global variables
that should have different values depending on which SICStus runtime is
calling the foreign resource.

   A header file is generated by 'splfr' when it builds a foreign
resource (before any C code is compiled).  This header file provides
prototypes for any 'foreign'-declared function, but it also provides
other things needed for multiple SICStus runtime support.  This header
file must be included by any C file that contains code that either calls
any SICStus API function or that contains any of the functions called by
SICStus.  *Note The Foreign Resource Linker::.

* Menu:

* MT Foreign Multiple Full:: Full Support for Multiple SICStus Runtimes


File: sicstus.info,  Node: MT Foreign Multiple Full,  Up: MT Foreign Multiple

8.3.2.1 Full Support for Multiple SICStus Runtimes
..................................................

To fully support multiple SICStus runtimes, a foreign resource should be
built with 'splfr --multi-sp-aware'.

   C code compiled by 'splfr --multi-sp-aware' will have the C
preprocessor macro 'MULTI_SP_AWARE' defined to a non-zero value.

   Full support for multiple SICStus runtimes means that more than one
SICStus runtime can execute code in the foreign resource at the same
time.  This rules out the option to use any global variables for
information that should be specific to each SICStus runtime.  In
particular, the SICStus dispatch vector cannot be stored in a global
variable.  Instead, the SICStus dispatch vector is passed as an extra
first argument to each foreign function.

   To ensure some degree of link time type checking, the name of each
foreign function will be changed (using '#define' in the generated
header file).

   The extra argument is used in the same way as when using multiple
SICStus runtimes from an embedding application.  It must be passed on to
any function that needs access to the SICStus API.

   To simplify the handling of this extra argument, several macros are
defined so that the same foreign resource code can be compiled both with
and without support for multiple SICStus runtimes:
   * 'SPAPI_ARG0'
   * 'SPAPI_ARG'
   * 'SPAPI_ARG_PROTO_DECL0'
   * 'SPAPI_ARG_PROTO_DECL'

   Their use is easiest to explain with an example.  Suppose the
original foreign code looked like:
     static int f1(void)
     {
             SOME SICSTUS API CALLS
     }

     static int f2(SP_term_ref t, int x)
     {
             SOME SICSTUS API CALLS
     }

     /* :- foreign(foreign_fun, c, foreign_pred(+integer)). */
     void foreign_fun(SP_integer x)
     {
       ... SOME SICSTUS API CALLS ...
       f1();
       ...
       f2(SP_new_term_ref(), 42);
       ...
     }

   Assuming no global variables are used, the following change will
ensure that the SICStus API dispatch vector is passed around to all
functions:

     static int f1(SPAPI_ARG_PROTO_DECL0) // _DECL<ZERO> for no-arg functions
     {
             SOME SICSTUS API CALLS
     }

     static int f2(SPAPI_ARG_PROTO_DECL SP_term_ref t, int x) // Note: no comma
     {
             SOME SICSTUS API CALLS
     }

     /* :- foreign(foreign_fun, c, foreign_pred([-integer])). */
     void foreign_fun(SPAPI_ARG_PROTO_DECL SP_integer x) // Note: no comma
     {
       ... SOME SICSTUS API CALLS ...
       f1(SPAPI_ARG0);               // ARG<ZERO> for no-arg functions
       ...
       f2(SPAPI_ARG SP_new_term_ref(), 42);       // Note: no comma
       ...
     }

   If 'MULTI_SP_AWARE' is not defined, i.e. '--multi-sp-aware' is not
specified to 'splfr', then all these macros expand to nothing, except
'SPAPI_ARG_PROTO_DECL0', which will expand to 'void'.

   You can use 'SP_foreign_stash()' to get access to a location,
initially set to NULL, where the foreign resource can store a 'void*'.
Typically this would be a pointer to a C struct that holds all
information that need to be stored in global variables.  This struct can
be allocated and initialized by the foreign resource init function.  It
should be deallocated by the foreign resource deinit function.  *Note OS
Threads::.  for details.

   Most foreign resources that come with SICStus fully support multiple
SICStus runtimes.  For a particularly simple example, see the code for
'library(random)'.  For an example that hides the passing of the extra
argument by using the C preprocessor, see the files in 'library/clpfd/'.


File: sicstus.info,  Node: Threads,  Prev: Foreign Resources and Multiple SICStus Runtimes,  Up: Multiple SICStus Runtimes

8.4 Multiple Runtimes and Threads
=================================

Perhaps the primary reason to use more than one SICStus runtime in a
process is to have each runtime running in a separate thread.  To this
end, a few mutual exclusion primitives are available.  *Note Operating
System Services::.  for details on mutual exclusion locks.

     *Please note*: the SICStus runtime is not thread safe in general.
     *Note Calling Prolog Asynchronously::.  for ways to safely interact
     with a running SICStus from arbitrary threads.


File: sicstus.info,  Node: Writing Efficient Programs,  Next: The Prolog Library,  Prev: Multiple SICStus Runtimes,  Up: Top

9 Writing Efficient Programs
****************************

* Menu:

* Eff Overview:: Overview
* Execution Profiling:: Execution Profiling
* Coverage Analysis:: Coverage Analysis
* The Cut:: The Cut
* Indexing:: Indexing
* Last Clause Determinacy Detection:: Last Clause Determinacy Detection
* The Determinacy Checker:: The Determinacy Checker
* Last Call Optimization:: Last Call Optimization
* Building and Dismantling Terms:: Building and Dismantling Terms
* Conditionals and Disjunction:: Conditionals and Disjunction
* Programming Examples:: Programming Examples
* The Cross-Referencer:: The Cross-Referencer


File: sicstus.info,  Node: Eff Overview,  Next: Execution Profiling,  Up: Writing Efficient Programs

9.1 Overview
============

This chapter gives a number of tips on how to organize your programs for
increased efficiency.  A lot of clarity and efficiency is gained by
sticking to a few basic rules.  This list is necessarily very
incomplete.  The reader is referred to textbooks such as [O'Keefe 90]
for a thorough exposition of the elements of Prolog programming style
and techniques.

   * Do Not write code in the first place if there is a library
     predicate that will do the job.

   * Write clauses representing base case before clauses representing
     recursive cases.

   * Input arguments before output arguments in clause heads and goals.

   * Use pure data structures instead of database changes.

   * Use cuts sparingly, and _only_ at proper places (*note
     ref-sem-ctr-cut::).  A cut should be placed at the exact point that
     it is known that the current choice is the correct one: no sooner,
     no later.

   * Make cuts as local in their effect as possible.  If a predicate is
     intended to be determinate, then define _it_ as such; do not rely
     on its callers to prevent unintended backtracking.

   * Binding output arguments before a cut is a common source of
     programming errors.  If a predicate is not steadfast, then it is
     usually for this reason.

   * Replace cuts by if-then-else constructs if the test is simple
     enough (*note Conditionals and Disjunction::).

   * Use disjunctions sparingly, _always_ put parentheses around them,
     _never_ put parentheses around the individual disjuncts, _never_
     put the ';' at the end of a line.

   * Write the clauses of a predicate so that they discriminate on the
     principal functor of the first argument (see below).  For maximum
     efficiency, avoid "defaulty" programming ("catch-all" clauses).

   * Do Not use lists ('[...]'), "round lists" ('(...)'), or braces
     ('{...}') to represent compound terms, or "tuples", of some fixed
     arity.  The name of a compound term comes for free.

   * Before trying to optimize your program for speed, use execution
     profiling to get an idea of where most of the time is being spent,
     and, more importantly, why.


File: sicstus.info,  Node: Execution Profiling,  Next: Coverage Analysis,  Prev: Eff Overview,  Up: Writing Efficient Programs

9.2 Execution Profiling
=======================

Execution profiling is a common aid for improving software performance.
As of release 4.2, execution profiling is available for compiled as well
as interpreted code.  Execution profiling requires no recompilation with
instrumentation.  Execution profiling is either globally _on_ or
globally _off_ for all compiled code.  This is reflected by the
'profiling' Prolog flag.  When the flag is on, the information gathered
depends on the execution mode:

compiled code
     Execution profiling counts the number of calls per caller-callee
     pair, the number of instructions executed, and the number of
     choicepoint accesses per predicate.  Calls that succeed
     nondeterminately are detected.  Compiled codes runs 2-10 times
     slower with execution profiling than without.

interpreted code
     Execution profiling counts the number of calls per caller-callee
     pair if the 'source_info' Prolog flag was on when the code was
     loaded; otherwise, the number of calls per predicate.  Calls that
     succeed nondeterminately are detected.

   A typical query pattern is:

     | ?- [LOAD SOME CODE.]
     | ?- prolog_flag(profiling,_,on).
     | ?- [RUN SOME QUERIES.]
     | ?- prolog_flag(profiling,_,off).
     | ?- print_profile.

   The predicate 'profile_data/1' makes the accumulated data available
as a Prolog term.  The predicate 'print_profile/0' prints the execution
profile in a format similar to 'gprof(1)'.  It can also be given an
argument which should be of the same type as the output of
'profile_data/1'.  The predicate 'profile_reset/0' clears all profiling
data.  For the details, see the respective reference page.  See also the
Gauge graphical user interface for inspecting execution profiles (*note
lib-gauge::) and the SICStus Prolog IDE (*note SICStus Prolog IDE:
SPIDER.) which both can visualize the profiling information.

'profile_reset   since release 4.2,development'

     Resets all profiling data.  *Note mpg-ref-profile_reset::.

'profile_data(-DATA)   since release 4.2,development'

     DATA is the profiling data accumulated so far.  *Note
     mpg-ref-profile_data::.

'print_profile   since release 4.2,development'
'print_profile(+DATA)   since release 4.2,development'

     The profiling data DATA is displayed in a format similar to
     'gprof(1)'.  DATA defaults to the profiling data accumulated so
     far.  *Note mpg-ref-print_profile::.


File: sicstus.info,  Node: Coverage Analysis,  Next: The Cut,  Prev: Execution Profiling,  Up: Writing Efficient Programs

9.3 Coverage Analysis
=====================

Coverage analysis is the gathering of information about which points in
the code, or _coverage sites_, were executed, and how many times, during
a particular run of the program.  It is available as of release 4.2, for
compiled as well as interpred code, provided that such code was loaded
with the 'source_info' Prolog flag switched on.  In fact, it uses the
same underlying support as execution profiling: while the program is
running with execution profiling switched on, the data accumulated can
be used for both purposes.  Roughly, coverage sites correspond to points
in the code at which the debugger would stop in 'trace' mode, plus one
site at entry to every clause.  A typical query pattern is:

     | ?- [LOAD SOME CODE.]
     | ?- prolog_flag(profiling,_,on).
     | ?- [RUN SOME QUERIES.]
     | ?- prolog_flag(profiling,_,off).
     | ?- print_coverage.

   The predicate 'coverage_data/1' makes the accumulated data available
as a Prolog term.  The predicate 'print_coverage/0' prints the execution
coverage in a hierarchical format.  It can also be given an argument
which should be of the same type as the output of 'coverage_data/1'.
The Emacs interface has commands for code coverage highlighting of
source code buffers (*note Usage::).  For the details, see the
respective reference page.

'profile_reset   since release 4.2,development'

     Resets all profiling and coverage data.  *Note
     mpg-ref-profile_reset::.

'coverage_data(-DATA)   since release 4.2,development'

     DATA is the coverage data accumulated so far.  *Note
     mpg-ref-coverage_data::.

'print_coverage   since release 4.2,development'
'print_coverage(+DATA)   since release 4.2,development'

     The coverage data DATA is displayed in a hierarchical format.  DATA
     defaults to the profiling data accumulated so far.  *Note
     mpg-ref-print_coverage::.


File: sicstus.info,  Node: The Cut,  Next: Indexing,  Prev: Coverage Analysis,  Up: Writing Efficient Programs

9.4 The Cut
===========

* Menu:

* Cut Overview:: Overview
* Making Predicates Determinate:: Making Predicates Determinate
* Placement of Cuts:: Placement of Cuts
* Terminating a Backtracking Loop:: Terminating a Backtracking Loop


File: sicstus.info,  Node: Cut Overview,  Next: Making Predicates Determinate,  Up: The Cut

9.4.1 Overview
--------------

One of the more difficult things to master when learning Prolog is the
proper use of the cut.  Often, when beginners find unexpected
backtracking occurring in their programs, they try to prevent it by
inserting cuts in a rather random fashion.  This makes the programs
harder to understand and sometimes stops them from working.

   During program development, each predicate in a program should be
considered _independently_ to determine whether or not it should be able
to succeed more than once.  In most applications, many predicates should
at most succeed only once; that is, they should be determinate.  Having
decided that a predicate should be determinate, it should be verified
that, in fact, it is.  The debugger can help in verifying that a
predicate is determinate (*note The Determinacy Checker::).


File: sicstus.info,  Node: Making Predicates Determinate,  Next: Placement of Cuts,  Prev: Cut Overview,  Up: The Cut

9.4.2 Making Predicates Determinate
-----------------------------------

Consider the following predicate, which calculates the factorial of a
number:

     fac(0, 1).
     fac(N, X) :-
             N1 is N - 1,
             fac(N1, Y),
             X is N * Y.

   The factorial of 5 can be found by typing:

     | ?- fac(5, X).

     X = 120

   However, backtracking into the above predicate by typing a semicolon
at this point, causes an infinite loop because the system starts
attempting to satisfy the goals 'fac(-1, X).', 'fac(-2, X).', etc.  The
problem is that there are two clauses that match the goal 'fac(0, F).',
but the effect of the second clause on backtracking has not been taken
into account.  There are at least three possible ways of fixing this:

  1. Efficient solution: rewrite the first clause as
          fac(0,1) :- !.

     Adding the cut essentially makes the first solution the only one
     for the factorial of 0 and hence solves the immediate problem.
     This solution is space-efficient because as soon as Prolog
     encounters the cut, it knows that the predicate is determinate.
     Thus, when it tries the second clause, it can throw away the
     information it would otherwise need in order to backtrack to this
     point.  Unfortunately, if this solution is implemented, then typing
     'fac(-1, X)' still generates an infinite search.

  2. Robust solution: rewrite the second clause as
          fac(N, X) :-
                  N > 0,
                  N1 is N - 1,
                  fac(N1, Y),
                  X is N * Y.

     This also solves the problem, but it is a more robust solution
     because this way it is impossible to get into an infinite loop.

     This solution makes the predicate _logically_ determinate--there is
     only one possible clause for any input--but the Prolog system is
     unable to detect this and must waste space for backtracking
     information.  The space-efficiency point is more important than it
     may at first seem; if 'fac/2' is called from another determinate
     predicate, and if the cut is omitted, then Prolog cannot detect the
     fact that 'fac/2' is determinate.  Therefore, it will not be able
     to detect the fact that the calling predicate is determinate, and
     space will be wasted for the calling predicate as well as for
     'fac/2' itself.  This argument applies again if the calling
     predicate is itself called by a determinate predicate, and so on,
     so that the cost of an omitted cut can be very high in certain
     circumstances.

  3. Preferred solution: rewrite the entire predicate as the single
     clause
          fac(N, X) :-
              (   N > 0 ->
                      N1 is N - 1,
                      fac(N1, Y),
                      X is N * Y
              ;   N =:= 0 ->
                      X = 1
              ).

     This solution is as robust as solution 2, and more efficient than
     solution 1, since it exploits conditionals with arithmetic tests
     (*note Conditionals and Disjunction:: for more information on
     optimization using conditionals).


File: sicstus.info,  Node: Placement of Cuts,  Next: Terminating a Backtracking Loop,  Prev: Making Predicates Determinate,  Up: The Cut

9.4.3 Placement of Cuts
-----------------------

Programs can often be made more readable by the placing of cuts as early
as possible in clauses.  For example, consider the predicate 'p/0'
defined by
     p :- a, b, !, c, d.
     p :- e, f.

   Suppose that 'b/0' is a test that determines which clause of 'p/0'
applies; 'a/0' may or may not be a test, but 'c/0' and 'd/0' are not
supposed to fail under any circumstances.  A cut is most appropriately
placed after the call to 'b/0'.  If in fact 'a/0' is the test and 'b/0'
is not supposed to fail, then it would be much clearer to move the cut
before the call to 'b/0'.

   A tool to aid in determinacy checking is included in the
distribution.  It is described in depth in *note The Determinacy
Checker::.


File: sicstus.info,  Node: Terminating a Backtracking Loop,  Prev: Placement of Cuts,  Up: The Cut

9.4.4 Terminating a Backtracking Loop
-------------------------------------

Cut is also commonly used in conjunction with the generate-and-test
programming paradigm.  For example, consider the predicate
'find_solution/1' defined by
     find_solution(X) :-
             candidate_solution(X),
             test_solution(X),
             !.

where 'candidate_solution/1' generates possible answers on backtracking.
The intent is to stop generating candidates as soon as one is found that
satisfies 'test_solution/1'.  If the cut were omitted, then a future
failure could cause backtracking into this clause and restart the
generation of candidate solutions.  A similar example is shown below:

     process_file(F) :-
             see(F),
             repeat,
                 read(X),
                 process_and_fail(X),
             !,
             seen.

     process_and_fail(end_of_file) :- !.
     process_and_fail(X) :-
             process(X),
             fail.

   The cut in 'process_file/1' is another example of terminating a
generate-and-test loop.  In general, a cut should always be placed after
a 'repeat/0' so that the backtracking loop is clearly terminated.  If
the cut were omitted in this case, then on later backtracking Prolog
might try to read another term after the end of the file had been
reached.

   The cut in 'process_and_fail/1' might be considered unnecessary
because, assuming the call shown is the only call to it, the cut in
'process_file/1' ensures that backtracking into 'process_and_fail/1' can
never happen.  While this is true, it is also a good safeguard to
include a cut in 'process_and_fail/1' because someone may unwittingly
change 'process_file/1' in the future.


File: sicstus.info,  Node: Indexing,  Next: Last Clause Determinacy Detection,  Prev: The Cut,  Up: Writing Efficient Programs

9.5 Indexing
============

* Menu:

* Indexing Overview:: Overview
* Data Tables:: Data Tables
* Determinacy Detection:: Determinacy Detection


File: sicstus.info,  Node: Indexing Overview,  Next: Data Tables,  Up: Indexing

9.5.1 Overview
--------------

In SICStus Prolog, predicates are indexed on their first arguments.
This means that when a predicate is called with an instantiated first
argument, a hash table is used to gain fast access to only those clauses
having a first argument with the same primary functor as the one in the
predicate call.  If the first argument is atomic, then only clauses with
a matching first argument are accessed.  Indexes are maintained
automatically by the built-in predicates manipulating the Prolog
database (for example, 'assert/1', 'retract/1', and 'compile/1'.

   Keeping this feature in mind when writing programs can help speed
their execution.  Some hints for program structuring that will best use
the indexing facility are given below.  Note that interpreted, e.g.
dynamic, predicates as well as compiled predicates are indexed.  The
programming hints given in this section apply equally to compiled and to
interpreted code.


File: sicstus.info,  Node: Data Tables,  Next: Determinacy Detection,  Prev: Indexing Overview,  Up: Indexing

9.5.2 Data Tables
-----------------

The major advantage of indexing is that it provides fast access to
tables of data.  For example, a table of employee records might be
represented as shown below in order to gain fast access to the records
by employee name:

     %  employee(LastName,FirstNames,Department,Salary,DateOfBirth)

     employee('Smith', ['John'], sales,       20000, 1-1-59).
     employee('Jones', ['Mary'], engineering, 30000, 5-28-56).
     ...

   If fast access to the data via department is also desired, then the
data can be organized little differently.  The employee records can be
indexed by some unique identifier, such as employee number, and
additional tables can be created to facilitate access to this table, as
shown in the example below.  For example,

     %  employee(Id,LastName,FirstNames,Department,Salary,DateOfBirth)

     employee(1000000, 'Smith', ['John'], sales,       20000, 1-1-59).
     employee(1000020, 'Jones', ['Mary'], engineering, 30000, 5-28-56).
     ...

     %  employee_name(LastName,EmpId)

     employee_name('Smith', 1000000).
     employee_name('Jones', 1000020).
     ...

     %  department_member(Department,EmpId)

     department_member(sales,       1000000).
     department_member(engineering, 1000020).
     ...

   Indexing would now allow fast access to the records of every employee
named Smith, and these could then be backtracked through looking for
John Smith.  For example:
     | ?- employee_name('Smith', Id),
          employee(Id, 'Smith', ['John'], Dept, Sal, DoB).

   Similarly, all the members of the engineering department born since
1965 could be efficiently found like this:
     | ?- department_member(engineering, Id),
          employee(Id, LN, FN, engineering, _, M-D-Y), 
          Y > 65.


File: sicstus.info,  Node: Determinacy Detection,  Prev: Data Tables,  Up: Indexing

9.5.3 Determinacy Detection
---------------------------

The other advantage of indexing is that it often makes possible early
detection of determinacy, even if cuts are not included in the program.
For example, consider the following simple predicate, which joins two
lists together:

     concat([], L, L).
     concat([X|L1], L2, [X|L3]) :- concat(L1, L2, L3).

   If this predicate is called with an instantiated first argument, then
the first argument indexing of SICStus Prolog will recognize that the
call is determinate--only one of the two clauses for 'concat/3' can
possibly apply.  Thus, the Prolog system knows it does not have to store
backtracking information for the call.  This significantly reduces
memory use and execution time.

   Determinacy detection can also reduce the number of cuts in
predicates.  In the above example, if there was no indexing, then a cut
would not strictly be needed in the first clause as long as the
predicate was always to be called with the first argument instantiated.
If the first clause matched, then the second clause could not possibly
match; discovery of this fact, however, would be postponed until
backtracking.  The programmer might thus be tempted to use a cut in the
first clause to signal determinacy and recover space for backtracking
information as early as possible.

   With indexing, if the example predicate is always called with its
first argument instantiated, then backtracking information is _never_
stored.  This gives substantial performance improvements over using a
cut rather than indexing to force determinacy.  At the same time greater
flexibility is maintained: the predicate can now be used in a
nondeterminate fashion as well, as in
     | ?- concat(L1, L2, [a,b,c,d]).

which will generate on backtracking all the possible partitions of the
list '[a,b,c,d]' on backtracking.  If a cut had been used in the first
clause, then this would not work.

   For interpreted code, but not for compiled code, a filtering similar
to indexing is done for _all_ argument positions.  The primary benefit
of this filtering is that it makes it possible to detect determinacy in
more cases.  This filtering is currently not using hashing techniques,
so it is not as performant as the first argument indexing.

   We may improve indexing and other filtering techniques in future
releases, which may decrease the number of choicepoints created.


File: sicstus.info,  Node: Last Clause Determinacy Detection,  Next: The Determinacy Checker,  Prev: Indexing,  Up: Writing Efficient Programs

9.6 Last Clause Determinacy Detection
=====================================

Even if the determinacy detection made possible by indexing is
unavailable to a predicate call, SICStus Prolog still can detect
determinacy before determinate exit from the predicate.  Space for
backtracking information can thus be recovered as early as possible,
reducing memory requirements and increasing performance.  For instance,
the predicate 'member/2' (found in the SICStus Prolog library) could be
defined by:
     member(Element, [Element|_]).
     member(Element, [_|Rest]) :-
             member(Element, Rest).

   'member/2' might be called with an instantiated first argument in
order to check for membership of the argument in a list, which is passed
as a second argument, as in
     | ?- member(4, [1,2,3,4]).

   The first arguments of both clauses of 'member/2' are variables, so
first argument indexing cannot be used.  However, determinacy can still
be detected before determinate exit from the predicate.  This is because
on entry to the last clause of a nondeterminate predicate, a call
becomes effectively determinate; it can tell that it has no more clauses
to backtrack to.  Thus, backtracking information is no longer needed,
and its space can be reclaimed.  In the example, each time a call fails
to match the first clause and backtracks to the second (last) clause,
backtracking information for the call is automatically deleted.

   Because of last clause determinacy detection, a cut is never needed
as the first subgoal in the last clause of a predicate.  Backtracking
information will have been deleted before a cut in the last clause is
executed, so the cut will have no effect except to waste time.

   Note that last clause determinacy detection is exploited by dynamic
code as well as static code in SICStus Prolog.


File: sicstus.info,  Node: The Determinacy Checker,  Next: Last Call Optimization,  Prev: Last Clause Determinacy Detection,  Up: Writing Efficient Programs

9.7 The Determinacy Checker
===========================

*Please note:* the Determinacy Checker tool is mostly superseeded by the
analysis performed by the SICStus Prolog IDE, SPIDER (*note SICStus
Prolog IDE: SPIDER.).  SPIDER will analyze the source code fully
automatically and will annotate the edited source code to highlight
unwanted non-determinism.  The analysis performed by SPIDER is more
precise than the analysis implemented by the determinism checker
described below.

   The determinacy checker can help you spot unwanted nondeterminacy in
your programs.  This tool examines your program source code and points
out places where nondeterminacy may arise.  It is not in general
possible to find exactly which parts of a program will be nondeterminate
without actually running the program, best with the execution profiler,
which endeavors to find exactly those parts.  However, this tool can
find most unwanted nondeterminacy.  Unintended nondeterminacy should be
eradicated because:

  1. it may give you wrong answers on backtracking
  2. it may cause a lot of memory to be wasted

* Menu:

* Using the Determinacy Checker:: Using the Determinacy Checker
* Declaring Nondeterminacy:: Declaring Nondeterminacy
* Checker Output:: Checker Output
* Det Example:: Example
* Det Options:: Options
* What is Detected:: What is Detected


File: sicstus.info,  Node: Using the Determinacy Checker,  Next: Declaring Nondeterminacy,  Up: The Determinacy Checker

9.7.1 Using the Determinacy Checker
-----------------------------------

There are two different ways to use the determinacy checker, either as a
stand-alone tool, or during compilation.  You may use it whichever way
fits best with the way you work.  Either way, it will discover the same
nondeterminacy in your program.

   The stand-alone determinacy checker is called 'spdet', and is run
from the shell prompt, specifying the names of the Prolog source files
you wish to check.

   The determinacy checker can also be integrated into the compilation
process, so that you receive warnings about unwanted nondeterminacy
along with warnings about singleton variables or discontiguous clauses.
To make this happen, simply insert the line
     :- load_files(library(detcheck),
                   [when(compile_time), if(changed)]).

   Once this line is added, every time that file is loaded, it will be
checked for unwanted nondeterminacy.


File: sicstus.info,  Node: Declaring Nondeterminacy,  Next: Checker Output,  Prev: Using the Determinacy Checker,  Up: The Determinacy Checker

9.7.2 Declaring Nondeterminacy
------------------------------

Some predicates are intended to be nondeterminate.  By declaring
intended nondeterminacy, you avoid warnings about predicates you intend
to be nondeterminate.  Equally importantly, you also inform the
determinacy checker about nondeterminate predicates.  It uses this
information to identify unwanted nondeterminacy.

   Nondeterminacy is declared by putting a declaration of the form

     :- NAME/ARITY is nondet.
using the 'is/2'-declarations introduced in SICStus Prolog 4.2.1,

   or the legacy form
     :- nondet NAME/ARITY.

in your source file.  This is similar to a 'dynamic' or 'discontiguous'
declaration.  You may have multiple 'nondet' declarations, and a single
declaration may mention several predicates, separating them by commas.

   Similarly, a predicate P/N may be classified as nondeterminate by the
checker, whereas in reality it is determinate.  This may happen e.g. if
P/N calls a dynamic predicate that in reality never has more than one
clause.  To prevent false alarms arising from this, you can inform the
checker about determinate predicates by declarations of the form:

     :- NAME/ARITY is det.
using the 'is/2'-declarations introduced in SICStus Prolog 4.2.1,

   or the legacy form
     :- det NAME/ARITY.

   If you wish to include the legacy 'det' and 'nondet' declarations in
your file and you plan to use the stand-alone determinacy checker, then
you must include the line
     :- load_files(library(nondetdecl),
                   [when(compile_time), if(changed)]).

near the top of each file that contains such declarations.  If you
instead use the recommended 'is/2'-declarations, or the integrated
determinacy checker, then you do not need (and should not have) this
line.


File: sicstus.info,  Node: Checker Output,  Next: Det Example,  Prev: Declaring Nondeterminacy,  Up: The Determinacy Checker

9.7.3 Checker Output
--------------------

The output of the determinacy checker is quite simple.  For each clause
containing unexpected nondeterminacy, a single line is printed showing
the module, name, arity, and clause number (counting from 1).  The form
of the information is:
     * Non-determinate: MODULE:NAME/ARITY (clause NUMBER)

   A second line for each nondeterminate clause indicates the cause of
the nondeterminacy.  The recognized causes are:

   * The clause contains a disjunction that is not forced to be
     determinate with a cut or by ending the clause with a call to
     'fail/0' or 'raise_exception/1'.

   * The clause calls a nondeterminate predicate.  In this case the
     predicate is named.

   * There is a later clause for the same predicate whose first argument
     has the same principal functor (or one of the two clauses has a
     variable for the first argument), and this clause does not contain
     a cut or end with a call to 'fail/0' or 'raise_exception/1'.  In
     this case, the clause number of the other clause is mentioned.

   * If the predicate is multifile, then clause indexing is not
     considered sufficient to ensure determinacy.  This is because other
     clauses may be added to the predicate in other files, so the
     determinacy checker cannot be sure it has seen all the clauses for
     the predicate.  It is good practice to include a cut (or fail) in
     every clause of a multifile predicate.

   The determinacy checker also occasionally prints warnings when
declarations are made too late in the file or not at all.  For example,
if you include a 'dynamic', 'nondet', or 'discontiguous' declaration for
a predicate after some clauses for that predicate, or if you put a
'dynamic' or 'nondet' declaration for a predicate after a clause that
includes a call to that predicate, then the determinacy checker may have
missed some nondeterminacy in your program.  The checker also detects
undeclared discontiguous predicates, which may also have undetected
nondeterminacy.  Finally, the checker looks for goals in your program
that indicate that predicates are dynamic; if no 'dynamic' declaration
for those predicates exists, then you will be warned.

   These warnings take the following form:
     ! warning: predicate module:name/arity is PROPERTY.
     !          Some nondeterminacy may have been missed.
     !          Add (or move) the directive
     !              :- PROPERTY module:name/arity.
     !          near the top of this file.


File: sicstus.info,  Node: Det Example,  Next: Det Options,  Prev: Checker Output,  Up: The Determinacy Checker

9.7.4 Example
-------------

Here is an example file:
     :- load_files(library(detcheck),
                   [when(compile_time), if(changed)]).

     parent(abe, rob).
     parent(abe, sam).
     parent(betty, rob).
     parent(betty, sam).

     is_parent(Parent) :- parent(Parent, _).

   The determinacy checker notices that the first arguments of clauses 1
and 2 have the same principal functor, and similarly for clauses 3 and
4.  It reports:
     * Non-determinate: user:parent/2 (clause 1)
     *     Indexing cannot distinguish this from clause 2.
     * Non-determinate: user:parent/2 (clause 3)
     *     Indexing cannot distinguish this from clause 4.

   In fact, 'parent/2' should be nondeterminate, so we should add the
declaration
     :- parent/2 is nondet.
before the clauses for 'parent/2'.  If run again after modifying file,
then the determinacy checker prints:
     * Non-determinate: user:is_parent/1 (clause 1)
     *     This clause calls user:parent/2, which may be nondeterminate.

   It no longer complains about 'parent/2' being nondeterminate, since
this is declared.  But now it notices that because 'parent/2' is
nondeterminate, then so is 'is_parent/1'.


File: sicstus.info,  Node: Det Options,  Next: What is Detected,  Prev: Det Example,  Up: The Determinacy Checker

9.7.5 Options
-------------

When run from the command line, the determinacy checker has a few
options to control its workings.

   The '-r' option specifies that the checker should recursively check
files in such a way that it finds nondeterminacy caused by calls to
other nondeterminate predicates, whether they are declared so or not.
Also, predicates that appear to be determinate will be treated as such,
whether declared 'nondet' or not.  This option is quite useful when
first running the checker on a file, as it will find all predicates that
should be either made determinate or declared 'nondet' at once.  Without
this option, each time a 'nondet' declaration is added, the checker may
find previously unnoticed nondeterminacy.

   For example, if the original example above, without any 'nondet'
declarations, were checked with the '-r' option, then the output would
be:
     * Non-determinate: user:parent/2 (clause 1)
     *     Indexing cannot distinguish this from clause 2.
     * Non-determinate: user:parent/2 (clause 3)
     *     Indexing cannot distinguish this from clause 4.
     * Non-determinate: user:is_parent/1 (clause 1)
     *     Calls nondet predicate user:parent/2.

   The '-d' option causes the tool to print out the needed 'nondet'
declarations.  These can be readily pasted into the source files.  Note
that it only prints the 'nondet' declarations that are not already
present in the files.  However, these declarations should not be pasted
into your code without each one first being checked to see if the
reported nondeterminacy is intended.

   The '-D' option is like '-d', except that it prints out all 'nondet'
declarations that should appear, whether they are already in the file or
not.  This is useful if you prefer to replace all old 'nondet'
declarations with new ones.

   Your code will probably rely on operator declarations and possibly
term expansion.  The determinacy checker handles this in the following
way: you must supply an initialization file, using the '-i' IFILE
option.  'spdet' will execute any operator declaration it encounters.


File: sicstus.info,  Node: What is Detected,  Prev: Det Options,  Up: The Determinacy Checker

9.7.6 What is Detected
----------------------

As mentioned earlier, it is not in general possible to find exactly
which places in a program will lead to nondeterminacy.  The determinacy
checker gives predicates the benefit of the doubt: when it is possible
that a predicate will be determinate, it will not be reported.  The
checker will only report places in your program that will be
nondeterminate regardless of which arguments are bound.  Despite this,
the checker catches most unwanted nondeterminacy in practice.

   The determinacy checker looks for the following sources of
nondeterminacy:

   * Multiple clauses that cannot be distinguished by the principal
     functor of the first arguments, and are not made determinate with
     an explicit cut, 'fail/0', 'false/0', or 'raise_exception/1'.
     First argument indexing is not considered for multifile predicates,
     because another file may have a clause for this predicate with the
     same principal functor of its first argument.

   * A clause with a disjunction not forced to be determinate by a cut,
     'fail/0', 'false/0', or 'raise_exception/1' in each arm of the
     disjunction but the last, or where the whole disjunction is
     followed by a cut, 'fail/0', 'false/0', or 'raise_exception/1'.

   * A clause that calls something known to be nondeterminate, other
     than when it is followed by a cut, 'fail/0', 'false/0', or
     'raise_exception/1', or where it appears in the condition of an
     if-then-else construct.  Known nondeterminate predicates include
     hooks and those declared nondeterminate or dynamic (since they can
     be modified, dynamic predicates are assumed to be nondeterminate),
     plus the following built-in predicates:

        - 'absolute_file_name/3', when the options list contains
          'solutions(all)'.

        - 'atom_concat/3', when the first two arguments are variables
          not appearing earlier in the clause (including the clause
          head).

        - 'bagof/3', when the second argument contains any variables not
          appearing earlier in the clause (including the clause head).

        - 'clause/[2,3]'.

        - 'current_op/3', when any argument contains any variables not
          appearing earlier in the clause (including the clause head).

        - 'current_key/2', when the second argument contains any
          variables not appearing earlier in the clause (including the
          clause head).

        - 'current_predicate/2', when the second argument contains any
          variables not appearing earlier in the clause (including the
          clause head).

        - 'length/2', when both arguments are variables not appearing
          earlier in the clause (including the clause head).

        - 'predicate_property/2', when either argument contains any
          variables not appearing earlier in the clause (including the
          clause head).

        - 'recorded/3'.

        - 'repeat/0'.

        - 'retract/1'.

        - 'setof/3', when the second argument contains any variables not
          appearing earlier in the clause (including the clause head).

        - 'source_file/[1,2]' when the last argument contains any
          variables not appearing earlier in the clause (including the
          clause head).

        - 'sub_atom/5', when at least two of the second, fourth and
          fifth arguments are variables not appearing earlier in the
          clause (including the clause head).


File: sicstus.info,  Node: Last Call Optimization,  Next: Building and Dismantling Terms,  Prev: The Determinacy Checker,  Up: Writing Efficient Programs

9.8 Last Call Optimization
==========================

Another important efficiency feature of SICStus Prolog is last call
optimization.  This is a space optimization technique, which applies
when a predicate is determinate at the point where it is about to call
the last goal in the body of a clause.  For example,
     % for(Int, Lower, Upper)
     % Lower and Upper should be integers such that Lower =< Upper.
     % Int should be uninstantiated; it will be bound successively on
     % backtracking to Lower, Lower+1, ... Upper.

     for(Int, Int, _Upper).
     for(Int, Lower, Upper) :-
             Lower < Upper,
             Next is Lower + 1,
             for(Int, Next, Upper).

   This predicate is determinate at the point where the recursive call
is about to be made, since this is the last clause and the preceding
goals '(<)/2' and 'is/2') are determinate.  Thus last call optimization
can be applied; effectively, the stack space being used for the current
predicate call is reclaimed before the recursive call is made.  This
means that this predicate uses only a constant amount of space, no
matter how deep the recursion.

* Menu:

* Accumulating Parameters:: Accumulating Parameters
* Accumulating Lists:: Accumulating Lists


File: sicstus.info,  Node: Accumulating Parameters,  Next: Accumulating Lists,  Up: Last Call Optimization

9.8.1 Accumulating Parameters
-----------------------------

To take best advantage of this feature, make sure that goals in
recursive predicates are determinate, and whenever possible put the
recursive call at the end of the predicate.

   This is not always possible, but often can be done through the use of
"accumulating parameters".  An accumulating parameter is an added
argument to a predicate that builds up the result as computation
proceeds.  For example, in our factorial example, the last goal in the
body of the recursive case is 'is/2', not the recursive call to 'fac/2'.

     fac(N, X) :-
         (   N > 0 ->
                 N1 is N - 1,
                 fac(N1, Y),
                 X is N * Y
         ;   N =:= 0 ->
                 X = 1
         ).

   This can be corrected by adding another argument to 'fac/2' to
accumulate the factorial.

     fac(N, X) :- fac(N, 1, X).

     %  fac(+N, +M, -X)
     %  X is M * the factorial of N.

     fac(N, M, X) :-
         (   N > 0 ->
                 N1 is N - 1,
                 M1 is N * M,
                 fac(N1, M1, X)
         ;   N =:= 0 ->
                 X = M
         ).

   Here, we do the multiplication before calling 'fac/3' recursively.
Note that we supply the base case, 1, at the start of the computation,
and that we are multiplying by decreasing numbers.  In the earlier
version, 'fac/2', we multiply after the recursive call, and so we
multiply by increasing numbers.  Effectively, the new version builds the
result backwards.  This is correct because multiplication is
associative.


File: sicstus.info,  Node: Accumulating Lists,  Prev: Accumulating Parameters,  Up: Last Call Optimization

9.8.2 Accumulating Lists
------------------------

This technique becomes much more important when extended to lists, as in
this case it can save much building of unneeded lists through
unnecessary calls to append sublists together.  For example, the naive
way to reverse a list is:

     nreverse([], []).
     nreverse([H|T], L) :-
             nreverse(T, L1),
             append(L1, [H], L).

   This is very wasteful, since each call to 'append/3' copies the
initial part of the list, and adds one element to it.  Fortunately, this
can be very easily rewritten to use an accumulating parameter:

     reverse(L1, L2) :- reverse(L1, [], L2).

     %  reverse(+X, +Y, -Z)
     %  Z is X reversed, followed by Y
     reverse([], Z, Z).
     reverse([H|T], L0, L) :-
             reverse(T, [H|L0], L).

   This version of reverse is many times faster than the naive version,
and uses much less memory.  The key to understanding the behavior of
this predicate is the observation made earlier: using an accumulating
parameter, we build the result backwards.

   Do Not let this confuse you.  Building a list forward is easy.  For
example, a predicate returning a list L of consecutive numbers from 1 to
N could be written in two different ways: counting up and collecting the
resulting list forward, or counting down and accumulating the result
backward.

     iota1(N, L) :- iota1(1, N, L).
     iota1(N, Max, L) :-
             (   N > Max ->
                     L = []
             ;   N1 is N+1,
                 L = [N|L1],
                 iota1(N1, Max, L1)
             ).
or,

     iota2(N, L) :- iota2(N, [], L).
     iota2(N, L0, L) :-
             (   N =< 0 ->
                     L = L0
             ;   N1 is N-1,
                 iota2(N1, [N|L0], L)
             ).

   Both versions generate the same results, and neither waste any space.
The second version is slightly faster.  Choose whichever approach you
prefer.


File: sicstus.info,  Node: Building and Dismantling Terms,  Next: Conditionals and Disjunction,  Prev: Last Call Optimization,  Up: Writing Efficient Programs

9.9 Building and Dismantling Terms
==================================

The built-in predicate '(=..)/2' is a clear way of building terms and
taking them apart.  However, it is almost never the most efficient way.
'functor/3' and 'arg/3' are generally much more efficient, though less
direct.  The best blend of efficiency and clarity is to write a
clearly-named predicate that implements the desired operation and to use
'functor/3' and 'arg/3' in that predicate.

   Here is an actual example.  The task is to reimplement the built-in
predicate '(==)/2'.  The first variant uses '(=..)/2' (this symbol is
pronounced "univ" for historical reasons).  Some Prolog textbooks
recommend code similar to this.
     ident_univ(X, Y) :-
             var(X),                 % If X is a variable,
             !,
             var(Y),                 % so must Y be, and
             samevar(X, Y).          % they must be the same.
     ident_univ(X, Y) :-             % If X is not a variable,
             nonvar(Y),              % neither may Y be;
             X =.. [F|L],            % they must have the
             Y =.. [F|M],            % same function symbol F
             ident_list(L, M).       % and identical arguments

     ident_list([], []).
     ident_list([H1|T1], [H2|T2]) :-
             ident_univ(H1, H2),
             ident_list(T1, T2).

     samevar(29, Y) :-               % If binding X to 29
             var(Y),                 % leaves Y unbound,
             !,                      % they were not the same
             fail.                   % variable.
     samevar(_, _).                  % Otherwise they were.

   This code performs the function intended; however, every time it
touches a non-variable term of arity N, it constructs a list with N+1
elements, and if the two terms are identical, then these lists are
reclaimed only when backtracked over or garbage collected.

   Better code uses 'functor/3' and 'arg/3'.
     ident_farg(X, Y) :-
             (   var(X) ->           % If X is a variable,
                     var(Y),         % so must Y be, and
                     samevar(X, Y)   % they must be the same;
             ;   nonvar(Y),          % otherwise Y must be nonvar
                 functor(X, F, N),   % The principal functors of X
                 functor(Y, F, N),   % and Y must be identical,
                 ident_farg(N, X, Y) % including the last N args.
             ).

     ident_farg(0, _, _) :- !.
     ident_farg(N, X, Y) :-          % The last N arguments are
             arg(N, X, Xn),          % identical
             arg(N, Y, Yn),          % if the Nth arguments
             ident_farg(Xn, Yn),     % are identical,
             M is N-1,               % and the last N-1 arguments
             ident_farg(M, X, Y).    % are also identical.

   This approach to walking through terms using 'functor/3' and 'arg/3'
avoids the construction of useless lists.

   The pattern shown in the example, in which a predicate of arity K
calls an auxiliary predicate of the same name of arity K+1 (the
additional argument denoting the number of items remaining to process),
is very common.  It is not necessary to use the same name for this
auxiliary predicate, but this convention is generally less prone to
confusion.

   In order to simply find out the principal function symbol of a term,
use
     | ?- THE_TERM_IS(Term),
     |    functor(Term, FunctionSymbol, _).

   The use of '(=..)/2', as in
     | ?- THE_TERM_IS(Term),
     |    Term =.. [FunctionSymbol|_].
is wasteful, and should generally be avoided.  The same remark applies
if the arity of a term is desired.

   '(=..)/2' should not be used to locate a particular argument of some
term.  For example, instead of
     Term =.. [_F,_,ArgTwo|_]
you should write
     arg(2, Term, ArgTwo)

   It is generally easier to get the explicit number "2" right than to
write the correct number of anonymous variables in the call to
'(=..)/2'.  Other people reading the program will find the call to
'arg/3' a much clearer expression of the program's intent.  The program
will also be more efficient.  Even if several arguments of a term must
be located, it is clearer and more efficient to write
     arg(1, Term, First),
     arg(3, Term, Third),
     arg(4, Term, Fourth)
than to write
     Term =.. [_,First,_,Third,Fourth|_]

   Finally, '(=..)/2' should not be used when the functor of the term to
be operated on is known (that is, when both the function symbol and the
arity are known).  For example, to make a new term with the same
function symbol and first arguments as another term, but one additional
argument, the obvious solution might seem to be to write something like
the following:
     add_date(OldItem, Date, NewItem) :-
             OldItem =.. [item,Type,Ship,Serial],
             NewItem =.. [item,Type,Ship,Serial,Date].

   However, this could be expressed more clearly and more efficiently as
     add_date(OldItem, Date, NewItem) :-
             OldItem = item(Type,Ship,Serial),
             NewItem = item(Type,Ship,Serial,Date).
or even
     add_date(item(Type,Ship,Serial),
              Date,
              item(Type,Ship,Serial,Date)
             ).


File: sicstus.info,  Node: Conditionals and Disjunction,  Next: Programming Examples,  Prev: Building and Dismantling Terms,  Up: Writing Efficient Programs

9.10 Conditionals and Disjunction
=================================

There is an efficiency advantage in using conditionals whose test part
consists only of arithmetic comparisons or type tests.  Consider the
following alternative definitions of the predicate
'type_of_character/2'.  In the first definition, four clauses are used
to group characters on the basis of arithmetic comparisons.

     type_of_character(Ch, Type) :-
             Ch >= "a", Ch =< "z",
             !,
             Type = lowercase.
     type_of_character(Ch, Type) :-
             Ch >= "A", Ch =< "Z",
             !,
             Type = uppercase.
     type_of_character(Ch, Type) :-
             Ch >= "0", Ch =< "9",
             !,
             Type = digit.
     type_of_character(_Ch, Type) :-
             Type = other.

   In the second definition, a single clause with a conditional is used.
The compiler generates equivalent, optimized code for both versions.

     type_of_character(Ch, Type) :-
             (   Ch >= "a", Ch =< "z" ->
                     Type = lowercase
             ;   Ch >= "A", Ch =< "Z" ->
                     Type = uppercase
             ;   Ch >= "0", Ch =< "9" ->
                     Type = digit
             ;   otherwise ->
                     Type = other
             ).

   Following is a list of built-in predicates that are compiled
efficiently in conditionals:

   * 'atom/1'
   * 'atomic/1'
   * 'callable/1'
   * 'compound/1'
   * 'db_reference/1'
   * 'float/1'
   * 'ground/1'
   * 'integer/1'
   * 'nonvar/1'
   * 'mutable/1'
   * 'number/1'
   * 'simple/1'
   * 'var/1'
   * '</2'
   * '=</2'
   * '=:=/2'
   * '=\=/2'
   * '>=/2'
   * '>/2'
   * '@</2'
   * '@=</2'
   * '==/2'
   * '\==/2'
   * '@>=/2'
   * '@>/2'

   This optimization is actually somewhat more general than what is
described above.  A sequence of guarded clauses:

     HEAD1 :- GUARD1, !, BODY1.
     ...
     HEADM :- GUARDM, !, BODYM.
     HEADN :- BODYM.

is eligible for the same optimization, provided that the arguments of
the clause heads are all unique variables and that the "guards" are
simple tests as listed above.


File: sicstus.info,  Node: Programming Examples,  Next: The Cross-Referencer,  Prev: Conditionals and Disjunction,  Up: Writing Efficient Programs

9.11 Programming Examples
=========================

The rest of this chapter contains a number of simple examples of Prolog
programming, illustrating some of the techniques described above.

* Menu:

* Simple List:: Simple List Processing
* Family Example:: Family Example (descendants)
* Association Lists:: Association List Primitives
* Derivative:: Differentiation
* Use Of Meta:: Use of Meta-Logical Predicates
* Interpreter:: Prolog in Prolog
* Translate:: Translating English Sentences into Logic Formulae


File: sicstus.info,  Node: Simple List,  Next: Family Example,  Up: Programming Examples

9.11.1 Simple List Processing
-----------------------------

The goal 'concatenate(L1,L2,L3)' is true if list L3 consists of the
elements of list L1 concatenated with the elements of list L2.  The goal
'member(X,L)' is true if X is one of the elements of list L.  The goal
'reverse(L1,L2)' is true if list L2 consists of the elements of list L1
in reverse order.

     concatenate([], L, L).
     concatenate([X|L1], L2, [X|L3]) :- concatenate(L1, L2, L3).

     member(X, [X|_]).
     member(X, [_|L]) :- member(X, L).

     reverse(L, L1) :- reverse_concatenate(L, [], L1).

     reverse_concatenate([], L, L).
     reverse_concatenate([X|L1], L2, L3) :-
             reverse_concatenate(L1, [X|L2], L3).


File: sicstus.info,  Node: Family Example,  Next: Association Lists,  Prev: Simple List,  Up: Programming Examples

9.11.2 Family Example (descendants)
-----------------------------------

The goal 'descendant(X,Y)' is true if Y is a descendant of X.

     descendant(X, Y) :- offspring(X, Y).
     descendant(X, Z) :- offspring(X, Y), descendant(Y, Z).

     offspring(abraham, ishmael).
     offspring(abraham, isaac).
     offspring(isaac, esau).
     offspring(isaac, jacob).

   If for example the query

     | ?- descendant(abraham, X).

is executed, then Prolog's backtracking results in different descendants
of Abraham being returned as successive instances of the variable X,
i.e.

     X = ishmael
     X = isaac
     X = esau
     X = jacob


File: sicstus.info,  Node: Association Lists,  Next: Derivative,  Prev: Family Example,  Up: Programming Examples

9.11.3 Association List Primitives
----------------------------------

These predicates implement "association list" primitives.  They use a
binary tree representation.  Thus the time complexity for these
predicates is O(LG N), where N is the number of keys.  These predicates
also illustrate the use of 'compare/3' for case analysis.

   The goal 'get_assoc(KEY, ASSOC, VALUE)' is true when KEY is identical
to one of the keys in ASSOC, and VALUE unifies with the associated
value.

     get_assoc(Key, t(K,V,L,R), Val) :-
             compare(Rel, Key, K),
             get_assoc(Rel, Key, V, L, R, Val).

     get_assoc(=, _, Val, _, _, Val).
     get_assoc(<, Key, _, Tree, _, Val) :-
             get_assoc(Key, Tree, Val).
     get_assoc(>, Key, _, _, Tree, Val) :-
             get_assoc(Key, Tree, Val).


File: sicstus.info,  Node: Derivative,  Next: Use Of Meta,  Prev: Association Lists,  Up: Programming Examples

9.11.4 Differentiation
----------------------

The goal 'd(E1, X, E2)' is true if expression E2 is a possible form for
the derivative of expression E1 with respect to X.

     d(X, X, D) :- atomic(X), !, D = 1.
     d(C, X, D) :- atomic(C), !, D = 0.
     d(U+V, X, DU+DV) :- d(U, X, DU), d(V, X, DV).
     d(U-V, X, DU-DV) :- d(U, X, DU), d(V, X, DV).
     d(U*V, X, DU*V+U*DV) :- d(U, X, DU), d(V, X, DV).
     d(U**N, X, N*U**N1*DU) :- integer(N), N1 is N-1, d(U, X, DU).
     d(-U, X, -DU) :- d(U, X, DU).


File: sicstus.info,  Node: Use Of Meta,  Next: Interpreter,  Prev: Derivative,  Up: Programming Examples

9.11.5 Use of Meta-Logical Predicates
-------------------------------------

This example illustrates the use of the meta-logical predicates 'var/1',
'arg/3', and 'functor/3'.  The goal 'variables(TERM, L, [])'
instantiates variable L to a list of all the variable occurrences in
TERM.  E.g.:

     | ?- variables(d(U*V, X, DU*V+U*DV), L, []).

     L = [U,V,X,DU,V,U,DV]

     variables(X, [X|L0], L) :- var(X), !, L = L0.
     variables(T, L0, L) :-
     %       nonvar(T),
             functor(T, _, A),
             variables(0, A, T, L0, L).

     variables(A, A, _, L0, L) :- !, L = L0.
     variables(A0, A, T, L0, L) :-
     %       A0<A,
             A1 is A0+1,
             arg(A1, T, X),
             variables(X, L0, L1),
             variables(A1, A, T, L1, L).


File: sicstus.info,  Node: Interpreter,  Next: Translate,  Prev: Use Of Meta,  Up: Programming Examples

9.11.6 Prolog in Prolog
-----------------------

This example shows how simple it is to write a Prolog interpreter in
Prolog, and illustrates the use of a variable goal.  In this
mini-interpreter, goals and clauses are represented as ordinary Prolog
data structures (i.e. terms).  Terms representing clauses are specified
using the predicate 'my_clause/1', e.g.:

     my_clause( (grandparent(X, Z) :- parent(X, Y), parent(Y, Z)) ).

   A unit clause will be represented by a term such as

     my_clause( (parent(john, mary) :- true) ).

   The mini-interpreter consists of three clauses:

     execute((P,Q)) :- !, execute(P), execute(Q).
     execute(P) :- predicate_property(P, built_in), !, P.
     execute(P) :- my_clause((P :- Q)), execute(Q).

   The second clause enables the mini-interpreter to cope with calls to
ordinary Prolog predicates, e.g. built-in predicates.  The
mini-interpreter needs to be extended to cope with the other control
structures, i.e. '!', '(P;Q)', '(P->Q)', '(P->Q;R)', '(\+ P)', and
'if(P,Q,R)'.


File: sicstus.info,  Node: Translate,  Prev: Interpreter,  Up: Programming Examples

9.11.7 Translating English Sentences into Logic Formulae
--------------------------------------------------------

The following example of a definite clause grammar defines in a formal
way the traditional mapping of simple English sentences into formulae of
classical logic.  By way of illustration, if the sentence

     Every man that lives loves a woman.

is parsed as a sentence by the call

     | ?- phrase(sentence(P), [every,man,that,lives,loves,a,woman]).

then P will get instantiated to

     all(X):(man(X)&lives(X) => exists(Y):(woman(Y)&loves(X,Y)))

where ':', '&' and '=>' are infix operators defined by

     :- op(900, xfx, =>).
     :- op(800, xfy, &).
     :- op(550, xfy, :). /* predefined */

   The grammar follows:

     sentence(P) --> noun_phrase(X, P1, P), verb_phrase(X, P1).

     noun_phrase(X, P1, P) -->
             determiner(X, P2, P1, P), noun(X, P3), rel_clause(X, P3, P2).
     noun_phrase(X, P, P) --> name(X).

     verb_phrase(X, P) --> trans_verb(X, Y, P1), noun_phrase(Y, P1, P).
     verb_phrase(X, P) --> intrans_verb(X, P).

     rel_clause(X, P1, P1&P2) --> [that], verb_phrase(X, P2).
     rel_clause(_, P, P) --> [].

     determiner(X, P1, P2, all(X):(P1=>P2)) --> [every].
     determiner(X, P1, P2, exists(X):(P1&P2)) --> [a].

     noun(X, man(X)) --> [man].
     noun(X, woman(X)) --> [woman].

     name(john) --> [john].

     trans_verb(X, Y, loves(X,Y)) --> [loves].
     intrans_verb(X, lives(X)) --> [lives].


File: sicstus.info,  Node: The Cross-Referencer,  Prev: Programming Examples,  Up: Writing Efficient Programs

9.12 The Cross-Referencer
=========================

* Menu:

* Xref Introduction:: Introduction
* Xref Practice and Experience:: Practice and Experience


File: sicstus.info,  Node: Xref Introduction,  Next: Xref Practice and Experience,  Up: The Cross-Referencer

9.12.1 Introduction
-------------------

*Please note:* the Cross-References tool is mostly superseeded by the
SICStus Prolog IDE, SPIDER (*note SICStus Prolog IDE: SPIDER.).  SPIDER
will analyze the source code fully automatically and will annotate the
edited source code to highlight unused and undefined predicates.  The
cross-reference analysis performed by SPIDER is more precise than the
analysis implemented by the cross-referencer described below.

   The main purpose of the cross-referencer, 'spxref', is to find
undefined predicates and unreachable code.  To this end, it begins by
looking for initializations, hooks and 'public' directives to start
tracing the reachable code from.  If an entire application is being
checked, then it also traces from 'user:runtime_entry/1'.  If individual
module-files are being checked, then it also traces from their export
lists.

   A second function of 'spxref' is to aid in the formation of module
statements.  'spxref' can list all of the required 'module/2' and
'use_module/2' statements by file.

   The cross-referencer is called 'spxref', and is run from the shell
prompt, specifying the names of the Prolog source files you wish to
check.


File: sicstus.info,  Node: Xref Practice and Experience,  Prev: Xref Introduction,  Up: The Cross-Referencer

9.12.2 Practice and Experience
------------------------------

Your code will probably rely on operator declarations and possibly term
expansion.  The cross-referencer handles this in the following way: you
must supply an initialization file, using the '-i' IFILE option.
'spxref' will execute any operator declaration it encounters.

   Supply meta-predicate declarations for your meta-predicates.
Otherwise, the cross-referencer will not follow the meta-predicates'
arguments.  Be sure the cross-referencer encounters the meta-predicate
declarations _before_ it encounters calls to the declared predicates.

   The cross-referencer traces from initializations, hooks, predicates
declared 'public', and optionally from 'user:runtime_entry/1' and module
declarations.  The way it handles meta-predicates requires that your
application load its module-files before its non-module-files.

   This cross-referencer was written in order to tear out the copious
dead code from the application that the author became responsible for.
If you are doing such a thing, then the cross-referencer is an
invaluable tool.  Be sure to save the output from the first run that you
get from the cross referencer: this is very useful resource to help you
find things that you've accidentally ripped out and that you really
needed after all.

   There are situations where the cross-referencer does not follow
certain predicates.  This can happen if the predicate name is
constructed on the fly, or if it is retrieved from the database.  In
this case, add 'public' declarations for these.  Alternatively, you
could create term expansions that are peculiar to the cross-referencer.


File: sicstus.info,  Node: The Prolog Library,  Next: Prolog Reference Pages,  Prev: Writing Efficient Programs,  Up: Top

10 The Prolog Library
*********************

The Prolog library comprises a number of packages that are thought to be
useful in a number of applications.  Note that the predicates in the
Prolog library are not built-in predicates.  One has to explicitly load
each package to get access to its predicates.

   As opposed to built-in predicates, predicates exported by library
modules generally do not check their arguments, although some do to a
lesser or greater extent.  Input arguments that are lists are usually
supposed to be proper lists, i.e., not end with an unbound variable.
Input arguments that are trees are usually not supposed to have
uninstantiated leaves, and so on.

   To load a library package PACKAGE, you will normally enter a query:

     | ?- use_module(library(PACKAGE)).

   A library package normally consists of one or more hidden (*note
ref-mod::) modules.  The following packages are provided:

'aggregate (*note lib-aggregate::)'
     provides an aggregation operator for data-base-style queries.

'assoc (*note lib-assoc::)'
     uses unbalanced binary trees trees to implement "association
     lists", i.e. extendible finite mappings from terms to terms.

'atts (*note lib-atts::)'
     provides a means of associating with variables arbitrary
     attributes, i.e. named properties that can be used as storage
     locations as well as hooks into Prolog's unification.

'avl (*note lib-avl::)'
     uses AVL trees to implement "association lists", i.e. extendible
     finite mappings from terms to terms.

'bags (*note lib-bags::)'
     defines operations on bags, or multisets

'bdb (*note lib-bdb::)'
     provides an interface to Berkeley DB, for storage and retrieval of
     terms on disk files with user-defined multiple indexing.

'between (*note lib-between::)'
     provides some means of generating integers.

'chr (*note lib-chr::)'
     provides Constraint Handling Rules

'clpb (*note lib-clpb::)   since release 4.0.7,unsupported'
     provides constraint solving over Booleans

'clpfd (*note lib-clpfd::)'
     provides constraint solving over Finite (Integer) Domains

'clpq (*note lib-clpqr::)   unsupported'
'clpr (*note lib-clpqr::)   unsupported'
     provides constraint solving over Q (Rationals) or R (Reals)

'codesio (*note lib-codesio::)'
     defines I/O predicates that read from, or write to, a code-list.

'csv (*note lib-csv::)'
     defines I/O predicates that read from, or write to, comma-separated
     values (CSV) files and strings.

'comclient (*note lib-comclient::)'
     An interface to Microsoft COM automaton objects.

'fdbg (*note lib-fdbg::)'
     provides a debugger for finite domain constraint programs

'file_systems (*note lib-file_systems::)'
     accesses files and directories.

'gauge (*note lib-gauge::)'
     A profiling tool for Prolog programs with a graphical interface
     based on 'tcltk'.

'heaps (*note lib-heaps::)'
     implements binary heaps, the main application of which are priority
     queues.

'jasper (*note lib-jasper::)   since release 4.0.3'
     Access Prolog from Java.

'linda/client (*note lib-linda::)'
'linda/server (*note lib-linda::)'
     provides an implementation of the Linda concept for process
     communication.

'lists (*note lib-lists::)'
     provides basic operations on lists.

'logarr (*note lib-logarr::)'
     provides an implementation of extendible arrays with logarithmic
     access time.

'objects (*note lib-objects::)'
     provides a package for object-oriented programming, and can be
     regarded as a high-level alternative to 'library(structs)'.

'odbc (*note lib-odbc::)   since release 4.1'
     provides an interface to an ODBC database driver.

'ordsets (*note lib-ordsets::)'
     defines operations on sets represented as lists with the elements
     ordered in Prolog standard order.

'pillow (*note lib-pillow::)   unsupported'
     The PiLLoW Web Programming Library,

'plunit (*note lib-plunit::)   since release 4.1.3'
     A Prolog unit-test framework.

'process (*note lib-process::)'
     provides process creation primitives.

'prologbeans (*note lib-prologbeans::)'
     Access Prolog from Java and .NET.

'queues (*note lib-queues::)'
     defines operations on queues (FIFO stores of information).

'random (*note lib-random::)'
     provides a random number generator.

'rem (*note lib-rem::)'
     provides Rem's algorithm for maintaining equivalence classes.

'samsort (*note lib-samsort::)'
     provides generic stable sorting and merging.

'sets (*note lib-sets::)'
     defines operations on sets represented as lists with the elements
     unordered.

'sockets (*note lib-sockets::)'
     provides an interface to sockets.

'statistics (*note lib-statistics::)   since release 4.3.4'
     provides commonly used sample and population statistics functions.

'structs (*note lib-structs::)'
     provides access to C data structures, and can be regarded as a
     low-level alternative to 'library(objects)'.

'system (*note lib-system::)'
     provides access to operating system services.

'tcltk (*note lib-tcltk::)'
     An interface to the Tcl/Tk language and toolkit.

'terms (*note lib-terms::)'
     provides a number of operations on terms.

'timeout (*note lib-timeout::)'
     Meta-call with limit on execution time.

'trees (*note lib-trees::)'
     uses binary trees to represent non-extendible arrays with
     logarithmic access time.  The functionality is very similar to that
     of 'library(logarr)', but 'library(trees)' is slightly more
     efficient if the array does not need to be extendible.

'types (*note lib-types::)'
     Provides type checking.

'ugraphs (*note lib-ugraphs::)'
     Provides an implementation of directed and undirected graphs with
     unlabeled edges.

'varnumbers (*note lib-varnumbers::)'
     An inverse of 'numbervars/3'.

'wgraphs (*note lib-wgraphs::)'
     provides an implementation of directed and undirected graphs where
     each edge has an integral weight.

'xml (*note lib-xml::)'
     provides an XML parser.

'zinc (*note lib-zinc::)   since release 4.0.5'
     provides an interpreter for FlatZinc programs

   For the purpose of migrating code from release 3, the following
*deprecated* library modules are also provided.  For documentation,
please see the release 3 documentation for the corresponding library
module with the trailing '3' removed from its name:

'arrays3'
'assoc3'
'lists3'
'queues3'
'random3'
'system3'

* Menu:

* lib-aggregate:: 'library(aggregate)'
* lib-assoc:: 'library(assoc)'
* lib-atts:: 'library(atts)'
* lib-avl:: 'library(avl)'
* lib-bags:: 'library(bags)'
* lib-bdb:: 'library(bdb)'
* lib-between:: 'library(between)'
* lib-chr:: 'library(chr)'
* lib-clpb:: 'library(clpb)'
* lib-clpfd:: 'library(clpfd)'
* lib-clpqr:: 'library(clpq)', 'library(clpr)'
* lib-codesio:: 'library(codesio)'
* lib-csv:: 'library(csv)'
* lib-comclient:: 'library(comclient)'
* lib-fdbg:: 'library(fdbg)'
* lib-file_systems:: 'library(file_systems)'
* lib-gauge:: 'library(gauge)'
* lib-heaps:: 'library(heaps)'
* lib-jasper:: 'library(jasper)'
* lib-linda:: 'library('linda/client')', 'library('linda/server')'
* lib-lists:: 'library(lists)'
* lib-logarr:: 'library(logarr)'
* lib-objects:: 'library(objects)'
* lib-odbc:: 'library(odbc)'
* lib-ordsets:: 'library(ordsets)'
* lib-pillow:: 'library(pillow)'
* lib-plunit:: 'library(plunit)'
* lib-process:: 'library(process)'
* lib-prologbeans:: 'library(prologbeans)'
* lib-queues:: 'library(queues)'
* lib-random:: 'library(random)'
* lib-rem:: 'library(rem)'
* lib-samsort:: 'library(samsort)'
* lib-sets:: 'library(sets)'
* lib-sockets:: 'library(sockets)'
* lib-statistics:: 'library(statistics)'
* lib-structs:: 'library(structs)'
* lib-system:: 'library(system)'
* lib-tcltk:: 'library(tcltk)'
* lib-terms:: 'library(terms)'
* lib-timeout:: 'library(timeout)'
* lib-trees:: 'library(trees)'
* lib-types:: 'library(types)'
* lib-ugraphs:: 'library(ugraphs)'
* lib-varnumbers:: 'library(varnumbers)'
* lib-wgraphs:: 'library(wgraphs)'
* lib-xml:: 'library(xml)'
* lib-zinc:: 'library(zinc)', 'library(zinc)'

