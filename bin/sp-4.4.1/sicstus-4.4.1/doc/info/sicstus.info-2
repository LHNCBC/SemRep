This is sicstus.info, produced by makeinfo version 5.2 from
sicstus.texi.

INFO-DIR-SECTION SICStus Prolog
START-INFO-DIR-ENTRY
* SICStus Prolog Manual: (sicstus).			SICStus Prolog User's Manual.
END-INFO-DIR-ENTRY

Generated March 15, 2018.


File: sicstus.info,  Node: ref-lte-c2t,  Next: ref-lte-atm,  Prev: ref-lte-acl,  Up: ref-lte

4.8.4 Converting between Constants and Text
-------------------------------------------

Three predicates convert between constants and lists of character codes:
'atom_codes/2', 'number_codes/2', and 'name/2'.  Two predicates convert
between constants and lists of character atoms: 'atom_chars/2',
'number_chars/2'.

   'atom_codes(ATOM, CODES)' is a relation between an atom ATOM and a
list CODES consisting of the character codes comprising the printed
representation of ATOM.  Initially, either ATOM must be instantiated to
an atom, or CODES must be instantiated to a proper code-list.

   'number_codes(NUMBER, CODES)' is a relation between a number NUMBER
and a list CODES consisting of the character codes comprising the
printed representation of NUMBER.  Initially, either NUMBER must be
instantiated to a number, or CODES must be instantiated to a proper
code-list.

   Similarly, 'atom_chars(ATOM, CHARS)' and 'number_chars(ATOM, CHARS)'
are relations between a constant and a list consisting of the character
atoms comprising the printed representation of the constant.

   'name/2' converts between a constant and a code-list.  Given a
code-list, 'name/2' will convert it to a number if it can, otherwise to
an atom.  This means that there are atoms that can be constructed by
'atom_codes/2' but not by 'name/2'.  'name/2' is retained for backwards
compatibility with other Prologs.  New programs should use
'atom_codes/2' or 'number_codes/2' as appropriate.

   'char_code/2' converts between a character atom and a character code.


File: sicstus.info,  Node: ref-lte-atm,  Next: ref-lte-anv,  Prev: ref-lte-c2t,  Up: ref-lte

4.8.5 Atom Operations
---------------------

To compute LENGTH, the number of characters of the atom ATOM, use:

     ?- atom_length(ATOM,LENGTH).

   To concatenate ATOM1 with ATOM2 giving ATOM12, use the following.
The predicate can also be used to split a given ATOM12 into two unknown
parts:

     ?- atom_concat(ATOM1,ATOM2,ATOM12).

   To extract a sub-atom SUBATOM from ATOM, such that the number of
characters preceding SUBATOM is BEFORE, the number of characters after
SUBATOM is AFTER, and the length of SUBATOM is LENGTH, use the
following.  Only ATOM needs to be instantiated:

     ?- sub_atom(ATOM,BEFORE,LENGTH,AFTER,SUBATOM).


File: sicstus.info,  Node: ref-lte-anv,  Next: ref-lte-cpt,  Prev: ref-lte-atm,  Up: ref-lte

4.8.6 Assigning Names to Variables
----------------------------------

Each variable in a term is instantiated to a term of the form
''$VAR'(N)', where N is an integer, by the predicate 'numbervars/3'.
The "write" predicates ('write/[1,2]', 'writeq/[1,2]', and
'write_term/[2,3]' with the 'numbervars(true)' option) transform these
terms into variable names starting with upper case letters.


File: sicstus.info,  Node: ref-lte-cpt,  Next: ref-lte-cte,  Prev: ref-lte-anv,  Up: ref-lte

4.8.7 Copying Terms
-------------------

The meta-logical predicate 'copy_term/2' makes a copy of a term in which
all variables have been replaced by brand new variables, and all
mutables by brand new mutables.  This is precisely the effect that would
have been obtained from the definition:
     copy_term(Term, Copy) :-
        recorda(copy, copy(Term), DBref),
        instance(DBref, copy(Temp)),
        erase(DBref),
        Copy = Temp.

although the built-in predicate 'copy_term/2' is more efficient.

   When you call 'clause/[2,3]' or 'instance/2', you get a new copy of
the term stored in the database, in precisely the same sense that
'copy_term/2' gives you a new copy.  One of the uses of 'copy_term/2' is
in writing interpreters for logic-based languages; with 'copy_term/2'
available you can keep "clauses" in a Prolog data structure and pass
this structure as an argument without having to store the "clauses" in
the Prolog database.  This is useful if the set of "clauses" in your
interpreted language is changing with time, or if you want to use clever
indexing methods.

   A naive way to attempt to find out whether one term is a copy of
another is shown in this example:
     identical_but_for_variables(X, Y) :-
        \+ \+ (
           numbervars(X, 0, N),
           numbervars(Y, 0, N),
           X = Y
        ).

   This solution is sometimes sufficient, but will not work if the two
terms have any variables in common.  If you want the test to succeed
even when the two terms do have some variables in common, then you need
to copy one of them; for example,
     identical_but_for_variables(X, Y) :-
        \+ \+ (
           copy_term(X, Z),
           numbervars(Z, 0, N),
           numbervars(Y, 0, N),
           Z = Y
        ).

   *Please note*: If the term being copied contains attributed variables
(*note lib-atts::) or suspended goals (*note ref-sem-sec::), then those
attributes are not retained in the copy.  To retain the attributes, you
can use:

     copy_term(Term, Copy, Body)

which in addition to copying the term unifies BODY with a goal such that
executing BODY will reinstate the attributes in the COPY.  COPY as well
as BODY contain brand new (unattributed) variables only.


File: sicstus.info,  Node: ref-lte-cte,  Next: ref-lte-mut,  Prev: ref-lte-cpt,  Up: ref-lte

4.8.8 Comparing Terms
---------------------

* Menu:

* ref-lte-cte-bas::                     Introduction
* ref-lte-cte-sot::                     Standard Order of Terms
* ref-lte-cte-sor::                     Sorting Terms


File: sicstus.info,  Node: ref-lte-cte-bas,  Next: ref-lte-cte-sot,  Up: ref-lte-cte

4.8.8.1 Introduction
....................

The predicates described in this section are used to compare and order
terms, rather than to evaluate or process them.  For example, these
predicates can be used to compare variables; however, they never
instantiate those variables.  These predicates should not be confused
with the arithmetic comparison predicates (see *note ref-ari-acm::) or
with unification.


File: sicstus.info,  Node: ref-lte-cte-sot,  Next: ref-lte-cte-sor,  Prev: ref-lte-cte-bas,  Up: ref-lte-cte

4.8.8.2 Standard Order of Terms
...............................

These predicates use a standard total order when comparing terms.  The
standard total order is:

   * Variables, by age (oldest first--the order is _not_ related to the
     names of variables).

   * Floats, in numeric order (e.g. -1.0 is put before 1.0).

   * Integers, in numeric order (e.g. -1 is put before 1).

   * Atoms, in alphabetical (i.e. character code) order.

   * Compound terms, ordered first by arity, then by the name of the
     principal functor, then by age for mutables and by the arguments in
     left-to-right order for other terms.  Recall that lists are
     equivalent to compound terms with principal functor './2'.

   For example, here is a list of terms in standard order:

     [ X, -1.0, -9, 1, fie, foe, X = Y, foe(0,2), fie(1,1,1) ]

     *Please note*: the standard order is only well-defined for finite
     (acyclic) terms.  There are infinite (cyclic) terms for which no
     order relation holds.  Furthermore, blocking goals (*note
     ref-sem-sec::) on variables or modifying their attributes (*note
     lib-atts::) does not preserve their order.

   The predicates for comparison of terms are described below.

+T1 '==' +T2
     T1 and T2 are literally identical (in particular, variables in
     equivalent positions in the two terms must be identical).

+T1 '\==' +T2
     T1 and T2 are _not_ literally identical.

+T1 '@<' +T2
     T1 is before term T2 in the standard order.

+T1 '@>' +T2
     T1 is after term T2

+T1 '@=<' +T2
     T1 is not after term T2

+T1 '@>=' +T2
     T1 is not before term T2

'compare(-OP, +T1, +T2)'
     the result of comparing terms T1 and T2 is OP, where the possible
     values for OP are:

     '='
          if T1 is identical to T2,
     '<'
          if T1 is before T2 in the standard order,
     '>'
          if T1 is after T2 in the standard order.


File: sicstus.info,  Node: ref-lte-cte-sor,  Prev: ref-lte-cte-sot,  Up: ref-lte-cte

4.8.8.3 Sorting Terms
.....................

Two predicates, 'sort/2' and 'keysort/2' sort lists into the standard
order.  'keysort/2' takes a list consisting of key-value pairs and sorts
according to the key.

   Further sorting predicates are available in 'library(samsort)'.


File: sicstus.info,  Node: ref-lte-mut,  Next: ref-lte-sum,  Prev: ref-lte-cte,  Up: ref-lte

4.8.9 Mutable Terms
-------------------

One of the tenets of logic programming is that terms are immutable
objects of the Herbrand universe, and the only sense in which they can
be modified is by means of instantiating non-ground parts.  There are,
however, algorithms where destructive assignment is essential for
performance.  Although alien to the ideals of logic programming, this
feature can be defended on practical grounds.

   SICStus Prolog provides an abstract datatype and four operations for
efficient _backtrackable_ destructive assignment.  In other words, any
destructive assignments are transparently undone on backtracking.
Modifications that are intended to survive backtracking must be done by
asserting or retracting dynamic program clauses instead.  Unlike
previous releases of SICStus Prolog, destructive assignment of arbitrary
terms is not allowed.

   A "mutable term" is represented as a compound term with a reserved
functor: ''$mutable'(VALUE,TIMESTAMP)' where VALUE is the current value
and TIMESTAMP is reserved for bookkeeping purposes [Aggoun & Beldiceanu
90].

   Any copy of a mutable term created by 'copy_term/[2,3]', 'assert',
'retract', a database predicate, or an all solutions predicate, is an
independent copy of the original mutable term.  Any destructive
assignment done to one of the copies will not affect the other copy.

   The following operations are provided:

'create_mutable(+DATUM,-MUTABLE)'

     DATUM.

'get_mutable(-DATUM,+MUTABLE)'

     The current value of the mutable term MUTABLE is DATUM.

'update_mutable(+DATUM,+MUTABLE)'

     Updates the current value of the mutable term MUTABLE to become
     DATUM.

'mutable(+MUTABLE)'

     X is currently instantiated to a mutable term.

     *Please note*: the effect of unifying two mutables is undefined.


File: sicstus.info,  Node: ref-lte-sum,  Prev: ref-lte-mut,  Up: ref-lte

4.8.10 Summary of Predicates
----------------------------

'atom(+T)   ISO'
     term T is an atom

'atomic(+T)   ISO'
     term T is an atom or a number

'callable(+T)   ISO'
     T is an atom or a compound term

'compound(+T)   ISO'
     T is a compound term

'db_reference(+X)   since release 4.1'
     X is a db_reference

'float(+N)   ISO'
     N is a floating-point number

'ground(+T)   ISO'
     term T is a nonvar, and all substructures are nonvar

'integer(+T)   ISO'
     term T is an integer

'mutable(+X)'
     X is a mutable term

'nonvar(+T)   ISO'
     term T is one of atom, number, compound (that is, T is
     instantiated)

'number(+N)   ISO'
     N is an integer or a float

'simple(+T)'
     T is not a compound term; it is either atomic or a var

'var(+T)   ISO'
     term T is a variable (that is, T is uninstantiated)

'compare(-C,+X,+Y)   ISO'
     C is the result of comparing terms X and Y

'+X == +Y   ISO'
     terms X and Y are strictly identical

'+X \== +Y   ISO'
     terms X and Y are not strictly identical

'+X @< +Y   ISO'
     term X precedes term Y in standard order for terms

'+X @>= +Y   ISO'
     term X follows or is identical to term Y in standard order for
     terms

'+X @> +Y   ISO'
     term X follows term Y in standard order for terms

'+X @=< +Y   ISO'
     term X precedes or is identical to term Y in standard order for
     terms

'?T =.. ?L   ISO'
     the functor and arguments of term T comprise the list L

'?X = ?Y   ISO'
     terms X and Y are unified

'+X \= +Y   ISO'
     terms X and Y no not unify

'?=(+X,+Y)'
     X and Y are either strictly identical or do not unify

'acyclic_term(+T)   since release 4.3, ISO'
     term T is a finite (acyclic) term

'arg(+N,+T,-A)   ISO'
     the Nth argument of term T is A

'atom_chars(?A,?L)   ISO'
     A is the atom containing the character atoms in list L

'atom_codes(?A,?L)   ISO'
     A is the atom containing the characters in code-list L

'atom_concat(?ATOM1,?ATOM2,?ATOM12)   ISO'
     Atom ATOM1 concatenated with ATOM2 gives ATOM12.

'atom_length(+ATOM,-LENGTH)   ISO'
     LENGTH is the number of characters of the atom ATOM.

'char_code(?CHAR,?CODE)   ISO'
     CODE is the character code of the one-char atom CHAR.

'copy_term(+T,-C)   ISO'
     C is a copy of T in which all variables have been replaced by new
     variables

'copy_term(+T,-C,-G)'
     C is a copy of T in which all variables have been replaced by new
     variables, and G is a goal for reinstating any attributes in C

'create_mutable(+DATUM,-MUTABLE)'
     MUTABLE is a new mutable term with current value DATUM.

'dif(+X,+Y)'
     X and Y are constrained to be different.

'frozen(+VAR,-GOAL)'
     The goal GOAL is blocked on the variable VAR.

'functor(?T,?F,?N)   ISO'
     the principal functor of term T has name F and arity N

'get_mutable(-DATUM,+MUTABLE)'
     The current value of the mutable term MUTABLE is DATUM.

'name(?A,?L)   deprecated'
     the code-list of atom or number A is L

'number_chars(?N,?L)   ISO'
     N is the numeric representation of list of character atoms L

'number_codes(?N,?L)   ISO'
     N is the numeric representation of code-list L

'numbervars(+T,+M,-N)'
     number the variables in term T from M to N-1

'sub_atom(+ATOM,?BEFORE,?LENGTH,?AFTER,?SUBATOM)   ISO'
     The characters of SUBATOM form a sublist of the characters of ATOM,
     such that the number of characters preceding SUBATOM is BEFORE, the
     number of characters after SUBATOM is AFTER, and the length of
     SUBATOM is LENGTH.

'subsumes_term(General,Specific)   since release 4.3, ISO'
     SPECIFIC is an instance of GENERAL

'term_variables(+TERM,-VARIABLES)   since release 4.3, ISO'
     VARIABLES is the set of variables that occur in TERM

'unify_with_occurs_check(?X,?Y)   ISO'
     True if X and Y unify to a finite (acyclic) term.

'?T =.. ?L   ISO'
     the functor and arguments of term T comprise the list L

'append(?A,?B,?C)'
     the list C is the concatenation of lists A and B

'keysort(+L,-S)   ISO'
     the list L sorted by key yields S

'length(?L,?N)'
     the length of list L is N

'member(?X,?L)'
     X is a member of L

'memberchk(+X,+L)'
     X is a member of L

'nonmember(+X,+L)'
     X is not a member of L

'sort(+L,-S)   ISO'
     sorting the list L into order yields S


File: sicstus.info,  Node: ref-lps,  Next: ref-mgc,  Prev: ref-lte,  Up: Prolog Intro

4.9 Looking at the Program State
================================

* Menu:

* ref-lps-ove::                         Overview
* ref-lps-app::                         Associating Predicates with their Properties
* ref-lps-apf::                         Associating Predicates with Files
* ref-lps-flg::                         Prolog Flags
* ref-lps-lco::                         Load Context
* ref-lps-sum::                         Predicate Summary


File: sicstus.info,  Node: ref-lps-ove,  Next: ref-lps-app,  Up: ref-lps

4.9.1 Overview
--------------

Various aspects of the program state can be inspected: the clauses of
all or selected dynamic procedures, currently available atoms, user
defined predicates, source files of predicates and clauses, predicate
properties and the current load context can all be accessed by calling
the predicates listed in *note ref-lps-ove::.  Furthermore, the values
of Prolog flags can be inspected and, where it makes sense, changed.


File: sicstus.info,  Node: ref-lps-app,  Next: ref-lps-apf,  Prev: ref-lps-ove,  Up: ref-lps

4.9.2 Associating Predicates with their Properties
--------------------------------------------------

The following properties are associated with predicates either
implicitly or by declaration:

'built_in'
     The predicate is built-in.

'compiled'
     The predicate is in virtual code representation.

'interpreted'
     The predicate is in interpreted representation.

'fd_constraint'
     The predicate is a so-called FD predicate; *note Defining Primitive
     Constraints::.

'dynamic'
     The predicate was declared dynamic.

'volatile'
     The predicate was declared volatile.

'multifile'
     The predicate was declared multifile.

'block(SKELETALGOAL)'
     The predicate has block declarations.

'meta_predicate(SKELETALGOAL)'
     The predicate is a meta-predicate.

     As of release 4.2, the SKELETALGOAL will contain the specifications
     used in the original meta-predicate declaration.

'exported'
     The predicate was exported from a module.

'imported_from(MODULE)'
     The predicate was imported from the module MODULE.

   Every predicate has exactly one of the properties '[built_in,
compiled, interpreted, fd_constraint]', at most one of the properties

   '[exported, imported_from(SKELETALGOAL)]', zero or more
'block(SKELETALGOAL)' properties, and at most one of the remaining
properties.

   To query these associations, use 'predicate_property/2'.  The
reference page contains several examples.  *Note
mpg-ref-predicate_property::.


File: sicstus.info,  Node: ref-lps-apf,  Next: ref-lps-flg,  Prev: ref-lps-app,  Up: ref-lps

4.9.3 Associating Predicates with Files
---------------------------------------

Information about loaded files and the predicates and clauses in them is
returned by 'source_file/[1,2]'.  'source_file/1' can be used to
identify an absolute filename as loaded, or to backtrack through all
loaded files.  To find out the correlation between loaded files and
predicates, call 'source_file/2'.  *Note mpg-ref-source_file::.


File: sicstus.info,  Node: ref-lps-flg,  Next: ref-lps-lco,  Prev: ref-lps-apf,  Up: ref-lps

4.9.4 Prolog Flags
------------------

Certain aspects of the state of the program are accessible as values of
the global Prolog flags.  Some of these flags are read-only and
correspond to implementation defined properties and exist to aid
portability.  Others can be set and impact the behavior of certain
built-in predicates.

   The flags are accessed by the built-in predicates
'prolog_flag/[2,3]', 'current_prolog_flag/2', and 'set_prolog_flag/2'.

   *Please note*: Prolog flags are _global_, as opposed to being local
to the current module, Prolog text, or otherwise.

   The possible Prolog flag names and values are listed below.  Flags
annotated "ISO" are prescribed by the ISO standard.  Flags annotated
"volatile" are not saved by 'save_program/[1,2]'.  Flags annotated
"read-only" are read-only:

'agc_margin'
     An integer MARGIN.  The atoms will be garbage collected when MARGIN
     new atoms have been created since the last atom garbage collection.
     Initially 10000.

'argv   volatile'
     The value is a list of atoms of the program arguments supplied when
     the current SICStus Prolog process was started.  For example, if
     SICStus Prolog were invoked with:

          % sicstus -- hello world 2001

     then the value will be '[hello,world,'2001']'.

     Setting the value can be useful when writing test cases for code
     that expects to be run with command line parameters.

'bounded   read-only,volatile,ISO'
     One of the flags defining the integer type.  For SICStus, its value
     is 'false', indicating that the domain of integers is practically
     unbounded.

'char_conversion   volatile,ISO'
     If this flag is 'on', then unquoted characters in terms and
     programs read in will be converted, as specified by previous
     invocations of 'char_conversion/2'.  If the flag is 'off', then no
     conversion will take place.  The default value is 'on'.

'compiling'
     Governs the mode in which 'compile/1' operate (*note ref-lod::).

     'compactcode'
          Compilation produces byte-coded abstract instructions (the
          default).

     'debugcode'
          Compiling is replaced by consulting.

'debugging   volatile'
     Corresponds to the predicates 'debug/0', 'nodebug/0', 'trace/0',
     'notrace/0', 'zip/0', 'nozip/0'.  The flag describes the mode the
     debugger is in, or is required to be switched to:

     'trace'
          Trace mode (the debugger is creeping).

     'debug'
          Debug mode (the debugger is leaping).

     'zip'
          Zip mode (the debugger is zipping).

     'off'
          The debugger is switched off (the default).

'debug   volatile,ISO'
     The flag 'debug', prescribed by the ISO Prolog standard, is a
     simplified form of the 'debugging' flag:

     'off   ISO'
          The debugger is switched off (the default).

     'on   ISO'
          The debugger is switched on (to trace mode, if previously
          switched off).

'profiling   since release 4.2'
     This flag describes the mode the execution profiler (*note
     Execution Profiling::) is in, or is required to be switched to:

     'off'
          The profiler is switched off (the default).

     'on'
          The profiler is switched on.

     (The flags 'profiling', 'debugging' and 'debug' have no effect in
     runtime systems.)

'double_quotes   volatile,ISO'
     Governs the interpretation of double quoted strings (*note
     ref-syn-cpt-sli::):

     'codes   ISO'
          Code-list comprising the string.  The default.

     'chars   ISO'
          Char-list comprising the string.

     'atom   ISO'
          The atom composed of the same characters as the string.

'quoted_charset'
     This flag is relevant when 'quoted(true)' holds when writing terms.
     Its value should be one of the atoms:

     'portable'
          Atoms and functors are written using character codes less than
          128 only, i.e. using the 7-bit subset of the ISO-8859-1 (Latin
          1) character set (*note ref-syn-syn-tok::).

     'prolog'

          Atoms and functors are written using a character set that can
          be read back by 'read/[1,2]'.  This is a subset of Unicode
          that includes all of ISO-8859-1 (Latin 1) as well as some
          additional characters.

          This character set may grow but not shrink in subsequent
          releases.  This ensures that future releases can always read a
          term written by an older release.

          Note that the character set supported by the stream is not
          taken into account.  You can use 'portable' instead of
          'prolog' if the stream does not support Unicode.

'debugger_print_options'
     The value is a list of options for 'write_term/3' (*note
     ref-iou-tou-wrt::), to be used in the debugger's messages.  The
     initial value is
     '[quoted(true),numbervars(true),portrayed(true),max_depth(10)]'.

'dialect   since release 4.1,read-only'
     The value of this flag is 'sicstus'.  It is useful for
     distinguishing between Prolog implementations.

     Also see the Prolog flag 'version_data', below.

'discontiguous_warnings   volatile'
     'on' or 'off'.  Enable or disable warning messages when clauses are
     not together in source files.  Initially 'on' in development
     systems, 'off' in runtime systems.

'fileerrors'
     'on' or 'off'.  Enables or disables raising of file error
     exceptions.  Initially 'on' (enabled).

'gc'
     'on' or 'off'.  Enables or disables garbage collection of the
     global stack.  Initially 'on' (enabled).

'gc_margin'
     MARGIN: At least MARGIN kilobytes of free global stack space are
     guaranteed to exist after a garbage collection.  Also, no garbage
     collection is attempted unless the global stack is at least MARGIN
     kilobytes.  Initially 1000.

'gc_trace'
     Governs global stack garbage collection trace messages.

     'verbose'
          Turn on verbose tracing of garbage collection.

     'terse'
          Turn on terse tracing of garbage collection.

     'off'
          Turn off tracing of garbage collection (the default).

'host_type   read-only,volatile'
     The value is an atom identifying the platform on which SICStus was
     compiled, such as ''x86-linux-glibc2.1'' or ''sparc-solaris-5.7''.

'informational   volatile'
     'on' or 'off'.  Enables or disables the printing of informational
     messages.  Initially 'on' (printing enabled) in development
     systems, unless the '--noinfo' command line option was used; 'off'
     (printing disabled) in runtime systems.

'integer_rounding_function   read-only,volatile,ISO'
     One of the flags defining the integer type.  In SICStus Prolog its
     value is 'toward_zero', indicating that the integer division
     ('(//)/2') and integer remainder ('rem/2') arithmetic functions use
     rounding toward zero; *note ref-ari::.

'legacy_char_classification   since release 4.0.3,volatile'
     'on' or 'off'.  When enabled, most legal Unicode codepoints above
     255 are treated as lowercase characters when reading Prolog terms.
     This improves compatibility with earlier versions of SICStus Prolog
     and makes it possible to use full Unicode, e.g. Chinese characters,
     in unquoted atoms as well as variable names, *note
     ref-syn-syn-tok::.  Initially 'off' (disabled).

     Setting this flag affects the 'read_term/[2,3]' option
     'singletons/1'; see *note mpg-ref-read_term::.  It also affects the
     style warning for singleton variables; see the description of the
     'single_var_warnings' in *note The Load Predicates: ref-lod-lod.

'max_arity   read-only,volatile,ISO'
     Specifies the maximum arity allowed for a compound term.  In
     SICStus Prolog this is 255.

'max_integer   read-only,volatile,ISO'
     Specifies the largest possible integer value.  As in SICStus Prolog
     the range of integers in not bounded, 'prolog_flag/[2,3]' and
     'current_prolog_flag/2' will fail when accessing this flag.

'max_tagged_integer   since release 4.1,read-only,volatile'
     The largest small integer, i.e. integers larger than this are less
     efficient to manipulate and are not available in 'library(clpfd)'.

'min_integer   read-only,volatile,ISO'
     Specifies the smallest possible integer value.  As in SICStus
     Prolog the range of integers in not bounded, 'prolog_flag/[2,3]'
     and 'current_prolog_flag/2' will fail, when accessing this flag.

'min_tagged_integer   since release 4.1,read-only,volatile'
     The smallest small integer, i.e. integers smaller than this are
     less efficient to manipulate and are not available in
     'library(clpfd)'.

'os_data   since release 4.1,read-only,volatile'
     The value is a term 'os(Family,Name,Extra)' describing the
     operating system on which this SICStus process is running, i.e. it
     is the runtime version of the 'platform_data' flag, below.

     FAMILY has the same value and meaning as for the 'platform_data'
     flag, below.

     On UNIX-like systems the NAME is the lower case value 'sysname'
     returned from 'uname(3)' at runtime, i.e. the same as from the
     comamnd 'uname -s'.  On all supported versions of Microsoft Windows
     this is 'win32nt'.

     'Extra' is a list of extra information.  Entries may be added to
     this list without prior notice.

     Currently, at least up to release 4.2.3, the FAMILY and NAME for
     the 'platform_data' and 'os_data' flags happens to be the same but
     this may change in the unlikely case that the operating system
     starts to return something new.  For this reason it is probably
     better to use 'platform_data' than 'os_data' in most cases.

     The 'Extra' value for 'os_data' may differ from its 'platform_data'
     counterpart in order to accurately describe the running operating
     system.

'platform_data   since release 4.1,read-only,volatile'
     The value is a term 'platform(Family,Name,Extra)' describing the
     operating system platform for which this version of SICStus was
     built.

     FAMILY describes the family or class of operating system.
     Currently documented values are 'unix', for UNIX-like systems like
     Linux, OS X, Solaris and Androind; and 'windows' for all supported
     versions of Microsoft Windows.  You should not assume that these
     are the only two possibilities.

     NAME describes the name of the operating system.  On UNIX-like
     systems this correspond to the (lower case) output from 'uname -s'.
     Currently documented values are 'linux', 'darwin', 'sunos',
     'android' and 'win32nt'.

     Note that this implies that some operating systems may have
     unexpected names.  In particular the name for Apple OS X is
     'darwin', for Oracle Solaris it is 'sunos' and for 64-bit versions
     of SICStus on Microsoft Windows it is 'win32nt'.

     'Extra' is bound to a list of extra information.  Entries may be
     added to this list without prior notice.

'redefine_warnings'
     Enable or disable warning messages when:

        * a module or predicate is being redefined from a different file
          than its previous definition.  Such warnings are currently not
          issued when a '.po' file is being loaded.
        * a predicate is being imported while it was locally defined
          already.
        * a predicate is being redefined locally while it was imported
          already.
        * a predicate is being imported while it was imported from
          another module already.

     The possible values are:

     'on'
          The default in development systems.  The user is queried about
          what to do in each case.
     'off'
          The default in runtime systems, but note that this flag is not
          "volatile".  Redefinitions are performed silently, as if the
          user had accepted them.
     'reject   since release 4.0.3'
          Redefinitions are refused silently, as if the user had
          rejected them.
     'proceed   since release 4.0.3'
          Redefinitions are performed, and warnings are issued.
     'suppress   since release 4.0.3'
          Redefinitions are refused, and warnings are issued.

'single_var_warnings   volatile'
     'on' or 'off'.  Enable or disable warning messages when a SENTENCE
     (*note ref-syn-syn-sen::) containing variables not beginning with
     '_' occurring once only is compiled or consulted.  Initially 'on'
     in development systems, 'off' in runtime systems.

'source_info   volatile'
     'emacs' or 'on' or 'off'.  If not 'off' while source code is being
     loaded, then information about line numbers and file names are
     stored with the loaded code.  If the value is 'on' while debugging,
     then this information is used to print the source code location
     while prompting for a debugger command.  If the value is 'on' while
     printing an uncaught error exception message, then the information
     is used to print the source code location of the culprit goal or
     one of its ancestors, as far as it can be determined.  If the value
     is 'emacs' in any of these cases, then the appropriate line of code
     is instead highlighted, and no extra text is printed.  The value is
     'off' initially, and that is its only available value in runtime
     systems.

'syntax_errors'
     Controls what action is taken upon syntax errors in 'read/[1,2]'.

     'dec10'
          The syntax error is reported and the read is repeated.

     'error'
          An exception is raised.  *Note ref-ere::.  (the default).

     'fail'
          The syntax error is reported and the read fails.

     'quiet'
          The read quietly fails.

'system_type   read-only,volatile'
     The value is 'development' in development systems and 'runtime' in
     runtime systems.

'title'
     The window title.  The default value is the same as the boot
     message 'SICStus 4.4.1 ... Licensed to SICS'.  It is currently only
     used as the window title on the Windows platform.

'toplevel_print_options'
     The value is a list of options for 'write_term/3' (*note
     ref-iou-tou-wrt::), to be used when the top-level displays variable
     bindings and answer constraints.  It is also used when messages are
     displayed.  The initial value is
     '[quoted(true),numbervars(true),portrayed(true),max_depth(10)]'.

'typein_module'
     Permitted values are atoms.  Controls the current type-in module
     (*note ref-mod-tyi::).  Corresponds to the predicate
     'set_module/1'.

'unknown   ISO'

     The system can optionally catch calls to predicates that have no
     definition.  First, the user defined predicate
     'user:unknown_predicate_handler/3' (*note ref-ere::) is called.  If
     undefined or if the call fails, then the action is governed by the
     state of the this flag, which can be:

     'trace'
          Causes calls to undefined predicates to be reported and the
          debugger to be entered at the earliest opportunity.  Not
          available in runtime systems.

     'error   ISO'
          Causes calls to such predicates to raise an exception (the
          default).  *Note ref-ere::.

     'warning   ISO'
          Causes calls to such predicates to display a warning message
          and then fail.

     'fail   ISO'
          Causes calls to such predicates to fail.

'user_input   volatile'
     Permitted values are any stream opened for reading.  Controls which
     stream is referenced by 'user_input' and 'SP_stdin'.  It is
     initially set to a stream connected to UNIX 'stdin'.

'user_output   volatile'
     Permitted values are any stream opened for writing.  Controls which
     stream is referenced by 'user_output' and 'SP_stdout'.  It is
     initially set to a stream connected to UNIX 'stdout'.

'user_error   volatile'
     Permitted values are any stream opened for writing.  Controls which
     stream is referenced by 'user_error' and 'SP_stderr'.  It is
     initially set to a stream connected to UNIX 'stderr'.

'version   read-only,volatile'
     The value is an atom containing the banner text displayed on
     startup, such as ''SICStus 4.1.0 (i386-darwin-9.8.0): Wed Oct 14
     14:43:58 CEST 2009''.

     Also see the Prolog flag 'version_data', below.

'version_data   since release 4.1,read-only,volatile'
     The value is a term 'sicstus(Major,Minor,Revision,Beta,Extra)' with
     integer major, minor, revision, and beta version.

     'Extra' is bound to a list of extra information.  Entries may be
     added to this list without prior notice.

     Also see the Prolog flag 'dialect', above.

   You can use 'prolog_flag/2' to enumerate all the FLAGNAMEs that the
system currently understands, together with their current values.  Use
'prolog_flag/2' to make queries, 'prolog_flag/3' to make changes.


File: sicstus.info,  Node: ref-lps-lco,  Next: ref-lps-sum,  Prev: ref-lps-flg,  Up: ref-lps

4.9.5 Load Context
------------------

When a Prolog source file is being read in, some aspects of the load
context can be accessed by the built-in predicate
'prolog_load_context/2', which accesses the value of a given key.  The
available keys are:

'source'
     The absolute path name of the file being loaded.  During loading of
     a PO file, the corresponding source file name is returned.

'file'
     Outside included files (*note Include Declarations::) this is the
     same as the 'source' key.  In included files this is the absolute
     path name of the file being included.

'directory'
     The absolute path name of the directory of the file being loaded.
     In included files this is the directory of the file being included.

'module'
     The source module (*note ref-mod-mne::).  This is useful for
     example if you are defining clauses for 'user:term_expansion/6' and
     need to access the source module at compile time.

'stream'
     The stream being loaded.  This key is not available during loading
     of a PO file.

'term_position'
     A term representing the stream position of the last clause read.
     This key is not available during loading of a PO file.


File: sicstus.info,  Node: ref-lps-sum,  Prev: ref-lps-lco,  Up: ref-lps

4.9.6 Predicate Summary
-----------------------

'current_atom(?A)'
     backtrack through all atoms

'current_module(?M)'
     M is the name of a current module

'current_module(?M,?F)'
     F is the name of the file in which M's module declaration appears

'current_predicate(:A/?N)   ISO'
'current_predicate(?A,:P)'
     A is the name of a predicate with most general goal P and arity N

'current_prolog_flag(?F,?V)   ISO'
     V is the current value of Prolog flag F

'listing'
     list all dynamic procedures in the type-in module

'listing(:P)'
     list the dynamic procedure(s) specified by P

'predicate_property(:P,?PROP)'
     PROP is a property of the loaded predicate P

'prolog_flag(?F,?V)'
     V is the current value of Prolog flag F

'prolog_flag(+F,=O,+N)'
     O is the old value of Prolog flag F; N is the new value

'prolog_load_context(?K,?V)'
     find out the context of the current load

'set_module(+M)'
     make M the type-in module

'set_prolog_flag(+F,+N)   ISO'
     N is the new value of Prolog flag F

'source_file(?F)'
     F is a source file that has been loaded into the database

'source_file(:P,?F)'
     P is a predicate defined in the loaded file F

'unknown(-O,+N)   development'
     Changes action on undefined predicates from O to N.


File: sicstus.info,  Node: ref-mgc,  Next: ref-mod,  Prev: ref-lps,  Up: Prolog Intro

4.10 Memory Use and Garbage Collection
======================================

* Menu:

* ref-mgc-ove::                         Overview
* ref-mgc-gcp::                         Garbage Collection and Programming Style
* ref-mgc-egc::                         Enabling and Disabling the Garbage Collector
* ref-mgc-mgc::                         Monitoring Garbage Collections
* ref-mgc-gch::                         Interaction of Garbage Collection and Heap Expansion
* ref-mgc-gcd::                         Invoking the Garbage Collector Directly
* ref-mgc-ago::                         Atom Garbage Collection
* ref-mgc-sum::                         Summary of Predicates


File: sicstus.info,  Node: ref-mgc-ove,  Next: ref-mgc-gcp,  Up: ref-mgc

4.10.1 Overview
---------------

* Menu:

* ref-mgc-ove-rsp::                     Reclaiming Space
* ref-mgc-ove-sta::                     Displaying Statistics

SICStus Prolog uses five data areas: program space, global stack, local
stack, choice stack, and trail stack.  Each of these areas is
automatically expanded if it overflows.

   The local stack contains all the control information and variable
bindings needed in a Prolog execution.  Space on the local stack is
reclaimed on determinate success of predicates and by tail recursion
optimization, as well as on backtracking.

   The choice stack contains data representing outstanding choices for
some goals or disjunctions.  Space on the choice stack is reclaimed on
backtracking.

   The global stack contains all the data structures constructed in an
execution of the program.  This area grows with forward execution and
shrinks on backtracking.

   The trail stack contains references to all the variables that need to
be reset when backtracking occurs.  This area grows with forward
execution and shrinks on backtracking.

   The program space contains compiled and interpreted code, recorded
terms, and atoms.  The space occupied by compiled code, interpreted
code, and recorded terms is recovered when it is no longer needed; the
space occupied by atoms that are no longer in use can be recovered by
atom garbage collection described in *note ref-mgc-ago::.

   These fluctuations in memory usage of the above areas can be
monitored by 'statistics/[0,2]'.

   SICStus Prolog uses the global stack to construct compound terms,
including lists.  Global Stack space is used as Prolog execution moves
forward.  When Prolog backtracks, it automatically reclaims space on the
global stack.  However, if a program uses a large amount of space before
failure and backtracking occur, then this type of reclamation may be
inadequate.

   Without garbage collection, the Prolog system must attempt to expand
the global stack whenever a global stack overflow occurs.  To do this,
it first requests additional space from the operating system.  If no
more space is available, then the Prolog system attempts to allocate
unused space from the other Prolog data areas.  If additional space
cannot be found, then a resource error is raised.

   Global stack expansion and abnormal termination of execution due to
lack of stack space can occur even if there are structures on the global
stack that are no longer accessible to the computation (these structures
are what is meant by "garbage").  The proportion of garbage to
non-garbage terms varies during execution and with the Prolog code being
executed.  The global stack may contain no garbage at all, or may be
nearly all garbage.

   The garbage collector periodically reclaims inaccessible global stack
space, reducing the need for global stack expansion and lessening the
likelihood of running out of global stack.  When the garbage collector
is enabled (as it is by default), the system makes fewer requests to the
operating system for additional space.  The fact that less space is
required from the operating system can produce a substantial savings in
the time taken to run a program, because paging overhead can be much
less.

   For example, without garbage collection, compiling a file containing
the sequence
     p(_) :- p([a]).
     :- p(_).

causes the global stack to expand until the Prolog process eventually
runs out of space.  With garbage collection enabled, the above sequence
continues indefinitely.  The list built on the global stack by each
recursive call is inaccessible to future calls (since 'p/1' ignores its
argument) and can be reclaimed by the garbage collector.

   Garbage collection does not guarantee freedom from out-of-space
errors, however.  Compiling a file containing the sequence
     p(X) :- p([X]).
     :- p(a).

expands the global stack until the Prolog process eventually runs out of
space.  This happens in spite of the garbage collector, because all the
terms built on the global stack are accessible to future computation and
cannot be reclaimed.


File: sicstus.info,  Node: ref-mgc-ove-rsp,  Next: ref-mgc-ove-sta,  Up: ref-mgc-ove

4.10.1.1 Reclaiming Space
.........................

'trimcore/0' reclaims space in all of Prolog's data areas.  At any given
time, each data area contains some free space.  For example, the local
stack space contains the local stack and some free space for that stack
to grow into.  The data area is automatically expanded when it runs out
of free space, and it remains expanded until 'trimcore/0' is called,
even though the stack may have shrunk considerably in the meantime.  The
effect of 'trimcore/0' is to reduce the free space in all the data areas
as much as possible, and to endeavor to give the space no longer needed
back to the operating system.

   The system property 'PROLOGKEEPSIZE' can be used to define a lower
bound on the amount of memory to be retained.  Also, the system property
'PROLOGINITSIZE' can be used to request that an initial amount of memory
be allocated.  This initially allocated memory will not be touched by
'trimcore/0'.

   When trimming a given stacks, 'trimcore/0' will retain at least the
amount of space initially allocated for that stack.

   'trimcore/0' is called each time Prolog returns to the top-level or
the top of a break level, except it does not trim the stacks then.
*Note mpg-ref-trimcore::.


File: sicstus.info,  Node: ref-mgc-ove-sta,  Prev: ref-mgc-ove-rsp,  Up: ref-mgc-ove

4.10.1.2 Displaying Statistics
..............................

Statistics relating to memory usage, run time, and garbage collection,
including information about which areas of memory have overflowed and
how much time has been spent expanding them, can be displayed by calling
'statistics/0'.

   The output from 'statistics/0' looks like this:

     memory (total)       3334072 bytes
        global stack      1507184 bytes:       2516 in use,   1504668 free
        local stack         49296 bytes:        276 in use,     49020 free
        trail stack         34758 bytes:        248 in use,     34510 free
        control stack       34874 bytes:        364 in use,     34510 free
        program space     1707960 bytes:    1263872 in use,    444088 free
        program space breakdown:
                 compiled code               575096 bytes
                 atom                        166528 bytes
                 predicate                   157248 bytes
                 try_node                    144288 bytes
                 sw_on_key                   105216 bytes
                 incore_info                  51096 bytes
                 atom table                   36864 bytes
                 interpreted code             13336 bytes
                 atom buffer                   2560 bytes
                 SP_malloc                     2288 bytes
                 FLI stack                     2048 bytes
                 miscellaneous                 1640 bytes
                 BDD hash table                1560 bytes
                 source info (B-tree)          1024 bytes
                 numstack                      1024 bytes
                 int_info                       880 bytes
                 file table                     400 bytes
                 source info (itable)           328 bytes
                 module                         320 bytes
                 source info (lheap)             80 bytes
                 foreign resource                32 bytes
                 all solutions                   16 bytes
         4323 atoms (151927 bytes) in use, 1044252 free
         No memory resource errors

            0.020 sec. for 7 global, 20 local, and 0 choice stack overflows
            0.060 sec. for 15 garbage collections which collected 5461007 bytes
            0.000 sec. for 0 atom garbage collections which collected 0 atoms (0 bytes)
            0.000 sec. for 4 defragmentations
            0.000 sec. for 7 dead clause reclamations
            0.000 sec. for 0 dead predicate reclamations
           39.410 sec. runtime
         ========
           39.490 sec. total runtime
          109.200 sec. elapsed time

   Note the use of indentation to indicate sub-areas.  That is, memory
contains the program space and the four stacks: global, local, choice,
and trail.

   The memory (total) figure shown as "in use" is the sum of the spaces
for the program space and stacks.  The "free" figures for the stacks are
for free space within those areas.  However, this free space is
considered used as far as the memory (total) area is concerned, because
it has been allocated to the stacks.  The program space is not
considered to have its own free space.  It always allocates new space
from the general memory (total) free area.

   If a memory resource error has occurred previously in the execution,
then the memory area for which memory could not be allocated is
displayed.

   Individual statistics can be obtained by 'statistics/2', which
accepts a keyword and returns a list of statistics related to that
keyword.

   The keys and values for 'statistics(KEYWORD, VALUE)' are summarized
below.  The keywords 'core' and 'heap' are included to retain
compatibility with other Prologs.  Times are given in milliseconds and
sizes are given in bytes.

'KEYWORD'
     VALUE

'runtime'
     '[SINCE START OF PROLOG,SINCE PREVIOUS STATISTICS]'
     These refer to CPU time used while executing, excluding time spent
     in memory management tasks or or in system calls.  The second
     element is the time since the latest call to 'statistics/2' with
     this key or to 'statistics/0'.

'total_runtime'
     '[SINCE START OF PROLOG,SINCE PREVIOUS STATISTICS]'
     These refer to total CPU time used while executing, including
     memory management tasks such as garbage collection but excluding
     system calls.  The second element is the time since the latest call
     to 'statistics/2' with this key or to 'statistics/0'.

'walltime'
     '[SINCE START OF PROLOG,SINCE PREVIOUS STATISTICS]'
     These refer to absolute time elapsed.  The second element is the
     time since the latest call to 'statistics/2' with this key or to
     'statistics/0'.

'global_stack'
     '[SIZE USED,FREE]'
     This refers to the global stack, where compound terms are stored.
     The values are gathered before the list holding the answers is
     allocated.  Formed from basic values below.

'local_stack'
     '[SIZE USED,FREE]'
     This refers to the local stack, where recursive predicate
     environments are stored.  Formed from basic values below.

'trail'
     '[SIZE USED,FREE]'
     This refers to the trail stack, where conditional variable bindings
     are recorded.  Formed from basic values below.

'choice'
     '[SIZE USED,FREE]'
     This refers to the choice stack, where partial states are stored
     for backtracking purposes.  Formed from basic values below.

'memory'
'core'
     '[SIZE USED,0]'
     These refer to the amount of memory actually allocated by the
     Prolog engine.  The zero is there for compatibility with other
     Prolog implementations.  Formed from basic values below.

'program'
'heap'
     '[SIZE USED,SIZE FREE]'
     These refer to the amount of memory allocated for the database,
     symbol tables, and the like.  Formed from basic values below.

'garbage_collection'
     '[NO. OF GCS,BYTES FREED,TIME SPENT]'
     Formed from basic values below.

'stack_shifts'
     '[NO. OF GLOBAL SHIFTS,NO. OF LOCAL/CHOICE SHIFTS,TIME SPENT]'
     Formed from basic values below.

'atoms'
     '[NO. OF ATOMS,BYTES USED,ATOMS FREE]'
     The number of atoms free is the number of atoms allocated (the
     first element in the list) subtracted from the maximum number of
     atoms, i.e. 262143 (33554431) on 32-bit (64-bit) architectures.
     Note that atom garbage collection may be able to reclaim some of
     the allocated atoms.  Formed from basic values below.

'atom_garbage_collection'
     '[NO. OF AGCS,BYTES FREED,TIME SPENT]'
     Formed from basic values below.

'defragmentation'
     '[NO. OF DEFRAGMENTATIONS,TIME SPENT]'
     Formed from basic values below.

'memory_used   since release 4.1'
     BYTES USED

'memory_free   since release 4.1'
     BYTES FREE

'global_stack_used   since release 4.1'
     BYTES USED

'global_stack_free   since release 4.1'
     BYTES FREE

'local_stack_used   since release 4.1'
     BYTES USED

'local_stack_free   since release 4.1'
     BYTES FREE

'trail_used   since release 4.1'
     BYTES USED

'trail_free   since release 4.1'
     BYTES FREE

'choice_used   since release 4.1'
     BYTES USED

'choice_free   since release 4.1'
     BYTES FREE

'atoms_used   since release 4.1'
     BYTES USED

'atoms_nbused   since release 4.1'
     ATOMS USED

'atoms_nbfree   since release 4.1'
     ATOMS FREE

'ss_global   since release 4.1'
     NUMBER OF GLOBAL STACK SHIFTS

'ss_local   since release 4.1'
     NUMBER OF LOCAL STACK SHIFTS

'ss_choice   since release 4.1'
     NUMBER OF CHOICE STACK SHIFTS

'ss_time   since release 4.1'
     TIME SPENT STACK SHIFTING

'gc_count   since release 4.1'
     NUMBER OF GARBAGE COLLECTIONS

'gc_freed   since release 4.1'
     NUMBER OF BYTES FREED

'gc_time   since release 4.1'
     TIME SPENT COLLECTING GARBAGE

'agc_count   since release 4.1'
     NUMBER OF ATOM GARBAGE COLLECTIONS

'agc_nbfreed   since release 4.1'
     NUMBER OF GARBAGE COLLECTED ATOMS

'agc_freed   since release 4.1'
     NUMBER OF BYTES FREED BY ATOM GARBAGE COLLECTED

'agc_time   since release 4.1'
     TIME SPENT GARBAGE COLLECTED ATOMS

'defrag_count   since release 4.1'
     NUMBER OF MEMORY DEFRAGMENTATIONS

'defrag_time   since release 4.1'
     TIME SPENT DEFRAGMENTING MEMORY

'dpgc_count   since release 4.1'
     NUMBER OF DEAD PREDICATE RECLAMATIONS

'dpgc_time   since release 4.1'
     TIME SPENT RECLAIMING DEAD PREDICATES

'dcgc_count   since release 4.1'
     NUMBER OF DEAD CLAUSE RECLAMATIONS

'dcgc_time   since release 4.1'
     TIME SPENT RECLAIMING DEAD CLAUSES

'memory_culprit   since release 4.1'
     MEMORY BUCKET IN WHICH LATEST MEMORY RESOURCE ERROR OCCURRED

'memory_buckets   since release 4.1'
     LIST OF BUCKET-SIZE PAIR
     where SIZE is the amount of memory in use for memory bucket BUCKET.

'jit_count   since release 4.3'
     NUMBER OF JIT-COMPILED PREDICATES
     This is zero when JIT compilation is not available.

'jit_time   since release 4.3'
     TIME SPENT JIT-COMPILING PREDICATES
     This is zero when JIT compilation is not available.

   To see an example of the use of each of these keywords, type
     | ?- statistics(K, L).

and then repeatedly type ';' to backtrack through all the possible
keywords.  As an additional example, to report information on the
runtime of a predicate 'p/0', add the following to your program:

     :- statistics(runtime, [T0| _]),
        p,
        statistics(runtime, [T1|_]),
        T is T1 - T0,
        format('p/0 took ~3d sec.~n', [T]).
   *Note mpg-ref-statistics::.


File: sicstus.info,  Node: ref-mgc-gcp,  Next: ref-mgc-egc,  Prev: ref-mgc-ove,  Up: ref-mgc

4.10.2 Garbage Collection and Programming Style
-----------------------------------------------

The availability of garbage collection can lead to a more natural
programming style.  Without garbage collection, a procedure that
generates heap garbage may have to be executed in a failure-driven loop.
Failure-driven loops minimize heap usage from iteration to iteration of
a loop via SICStus Prolog's automatic recovery of heap space on failure.
For instance, in the following procedure 'echo/0' echoes Prolog terms
until it reads an end-of-file character.  It uses a failure-driven loop
to recover inaccessible heap space.
     echo :- repeat,
             read(Term),
             echo_term(Term),
             !.

     echo_term(Term) :-
             Term == end_of_file.
     echo_term(Term) :-
             writeq(Term), nl,
             fail.

   Any heap garbage generated by 'read/1' or 'write/1' is automatically
reclaimed by the failure of each iteration.

   Although failure-driven loops are an accepted Prolog idiom, they are
not particularly easy to read or understand.  So we might choose to
write a clearer version of 'echo/0' using recursion instead, as in
     echo :- read(Term),
             echo_term(Term).

     echo_term(Term) :-
             Term == end_of_file,
             !.
     echo_term(Term) :-
             writeq(Term), nl,
             echo.

   Without garbage collection the more natural recursive loop
accumulates heap garbage that cannot be reclaimed automatically.  While
it is unlikely that this trivial example will run out of heap space,
larger and more practical applications may be unable to use the clearer
recursive style without garbage collection.  With garbage collection,
all inaccessible heap space will be reclaimed by the garbage collector.

   Using recursion rather than failure-driven loops can improve
programming style further.  We might want to write a predicate that
reads terms and collects them in a list.  This is naturally done in a
recursive loop by accumulating results in a list that is passed from
iteration to iteration.  For instance,
     collect(List) :-
             read(Term),
             collect_term(Term, List).

     collect_term(Term, []) :-
             Term == end_of_file,
             !.
     collect_term(Term, [Term|List0]) :-
             collect(List0).

   For more complex applications this sort of construction might prove
unusable without garbage collection.  Instead, we may be forced to use a
failure-driven loop with side-effects to store partial results, as in
the following much less readable version of 'collect/1':
     collect(List) :-
             repeat,
             read(Term),
             store_term(Term),
             !,
             collect_terms(List).

     store_term(Term) :-
             Term == end_of_file.

     store_term(Term) :-
             assertz(term(Term)),
             fail.

     collect_terms([M|List]) :-
             retract(term(M)),
             !,
             collect_terms(List).
     collect_terms([]).

   The variable bindings made in one iteration of a failure-driven loop
are unbound on failure of the iteration.  Thus partial results cannot
simply be stored in a data structure that is passed along to the next
iteration.  We must instead resort to storing partial results via
side-effects (here, 'assertz/1') and collect (and clean up) partial
results in a separate pass.  The second example is much less clear to
most people than the first.  It is also much less efficient than the
first.  However, if there were no garbage collector, then larger
examples of the second type might be able to run where those of the
first type would run out of memory.


File: sicstus.info,  Node: ref-mgc-egc,  Next: ref-mgc-mgc,  Prev: ref-mgc-gcp,  Up: ref-mgc

4.10.3 Enabling and Disabling the Garbage Collector
---------------------------------------------------

The user has the option of executing programs with or without garbage
collection.  Procedures that do not use a large amount of heap space
before backtracking may not be affected when garbage collection is
enabled.  Procedures that do use a large amount of heap space may
execute more slowly due to the time spent garbage collecting, but will
be more likely to run to completion.  On the other hand, such programs
may run faster when the garbage collector is enabled because the virtual
memory is not expanded to the extent that "thrashing" occurs.  The 'gc'
Prolog flag can be set to 'on' or 'off'.  To monitor garbage collections
in verbose mode, set the 'gc_trace' flag to 'verbose'.  By default,
garbage collection is enabled.


File: sicstus.info,  Node: ref-mgc-mgc,  Next: ref-mgc-gch,  Prev: ref-mgc-egc,  Up: ref-mgc

4.10.4 Monitoring Garbage Collections
-------------------------------------

By default, the user is given no indication that the garbage collector
is operating.  If no program ever runs out of space and no program using
a lot of heap space requires an inordinate amount of processing time,
then such information is unlikely to be needed.

   However, if a program thought to be using much heap space runs out of
space or runs inordinately slowly, then the user may want to determine
whether more or less frequent garbage collections are necessary.
Information obtained from the garbage collector by turning on the
'gc_trace' Prolog flag can be helpful in this determination.


File: sicstus.info,  Node: ref-mgc-gch,  Next: ref-mgc-gcd,  Prev: ref-mgc-mgc,  Up: ref-mgc

4.10.5 Interaction of Garbage Collection and Heap Expansion
-----------------------------------------------------------

For most programs, the default settings for the garbage collection
parameters should suffice.  For programs that have high heap
requirements, the default parameters may result in a higher ratio of
garbage collection time to run time.  These programs should be given
more space in which to run.

   The 'gc_margin' is a non-negative integer specifying the desired
margin in kilobytes.  For example, the default value of 1000 means that
the heap will not be expanded if garbage collection can reclaim at least
one megabyte.  The advantage of this criterion is that it takes into
account both the user's estimate of the heap usage and the effectiveness
of garbage collecting.

  1. Setting the 'gc_margin' higher than the default will cause fewer
     heap expansions and garbage collections.  However, it will use more
     space, and garbage collections will be more time-consuming when
     they do occur.

     Setting the margin too large will cause the heap to expand so that
     if it does overflow, then the resulting garbage collection will
     significantly disrupt normal processing.  This will be especially
     so if much of the heap is accessible to future computation.
  2. Setting the 'gc_margin' lower than the default will use less space,
     and garbage collections will be less time-consuming.  However, it
     will cause more heap expansions and garbage collections.

     Setting the margin too small will cause many garbage collections in
     a small amount of time, so that the ratio of garbage-collecting
     time to computation time will be abnormally high.
  3. Setting the margin correctly will cause the heap to expand to a
     size where expansions and garbage collections are infrequent and
     garbage collections are not too time-consuming, if they occur at
     all.

   The correct value for the 'gc_margin' is dependent upon many factors.
Here is a non-prioritized list of some of them:

   * The amount of memory available to the Prolog process
   * The maximum memory limit imposed on the Prolog process
   * The program's rate of heap garbage generation
   * The program's rate of heap non-garbage generation
   * The program's backtracking behavior
   * The amount of time needed to collect the generated garbage
   * The growth rate of the other Prolog stacks

   The algorithm used when the heap overflows is as follows:


     if 'gc' is on
     and the heap is larger than 'gc_margin' kilobytes then
        garbage collect the heap
        if less than 'gc_margin' kilobytes are reclaimed then
           try to expand the heap
        endif
     else
        try to expand the heap
     endif

   The user can use the 'gc_margin' option of 'prolog_flag/3' to reset
the 'gc_margin' (see *note ref-lps-ove::).  If a garbage collection
reclaims at least the 'gc_margin' kilobytes of heap space, then the heap
is not expanded after garbage collection completes.  Otherwise, the heap
is expanded after garbage collection.  This expansion provides space for
the future heap usage that will presumably occur.  In addition, no
garbage collection occurs if the heap is smaller than 'gc_margin'
kilobytes.


File: sicstus.info,  Node: ref-mgc-gcd,  Next: ref-mgc-ago,  Prev: ref-mgc-gch,  Up: ref-mgc

4.10.6 Invoking the Garbage Collector Directly
----------------------------------------------

Normally, the garbage collector is invoked only when some Prolog data
area overflows, so the time of its invocation is not predictable.  In
some applications it may be desirable to invoke the garbage collector at
regular intervals (when there is known to be a significant amount of
garbage on the heap) so that the time spent garbage collecting is more
evenly distributed in the processing time.  For instance, it may prove
desirable to invoke the garbage collector after each iteration of a
question-and-answer loop that is not failure-driven.

   In rare cases the default garbage collection parameters result in
excessive garbage collecting costs or heap expansion, and the user
cannot tune the 'gc_margin' parameter adequately.  Explicitly invoking
the garbage collector using the built-in predicate 'garbage_collect/0'
can be useful in these circumstances.

   *Note mpg-ref-garbage_collect::.


File: sicstus.info,  Node: ref-mgc-ago,  Next: ref-mgc-sum,  Prev: ref-mgc-gcd,  Up: ref-mgc

4.10.7 Atom Garbage Collection
------------------------------

* Menu:

* ref-mgc-ago-agc::                     The Atom Garbage Collector User Interface
* ref-mgc-ago-pat::                     Protecting Atoms in Foreign Memory
* ref-mgc-ago-prm::                     Permanent Atoms
* ref-mgc-ago-are::                     Details of Atom Registration

By default, atoms created during the execution of a program remain
permanently in the system until Prolog exits.  For the majority of
applications this behavior is not a problem and can be ignored.
However, for two classes of application this can present problems.
Firstly the internal architecture of SICStus Prolog limits the number of
atoms that be can created to 1,048,575 on 32-bit machines, and this can
be a problem for database applications that read large numbers of atoms
from a database.  Secondly, the space occupied by atoms can become
significant and dominate memory usage, which can be a problem for
processes designed to run perpetually.

   These problems can be overcome by using atom garbage collection to
reclaim atoms that are no longer accessible to the executing program.

   Atoms can be created in many ways: when an appropriate token is read
with 'read_term/3', when source or PO files are loaded, when
'atom_codes/2' is called with a character list, or when
'SP_atom_from_string()' is called in C code.  In any of these contexts
an atom is only created if it does not already exist; all atoms for a
given string are given the same identification number, which is
different from the atom of any other string.  Thus, atom recognition and
comparison can be done quickly, without having to look at strings.  An
occurrence of an atom is always of a fixed, small size, so where a given
atom is likely to be used in several places simultaneously the use of
atoms can also be more compact than the use of strings.

   A Prolog functor is implemented like an atom, but also has an
associated arity.  For the purposes of atom garbage collection, a
functor is considered to be an occurrence of the atom of that same name.

   Atom garbage collection is similar to heap garbage collection,
invoked automatically as well as through a call to the built-in
predicate 'garbage_collect_atoms/0'.  The atom garbage collector scans
Prolog's data areas looking for atoms that are currently in use and then
throws away all unused atoms, reclaiming their space.

   Atom garbage collection can turn an application that continually
grows and eventually either runs into the atom number limit or runs out
of space into one that can run perpetually.  It can also make feasible
applications that load and manipulate huge quantities of atom-rich data
that would otherwise become full of useless atoms.


File: sicstus.info,  Node: ref-mgc-ago-agc,  Next: ref-mgc-ago-pat,  Up: ref-mgc-ago

4.10.7.1 The Atom Garbage Collector User Interface
..................................................

Because the creation of atoms does not follow any other system behaviors
like memory growth or heap garbage collection, SICStus has chosen to
keep the invocation of atom garbage collection independent of any other
operation and to keep the invocation of atom garbage collection explicit
rather than making it automatic.  It is often preferable for the
programmer to control when it will occur in case preparations need to be
made for it.

   Atom garbage collection is invoked automatically when the number of
new atoms created since the last atom garbage collection reaches the
value of the 'agc_margin' flag.

   Atom garbage collection can be invoked explicitly by calling
'garbage_collect_atoms/0'.  The predicate normally succeeds silently.
The user may determine whether to invoke atom garbage collection at a
given point based on information returned from a call to 'statistics/2'
with the keyword 'atoms'.  That call returns a list of the form

     [NUMBER OF ATOMS, ATOM SPACE IN USE, ATOM SPACE FREE]

   For example,

     | ?- statistics(atoms, Stats).

     Stats = [4313,121062,31032]

   One would typically choose to call 'garbage_collect_atoms/0' prior to
each iteration of an iterative application, when either the number of
atoms or the atom space in use passes some threshold, e.g.

     <driver loop> :-
             ...
             repeat,
                maybe_atom_gc,
                <do next iteration>
                ...
             fail.
     <driver loop>.

where

     maybe_atom_gc :-
             statistics(atoms, [_,Inuse,_]),
             atom_gc_space_threshold(Space),
             ( Inuse > Space -> garbage_collect_atoms ; true ).

     % Atom GC if there are more than 100000 bytes of atoms:
     atom_gc_space_threshold(100000).

   More sophisticated approaches might use both atom number, atom space
and 'agc_margin' thresholds, or could adjust a threshold if atom garbage
collection did not free an adequate number of atoms.

   To be most effective, atom garbage collection should be called when
as few as possible atoms are actually in use.  In the above example, for
instance, it makes the most sense to do atom garbage collection at the
beginning of each iteration rather than at the end, as at the beginning
of the iteration the previous failure may just have freed large amounts
of atom-rich global and local stack.  Similarly, it is better to invoke
atom garbage collection after abolishing or retracting a large database
than to do so before.  *Note mpg-ref-garbage_collect_atoms::.


File: sicstus.info,  Node: ref-mgc-ago-pat,  Next: ref-mgc-ago-prm,  Prev: ref-mgc-ago-agc,  Up: ref-mgc-ago

4.10.7.2 Protecting Atoms in Foreign Memory
...........................................

SICStus Prolog's foreign language interface allows atoms to be passed to
foreign functions.  When calling foreign functions from Prolog, atoms
are passed via the '+atom' argument type in the predicate specifications
of 'foreign/[2,3]' facts.  The strings of atoms can be passed to foreign
functions via the '+string' argument type.  In the latter case a pointer
to the Prolog symbol table's copy of the string for an atom is what is
passed.  When calling Prolog from C, atoms are passed back from C to
Prolog using the '-atom' and '-string' argument types in 'extern/1'
declarations.  Atoms can also be created in foreign code via functions
like 'SP_atom_from_string()'.

   Prolog does not keep track of atoms (or strings of atoms) stored in
foreign memory.  As such, it cannot guarantee that those atoms will be
retained by atom garbage collection.  Therefore SICStus Prolog provides
functions to "register" atoms (or their strings) with the atom garbage
collector.  Registered atoms will not be reclaimed by the atom garbage
collector.  Atoms can be registered while it is undesirable for them to
be reclaimed, and then unregistered when they are no longer needed.

   Of course, the majority of atoms passed as atoms or strings to
foreign functions do not need to be registered.  Only those that will be
stored across foreign function calls (in global variables) or across
nested calls to Prolog are at risk.  An extra margin of control is given
by the fact the programmer always invokes atom garbage collection
explicitly, and can ensure that this is only done in contexts that are
"safe" for the individual application.

   To register or unregister an atom, one of the following functions is
used:

     int SP_register_atom(atom)
     SP_atom atom;

     int SP_unregister_atom(atom)
     SP_atom atom;

   These functions return either 'SP_ERROR' or a non-negative integer.
The return values are discussed further in *note ref-mgc-ago-are::.

   As noted above, when an atom is passed as a string ('+string') to a
foreign function, the string the foreign function receives is the one in
Prolog's symbol table.  When atom garbage collection reclaims the atom
for that string, the space for the string will also be reclaimed.

   Thus, if the string is to be stored across foreign calls, then either
a copy of the string or else the atom ('+atom') should be passed into
the foreign function so that it can be registered and
'SP_string_from_atom()' can be used to access the string from the atom.

   Keep in mind that the registration of atoms only pertains to those
passed to foreign functions or created in foreign code.  Atoms in
Prolog's data areas are maintained automatically.  Note also that even
though an atom may be unregistered in foreign code, atom garbage
collection still may not reclaim it as it may be referenced from
Prolog's data areas.  But if an atom is registered in foreign code, then
it will be preserved regardless of its presence in Prolog's data areas.

   The following example illustrates the use of these functions.  In
this example the current value of an object (which is an atom) is being
stored in a C global variable.  There are two C functions that can be
called from Prolog, one to update the current value and one to access
the value.

     #include <sicstus/sicstus.h>

     SP_atom current_object = NULL;

     update_object(newvalue)
     SP_atom newvalue;
     {
             /* if current_object contains an atom, unregister it */
             if (current_object)
                     (void) SP_unregister_atom(current_object);

             /* register new value */
             (void) SP_register_atom(newvalue);
             current_object = newvalue;
     }

     SP_atom get_object()
     {
             return current_object;
     }


File: sicstus.info,  Node: ref-mgc-ago-prm,  Next: ref-mgc-ago-are,  Prev: ref-mgc-ago-pat,  Up: ref-mgc-ago

4.10.7.3 Permanent Atoms
........................

Atom garbage collection scans all Prolog's dynamic data areas when
looking for atoms that are in use.  Scanning finds atoms in the Prolog
stacks and in all compiled and interpreted code that has been
dynamically loaded into Prolog via 'consult/1', 'use_module/1',
'assert/2', etc.  However, there are certain potential sources of atoms
in the Prolog image from which atoms cannot be reclaimed.  Atoms for
Prolog code that has been statically linked with either the Prolog
Development Environment or the Runtime Environment have been placed in
the text space, making them (and the code that contains them)
effectively permanent.  Although such code can be abolished, its space
can never be reclaimed.

   These atoms are internally flagged as permanent by the system and are
always retained by atom garbage collection.  An atom that has become
permanent cannot be made non-permanent, so can never be reclaimed.


File: sicstus.info,  Node: ref-mgc-ago-are,  Prev: ref-mgc-ago-prm,  Up: ref-mgc-ago

4.10.7.4 Details of Atom Registration
.....................................

The functions that register and unregister atoms are in fact using
reference counting to keep track of atoms that have been registered.  As
a result, it is safe to combine your code with libraries and code others
have written.  If the other code has been careful to register and
unregister its atoms as appropriate, then atoms will not be reclaimed
until everyone has unregistered them.

   Of course, it is possible when writing code that needs to register
atoms that errors could occur.  Atoms that are registered too many times
simply will not be garbage collected until they are fully unregistered.
However, atoms that are not registered when they should be may be
reclaimed on atom garbage collection.  One normally does not need to
think about the reference counting going on in 'SP_register_atom()' and
'SP_unregister_atom()', but some understanding of its details could
prove helpful when debugging.

   To help you diagnose problems with registering and unregistering
atoms, 'SP_register_atom()' and 'SP_unregister_atom()' both normally
return the current reference count for the atom.  If an error occurs,
e.g. a nonexistent atom is registered or unregistered, then 'SP_ERROR'
is returned.

   An unregistered atom has a reference count of 0.  Unregistering an
atom that is unregistered is a no-op; in this case,
'SP_unregister_atom()' returns 0.  A permanent atom has a reference
count of 256.  In addition, if an atom is simultaneously registered 256
times, then it becomes permanent.  (An atom with 256 distinct references
is an unlikely candidate for reclamation!)  Registering or unregistering
an atom that is permanent is also a no-op; 'SP_register_atom()' and
'SP_unregister_atom()' return 256.


File: sicstus.info,  Node: ref-mgc-sum,  Prev: ref-mgc-ago,  Up: ref-mgc

4.10.8 Summary of Predicates
----------------------------

'garbage_collect'
     force an immediate garbage collection

'garbage_collect_atoms'
     garbage collect atom space

'statistics'
     display various execution statistics

'statistics(?K,?V)'
     the execution statistic with key K has value V

'trimcore'
     reduce free stack space to a minimum


File: sicstus.info,  Node: ref-mod,  Next: ref-mdb,  Prev: ref-mgc,  Up: Prolog Intro

4.11 Modules
============

* Menu:

* ref-mod-ove::                         Overview
* ref-mod-bas::                         Basic Concepts
* ref-mod-def::                         Defining a Module
* ref-mod-n2m::                         Converting Non-module-files into Module-files
* ref-mod-lod::                         Loading a Module
* ref-mod-vis::                         Visibility Rules
* ref-mod-som::                         The Source Module
* ref-mod-tyi::                         The Type-in Module
* ref-mod-dmo::                         Creating a Module Dynamically
* ref-mod-mpc::                         Module Prefixes on Clauses
* ref-mod-cim::                         Debugging Code in a Module
* ref-mod-ncl::                         Name Clashes
* ref-mod-ilm::                         Obtaining Information about Loaded Modules
* ref-mod-idp::                         Importing Dynamic Predicates
* ref-mod-mne::                         Module Name Expansion
* ref-mod-met::                         The meta_predicate Declaration
* ref-mod-sem::                         Semantics of Module Name Expansion
* ref-mod-sum::                         Predicate Summary


File: sicstus.info,  Node: ref-mod-ove,  Next: ref-mod-bas,  Up: ref-mod

4.11.1 Overview
---------------

The module system lets the user divide large Prolog programs into
"modules", or rather smaller sub-programs, and define the interfaces
between those modules.  Each module has its own name space; that is, a
predicate defined in one module is distinct from any predicates with the
same name and arity that may be defined in other modules.  The module
system encourages a group of programmers to define the dependence each
has on others' work before any code is written, and subsequently allows
all to work on their own parts independently.  It also helps to make
library predicates behave as extensions of the existing set of built-in
predicates.

   The SICStus Prolog library uses the module system and can therefore
serve as an extended example of the concepts presented in the following
text.  The design of the module system is such that loading library
files and calling library predicates can be performed without knowledge
of the module system.

   Some points to note about the module system are that:

   * It is based on predicate modularity rather than on data modularity;
     that is, atoms and functors are global.

   * It is flat rather than hierarchical; any module may refer to any
     other module by its name--there is no need to specify a path of
     modules.
   * It is not strict; modularity rules can be explicitly overridden.
     This is primarily for flexibility during debugging.
   * It is efficient; calls to predicates across module boundaries incur
     little or no overhead.


File: sicstus.info,  Node: ref-mod-bas,  Next: ref-mod-def,  Prev: ref-mod-ove,  Up: ref-mod

4.11.2 Basic Concepts
---------------------

Each predicate in a program is identified by its "module", as well as by
its name and arity.

   A module defines a set of predicates, among which some have the
property of being "public".  Public predicates are predicates that can
be "imported" by other modules, which means that they can then be called
from within those modules.  Predicates that are not public are "private"
to the module in which they are defined; that is, they cannot be called
from outside that module (except by explicitly overriding the modularity
rules as described in *note ref-mod-vis::).

   There are two kinds of importation:

  1. A module M1 may import a specified set of predicates from another
     module M2.  All the specified predicates should be public in M2.
  2. A module M1 may import all the public predicates of another module
     M2.

   Built-in predicates do not need to be imported; they are
automatically available from within any module.

   There is a special module called 'user', which is used by default
when predicates are being defined and no other module has been
specified.

   The other predefined module is the 'prolog' module where all the
built-in predicates reside.  The exported built-in predicates are
automatically imported into each new module as it is created.

   If you are using a program written by someone else, then you need not
be concerned as to whether or not that program has been made into a
module.  The act of loading a module from a file using 'compile/1', or
'ensure_loaded/1' (see *note ref-lod::) will automatically import all
the public predicates in that module.  Thus the command
     :- ensure_loaded(library(lists)).

will load the list-processing predicates from the library and make them
available.


File: sicstus.info,  Node: ref-mod-def,  Next: ref-mod-n2m,  Prev: ref-mod-bas,  Up: ref-mod

4.11.3 Defining a Module
------------------------

The normal way to define a module is by creating a "module-file" for it
and loading it into the Prolog system.  A module-file is a Prolog file
that begins with a "module declaration".

   A module declaration has one of the forms:
     :- module(+MODULENAME, +PUBLICPREDLIST).

     :- module(+MODULENAME, +PUBLICPREDLIST, +OPTIONS).

   Such a declaration must appear as the first term in a file, and
declares that file to be a module-file.  The predicates in the file will
become part of the module MODULENAME, and the predicates specified in
PUBLICPREDLIST are those that can be imported by other modules; that is,
the public predicates of this module.

   OPTIONS is an optional argument, and should be a list.  The only
available option is 'hidden(BOOLEAN)', where BOOLEAN is 'false' (the
default) or 'true'.  In the latter case, tracing of the predicates of
the module is disabled (although spypoints can be set), and no source
information is generated at compile time.

   Instead of creating and loading a module-file, it is also possible to
define a module dynamically by, for example, asserting clauses into a
specified module.  A module created in this way has no public
predicates; all its predicates are private.  This means that they cannot
be called from outside that module except by explicitly overriding the
modularity rules as described in *note ref-mod-vis::.  Dynamic creation
of modules is described in more detail in *note ref-mod-dmo::.


File: sicstus.info,  Node: ref-mod-n2m,  Next: ref-mod-lod,  Prev: ref-mod-def,  Up: ref-mod

4.11.4 Converting Non-module-files into Module-files
----------------------------------------------------

The Prolog cross-referencer can automatically generate 'module/2'
declarations from its cross-reference information.  This is useful if
you want to take a set of files making up a program and make each of
those files into a module-file.  For more information, *note The
Cross-Referencer::

   Alternatively, if you have a complete Prolog program consisting of a
set of source files '{file1, file2, ...}', and you wish to encapsulate
it in a single module MOD, then this can be done by creating a "driver"
file of the following form:


     :- module(MOD, [ ... ]).

     :- ensure_loaded(file1).
     :- ensure_loaded(file2).
        .
        .
        .

   When a module is created in this way, none of the files in the
program '{file1, file2, ...}' have to be changed.


File: sicstus.info,  Node: ref-mod-lod,  Next: ref-mod-vis,  Prev: ref-mod-n2m,  Up: ref-mod

4.11.5 Loading a Module
-----------------------

To gain access to the public predicates of a module-file, load it as you
would any other file--using 'compile/1', or 'ensure_loaded/1' as
appropriate.  For example, if your code contains a directive such as
     :- ensure_loaded(FILE).

then this directive will load the appropriate file FILE whether or not
FILE is a module-file.  The only difference is that if FILE is a
module-file, then any private predicates that it defines will not be
visible to your program.

   The load predicates are adequate for use at Prolog's top-level, or
when the file being loaded is a utility such as a library file.  When
you are writing modules of your own, 'use_module/[1,2,3]' is the most
useful.

   The following predicates are used to load modules:

'use_module(F)'
     import the module-file(s) F, loading them if necessary; same as
     'ensure_loaded(F)' if all files in F are module-files

'use_module(:F,+I)'
     import the procedure(s) I from the module-file F, loading
     module-file F if necessary

'use_module(?M,:F,+I)'
     import I from module M, loading module-file F if necessary

   Before a module-file is loaded, the associated module is
"reinitialized": any predicates previously imported into or defined in
that module are forgotten by the module.

   If a module of the same name with a different PUBLICPREDLIST or
different meta-predicate list has previously been loaded from a
different module-file, then a warning is printed and you are given the
option of abandoning the load.  Only one of these two modules can exist
in the system at one time.

   Normally, a module-file can be reloaded after editing with no need to
reload any other modules.  However, when a module-file is reloaded after
its PUBLICPREDLIST has been changed, any modules that import predicates
from it may have become inconsistent.  This is because a module is
associated with a predicate at compile time, rather than run time.
Thus, other modules may refer to predicates in a module-file that are no
longer public.  In the case of module-importation (where all, rather
than specific, public predicates of a module are imported), it is
possible that some predicates in the importing module should now refer
to a newly-public predicate but do not.  SICStus Prolog tries to detect
such inconsistencies, and issues a warning when it does detect one.
Similarly, if a meta-predicate declaration of an exported predicate
changes, then modules that have already imported that predicate become
inconsistent, because module name expansion requirements have changed.
The current release of SICStus Prolog is unable to detect such
inconsistencies.

   Modules may be saved to a PO file by calling
'save_modules(MODULES,FILE)' (see *note ref-sls::).


File: sicstus.info,  Node: ref-mod-vis,  Next: ref-mod-som,  Prev: ref-mod-lod,  Up: ref-mod

4.11.6 Visibility Rules
-----------------------

By default, predicates defined in one module cannot be called from
another module.  This section enumerates the exceptions to this--the
ways in which a predicate can be "visible" to modules other than the one
in which it is defined.

  1. The built-in predicates can be called from any module.
  2. Any predicate that is named in the PUBLICPREDLIST of a module, and
     that is imported by some other module M, can be called from within
     M.
  3. Module Prefixing: Any predicate, whether public or not, can be
     called from any other module if its module is explicitly given as a
     prefix to the goal, attached with the ':/2' operator.  The module
     prefix overrides the default module.  For example,
          :- mod:foo(X,Y).

     always calls 'foo/2' in module MOD.  This is effectively a loophole
     in the module system, which allows you to override the normal
     module visibility rules.  It is intended primarily to facilitate
     program development and debugging, and it should not be used
     extensively since it subverts the original purposes of using the
     module system.

     Note that a predicate called in this way does not necessarily have
     to be defined in the specified module.  It may be imported into it.
     It can even be a built-in predicate, and this is sometimes
     useful--see *note ref-mod-som:: for an example.


File: sicstus.info,  Node: ref-mod-som,  Next: ref-mod-tyi,  Prev: ref-mod-vis,  Up: ref-mod

4.11.7 The Source Module
------------------------

For any given procedure call, or goal, the "source module" is the module
in which the corresponding predicate must be visible.  That is, unless
the predicate is built-in, it must be defined in, or imported into, the
source module.

   For goals typed at the top-level, the source module is the "type-in
module", which is 'user' by default--see *note ref-mod-tyi::.  For goals
appearing in a file, whether in a directive or in the body of a clause,
the source module is the one into which that file has been loaded.

   There are a number of built-in predicates that take predicate
specifications, clauses, or goals as arguments.  Each of these types of
argument must be understood with reference to some module.  For example,
'assert/1' takes a clause as its argument, and it must decide into which
module that clause should be asserted.  The default assumption is that
it asserts the clause into the source module.  Another example is
'call/1'.  The goal (A) calls the predicate 'foo/1' in the source
module; this ensures that in the compound goal (B) both occurrences of
'foo/1' refer to the same predicate.

     call(foo(X))  (A)

     call(foo(X)), foo(Y)   (B)

   All predicates that refer to the source module allow you to override
it by explicitly naming some other module to be used instead.  This is
done by prefixing the relevant argument of the predicate with the module
to be used followed by a ':' operator.  For example (C), asserts 'f(x)'
in module 'm'.

     | ?- assert(m:f(x)).  (C)

   Note that if you call a goal in a specified module, overriding the
normal visibility rules (see *note ref-mod-vis::), then the source
module for that goal is the one you specify, not the module in which
this call occurs.  For example (D), has exactly the same effect as
(C)--'f(x)' is asserted in module 'm'.  In other words, prefixing a goal
with a module duplicates the effect of calling that goal from that
module.
     | ?- m:assert(f(x)).  (D)

   Another built-in predicate that refers to the source module is
'compile/1'.  In this case, the argument is a file, or list of files,
rather than a predicate specification, clause, or goal.  However, in the
case where a file is not a module-file, 'compile/1' must decide into
which module to compile its clauses, and it chooses the source module by
default.  This means that you can compile a file FILE into a specific
module M using
     | ?- compile(M:FILE).

   Thus if FILE is a module-file, then this command would cause its
public predicates to be imported into module M.  If FILE is a
non-module-file, then it is loaded into module M.

   For a list of the built-in predicates that depend on the source
module, see *note ref-mod-mne::.  In some cases, user-defined predicates
may also require the concept of a source module.  This is discussed in
*note ref-mod-met::.


File: sicstus.info,  Node: ref-mod-tyi,  Next: ref-mod-dmo,  Prev: ref-mod-som,  Up: ref-mod

4.11.8 The Type-in Module
-------------------------

The "type-in" module is the module that is taken as the source module
for goals typed in by the user.  The name of the default type-in module
is 'user'.  That is, the predicates that are available to be called
directly by the user are those that are visible in the module 'user'.

   When debugging, it is often useful to call, directly from the
top-level, predicates that are private to a module, or predicates that
are public but that are not imported into 'user'.  This can be done by
prefixing each goal with the module name, as described in *note
ref-mod-vis::; but rather than doing this extensively, it may be more
convenient to make this module the type-in module.

   The type-in module can be changed using the built-in predicate
'set_module/1'; for example,
     | ?- set_module(mod).

   This command will cause subsequent goals typed at the top-level to be
executed with 'mod' as their source module.

   The name of the type-in module is always displayed, except when it is
'user'.  If you are running Prolog under the editor interface, then the
type-in module is displayed in the status line of the Prolog window.  If
you are running Prolog without the editor interface, then the type-in
module is displayed before each top-level prompt.

   For example, if you are running Prolog without the editor:
     | ?- set_module(foo).

     yes
     [foo]
     | ?-

   It should be noted that it is unlikely to be useful to change the
type-in module via a directive embedded in a file to be loaded, because
this will have no effect on the load--it will only change the type-in
module for commands subsequently entered by the user.


File: sicstus.info,  Node: ref-mod-dmo,  Next: ref-mod-mpc,  Prev: ref-mod-tyi,  Up: ref-mod

4.11.9 Creating a Module Dynamically
------------------------------------

There are several ways in which you can create a module without loading
a module-file for it.  One way to do this is by asserting clauses into a
specified module.  For example, the command (A) will create the dynamic
predicate 'f/1' and the module 'm' if they did not previously exist.

     | ?- assert(m:f(x)).  (A)

   Another way to create a module dynamically is to compile a
non-module-file into a specified module.  For example (B), will compile
the clauses in FILE into the module M.

     | ?- compile(M:FILE).  (B)

   The same effect can be achieved by (temporarily) changing the type-in
module to M (see *note ref-mod-tyi::) and then calling 'compile(FILE)',
or executing the command in module M as in (C).

     | ?- M:compile(FILE).  (C)


File: sicstus.info,  Node: ref-mod-mpc,  Next: ref-mod-cim,  Prev: ref-mod-dmo,  Up: ref-mod

4.11.10 Module Prefixes on Clauses
----------------------------------

* Menu:

* ref-mod-mpc-cmo::                     Current Modules

Every clause in a Prolog file has a source module implicitly associated
with it.  If the file is a module-file, then the module named in the
module declaration at the top of the file is the source module for all
the clauses.  If the file is not a module-file, then the relevant module
is the source module for the command that caused this file to be loaded.

   The source module of a predicate decides in which module it is
defined (the module of the head), and in which module the goals in the
body are going to be called (the module of the body).  It is possible to
override the implicit source module, both for head and body, of clauses
and directives, by using prefixes.  For example, consider the
module-file:
     :- module(a, []).

     :- dynamic m:a/1.
     b(1).
     m:c([]).
     m:d([H|T]) :- q(H), r(T).
     m:(e(X) :- s(X), t(X)).
     f(X) :- m:(u(X), v(X)).

   In the previous example, the following modules apply:

  1. 'a/1' is declared dynamic in the module 'm'.
  2. 'b/1' is defined in module 'a' (the module of the file).
  3. 'c/1' is defined in module 'm'.
  4. 'd/1' is defined in module 'm', but 'q/1' and 'r/1' are called in
     module 'a' (and must therefore be defined in module 'a').
  5. 'e/1' is defined in module 'm', and 's/1' and 't/1' are called in
     module 'm'.
  6. 'f/1' is defined in module 'a', but 'u/1' and 'v/1' are called in
     module 'm'.

   Module prefixing is especially useful when the module prefix is
'user'.  There are several predicates that have to be defined in module
'user' but that you may want to define (or extend) in a program that is
otherwise entirely defined in some other module or modules; *note
mpg-top-hok::.

   Note that if clauses for one of these predicates are to be spread
across multiple files, then it will be necessary to declare that
predicate to be multifile by putting a multifile declaration in each of
the files.


File: sicstus.info,  Node: ref-mod-mpc-cmo,  Up: ref-mod-mpc

4.11.10.1 Current Modules
.........................

A loaded, or dynamically created, module becomes current as soon as it
is encountered, and a module can never lose the property of being
current.  The set of current modules can be obtained with
'current_module/1', see *note ref-mod-ilm::.


File: sicstus.info,  Node: ref-mod-cim,  Next: ref-mod-ncl,  Prev: ref-mod-mpc,  Up: ref-mod

4.11.11 Debugging Code in a Module
----------------------------------

Having loaded a module to be debugged, you can trace through its
execution in the normal way.  When the debugger stops at a port, the
procedure being debugged is displayed with its module name as a prefix
unless the module is 'user'.

   The predicate 'spy/1' depends on the source module.  It can be useful
to override this during debugging.  For example,
     | ?- spy mod1:f/3.

puts a spypoint on 'f/3' in module 'mod1'.

   It can also be useful to call directly a predicate that is private to
its module in order to test that it is doing the right thing.  This can
be done by prefixing the goal with its module; for example,
     | ?- mod1:f(a,b,X).


File: sicstus.info,  Node: ref-mod-ncl,  Next: ref-mod-ilm,  Prev: ref-mod-cim,  Up: ref-mod

4.11.12 Name Clashes
--------------------

A "name clash" can arise if:

  1. a module tries to import a predicate from some other module 'm1'
     and it has already imported a predicate with the same name and
     arity from a module 'm2';
  2. a module tries to import a predicate from some other module 'm1'
     and it already contains a definition of a predicate with the same
     name and arity; or
  3. a module tries to define a predicate with the same name and arity
     as one that it has imported.

   Whenever a name clash arises, a message is displayed beginning with
the words 'NAME CLASH'.  The user is asked to choose from one of several
options; for example,
     NAME CLASH: f/3 is already imported into module user
                 from module m1;
                 do you want to override this definition with
                 the one in m2? (y,n,p,s,a or ?)

   The meanings of the five recognized replies are as follows:

'y'
     forget the previous definition of 'f/3' from 'm1' and use the new
     definition of 'f/3' from 'm2' instead.
'n'
     retain the previous definition of 'f/3' from 'm1' and ignore the
     new definition of 'f/3' from 'm2'.
'p'
     (for proceed) means forget the previous definition of 'f/3' and of
     all subsequent predicate definitions in 'm1' that clash during the
     current load of 'm2'.  Instead, use the new definitions in 'm2'.
     When the 'p' option is chosen, predicates being loaded from 'm1'
     into 'm2' will cause no 'NAME CLASH' messages for the remainder of
     the load, though clashes with predicates from other modules will
     still generate such messages.
's'
     (for suppress) means forget the new definition of 'f/3' and of all
     subsequent predicate definitions in 'm1' that clash during the
     current load of 'm2'.  Instead, use the old definitions in 'm2'.
     When the 's' option is chosen, predicates being loaded from 'm1'
     into 'm2' will cause no 'NAME CLASH' messages for the remainder of
     the load, though clashes with predicates from other modules will
     still generate such messages.
'?'
     gives brief help information.


File: sicstus.info,  Node: ref-mod-ilm,  Next: ref-mod-idp,  Prev: ref-mod-ncl,  Up: ref-mod

4.11.13 Obtaining Information about Loaded Modules
--------------------------------------------------

* Menu:

* ref-mod-ilm-def::                     Predicates Defined in a Module
* ref-mod-ilm-vis::                     Predicates Visible in a Module

The built-in predicate 'current_module/2' can be used to find all the
currently loaded module, and where they were loaded from.  *Note
mpg-ref-current_module::.

'current_module(?M)'
     M is the name of a current module

'current_module(?M,?F)'
     F is the name of the file in which M's module declaration appears.
     Not all modules have a corresponding file.


File: sicstus.info,  Node: ref-mod-ilm-def,  Next: ref-mod-ilm-vis,  Up: ref-mod-ilm

4.11.13.1 Predicates Defined in a Module
........................................

The built-in predicate 'current_predicate/2' can be used to find the
predicates that are defined in a particular module.

   To backtrack through all of the predicates defined in module 'm', use

     | ?- current_predicate(_, m:Goal).

   To backtrack through _all_ predicates defined in _any_ module, use
     | ?- current_predicate(_, M:Goal).

   This succeeds once for every predicate in your program.  *Note
mpg-ref-current_predicate::.


File: sicstus.info,  Node: ref-mod-ilm-vis,  Prev: ref-mod-ilm-def,  Up: ref-mod-ilm

4.11.13.2 Predicates Visible in a Module
........................................

The built-in predicate 'predicate_property/2' can be used to find the
properties of any predicate that is visible to a particular module.

   To backtrack through all of the predicates imported by module 'm',
use

     | ?- predicate_property(m:Goal, imported_from(_)).

   To backtrack through all of the predicates imported by module 'm1'
from module 'm2', use

     | ?- predicate_property(m1:Goal, imported_from(m2)).

   For example, you can load the 'between' module from the library and
then remind yourself of what predicates it defines like this:

     | ?- compile(library(between)).
     % ... loading messages ...

     yes
     | ?- predicate_property(P, imported_from(between)).
     P = numlist(_A,_B) ? ;
     P = numlist(_A,_B,_C,_D,_E) ? ;
       .
       .
       .

   This tells you what predicates are imported into the type-in module
from 'basics'.

   You can also find _all_ imports into _all_ modules using
     | ?- predicate_property(M1:G, imported_from(M2)).

   To backtrack through all of the defined predicates exported by module
'm', use

     | ?- predicate_property(m:Goal, exported).
   *Note mpg-ref-predicate_property::.


File: sicstus.info,  Node: ref-mod-idp,  Next: ref-mod-mne,  Prev: ref-mod-ilm,  Up: ref-mod

4.11.14 Importing Dynamic Predicates
------------------------------------

Imported dynamic predicates may be asserted and retracted.  For example,
suppose the following file is loaded via 'use_module/1':

     :- module(m1, [f/1]).
     :- dynamic f/1.
     f(0).

   Then 'f/1' can be manipulated as if it were defined in the current
module.  For example,
     | ?- clause(f(X), true).

     X = 0

   The built-in predicate 'listing/[0,1]' distinguishes predicates that
are imported into the current source module by prefixing each clause
with the module name.  Thus,

     | ?- listing(f).

     m1:f(0).

   However, 'listing/[0,1]' does not prefix clauses with their module if
they are defined in the source module itself.  Note that
     | ?- listing.

can be used to see all the dynamic predicates defined in or imported
into the current type-in module.  And
     | ?- listing(m1:_).

can be used to see all such predicates that are defined in or imported
into module 'm1'.  *Note mpg-ref-listing::.


File: sicstus.info,  Node: ref-mod-mne,  Next: ref-mod-met,  Prev: ref-mod-idp,  Up: ref-mod

4.11.15 Module Name Expansion
-----------------------------

The concept of a source module is explained in *note ref-mod-som::.  For
any goal, the applicable source module is determined when the goal is
compiled rather than when it is executed.

   A procedure that needs to refer to the source module has arguments
designated for module name expansion.  These arguments are expanded when
code is consulted, compiled or asserted by the transformation X -> M:X
where M is the name of the source module.  For example, the goal
'call(X)' is expanded into 'call(M:X)' and the goal 'clause(Head, Body)'
is expanded into 'clause(M:Head, Body)'.

   Module name expansion is avoided if the argument to be expanded is
already a ':/2' term.  In this case it is unnecessary since the module
to be used has already been supplied by the programmer.


File: sicstus.info,  Node: ref-mod-met,  Next: ref-mod-sem,  Prev: ref-mod-mne,  Up: ref-mod

4.11.16 The 'meta_predicate' Declaration
----------------------------------------

Sometimes a user-defined predicate will require module name expansion
(see *note ref-mod-mne::).  This can be specified by providing a
'meta_predicate' declaration for that procedure.

   Module name expansion is needed whenever the argument of a predicate
has some module-dependent meaning.  For example, if this argument is a
goal that is to be called, then it will be necessary to know in which
module to call it--or, if the argument is a clause to be asserted, in
which module it should go.

   Consider, for example, a sort routine to which the name of the
comparison predicate is passed as an argument.  In this example, the
comparison predicate should be called, with two arguments like the
built-in '@=</2', with respect to the module containing the call to the
sort routine.  Suppose that the sort routine is
     mysort(COMPAREPROC, INPUTLIST, OUTPUTLIST)

   An appropriate 'meta_predicate' declaration for this is
     :- meta_predicate mysort(2, +, -).

   The significant argument in the 'mysort/3' term is the '2', which
indicates that module name expansion is required for this argument and
that two additional arguments will be added when this argument is
invoked as a goal.  This means that whenever a goal 'mysort(A, B, C)'
appears in a clause, it will be transformed at load time into
'mysort(M:A, B, C)', where M is the source module.  There are some
exceptions to this compile-time transformation rule; the goal is not
transformed if either of the following applies:

  1. A is of the form MODULE:GOAL.
  2. A is a variable and the same variable appears in the head of the
     clause in a module-name-expansion position.

   The reason for (2) is that otherwise module name expansion could
build larger and larger structures of the form MN: ... :M2:M1:GOAL.  For
example, consider the following program fragment adapted from the
library (see 'library(samsort)' for the full program):

     :- module(samsort, [samsort/3]).

     :- meta_predicate
             samsort(2, +, ?),
             sam_sort(+, 2, +, +, ?).

     samsort(_, [], []) :- !.
     samsort(Order, List, Sorted) :-
             sam_sort(List, Order, [], 0, Sorted).
       .
       .
       .

   Normally, the 'sam_sort/5' goal in this example would have the module
name of its second argument expanded thus:
     sam_sort(List, samsort:Order, [], 0, Sorted)

because of the 'meta_predicate' declaration.  However, in this situation
the appropriate source module will have already been attached to ORDER
because it is the first argument of 'samsort/3', which also has a
'meta_predicate' declaration.  Therefore it is not useful to attach the
module name ('samsort') to ORDER in the call of 'sam_sort/5'.

   The argument of a 'meta_predicate' declaration can be a term, or a
sequence of terms separated by commas.  Each argument of each of these
terms must be one of the following:

':'
     requires module name expansion

     If the argument will be treated as a goal, then it is better to
     explicitly indicate this using an integer; see the next item.

NSUPPRESSED
     a non-negative integer.

     This is a special case of ':' which means that the argument can be
     made into a goal by adding NSUPPRESSED additional arguments.  E.g.,
     if the argument will be passed to 'call/1', then '0' (zero) should
     be used.

     An integer is treated the same as ':' above by the SICStus runtime.
     Other tools, such as the cross referencer (*note The
     Cross-Referencer::) and the SICStus Prolog IDE (*note SICStus
     Prolog IDE: SPIDER.), will use this information to better follow
     predicate references in analyzed source code.

     If the number of extra arguments is unknown or varies, then the
     generic ':' is always safe to use, but will give less accurate
     results from source analysis tools.

'*'
'+'
'-'
'?'
     ignored

   The reason for '+', '-' and '?' is simply so that the information
contained in a DEC-10 Prolog-style "mode" declaration may be represented
in the 'meta_predicate' declaration if you wish.  There are many
examples of 'meta_predicate' declarations in the library.

   Prior to release 4.1, only ':' (colon) was used and the integer form
was undocumented (but supported, e.g. by the cross referencer).


File: sicstus.info,  Node: ref-mod-sem,  Next: ref-mod-sum,  Prev: ref-mod-met,  Up: ref-mod

4.11.17 Semantics of Module Name Expansion
------------------------------------------

Although module name expansion is performed when code is consulted,
compiled or asserted, it is perhaps best explained in terms of an
interpreter, especially the issue of how deeply clauses are expanded.
The semantics of 'call/1', taking 'meta_predicate' declarations into
account, is shown as if defined by the interpreter shown below.  The
interpreter's case analysis is as follows:

CONTROL CONSTRUCTS
     (Including cuts and module prefixes).  The interpreter implements
     the semantics of the construct, expanding its argument.
CALLABLE TERMS WITH FUNCTOR N/A
     First, we look for a 'meta_predicate' declaration for N/A.  If one
     exists, then the relevant arguments are expanded.  Otherwise, the
     goal is left unexpanded.  Then, if N/A is a built-in predicate,
     then it is called.  Otherwise, a clause with head functor N/A is
     looked up using the imaginary predicate ':-/2', unified against,
     and its body is interpreted.
NON-CALLABLE TERMS
     Raise error exception.

   Throughout the interpretation, we must keep track of the module
context.  The interpreter is as follows, slightly simplified.  '-->/2'
is _not_ a predicate:

     call(M:Body) :-
             icall(Body, M).

     icall(Var, M) :- \+callable(Var), !,
             must_be(Var, callable, call(M:Var), 1).
     icall(!, _) :- !,
             % _cut relevant choicepoints._
     icall((A, B), M) :- !,
             icall(A, M),
             icall(B, M).
     icall((A -> B), M) :- !,
         (   icall(A, M) ->
             icall(B, M)
         ).
     icall((A -> B ; C), M) :- !,
         (   icall(A, M) ->
             icall(B, M)
         ;   icall(C, M)
         ).
     icall((A ; B), M) :- !,
         (   icall(A, M)
         ;   icall(B, M)
         ).
     icall(\+(A), M) :- !,
         (   icall(A, M) ->
             fail
         ;   true
         ).
     icall(_^A, M) :- !,
             icall(A, M).
     icall(do(Iter,Body), M) :- !,
         (   Iter
         do  icall(Body, M)
         ).
     icall(if(A,B,C), M) :- !,
          if(icall(A, M),
             icall(B, M),
             icall(C, M)).
     icall(once(A), M) :- !,
         (   icall(A, M) -> true
         ).
     icall(Goal, M) :-
         (   predicate_property(M:Goal, meta_predicate(Meta)) ->
             functor(Goal, Name, Arity),
             functor(AGoal, Name, Arity),
             (   foreacharg(Spec,Meta),
                 foreacharg(Arg,Goal),
                 foreacharg(Ann,AGoal),
                 param(M)
             do  (   Spec==(:) -> Ann = M:Arg
                 ;   integer(Spec) -> Ann = M:Arg
                 ;   Ann = Arg
                 )
             ),
             call_goal(AGoal, M)
         ;   call_goal(Goal, M)
         ).

     call_goal(asserta(X), _) :- !,
             asserta(X).
     call_goal(asserta(X,R), _) :- !,
             asserta(X, R).
     % _and so on for all built-in predicates_
     call_goal(Goal, M) :-
             (M:Goal :- Body),
             icall(Body, M).


File: sicstus.info,  Node: ref-mod-sum,  Prev: ref-mod-sem,  Up: ref-mod

4.11.18 Predicate Summary
-------------------------

'current_module(?M)'
     M is the name of a current module

'current_module(?M,?F)'
     F is the name of the file in which M's module declaration appears

'meta_predicate :P   declaration'
     declares predicates P that are dependent on the module from which
     they are called

'module(+M,+L)   declaration'
'module(+M,+L,+O)   declaration'
     declaration that module M exports predicates in L, options O

'save_modules(+L,+F)'
     save the modules specifed in L into file F

'set_module(+M)'
     make M the type-in module

'use_module(:F)'
     import the module-file(s) F, loading them if necessary

'use_module(:F,+I)'
     import the procedure(s) I from the module-file F

'use_module(?M,:F,+I)'
     import I from module M, loading module-file F if necessary


File: sicstus.info,  Node: ref-mdb,  Next: ref-all,  Prev: ref-mod,  Up: Prolog Intro

4.12 Modification of the Database
=================================

* Menu:

* ref-mdb-bas::                         Introduction
* ref-mdb-dsp::                         Dynamic and Static Procedures
* ref-mdb-dre::                         Database References
* ref-mdb-acd::                         Adding Clauses to the Database
* ref-mdb-rcd::                         Removing Clauses from the Database
* ref-mdb-acl::                         Accessing Clauses
* ref-mdb-exa::                         Modification of Running Code: Examples
* ref-mdb-idb::                         The Internal Database
* ref-mdb-bbd::                         The Blackboard
* ref-mdb-sum::                         Summary of Predicates


File: sicstus.info,  Node: ref-mdb-bas,  Next: ref-mdb-dsp,  Up: ref-mdb

4.12.1 Introduction
-------------------

The family of assertion and retraction predicates described below
enables you to modify a Prolog program by adding or deleting clauses
while it is running.  These predicates should not be overused.  Often
people who are experienced with other programming languages have a
tendency to think in terms of global data structures, as opposed to data
structures that are passed as procedure arguments, and hence they make
too much use of assertion and retraction.  This leads to less readable
and less efficient programs.

   An interesting question in Prolog is what happens if a procedure
modifies itself, by asserting or retracting a clause, and then fails.
On backtracking, does the current execution of the procedure use new
clauses that are added to the bottom of the procedure?

     *Historical note:* In some non-ISO-conforming implementations of
     Prolog, changes to the Prolog database become globally visible upon
     the success of the built-in predicate modifying the database.  An
     unsettling consequence is that the definition of a procedure can
     change while it is being run.  This can lead to code that is
     difficult to understand.  Furthermore, the memory performance of
     the interpreter implementing these semantics is poor.  Worse yet,
     the semantics rendered ineffective the added determinacy detection
     available through indexing.

   SICStus Prolog implements the "logical" view in updating dynamic
predicates, conforming to the ISO standard.  This means that the
definition of a dynamic procedure that is visible to a call is
effectively frozen when the call is made.  A procedure always contains,
as far as a call to it is concerned, exactly the clauses it contained
when the call was made.

   A useful way to think of this is to consider that a call to a dynamic
procedure makes a "virtual copy" of the procedure and then runs the copy
rather than the original procedure.  Any changes to the procedure made
by the call are immediately reflected in the Prolog database, but not in
the copy of the procedure being run.  Thus, changes to a running
procedure will not be visible on backtracking.  A subsequent call,
however, makes and runs a copy of the modified Prolog database.  Any
changes to the procedure that were made by an earlier call will now be
visible to the new call.

   In addition to being more intuitive and easy to understand, the new
semantics allow interpreted code to execute with the same determinacy
detection (and excellent memory performance) as static compiled code
(*note Indexing:: for more information on determinacy detection).


File: sicstus.info,  Node: ref-mdb-dsp,  Next: ref-mdb-dre,  Prev: ref-mdb-bas,  Up: ref-mdb

4.12.2 Dynamic and Static Procedures
------------------------------------

All Prolog procedures are classified as being either "static" or
"dynamic procedures".  Static procedures can be changed only by
completely redefining them using the Load Predicates (see *note
ref-lod::).  Dynamic procedures can be modified by adding or deleting
individual clauses using the assert and retract procedures.

   If a procedure is defined by loading source code, then it is static
by default.  If you need to be able to add, delete, or inspect the
individual clauses of such a procedure, then you must make the procedure
dynamic.

   There are two ways to make a procedure dynamic:

   * If the procedure is defined by loading source code, then it must be
     declared to be dynamic before it is defined.
   * If the procedure is to be created by assertions only, then the
     first 'assert' operation on the procedure automatically makes it
     dynamic.

   A procedure is declared dynamic by preceding its definition with a
declaration of the form:
     :- dynamic :PRED

where PRED must be a procedure specification of the form NAME/ARITY, or
a sequence of such specifications, separated by commas.  For example,
     :- dynamic exchange_rate/3, spouse_of/2,
                gravitational_constant/1.

where 'dynamic' is a built-in prefix operator.  If PRED is not of the
specified form, then an exception is raised, and the declaration is
ignored.

   Note that the symbol ':- ' preceding the word 'dynamic' is essential.
If this symbol is omitted, then a permission error is raised because it
appears that you are trying to define a clause for the built-in
predicate 'dynamic/1'.  Although 'dynamic/1' is a built-in predicate, it
may only be used in declarations.

   When a dynamic declaration is encountered in a file being loaded, it
is considered to be a part of the redefinition of the procedures
specified in its argument.  Thus, if you load a file containing only
     :- dynamic hello/0

then the effect will be to remove any previous definition of 'hello/0'
from the database, and to make the procedure dynamic.  You cannot make a
procedure dynamic retroactively.  If you wish to make an
already-existing procedure dynamic, then it must be redefined.

   It is often useful to have a dynamic declaration for a procedure even
if it is to be created only by assertions.  This helps another person to
understand your program, since it emphasizes the fact that there are no
pre-existing clauses for this procedure, and it also avoids the
possibility of Prolog stopping to tell you there are no clauses for this
procedure if you should happen to call it before any clauses have been
asserted.  This is because unknown procedure catching (see *note
Undefined Predicates::) does not apply to dynamic procedures; it is
presumed that a call to a dynamic procedure should simply fail if there
are no clauses for it.

   If a program needs to make an undefined procedure dynamic, then this
can be achieved by calling 'clause/2' on that procedure.  The call will
fail because the procedure has no clauses, but as a side-effect it will
make the procedure dynamic and thus prevent unknown procedure catching
on that procedure.  See the Reference page for details of 'clause/2'.

   Although you can simultaneously declare several procedures to be
dynamic, as shown above, it is recommended that you use a separate
dynamic declaration for each procedure placed immediately before the
clauses for that procedure.  In this way when you reload the procedure
using the editor interface, you will be reminded to include its dynamic
declaration.

   Dynamic procedures are implemented by interpretation, even if they
are included in a file that is compiled.  This means that they are
executed more slowly than if they were static, and also that they can be
printed using 'listing/0'.  Dynamic procedures, as well as static
procedures, are indexed on their first argument; see *note Indexing::.


File: sicstus.info,  Node: ref-mdb-dre,  Next: ref-mdb-acd,  Prev: ref-mdb-dsp,  Up: ref-mdb

4.12.3 Database References
--------------------------

A "database reference" is a term that uniquely identifies a clause or
recorded term (see *note ref-mdb-idb::) in the database.  Database
references are provided only to increase efficiency in programs that
access the database in complex ways.  Use of a database reference to a
clause can save repeated searches using 'clause/2'.  However, it does
_not_ normally pay to access a clause via a database reference when
access via first argument indexing is possible.


File: sicstus.info,  Node: ref-mdb-acd,  Next: ref-mdb-rcd,  Prev: ref-mdb-dre,  Up: ref-mdb

4.12.4 Adding Clauses to the Database
-------------------------------------

The assertion predicates are used to add clauses to the database in
various ways.  The relative position of the asserted clause with respect
to other clauses for the same predicate is determined by the choice
among 'assert/1', 'asserta/1', and 'assertz/1'.  A database reference
that uniquely identifies the clause being asserted is established by
providing an optional second argument to any of the assertion
predicates.

'assert(:C)'
     clause C is asserted in an arbitrary position in its predicate

'assert(:C,-R)'
     as 'assert/1'; reference R is returned

'asserta(:C)'
     clause C is asserted before existing clauses

'asserta(:C,-R)'
     as 'asserta/1'; reference R is returned

'assertz(:C)'
     clause C is asserted after existing clauses

'assertz(:C,-R)'
     as 'assertz/1'; reference R is returned

   *Please note*: If the term being asserted contains attributed
variables (*note lib-atts::) or suspended goals (*note ref-sem-sec::),
then those attributes are not stored in the database.  To retain the
attributes, you can use 'copy_term/3' (*note ref-lte-cpt::).


File: sicstus.info,  Node: ref-mdb-rcd,  Next: ref-mdb-acl,  Prev: ref-mdb-acd,  Up: ref-mdb

4.12.5 Removing Clauses from the Database
-----------------------------------------

* Menu:

* ref-mdb-rcd-efu::                     A Note on Efficient Use of retract/1

This section briefly describes the predicates used to remove the clauses
and/or properties of a predicate from the system.

     *Please note:* Removing all of a predicate's clauses by 'retract/1'
     and/or 'erase/1' (see *note ref-mdb-rcd-efu::) does not remove the
     predicate's properties (and hence its definition) from the system.
     The only way to completely remove a predicate's clauses _and_
     properties is to use 'abolish/[1,2]'.

'retract(:C)'
     erase the first dynamic clause that matches C

'retractall(:H)'
     erase every clause whose head matches H

'abolish(:F)'
     abolish the predicate(s) specified by F

'abolish(:F,+O)'
     abolish the predicate(s) specified by F with options O

'erase(+R)'
     erase the clause or recorded term (see *note ref-mdb-idb::) with
     reference R


File: sicstus.info,  Node: ref-mdb-rcd-efu,  Up: ref-mdb-rcd

4.12.5.1 A Note on Efficient Use of 'retract/1'
...............................................

_WARNING:_ 'retract/1' is a nondeterminate procedure.  Thus, we can use
     | ?- retract((foo(X) :- Body)), fail.

to retract all clauses for 'foo/1'.  A nondeterminate procedure in
SICStus Prolog uses a "choicepoint", a data structure kept on an
internal stack, to implement backtracking.  This applies to user-defined
procedures as well as to built-in and library procedures.  In a simple
model, a choicepoint is created for each call to a nondeterminate
procedure, and is deleted on determinate success or failure of that
call, when backtracking is no longer possible.  In fact, SICStus Prolog
improves upon this simple model by recognizing certain contexts in which
choicepoints can be avoided, or are no longer needed.

   The Prolog "cut" ('!') works by removing choicepoints, disabling the
potential backtracking they represented.  A choicepoint can thus be
viewed as an "outstanding call", and a "cut" as deleting outstanding
calls.

   To avoid leaving inconsistencies between the Prolog database and
outstanding calls, a retracted clause is reclaimed only when the system
determines that there are no choicepoints on the stack that could allow
backtracking to the clause.  Thus, the existence of a single choicepoint
on the stack can disable reclamation of retracted clauses for the
procedure whose call created the choicepoint.  Space is recovered only
when the choicepoint is deleted.

   Often 'retract/1' is used determinately; for example, to retract a
single clause, as in
     | ?- <do some stuff>
           retract(Clause),
          <do more stuff without backtracking>.

   No backtracking by 'retract/1' is intended.  Nonetheless, if Clause
may match more than one clause in its procedure, then a choicepoint will
be created by 'retract/1'.  While executing "<do more stuff without
backtracking>", that choicepoint will remain on the stack, making it
impossible to reclaim the retracted Clause.  Such choicepoints can also
disable tail recursion optimization.  If not cut away, then the
choicepoint can also lead to runaway retraction on the unexpected
failure of a subsequent goal.  This can be avoided by simply cutting
away the choicepoint with an explicit 'cut' or a local cut ('->').
Thus, in the previous example, it is preferable to write either
     | ?- <do some stuff>
           retract(Clause),
           !,
          <do more stuff without backtracking>.

or

     | ?- <do some stuff>
          ( retract(Clause) -> true ),
          <do more stuff without backtracking>.

   This will reduce stack size and allow the earliest possible
reclamation of retracted clauses.


File: sicstus.info,  Node: ref-mdb-acl,  Next: ref-mdb-exa,  Prev: ref-mdb-rcd,  Up: ref-mdb

4.12.6 Accessing Clauses
------------------------

'Goal'
     Succeeds If:

'clause(:P,?Q)'
     there is a clause for a dynamic predicate with head P and body Q

'clause(:P,?Q,?R)'
     there is a clause for a dynamic predicate with head P, body Q, and
     reference R

'instance(+R,-T)'
     T is an instance of the clause or term referenced by R


File: sicstus.info,  Node: ref-mdb-exa,  Next: ref-mdb-idb,  Prev: ref-mdb-acl,  Up: ref-mdb

4.12.7 Modification of Running Code: Examples
---------------------------------------------

* Menu:

* ref-mdb-exa-asz::                     Example: assertz
* ref-mdb-exa-rtr::                     Example: retract
* ref-mdb-exa-abo::                     Example: abolish

The following examples show what happens when a procedure is modified
while it is running.  This can happen in two ways:

  1. The procedure calls some other procedure that modifies it.
  2. The procedure succeeds nondeterminately, and a subsequent goal
     makes the modification.
   In either case, the question arises as to whether the modifications
take effect upon backtracking into the modified procedure.  In SICStus
Prolog the answer is that they do not.  As explained in the overview to
this section (see *note ref-mdb-bas::), modifications to a procedure
affect only calls to that procedure that occur after the modification.


File: sicstus.info,  Node: ref-mdb-exa-asz,  Next: ref-mdb-exa-rtr,  Up: ref-mdb-exa

4.12.7.1 Example: assertz
.........................

Consider the procedure 'foo/0' defined by

     :- dynamic foo/0.
     foo :- assertz(foo), fail.

   Each call to 'foo/0' asserts a new last clause for 'foo/0'.  After
the Nth call to 'foo/0' there will be N+1 clauses for 'foo/0'.  When
'foo/0' is first called, a virtual copy of the procedure is made,
effectively freezing the definition of 'foo/0' for that call.  At the
time of the call, 'foo/0' has exactly one clause.  Thus, when 'fail/0'
forces backtracking, the call to 'foo/0' simply fails: it finds no
alternatives.  For example,

     | ?- compile(user).
     | :- dynamic foo/0.
     | foo :- assertz(foo), fail.
     | ^D
     % user compiled in module user, 0.100 sec 2.56 bytes

     yes
     | ?- foo.  % The asserted clause is not found

     no
     | ?- foo.  % A later call does find it, however

     yes
     | ?-

   Even though the virtual copy of 'foo/0' being run by the first call
is not changed by the assertion, the Prolog database is.  Thus, when a
second call to 'foo/0' is made, the virtual copy for that call contains
two clauses.  The first clause fails, but on backtracking the second
clause is found and the call succeeds.


File: sicstus.info,  Node: ref-mdb-exa-rtr,  Next: ref-mdb-exa-abo,  Prev: ref-mdb-exa-asz,  Up: ref-mdb-exa

4.12.7.2 Example: retract
.........................

     | ?- assert(p(1)), assert(p(2)), assert(p(3)).

     yes
     | ?- p(N), write(N), nl, retract(p(2)),
          retract(p(3)), fail.
     1
     2
     3

     no
     | ?- p(N), write(N), fail.
     1
     no
     | ?-

   At the first call to 'p/1', the procedure has three clauses.  These
remain visible throughout execution of the call to 'p/1'.  Thus, when
backtracking is forced by 'fail/0', N is bound to 2 and written.  The
retraction is again attempted, causing backtracking into 'p/1'.  N is
bound to 3 and written out.  The call to 'retract/1' fails.  There are
no more clauses in 'p/1', so the query finally fails.  A subsequent call
to 'p/1', made after the retractions, sees only one clause.


File: sicstus.info,  Node: ref-mdb-exa-abo,  Prev: ref-mdb-exa-rtr,  Up: ref-mdb-exa

4.12.7.3 Example: abolish
.........................

     | ?- compile(user).
     | :- dynamic q/1.
     | q(1).
     | q(2).
     | q(3).
     | ^D
     % user compiled in modules user, 0.117 sec 260 bytes

     yes
     | ?- q(N), write(N), nl, abolish(q/1), fail.
     1
     2
     3

     no
     | ?-

   Procedures that are abolished while they have outstanding calls do
not become invisible to those calls.  Subsequent calls however, will
find the procedure undefined.


File: sicstus.info,  Node: ref-mdb-idb,  Next: ref-mdb-bbd,  Prev: ref-mdb-exa,  Up: ref-mdb

4.12.8 The Internal Database
----------------------------

The following predicates are provided solely for compatibility with
other Prolog systems.  Their semantics can be understood by imagining
that they are defined by the following clauses:
     recorda(Key, Term, Ref) :-
          functor(Key, Name, Arity),
          functor(F, Name, Arity),
          asserta('$recorded'(F,Term), Ref).
     recordz(Key, Term, Ref) :-
          functor(Key, Name, Arity),
          functor(F, Name, Arity),
          assertz('$recorded'(F,Term), Ref).
     recorded(Key, Term, Ref) :-
          functor(Key, Name, Arity),
          functor(F, Name, Arity),
          clause('$recorded'(F,Term), _, Ref).

   The reason for the calls to 'functor/3' in the above definition is
that only the principal functor of the key is significant.  If KEY is a
compound term, then its arguments are ignored.

     *Please note:* Equivalent functionality and performance, with
     reduced memory costs, can usually be had through normal dynamic
     procedures and indexing (see *note ref-mdb-bas:: and *note
     Indexing::).

   'recorda(KEY, TERM, REF)' records the TERM in the internal database
as the first item for the key KEY; a database reference to the
newly-recorded term is returned in REF.

   'recordz(KEY, TERM, REF)' is like 'recorda/3' except that it records
the term as the last item in the internal database.

   'recorded(KEY, TERM, REF)' searches the internal database for a term
recorded under the key KEY that unifies with TERM, and whose database
reference unifies with REF.

   'current_key(KEYNAME, KEYTERM)' succeeds when KEYNAME is the atom or
integer that is the name of KEYTERM.  KEYTERM is an integer, atom, or
compound term that is the key for a currently recorded term.


File: sicstus.info,  Node: ref-mdb-bbd,  Next: ref-mdb-sum,  Prev: ref-mdb-idb,  Up: ref-mdb

4.12.9 Blackboard Primitives
----------------------------

The predicates described in this section store arbitrary terms in a
per-module repository known as the "blackboard".  The main purpose of
the blackboard was initially to provide a means for communication
between branches executing in parallel, but the blackboard works equally
well during sequential execution.  The blackboard implements a mapping
from keys to values.  Keys are restricted to being atoms or small
integers, whereas values are arbitrary terms.  In contrast to the
predicates described in the previous sections, a given key can map to at
most a single term.

   Each Prolog module maintains its own blackboard, so as to avoid name
clashes if different modules happen to use the same keys.  The "key"
arguments of these predicates are subject to module name expansion, so
the module name does not have to be explicitly given unless multiple
Prolog modules are supposed to share a single blackboard.

   The predicates below implement atomic blackboard actions.

'bb_put(:KEY, +TERM)'

     A copy of TERM is stored under KEY.  *Note mpg-ref-bb_put::.

'bb_get(:KEY, ?TERM)'

     If a term is currently stored under KEY, then a copy of it is
     unified with TERM.  Otherwise, 'bb_get/2' silently fails.  *Note
     mpg-ref-bb_get::.

'bb_delete(:KEY, ?TERM)'

     If a term is currently stored under KEY, then the term is deleted,
     and a copy of it is unified with TERM.  Otherwise, 'bb_delete/2'
     silently fails.  *Note mpg-ref-bb_delete::.

'bb_update(:KEY, ?OLDTERM, ?NEWTERM)'

     If a term is currently stored under KEY and unifies with OLDTERM,
     then the term is replaced by a copy of NEWTERM.  Otherwise,
     'bb_update/3' silently fails.  This predicate provides an atomic
     swap operation.  *Note mpg-ref-bb_update::.

   *Please note*: If the term being stored contains attributed variables
(*note lib-atts::) or suspended goals (*note ref-sem-sec::), then those
attributes are not stored.  To retain the attributes, you can use
'copy_term/3' (*note ref-lte-cpt::).

   The following example illustrates how these primitives may be used to
implement a "maxof" predicate that finds the maximum value computed by
some nondeterminate goal.  We use a single key 'max'(1).  We assume that
GOAL does not produce any "false" solutions that would be eliminated by
cuts in a sequential execution.  Thus, GOAL may need to include
redundant checks to ensure that its solutions are valid, as discussed
above.

     maxof(Value, Goal, _) :-
             bb_put(max, -1),                % initialize max-so-far
             call(Goal),
             update_max(Value),
             fail.
     maxof(_, _, Max) :-
             bb_delete(max, Max),
             Max > 1.

     update_max(New):-
             bb_get(max, Old),
             compare(C, Old, New),
             update_max(C, Old, New).

     update_max(<, Old, New) :- bb_update(max, Old, New).
     update_max(=, _, _).
     update_max(>, _, _).

   ---------- Footnotes ----------

   (1) This is not necessarily a good example of using the blackboard.
For instance, the implementation is not reentrant, e.g.  it will not
work if the GOAL itself uses 'maxof/3'.  A reentrant implementation
would need to ensure that multiple nested calls to 'maxof/3' do not
interfer with each other.


File: sicstus.info,  Node: ref-mdb-sum,  Prev: ref-mdb-bbd,  Up: ref-mdb

4.12.10 Summary of Predicates
-----------------------------

'abolish(:F)   ISO'
     abolish the predicate(s) specified by F

'abolish(:F,+O)'
     abolish the predicate(s) specified by F with options O

'assert(:C)'
'assert(:C,-R)'
     clause C is asserted; reference R is returned

'asserta(:C)   ISO'
'asserta(:C,-R)'
     clause C is asserted before existing clauses; reference R is
     returned

'assertz(:C)   ISO'
'assertz(:C,-R)'
     clause C is asserted after existing clauses; reference R is
     returned

'bb_delete(:KEY,-TERM)'
     Delete from the blackboard TERM stored under KEY.

'bb_get(:KEY,-TERM)'
     Get from the blackboard TERM stored under KEY.

'bb_put(:KEY,+TERM)'
     Store TERM under KEY on the blackboard.

'bb_update(:KEY, -OLDTERM, +NEWTERM)'
     Replace OLDTERM by NEWTERM under KEY on the blackboard.

'clause(:P,?Q)   ISO'
'clause(:P,?Q,?R)'
     there is a clause for a dynamic predicate with head P, body Q, and
     reference R

'current_key(?N, ?K)'
     N is the name and K is the key of a recorded term

'dynamic :P   declaration,ISO'
     predicates specified by P are dynamic

'erase(+R)'
     erase the clause or record with reference R

'instance(+R,-T)'
     T is an instance of the clause or term referenced by R

'recorda(+K,+T,-R)'
     make term T the first record under key K; reference R is returned

'recorded(?K,?T,?R)'
     term T is recorded under key K with reference R

'recordz(+K,+T,-R)'
     make term T the last record under key K; reference R is returned

'retract(:C)   ISO'
     erase the first dynamic clause that matches C

'retractall(:H)   ISO'
     erase every clause whose head matches H


File: sicstus.info,  Node: ref-all,  Next: ref-gru,  Prev: ref-mdb,  Up: Prolog Intro

4.13 Sets and Bags: Collecting Solutions to a Goal
==================================================

* Menu:

* ref-all-bas::                         Introduction
* ref-all-cse::                         Collecting a Sorted List
* ref-all-cba::                         Collecting a Bag of Solutions
* ref-all-sum::                         Predicate Summary


File: sicstus.info,  Node: ref-all-bas,  Next: ref-all-cse,  Up: ref-all

4.13.1 Introduction
-------------------

When there are many solutions to a goal, and a list of all those
solutions is desired, one means of collecting them is to write a
procedure that repeatedly backtracks into that goal to get another
solution.  In order to collect all the solutions together, it is
necessary to use the database (via assertion) to hold the solutions as
they are generated, because backtracking to redo the goal would undo any
list construction that had been done after satisfying the goal.

   The writing of such a backtracking loop can be avoided by the use of
one of the built-in predicates 'setof/3', 'bagof/3' and 'findall/[3,4]',
which are described below.  These provide a nice logical abstraction,
whereas with a user-written backtracking loop the need for explicit
side-effects (assertions) destroys the declarative interpretation of the
code.  The built-in predicates are also more efficient than those a user
could write.

   *Please note*: If the solutions being collected contain attributed
variables (*note lib-atts::) or suspended goals (*note ref-sem-sec::),
then those attributes are not retained in the list of solutions.  To
retain the attributes, you can use 'copy_term/3' (*note ref-lte-cpt::).


File: sicstus.info,  Node: ref-all-cse,  Next: ref-all-cba,  Prev: ref-all-bas,  Up: ref-all

4.13.2 Collecting a Sorted List
-------------------------------

* Menu:

* ref-all-cse-equ::                     Existential Quantifier

'setof(TEMPLATE, GENERATOR, SET)' returns the set SET of all instances
of TEMPLATE such that GENERATOR is provable, where that set is
non-empty.  The term GENERATOR specifies a goal to be called as if by
'call/1'.  SET is a set of terms represented as a list of those terms,
without duplicates, in the standard order for terms (see *note
ref-lte-cte::).

   Obviously, the set to be enumerated should be finite, and should be
enumerable by Prolog in finite time.  It is possible for the provable
instances to contain variables, but in this case SET will only provide
an imperfect representation of what is in reality an infinite set.

   If GENERATOR is instantiated, but contains uninstantiated variables
that do not also appear in TEMPLATE, then 'setof/3' can succeed
nondeterminately, generating alternative values for SET corresponding to
different instantiations of the free variables of GENERATOR.  (It is to
allow for such usage that SET is constrained to be non-empty.)  For
example, if your program contained the clauses
     likes(tom, beer).
     likes(dick, beer).
     likes(harry, beer).
     likes(bill, cider).
     likes(jan, cider).
     likes(tom, cider).

then the call
     | ?- setof(X, likes(X,Y), S).

might produce two alternative solutions via backtracking:
     Y = beer,
     S = [dick,harry,tom] ;
     Y = cider,
     S = [bill,jan,tom] ;
     no

   The call
     | ?- setof((Y,S), setof(X,likes(X,Y),S), SS).

would then produce
     SS = [(beer,[dick,harry,tom]),(cider,[bill,jan,tom])] ;
     no
   *Note mpg-ref-setof::.


File: sicstus.info,  Node: ref-all-cse-equ,  Up: ref-all-cse

4.13.2.1 Existential Quantifier
...............................

X '^' P is recognized as meaning "there exists an X such that P is
true", and is treated as equivalent to simply calling P.  The use of the
explicit existential quantifier outside 'setof/3' and 'bagof/3' is
superfluous.

   Variables occurring in GENERATOR will not be treated as free if they
are explicitly bound within GENERATOR by an existential quantifier.  An
existential quantification is written:
     Y^Q

meaning "there exists a Y such that Q is true", where Y is some Prolog
variable.  For example:
     | ?- setof(X, Y^likes(X,Y), S).

would produce the single result
     S = [bill,dick,harry,jan,tom] ;
     no

in contrast to the earlier example.

   Furthermore, it is possible to existentially quantify a term, where
all the variables in that term are taken to be existentially quantified
in the goal.  E.g.

     A=term(X,Y), setof(Z, A^foo(X,Y,Z), L).

will treat X and Y as if they are existentially quantified.


File: sicstus.info,  Node: ref-all-cba,  Next: ref-all-sum,  Prev: ref-all-cse,  Up: ref-all

4.13.3 Collecting a Bag of Solutions
------------------------------------

* Menu:

* ref-all-cba-cal::                     Collecting All Instances

'bagof/3' is is exactly the same as 'setof/3' except that the list (or
alternative lists) returned will not be ordered, and may contain
duplicates.  This relaxation saves time and space in execution.  *Note
mpg-ref-bagof::.


File: sicstus.info,  Node: ref-all-cba-cal,  Up: ref-all-cba

4.13.3.1 Collecting All Instances
.................................

'findall/3' is a special case of 'bagof/3', where all free variables in
the generator are taken to be existentially quantified.  Thus the use of
the operator '^' is avoided.  Because 'findall/3' avoids the relatively
expensive variable analysis done by 'bagof/3', using 'findall/3' where
appropriate rather than 'bagof/3' can be considerably more efficient.

   'findall/4' is a variant of 'findall/3' with an extra argument to
which the list of solutions is appended.  This can reduce the amount of
append operations in the program.  *Note mpg-ref-findall::.


File: sicstus.info,  Node: ref-all-sum,  Prev: ref-all-cba,  Up: ref-all

4.13.4 Predicate Summary
------------------------

'?X ^ :P'
     there exists an X such that P is provable (used in 'setof/3' and
     'bagof/3')

'bagof(?X,:P,-B)   ISO'
     B is the bag of instances of X such that P is provable

'findall(?T,:G,-L)   ISO'
'findall(?T,:G,?L,?R)'
     L is the list of all solutions T for the goal G, concatenated with
     R or with the empty list

'setof(?X,:P,-S)   ISO'
     S is the set of instances of X such that P is provable


File: sicstus.info,  Node: ref-gru,  Next: ref-ere,  Prev: ref-all,  Up: Prolog Intro

4.14 Grammar Rules
==================

* Menu:

* ref-gru-dcg::                         Definite Clause Grammars
* ref-gru-gru::                         How to Use the Grammar Rule Facility
* ref-gru-exa::                         An Example
* ref-gru-tra::                         Semantics of Grammar Rules
* ref-gru-sum::                         Summary of Predicates

This section describes SICStus Prolog's grammar rules, and the
translation of these rules into Prolog clauses.  At the end of the
section is a list of grammar-related built-in predicates.


File: sicstus.info,  Node: ref-gru-dcg,  Next: ref-gru-gru,  Up: ref-gru

4.14.1 Definite Clause Grammars
-------------------------------

Prolog's grammar rules provide a convenient notation for expressing
definite clause grammars, which are useful for the analysis of both
artificial and natural languages.

   The usual way one attempts to make precise the definition of a
language, whether it is a natural language or a programming language, is
through a collection of rules called a "grammar".  The rules of a
grammar define which strings of words or symbols are valid sentences of
the language.  In addition, the grammar generally analyzes the sentence
into a structure that makes its meaning more explicit.

   A fundamental class of grammar is the context-free grammar (CFG),
familiar to the computing community in the notation of "BNF"
(Backus-Naur form).  In CFGs, the words, or basic symbols, of the
language are identified by "terminal symbols", while categories of
phrases of the language are identified by non-terminal symbols.  Each
rule of a CFG expresses a possible form for a non-terminal, as a
sequence of terminals and non-terminals.  The analysis of a string
according to a CFG is a parse tree, showing the constitutent phrases of
the string and their hierarchical relationships.

   Context-free grammars (CFGs) consist of a series of rules of the
form:
     NT --> BODY.

where NT is a non-terminal symbol and body is a sequence of one or more
items separated by commas.  Each item is either a non-terminal symbol or
a sequence of terminal symbols.  The meaning of the rule is that BODY is
a possible form for a phrase of type NT.  A non-terminal symbol is
written as a Prolog atom, while a sequence of terminals is written as a
Prolog list, whereas a terminal may be any Prolog term.

   Definite clause grammars (DCGs) are a generalization of context-free
grammars and rules corresponding to DCGs are referred to as "Grammar
Rules".  A grammar rule in Prolog takes the general form
     HEAD --> BODY.

meaning "a possible form for HEAD is BODY".  Both BODY and HEAD are
sequences of one or more items linked by the standard Prolog conjunction
operator ',' (comma).

   Definite clause grammars extend context-free grammars in the
following ways:

   * A non-terminal symbol may be any callable Prolog term.
   * A terminal symbol may be any Prolog term.  To distinguish terminals
     from non-terminals, a sequence of one or more terminal symbols is
     written within a grammar rule as a Prolog list.  An empty sequence
     is written as the empty list '[]'.  If the terminal symbols are
     character codes, then such lists can be written (as elsewhere) as
     strings.  An empty sequence is written as the empty list ('[]' or
     '""').

   * Extra conditions, in the form of Prolog procedure calls, may be
     included in the right-hand side of a grammar rule.  These extra
     conditions allow the explicit use of procedure calls in the body of
     a rule to restrict the constitutents accepted.  Such procedure
     calls are written enclosed in curly brackets ('{' and '}').
   * The left-hand side of a grammar rule consists of a non-terminal,
     optionally followed by a sequence of terminals (again written as a
     Prolog list).
   * Alternatives may be stated explicitly in the right-hand side of a
     grammar rule, using the disjunction operator ';' (semicolon) as in
     Prolog.
   * The cut symbol '!' may be included in the right-hand side of a
     grammar rule, as in a Prolog clause.  The cut symbol does not need
     to be enclosed in curly brackets.  The same is true for the control
     constructs.  However, all other built-in predicates not enclosed in
     curly brackets will be treated as non-terminal symbols.  The
     precise meaning of this rule is clarified in *note ref-gru-tra::.
   * The extra arguments of non-terminals provide the means of building
     structure (such as parse trees) in grammar rules.  As non-terminals
     are "expanded" by matching against grammar rules, structures are
     progressively built up in the course of the unification process.
   * The extra arguments of non-terminals can also provide a general
     treatment of context dependency by carrying test and contextual
     information.


File: sicstus.info,  Node: ref-gru-gru,  Next: ref-gru-exa,  Prev: ref-gru-dcg,  Up: ref-gru

4.14.2 How to Use the Grammar Rule Facility
-------------------------------------------

Following is a summary of the steps that enable you to construct and
utilize definite clause grammars:

   STEPS:

  1. Write a grammar, using '-->/2' to formulate rules.
  2. Compile the file containing the grammar rules.  The Load Predicates
     automatically translate the grammar rules into Prolog clauses.
  3. Use 'phrase/[2,3]' to parse or generate strings.

   OPTIONAL STEPS:

  1. Modify the way in which Prolog translates your grammar rules by
     defining clauses for 'user:term_expansion/6'; *note ref-lod-exp::.
  2. In debugging or in using the grammar facility for more obscure
     purposes it may be useful to understand more about 'expand_term/2'.


File: sicstus.info,  Node: ref-gru-exa,  Next: ref-gru-tra,  Prev: ref-gru-gru,  Up: ref-gru

4.14.3 An Example
-----------------

As an example, here is a simple grammar that parses an arithmetic
expression (made up of digits and operators) and computes its value.
Create a file containing the following rules:

                                                           _grammar.pl_

     expr(Z) --> term(X), "+", expr(Y), {Z is X + Y}.
     expr(Z) --> term(X), "-", expr(Y), {Z is X - Y}.
     expr(X) --> term(X).

     term(Z) --> number(X), "*", term(Y), {Z is X * Y}.
     term(Z) --> number(X), "/", term(Y), {Z is X / Y}.
     term(Z) --> number(Z).

     number(C) --> "+", number(C).
     number(C) --> "-", number(X), {C is -X}.
     number(X) --> [C], {"0"=<C, C=<"9", X is C - "0"}.

   In the last rule, C is the character code of a decimal digit.

   This grammar can now be used to parse and evaluate an expression by
means of the built-in predicates 'phrase/[2,3]'.  *Note
mpg-ref-phrase::.  For example,

     | ?- [grammar].
     | ?- phrase(expr(Z), "-2+3*5+1").

     Z = 14

     | ?- phrase(expr(Z), "-2+3*5", Rest).

     Z = 13,
     Rest = [] ;

     Z = 1,
     Rest = "*5" ;

     Z = -2,
     Rest = "+3*5" ;

     no


File: sicstus.info,  Node: ref-gru-tra,  Next: ref-gru-sum,  Prev: ref-gru-exa,  Up: ref-gru

4.14.4 Semantics of Grammar Rules
---------------------------------

Grammar rules are best explained in terms of an interpreter.  The
semantics of 'phrase/3' is shown as if defined by the interpreter shown
below.  The interpreter's case analysis is as follows:

CONTROL CONSTRUCTS
     (Including cuts and module prefixes).  The interpreter implements
     the semantics of the construct, descending into its argument.  Note
     that other built-in predicates are _not_ treated this way.
LISTS
     Treated as terminal symbols.
CURLY BRACKETS
     Treated as procedure calls.
CALLABLE TERMS WITH FUNCTOR N/A
     A grammar rule with head functor N/A is looked up using the
     imaginary predicate '-->/2', unified against, and its body is
     interpreted.  If none exists, then this is treated as a procedure
     call to a predicate N/A+2.
NON-CALLABLE TERMS
     Raise error exception.

   The following points are worth noting:

   * The code below defines what constructs of and to what depth grammar
     rule bodies are interpreted, as opposed to being treated as
     non-terminals.
   * Throughout the interpretation, we must keep track of the module
     context.
   * The head non-terminal of a grammar rule is optionally followed by a
     sequence of terminals.  This feature is not supported by the
     interpreter, but is supported in the actual implementation.
   * As a general rule, the last argument is unified _after_ any
     side-effects, including cuts.  This is in line with the rule that
     output arguments should not be unified before a cut (*note Eff
     Overview::).  In other words, grammar rules are "steadfast".
   * The last clause gives a clue to how grammar rules are actually
     implemented, i.e. by compile-time transformation to ordinary Prolog
     clauses.  A grammar rule with head functor N/A is transformed to a
     Prolog clause with head functor N/A+2, the extra arguments being
     'S0' and 'S'.  '-->/2' is _not_ a predicate.

   The interpreter is as follows, slightly simplified:

     phrase(M:Body, S0, S) :-
             phrase(Body, M, S0, S).

     phrase(Var, M, S0, S) :- \+callable(Var), !,
             must_be(Var, callable, phrase(M:Var,S0,S), 1).
     phrase(M:Body, _, S0, S) :- !,
             phrase(Body, M, S0, S).
     phrase(!, _, S0, S) :- !,
             _cut relevant choicepoints_,
             S0 = S.                 % _unification AFTER action_
     phrase((A, B), M, S0, S) :- !,
             phrase(A, M, S0, S1),
             phrase(B, M, S1, S).
     phrase((A -> B), M, S0, S) :- !,
         (   phrase(A, M, S0, S1) ->
             phrase(B, M, S1, S)
         ).
     phrase((A -> B ; C), M, S0, S) :- !,
         (   phrase(A, M, S0, S1) ->
             phrase(B, M, S1, S)
         ;   phrase(C, M, S0, S)
         ).
     phrase((A ; B), M, S0, S) :- !,
         (   phrase(A, M, S0, S)
         ;   phrase(B, M, S0, S)
         ).
     phrase(\+(A), M, S0, S) :- !,
         (   phrase(A, M, S0, _) ->
             fail
         ;   S0 = S
         ).
     phrase(_^A, M, S0, S) :- !,
             phrase(A, M, S0, S).
     phrase(do(Iter,Body), M, S0, S) :- !,
         (   Iter,
             fromto(S0,S1,S2,S)
         do  phrase(Body, M, S1, S2)
         ).
     phrase(if(A,B,C), M, S0, S) :- !,
             if(phrase(A, M, S0, S1),
                phrase(B, M, S1, S),
                phrase(C, M, S0, S)).
     phrase(once(A), M, S0, S) :- !,
         (   phrase(A, M, S0, S1) ->
             S1 = S                  % _unification AFTER call_
         ).
     phrase([], _, S0, S) :- !,
             S0 = S.
     phrase([H|T], M, S0, S) :- !,
             S0 = [H|S1],
             phrase(T, M, S1, S).
     phrase({G}, M, S0, S) :- !,
             call(M:G),              % *Please note:* _transparent to cuts_
             S0 = S.                 % _unification AFTER call_
     phrase(NT, M, S0, S) :-
             \+ \+(M:NT --> Rhs), !, % _grammar rule exists?_
             (M:NT --> Rhs),
             phrase(Rhs, M, S0, S).
     phrase(NT, M, S0, S) :-
             call(M:NT, S0, S).      % _otherwise, treat as procedure call_

   As mentioned above, grammar rules are merely a convenient
abbreviation for ordinary Prolog clauses.  Each grammar rule is
translated into a Prolog clause as it is compiled.  This translation is
exemplified below.

   The procedural interpretation of a grammar rule is that it takes an
input list of symbols or character codes, analyzes some initial portion
of that list, and produces the remaining portion (possibly enlarged) as
output for further analysis.  The arguments required for the input and
output lists are not written explicitly in a grammar rule, but are added
when the rule is translated into an ordinary Prolog clause.  The
translations shown differ from the output of 'listing/[0,1]' in that
internal translations such as variable renaming are not represented.
This is done in the interests of clarity.  For example, a rule such as
(A) will be depicted as translating into (B) rather than (C).
     p(X) --> q(X).  (A)

     p(X, S0, S) :-
             q(X, S0, S).  (B)

     p(A, B, C) :-
             q(A, B, C).  (C)

   If there is more than one non-terminal on the right-hand side, as in
(D), then the corresponding input and output arguments are identified,
translating into (E):

     p(X, Y) --> q(X), r(X, Y), s(Y).  (D)

     p(X, Y, S0, S) :-  (E)
         q(X, S0, S1),
         r(X, Y, S1, S2),
         s(Y, S2, S).

   Terminals are translated using the built-in predicate '=/2'.  For
instance, (F) is translated into (G):

     p(X) --> [go, to], q(X), [stop].  (F)

     p(X, S0, S) :-  (G)
         S0 = [go,to|S1],
         q(X, S1, S2),
         S2 = [stop|S].

   Extra conditions expressed as explicit procedure calls, enclosed in
curly braces, naturally translate into themselves.  For example (H)
translates to (I):
     p(X) --> [X], {integer(X), X > 0}, q(X).  (H)

     p(X, S0, S) :-  (I)
         S0 = [X|S1],
         integer(X),
         X > 0,
         q(X, S1, S).

   Terminals on the left-hand side of a rule, enclosed in square
brackets, also translate into a unification.  For example, (J) becomes
(K):
     is(N), [not] --> [aint].  (J)

     is(N, S0, S) :-  (K)
         S0 = [aint|S1],
         S = [not|S1].

   Disjunction and other control constructs have a fairly obvious
translation.  For example, (L), a rule that equates phrases like "(sent)
a letter to him" and "(sent) him a letter", translates to (M):
     args(X, Y) -->  (L)
         (   indir(X), [to], indir(Y)
         ;   indir(Y), dir(X)
         ).

     args(X, Y, S0, S) :-  (M)
         (   dir(X, S0, S1),
             S1 = [to|S2],
             indir(Y, S2, S)
         ;   indir(Y, S0, S1),
             dir(X, S1, S)
         ).

   In order to look at these translations, declare the grammar rules
dynamic and use 'listing/[0,1]'.  However, bear in mind that a grammar
rule with head functor N/A is transformed to a Prolog clause with head
functor N/A+2.  For example, the following declaration for grammar rule
(L) would enable you to list its translation, (M):
      :- dynamic args/4.


File: sicstus.info,  Node: ref-gru-sum,  Prev: ref-gru-tra,  Up: ref-gru

4.14.5 Summary of Predicates
----------------------------

':HEAD --> :BODY'
     A possible form for HEAD is BODY

'expand_term(+T,-X)   hookable'
     term T expands to term X using 'user:term_expansion/6' or grammar
     rule expansion

'phrase(:P, -L)'
'phrase(:P, ?L, ?R)'
     R or the empty list is what remains of list L after phrase P has
     been found

'user:term_expansion(+TERM1, +LAYOUT1, +TOKENS1, -TERM2, -LAYOUT2, -TOKENS2)   hook'
     Overrides or complements the standard transformations to be done by
     'expand_term/2'.


File: sicstus.info,  Node: ref-ere,  Next: ref-msg,  Prev: ref-gru,  Up: Prolog Intro

4.15 Errors and Exceptions
==========================

* Menu:

* ref-ere-ove::                         Overview
* ref-ere-rex::                         Throwing Exceptions
* ref-ere-hex::                         Handling Exceptions
* ref-ere-err::                         Error Classes
* ref-ere-exa::                         An Example
* ref-ere-leg::                         Legacy Predicates
* ref-ere-int::                         Interrupting Execution
* ref-ere-sum::                         Summary of Predicates


File: sicstus.info,  Node: ref-ere-ove,  Next: ref-ere-rex,  Up: ref-ere

4.15.1 Overview
---------------

Whenever the Prolog system encounters a situation where it cannot
continue execution, it throws an exception.  For example, if a built-in
predicate detects an argument of the wrong type, then it throws a
'type_error' exception.  The manual page description of each built-in
predicate lists the kinds of exceptions that can be thrown by that
built-in predicate.

   The default effect of throwing an exception is to terminate the
current computation and then print an error message.  After the error
message, you are back at Prolog's top-level.  For example, if the goal
     X is a/2

is executed somewhere in a program, then you get
     ! Type error in argument 2 of (is)/2
     ! expected evaluable, but found a/0
     ! goal:  _255 is a/2
     | ?-

   Particular things to notice in this message are:

'!'
     This character indicates that this is an error message rather than
     a warning(1) or informational message.

'Type Error'
     This is the "error class".  Exceptions thrown by the Prolog system
     are called "errors".  Every error is categorized into one of a
     small number of classes.  The classes are listed in *note
     ref-ere-err::.

'goal:'
     The goal that caused the exception to be thrown.

   Built-in predicates check their arguments, but predicates exported by
library modules generally do not, although some do check their arguments
to a lesser or greater extent.

   ---------- Footnotes ----------

   (1) The difference between an error (including exceptions) and a
warning: A "warning" is issued if Prolog detects a situation that is
likely to cause problems, though it is possible that you intended it.
An "error", however, indicates that Prolog recognizes a situation where
it cannot continue.


File: sicstus.info,  Node: ref-ere-rex,  Next: ref-ere-hex,  Prev: ref-ere-ove,  Up: ref-ere

4.15.2 Throwing Exceptions
--------------------------

You can throw exceptions from your own code using:

'throw(+EXCEPTIONTERM)   ISO'

   The argument to this predicate is the "exception term", an arbitrary
non-variable term.  *Note mpg-ref-throw::.

   *Please note*: If the exception term contains attributed variables
(*note lib-atts::) or suspended goals (*note ref-sem-sec::), then those
attributes do not become part of the exception.  To retain the
attributes, you can use 'copy_term/3' (*note ref-lte-cpt::).


File: sicstus.info,  Node: ref-ere-hex,  Next: ref-ere-err,  Prev: ref-ere-rex,  Up: ref-ere

4.15.3 Handling Exceptions
--------------------------

* Menu:

* ref-ere-hex-pgo::                     Protecting a Particular Goal
* ref-ere-hex-hup::                     Handling Unknown Predicates

It is possible to protect a part of a program against abrupt termination
in the event of an exception.  There are several ways to do this:

   * Trap exceptions to a particular goal by calling 'catch/3' as
     described in *note ref-ere-hex-pgo::.

   * Handle undefined predicates or subsets of them through the hook
     predicate 'user:unknown_predicate_handler/3'; *note
     ref-ere-hex-hup::.

   * Trap exceptions matching EXCEPTION to the debugger by defining the
     following hook predicate:

     'user:error_exception(+EXCEPTION)   hook,development'
          *Note mpg-ref-error_exception::.

   * Control syntax errors with the 'syntax_errors' Prolog flag or with
     the same option to 'read_term/[2,3]'; *note ref-ere-err-syn::.

   * Control existence and permission errors in the context of opening
     files with the 'fileerrors' Prolog flag or with the same option to
     'absolute_file_name/3'; *note ref-ere-err-exi:: and *note
     ref-ere-err-per::.


File: sicstus.info,  Node: ref-ere-hex-pgo,  Next: ref-ere-hex-hup,  Up: ref-ere-hex

4.15.3.1 Protecting a Particular Goal
.....................................

The built-in predicate 'catch/3' enables you to handle exceptions to a
specific goal:

'catch(:PROTECTEDGOAL, ?EXCEPTIONTERM, :HANDLER)   ISO'

   PROTECTEDGOAL is executed.  If all goes well, then it will behave
just as if you had written 'call(PROTECTEDGOAL)' instead.  If an
exception is thrown while PROTECTEDGOAL is running, then Prolog will
abandon PROTECTEDGOAL entirely.  Any bindings made by PROTECTEDGOAL will
be undone, just as if it had failed.  If the exception occurred in the
scope of a 'call_cleanup(GOAL,CLEANUP)', then CLEANUP will be called.
Side-effects, such as asserts and retracts, are not undone, just as they
are not undone when a goal fails.  After undoing the bindings, Prolog
tries to unify the exception term thrown with the EXCEPTIONTERM
argument.  If this unification succeeds, then HANDLER will be executed
as if you had written

     EXCEPTIONTERM=<the actual exception term>,
     HANDLER

   If this unification fails, then Prolog will keep searching up the
ancestor list looking for another exception handler.  If during this
search it reaches a recursive call to Prolog from C, then the recursive
calls returns with an uncaught exception.  If it reaches the top-level
(or a break level), then an appropriate error message is printed (using
'print_message/2').

   PROTECTEDGOAL need not be determinate.  That is, backtracking into
PROTECTEDGOAL is possible, and the exception handler becomes reactivated
in this case.  However, if PROTECTEDGOAL is determinate, then the call
to 'catch/3' is also determinate.

   The PROTECTEDGOAL is logically _inside_ the 'catch/3' goal, but the
HANDLER is _not_.  If an exception is thrown inside the HANDLER, then
this 'catch/3' goal will _not_ be reactivated.  If you want an exception
handler that protects itself, then you have to program it, perhaps like
this:
     recursive_catch_handler(Err, Goal, Handler) :-
         catch(Goal, Err,
             recursive_catch_handler(Err, Handler, Handler)).
   *Note mpg-ref-catch::.

   Certain built-in and library predicates rely on the exception
mechanism, so it is usually a bad idea to let PATTERN be a variable,
matching any exception.  If it must be a variable, then the HANDLER
should examine the exception and pass it on if it is not relevant to the
current invocation.


File: sicstus.info,  Node: ref-ere-hex-hup,  Prev: ref-ere-hex-pgo,  Up: ref-ere-hex

4.15.3.2 Handling Unknown Predicates
....................................

Users can write a handler for the specific exception occurring when an
undefined predicate is called by defining clauses for the hook predicate
'user:unknown_predicate_handler/3'.  This can be thought of as a
"global" exception handler for this particular exception, because unlike
'catch/3', its effect is not limited to a particular goal.  Furthermore,
the exception is handled at the point where the undefined predicate is
called.

   The handler can be written to apply to all unknown predicates, or to
a class of them.  The reference page contains an example of constraining
the handler to certain predicates.

   If 'call(MODULE:GOAL)' is the trapped call to the undefined
predicate, then the hook is called as:

'user:unknown_predicate_handler(+GOAL, +MODULE, -NEWGOAL)   hook'

   If this succeeds, then Prolog replaces the call to the undefined
predicate with the call to MODULE:NEWGOAL.  Otherwise, the action taken
is governed by the 'unknown' Prolog flag (*note ref-lps-flg::), the
allowed values of which are:

'trace'
     Causes calls to undefined predicates to be reported and the
     debugger to be entered at the earliest opportunity.  Not available
     in runtime systems.

'error   ISO'
     Causes calls to such predicates to raise an exception (the
     default).

'warning   ISO'
     Causes calls to such predicates to display a warning message and
     then fail.

'fail   ISO'
     Causes calls to such predicates to fail.

   Finally, this flag can be accessed by the built-in predicate:

'unknown(?OLDVALUE, ?NEWVALUE)   development'

   This unifies OLDVALUE with the current value, sets the flag to
NEWVALUE, and prints a message about the new value.  *Note
mpg-ref-unknown_predicate_handler::.


File: sicstus.info,  Node: ref-ere-err,  Next: ref-ere-exa,  Prev: ref-ere-hex,  Up: ref-ere

4.15.4 Error Classes
--------------------

* Menu:

* ref-ere-err-ins::                     Instantiation Errors
* ref-ere-err-uns::                     Uninstantiation Errors
* ref-ere-err-typ::                     Type Errors
* ref-ere-err-dom::                     Domain Errors
* ref-ere-err-eva::                     Evaluation Errors
* ref-ere-err-rep::                     Representation Errors
* ref-ere-err-exi::                     Existence Errors
* ref-ere-err-per::                     Permission Errors
* ref-ere-err-con::                     Context Errors
* ref-ere-err-cns::                     Consistency Errors
* ref-ere-err-syn::                     Syntax Errors
* ref-ere-err-res::                     Resource Errors
* ref-ere-err-sys::                     System Errors

Exceptions thrown by the Prolog system are called errors.

   Error terms have the form:

     error(ISO_ERROR, SICSTUS_ERROR)

where the principal functor of ISO_ERROR (resp. SICSTUS_ERROR) indicates
the error class (*note ref-ere-err::).  The classification always
coincides.

   *Please note:* Do Not throw error terms except when you re-throw a
previously caught error term.  They correspond to the exceptions thrown
by the built-in predicates.  Throwing such forged error terms can lead
to unexpected results.

   *Note lib-types::.  for an alternative interface to throwing error
exceptions, which tries to include line number information for
source-linked debugging.

   Error messages like the one shown earlier are printed using the
built-in predicate 'print_message/2'.  One of the arguments to
'print_message/2' is the exception term.  'print_message/2' can be
customized, as described in *note ref-msg::.

   The set of error classes used by the system has been kept small:

Instantiation Error   ISO
     An input argument is insufficiently instantiated.

Uninstantiation Error   ISO
     An input argument is too instantiated.

Type Error   ISO
     An input argument is of the wrong type.

Domain Error   ISO
     An input argument is illegal but of the right type.

Evaluation Error   ISO
     An incorrect arithmetic expression was evaluated.

Representation Error   ISO
     A computed value cannot be represented.

Existence Error   ISO
     Something does not exist.

Permission Error   ISO
     Specified operation is not permitted.

Context Error
     Specified operation is not permitted in this context.

Consistency Error
     Two otherwise correct values are inconsistent with each other.

Syntax Error   ISO
     Error in reading a term.

Resource Error   ISO
     Some resource limit has been exceeded.

System Error   ISO
     An error detected by the operating system.

   The format of the exception thrown by the built-in predicates is:

     error(ISO_ERROR, SICSTUS_ERROR)

where ISO_ERROR is the error term prescribed by the ISO Prolog standard,
while SICSTUS_ERROR is the part defined by the standard to be
implementation defined.  This so called SICStus error term has the same
principal functor as ISO_ERROR but more arguments containing additional
information, such as the goal and the argument number causing the error.
Arguments are numbered from 1 upwards.  An argument number given as zero
means that an unspecific argument caused the error.

   The list below itemizes the error terms, showing the ISO_ERROR and
SICSTUS_ERROR form of each one, in that order.  The SICStus and ISO
error terms always belong to the same error class, but note that the
Context and Consistency error classes are extensions to the ISO Prolog
standard.

   The goal part of the error term may optionally have the form
'$@(CALLABLE,PC)' where PC is an internal encoding of the line of code
containing the culprit goal or one of its ancestors.  To decompose an
annotated goal AGOAL into a GOAL proper and a SOURCEINFO descriptor
term, indicating the source position of the goal, use:

     ?- goal_source_info(AGOAL, GOAL, SOURCEINFO).

   The reference page gives details about the SOURCEINFO format.  *Note
mpg-ref-goal_source_info::.

'instantiation_error   ISO'
'instantiation_error(GOAL,ARGNO)'
     GOAL was called with insufficiently instantiated arguments.

'uninstantiation_error(CULPRIT)   ISO'
'uninstantiation_error(GOAL,ARGNO,CULPRIT)'
     GOAL was called with too instantiated arguments, expecting CULPRIT
     to be uninstantiated.

'type_error(TYPENAME,CULPRIT)   ISO'
'type_error(GOAL,ARGNO,TYPENAME,CULPRIT)'
     GOAL was called with the wrong type of argument(s).  TYPENAME is
     the expected type and CULPRIT what was actually found.

'domain_error(DOMAIN,CULPRIT)   ISO'
'domain_error(GOAL,ARGNO,DOMAIN,CULPRIT)'
     GOAL was called with argument(s) of the right type but with illegal
     value(s).  DOMAIN is the expected domain and CULPRIT what was
     actually found.

'existence_error(OBJECTTYPE,CULPRIT)   ISO'
'existence_error(GOAL,ARGNO,OBJECTTYPE,CULPRIT,RESERVED)'
     Something does not exist as indicated by the arguments.  *Note
     ref-ere-err-exi::.  for ways of controlling this behavior.

'permission_error(OPERATION,OBJECTTYPE,CULPRIT)   ISO'
'permission_error(GOAL,OPERATION,OBJECTTYPE,CULPRIT,RESERVED)'
     The OPERATION is not permitted on CULPRIT of the OBJECTTYPE.  *Note
     ref-ere-err-per::.  for ways of controlling this behavior.

'context_error(CONTEXTTYPE,COMMANDTYPE)'
'context_error(GOAL,CONTEXTTYPE,COMMANDTYPE)'
     The COMMANDTYPE is not permitted in CONTEXTTYPE.

'syntax_error(MESSAGE)   ISO'
'syntax_error(GOAL,POSITION,MESSAGE,TOKENS,AFTERERROR)'
     A syntax error was found when reading a term with 'read/[1,2]' or
     assembling a number from its characters with 'number_chars/2' or
     'number_codes/2'.  *Note ref-ere-err-syn::.  for ways of
     controlling this behavior.

'evaluation_error(ERRORTYPE,CULPRIT)   ISO'
'evaluation_error(GOAL,ARGNO,ERRORTYPE,CULPRIT)'
     An incorrect arithmetic expression was evaluated.

'representation_error(ERRORTYPE)   ISO'
'representation_error(GOAL,ARGNO,ERRORTYPE)'
     A representation error occurs when the program tries to compute
     some well-defined value that cannot be represented, such as a
     compound term with arity > 255.

'consistency_error(CULPRIT1,CULPRIT2,MESSAGE)'
'consistency_error(GOAL,CULPRIT1,CULPRIT2,MESSAGE)'
     A consistency error occurs when two otherwise valid values or
     operations have been specified that are inconsistent with each
     other.

'resource_error(RESOURCETYPE)   ISO'
'resource_error(GOAL,RESOURCETYPE)'
     A resource error occurs when SICStus Prolog has insufficient
     resources to complete execution.  The only value for RESOURCETYPE
     that is currently in use is 'memory'.

'system_error   ISO'
'system_error(MESSAGE)'
     An error occurred while dealing with the operating system.

   Most exception terms include a copy of the GOAL that threw the
exception.

   In general, built-in predicates that cause side-effects, such as the
opening of a stream or asserting a clause into the Prolog database,
attempt to do all error checking before the side-effect is performed.
Unless otherwise indicated in the documentation for a particular
predicate or error class, it should be assumed that goals that throw
exceptions have not performed any side-effect.


File: sicstus.info,  Node: ref-ere-err-ins,  Next: ref-ere-err-uns,  Up: ref-ere-err

4.15.4.1 Instantiation Errors
.............................

An instantiation error occurs when a predicate or command is called with
one of its input arguments insufficiently instantiated.

   The SICSTUS_ERROR term associated with an instantiation error is
     instantiation_error(GOAL, ARGNO)

where ARGNO is a non-negative integer indicating which argument caused
the problem.  ARGNO=0 means that the problem could not be localized to a
single argument.

   Note that the ARGNOth argument of GOAL might well be a non-variable:
the error is _in_ that argument.  For example, the goal
     X is Y+1

where Y is uninstantiated throws the exception
     error(instantiation_error,
           instantiation_error(_A is _B+1,2))

because the second argument to 'is/2' contains a variable.


File: sicstus.info,  Node: ref-ere-err-uns,  Next: ref-ere-err-typ,  Prev: ref-ere-err-ins,  Up: ref-ere-err

4.15.4.2 Uninstantiation Errors
...............................

An uninstantiation error occurs when a predicate or command is called
with one of its input arguments instantiated when an unbound variable
was expected.

   The SICSTUS_ERROR term associated with an instantiation error is
     uninstantiation_error(GOAL,ARGNO,CULPRIT)

   For example, the goal

     open(f, write, bar)

throws the exception
     error(uninstantiation_error(bar),
           uninstantiation_error(open(f,write,bar),3,bar))

because the third argument was not a variable.


File: sicstus.info,  Node: ref-ere-err-typ,  Next: ref-ere-err-dom,  Prev: ref-ere-err-uns,  Up: ref-ere-err

4.15.4.3 Type Errors
....................

A type error occurs when an input argument is of the wrong "type".  In
general, a "type" is taken to be a class of terms for which there exists
a unary "type test predicate".  Some types are built-in, such as
'atom/1' and 'integer/1'.

   The type of a term is the sort of thing you can tell just by looking
at it, without checking to see how _big_ it is.  So "integer" is a type,
but "non-negative integer" is not, and "atom" is a type, but "atom with
5 letters in its name" and "atom starting with 'x'" are not.

   The point of a type error is that you have _obviously_ passed the
wrong sort of argument to a command; perhaps you have switched two
arguments, or perhaps you have called the wrong predicate, but it is not
a subtle matter of being off by one.

   Most built-in predicates check all their input arguments for type
errors.

   The SICSTUS_ERROR term associated with a type error is
     type_error(GOAL, ARGNO, TYPENAME, CULPRIT)

ARGNO
     CULPRIT occurs somewhere in the ARGNOth argument of GOAL.

TYPENAME
     says what sort of term was expected; it should be the name of a
     unary predicate that is true of whatever terms would not provoke a
     type error.

CULPRIT
     is the actual term being complained about: TYPENAME(CULPRIT) should
     be false.

   For example:
     | ?- catch((write(3),1), Error, true).
     Error = error(type_error(callable,(write(3),1)),
                   type_error(user:(write(3),1),0,callable,(write(3),1)))


File: sicstus.info,  Node: ref-ere-err-dom,  Next: ref-ere-err-eva,  Prev: ref-ere-err-typ,  Up: ref-ere-err

4.15.4.4 Domain Errors
......................

A domain error occurs when an input argument is of the right type but
there is something wrong with its value.  For example, the second
argument to 'open/[3,4]' is supposed to be an atom that represents a
valid mode for opening a file, such as 'read' or 'write'.  If a number
or a compound term is given instead, then that is a type error.  If an
atom is given that is not a valid mode, then that is a domain error.

   The main reason that we distinguish between type errors and domain
errors is that they usually represent different sorts of mistakes in
your program.  A type error usually indicates that you have passed the
wrong argument to a command, whereas a domain error usually indicates
that you passed the argument you meant to check, but you hadn't checked
it enough.

   The SICSTUS_ERROR term associated with a domain error is
     domain_error(GOAL, ARGNO, DOMAINNAME, CULPRIT)

   The arguments correspond to those of the SICSTUS_ERROR term for a
type error, except that DOMAINNAME is not in general the name of a unary
predicate: it needn't even be an atom.  For example, if some command
requires an argument to be an integer in the range 1..99, then it might
use 'between(1,99)' as the DOMAINNAME.  With respect to the 'date_plus'
example under Type Errors, if the month had been given as 13, then it
would have passed the type test but would throw a domain error.

   For example, the goal
     open(somefile,rread,S)

throws the exception
     error(domain_error(io_mode,rread),
           domain_error(open(somefile,rread,_A),2,io_mode,rread))

   The MESSAGE argument is used to provide extra information about the
problem.


File: sicstus.info,  Node: ref-ere-err-eva,  Next: ref-ere-err-rep,  Prev: ref-ere-err-dom,  Up: ref-ere-err

4.15.4.5 Evaluation Errors
..........................

An evaluation error occurs when an incorrect arithmetic expression was
evaluated.  Floating-point overflow is another evaluation error.  The
SICSTUS_ERROR term associated with an evaluation error is
     evaluation_error(GOAL, ARGNO, TYPENAME, CULPRIT)

   This has the same arguments as a type error.


File: sicstus.info,  Node: ref-ere-err-rep,  Next: ref-ere-err-exi,  Prev: ref-ere-err-eva,  Up: ref-ere-err

4.15.4.6 Representation Errors
..............................

A representation error occurs when your program calls for the
computation of some well-defined value that cannot be represented.

   Most representation errors are some sort of overflow.  For example,
creating a compound term with arity greater than 255 results in a
representation error.

   The SICSTUS_ERROR term for a representation error is
     representation_error(GOAL, ARGNO, MESSAGE)

ARGNO
     identifies the argument of the goal that cannot be constructed.

MESSAGE
     further classifies the problem.  A message of '0' or '''' provides
     no further information.


File: sicstus.info,  Node: ref-ere-err-exi,  Next: ref-ere-err-per,  Prev: ref-ere-err-rep,  Up: ref-ere-err

4.15.4.7 Existence Errors
.........................

An existence error occurs when a predicate attempts to access something
that does not exist.  For example, trying to compile a file that does
not exist, erasing a database reference that has already been erased.

   The SICSTUS_ERROR term associated with an existence error is
     existence_error(GOAL, ARGNO, OBJECTTYPE, CULPRIT, MESSAGE)

ARGNO
     index of argument of GOAL where CULPRIT appears

OBJECTTYPE
     expected type of non-existent object

CULPRIT
     name for the non-existent object

MESSAGE
     the constant '0' or '''', or some additional information provided
     by the operating system or other support system indicating why
     CULPRIT is thought not to exist.

   For example, 'see('../brother/niece')' might throw the exception
     error(existence_error(source_sink,'../brother/niece'),
           existence_error(see('../brother/niece'),1,file,'../brother/niece',0))

   An existence error does not necessarily cause an exception to be
thrown.  For I/O predicates, the behavior can be controlled with the
'fileerrors' Prolog flag (*note ref-lps-flg::) or with the
'fileerrors/1' alias 'file_errors/1' option to 'absolute_file_name/3'.
The following values are possible:

'on (fileerrors flag value)'
'error (absolute_file_name/3 fileerrors value)'
     Throw an exception if a given file cannot be opened.  The default.

'off (fileerrors flag value)'
'fail (absolute_file_name/3 fileerrors value)'
     Merely fail if a given file cannot be opened.


File: sicstus.info,  Node: ref-ere-err-per,  Next: ref-ere-err-con,  Prev: ref-ere-err-exi,  Up: ref-ere-err

4.15.4.8 Permission Errors
..........................

A permission error occurs when an operation is attempted that is among
the kinds of operation that the system is in general capable of
performing, and among the kinds that you are in general allowed to
request, but this particular time it is not permitted.  Usually, the
reason for a permission error is that the "owner" of one of the objects
has requested that the object be protected.

   For example, an attempts to assert or retract clauses for a predicate
that has not been declared ':-dynamic' is rejected with a permission
error.

   File system protection is another major source of such errors.

   The SICSTUS_ERROR term associated with a permission error is
     permission_error(GOAL, OPERATION, OBJECTTYPE, CULPRIT, MESSAGE)

OPERATION
     operation attempted; OPERATION exists but is not permitted with
     CULPRIT.

OBJECTTYPE
     CULPRIT's type.

CULPRIT
     name of protected object.

MESSAGE
     provides such operating-system-specific additional information as
     may be available.  A message of '0' or '''' provides no further
     information.

   A permission error does not necessarily cause an exception to be
thrown.  For I/O predicates, the behavior can be controlled with the
'fileerrors' Prolog flag (*note ref-lps-flg::) or with the
'fileerrors/1' alias 'file_errors/1' option to 'absolute_file_name/3',
exactly as for existence errors.


File: sicstus.info,  Node: ref-ere-err-con,  Next: ref-ere-err-cns,  Prev: ref-ere-err-per,  Up: ref-ere-err

4.15.4.9 Context Errors
.......................

A context error occurs when a goal or declaration appears in the wrong
place.  There may or may not be anything wrong with the goal or
declaration as such; the point is that it is out of place.  Calling
'multifile/1' as a goal is a context error, as is having ':-module/2'
anywhere but as the first term in a source file.  This error classe is
an extension to the ISO Prolog standard.

   The SICSTUS_ERROR term associated with a context error is
     context_error(GOAL, CONTEXTTYPE, COMMANDTYPE)

CONTEXTTYPE
     the context in which the command was attempted.

COMMANDTYPE
     the type of command that was attempted.


File: sicstus.info,  Node: ref-ere-err-cns,  Next: ref-ere-err-syn,  Prev: ref-ere-err-con,  Up: ref-ere-err

4.15.4.10 Consistency Errors
............................

A consistency error occurs when two otherwise valid values or operations
have been specified that are inconsistent with each other.  For example,
if two modules each import the same predicate from the other, then that
is a consistency error.  This error classe is an extension to the ISO
Prolog standard.

   The SICSTUS_ERROR term associated with a consistency error is
     consistency_error(GOAL, CULPRIT1, CULPRIT2, MESSAGE)

CULPRIT1
     One of the conflicting values/operations.

CULPRIT2
     The other conflicting value/operation.

MESSAGE
     Additional information, or '0', or ''''.


File: sicstus.info,  Node: ref-ere-err-syn,  Next: ref-ere-err-res,  Prev: ref-ere-err-cns,  Up: ref-ere-err

4.15.4.11 Syntax Errors
.......................

A syntax error occurs when data are read from some external source but
have an improper format or cannot be processed for some other reason.
This category mainly applies to 'read/1' and its variants.

   The SICSTUS_ERROR term associated with a syntax error is
     syntax_error(GOAL, POSITION, MESSAGE, LEFT, RIGHT)

where GOAL is the goal in question, POSITION identifies the position in
the stream where reading started, and MESSAGE describes the error.  Left
and right are lists of tokens before and after the error, respectively.

   Note that the POSITION is where reading started, not where the error
_is_.

   'read/1' does two things.  First, it reads a sequence of characters
from the current input stream up to and including a clause terminator,
or the end of file marker, whichever comes first.  Then it attempts to
parse the sequence of characters as a Prolog term.  If the parse is
unsuccessful, then a syntax error occurs.  Thus, in the case of syntax
errors, 'read/1' disobeys the normal rule that predicates should detect
and report errors before they perform any side-effects, because the
side-effect of reading the characters has been done.

   A syntax error does not necessarily cause an exception to be thrown.
For I/O predicates, but not for 'number_chars/2' and 'number_codes/2',
The behavior can be controlled via the 'syntax_errors' Prolog flag
(*note ref-lps-flg::), or via the 'syntax_errors/1' option to
'read_term/[2,3]'.  The following values are possible:

'quiet'
     When a syntax error is detected, nothing is printed, and 'read/1'
     just quietly fails.

'dec10'
     This provides compatibility with other Prologs: when a syntax error
     is detected, a syntax error message is issued with
     'print_message/2', and the 'read' is repeated.  This is the
     default.

'fail'
     This provides compatibility with other Prologs.  When a syntax
     error is detected, a syntax error message is printed on
     'user_error', and the 'read' then fails.

'error'
     When a syntax error is detected, an exception is thrown.


File: sicstus.info,  Node: ref-ere-err-res,  Next: ref-ere-err-sys,  Prev: ref-ere-err-syn,  Up: ref-ere-err

4.15.4.12 Resource Errors
.........................

A resource error occurs when some resource runs out.  For example, you
can run out of virtual memory, or you can exceed the operating system
limit on the number of simultaneously open files.

   Often a resource error arises because of a programming mistake: for
example, you may exceed the maximum number of open files because your
program does not close files when it has finished with them.  Or, you
may run out of virtual memory because you have a non-terminating
recursion in your program.

   The SICSTUS_ERROR term for a resource error is
     resource_error(GOAL, RESOURCE)

GOAL
     A copy of the goal, or '0' if no goal was responsible; for example
     there is no particular goal to blame if you run out of virtual
     memory.

RESOURCE
     identifies the resource that was exhausted.  The only value
     currently in use is 'memory'.


File: sicstus.info,  Node: ref-ere-err-sys,  Prev: ref-ere-err-res,  Up: ref-ere-err

4.15.4.13 System Errors
.......................

System errors are problems that the operating system notices (or
causes).  Note that many of the exception indications returned by the
operating system (such as "file does not exist") are mapped to Prolog
exceptions; it is only really unexpected things that show up as system
errors.

   The SICSTUS_ERROR term for a system error is
     system_error(MESSAGE)

where MESSAGE is not further specified.


File: sicstus.info,  Node: ref-ere-exa,  Next: ref-ere-leg,  Prev: ref-ere-err,  Up: ref-ere

4.15.5 An Example
-----------------

Suppose you want a routine that is to prompt for a file name and open
the file if it can; otherwise it is to prompt the user for a replacement
name.  If the user enters an empty name, then it is to fail.  Otherwise,
it is to keep asking the user for a name until something works, and then
it is to return the stream that was opened.  There is no need to return
the file name that was finally used.  We can get it from the stream.
Code:

     retry_open_output(Stream) :-
         ask_query(filename, format('Type name of file to open\n',[]), -, FileName),
         FileName \== '',
         catch(open(FileName, write, Stream),
               Error,
               (   Error = error(_,Excp),
                   file_error(Excp)
               ->  print_message(warning, Excp),
                   retry_open_output(Stream)
               ;   throw(Error)
               )).

     file_error(existence_error(open(_,_,_), 1, _, _, _)).
     file_error(permission_error(open(_,_,_), _, _, _, _)).

     :- multifile 'SU_messages':query_class/5.
     'SU_messages':query_class(filename, '> ', line, atom_codes, help_query) :- !.

     :- multifile 'SU_messages':query_map/4.
     'SU_messages':query_map(atom_codes, Codes, success, Atom) :- !,
             (Codes==end_of_file -> Atom = '' ; atom_codes(Atom, Codes)).

   Sample session:

     | ?- retry_open_output(S).
     Type name of file to open
     > nodir/nofile
     * Existence error in argument 1 of open/3
     * file '/tmp/nodir/nofile' does not exist
     * goal:  open('nodir/nofile',write,_701)
     Type name of file to open
     > newfile
     S = '$stream'(3491752)

   What this example does _not_ catch is as interesting as what it does.
All errors except existence and permission errors are re-thrown, as they
represent errors in the program.  The example also shows that you
generally do not want to catch _all_ exceptions that a particular goal
might throw.


File: sicstus.info,  Node: ref-ere-leg,  Next: ref-ere-int,  Prev: ref-ere-exa,  Up: ref-ere

4.15.6 Legacy Predicates
------------------------

Exception handling for Prolog was originally introduced in Quintus
Prolog, and later inherited by SICStus Prolog, with an API that predated
the ISO standard.  This API is still supported but should be regarded as
legacy, and consists of the two predicates 'raise_exception/1' and
'on_exception/3':

'on_exception(?TEMPLATE, :PROTECTEDGOAL, :HANDLER)'
     Equivalent to 'catch(:PROTECTEDGOAL, ?TEMPLATE, :HANDLER)'.  Any
     exception term matching TEMPLATE is caught and handled.  *Note
     mpg-ref-on_exception::.

'raise_exception(+EXCEPTIONTERM)'
     If EXCEPTIONTERM matches one of the SICStus error terms listed in
     *note ref-ere-err::, then the corresponding error term
     'error(ISO_ERROR, SICSTUS_ERROR)' is constructed and thrown.
     Otherwise, EXCEPTIONTERM is thrown as is.

   Prior to release 4.3, 'throw/1' and 'raise_exception/3' used to be
equivalent and throw their argument as is, whereas 'catch/3' and
'on_exception/3' both used to attempt to recognize and expand SICStus
error terms into 'error/2' terms.  Unless a forged SICStus error term is
thrown by 'throw/1', the net behavior is unchanged.  *Note
mpg-ref-raise_exception::.


File: sicstus.info,  Node: ref-ere-int,  Next: ref-ere-sum,  Prev: ref-ere-leg,  Up: ref-ere

4.15.7 Interrupting Execution
-----------------------------

There exist more drastic means of interrupting the normal control flow.
To invoke a recursive top-level, use:

     ?- break.
   *Note mpg-ref-break::.

   To exit from Prolog, use:

     ?- halt.

   To exit from Prolog with return code CODE, use:

     ?- halt(CODE).
   *Note mpg-ref-halt::.

   To abort the execution of the current query and return to the
top-level, use:

     ?- abort.
   *Note mpg-ref-abort::.

     *Please note:* 'halt/[0,1]' and 'abort/0' are implemented by
     throwing a reserved exception, which has a handler at the top-level
     of development systems and executables built with the 'spld' tool.
     Thus they give the opportunity for cleanup goals (see
     'call_cleanup/2') to run.


File: sicstus.info,  Node: ref-ere-sum,  Prev: ref-ere-int,  Up: ref-ere

4.15.8 Summary of Predicates
----------------------------

'abort'
     abort execution of the program; return to current break level

'break'
     start a new break-level to interpret commands from the user

'catch(:P,?E,:H)   ISO'
     specify a handler H for any exception E arising in the execution of
     the goal P

'user:error_exception(+EXCEPTION)   hook,development'
     EXCEPTION is an exception that traps to the debugger if it is
     switched on.

'goal_source_info(+AGOAL, -GOAL, -SOURCEINFO)'
     Decomposes the annotated goal AGOAL into a GOAL proper and the
     SOURCEINFO descriptor term, indicating the source position of the
     goal.

'halt   ISO'
'halt(C)   ISO'
     exit from Prolog with exit code C

'on_exception(?E,:P,:H)'
     specify a handler H for any exception E arising in the execution of
     the goal P

'raise_exception(+E)'
     raise exception E

'throw(+E)   ISO'
     raise exception E

'unknown(?OLDVALUE, ?NEWVALUE)   development'
     access the 'unknown' Prolog flag and print a message

'user:unknown_predicate_handler(+GOAL, +MODULE, -NEWGOAL)   hook'
     tell Prolog to call 'MODULE:NEWGOAL' if 'MODULE:GOAL' is undefined


File: sicstus.info,  Node: ref-msg,  Next: ref-oth,  Prev: ref-ere,  Up: Prolog Intro

4.16 Messages and Queries
=========================

This section describes the two main aspects of user interaction,
displaying messages and querying the user.  We will deal with these two
issues in turn.

* Menu:

* Message Processing:: Message Processing
* Message Handling Predicates:: Message Handling Predicates
* Query Processing:: Query Processing
* Query Handling Predicates:: Query Handling Predicates
* Message Summary:: Predicate Summary


File: sicstus.info,  Node: Message Processing,  Next: Message Handling Predicates,  Up: ref-msg

4.16.1 Message Processing
-------------------------

Every message issued by the Prolog system is displayed using a single
predicate:
     print_message(SEVERITY, MESSAGE)

   MESSAGE is a term that encodes the message to be printed.  The format
of message terms is subject to change, but can be inspected in the file
'library('SU_messages')' of the SICStus Prolog distribution.

   The atom SEVERITY specifies the type (or importance) of the message.
The following table lists the severities known to the SICStus Prolog
system, together with the line prefixes used in displaying messages of
the given severity:

'error'           ''! ''   for error messages
'warning'         ''* ''   for warning messages
'informational'   ''% ''   for informational messages
'help'            ''''     for help messages
'query'           ''''     for query texts (*note Query Processing::)
'silent'          ''''     a special kind of message, which normally
                           does not produce any output, but can be
                           intercepted by hooks

   'print_message/2' is a built-in predicate, so that users can invoke
it to have their own messages processed in the same way as the system
messages.

   The processing and printing of the messages is highly customizable.
For example, this allows the user to change the language of the
messages, or to make them appear in dialog windows rather than on the
terminal.

* Menu:

* Message Phases:: Phases of Message Processing
* Message Generation Phase:: Message Generation Phase
* Message Printing Phase:: Message Printing Phase


File: sicstus.info,  Node: Message Phases,  Next: Message Generation Phase,  Up: Message Processing

4.16.1.1 Phases of Message Processing
.....................................

Messages are processed in two major phases.  The user can influence the
behavior of each phase using appropriate hooks, described later.

   The first phase is called the _message generation phase_: it
determines the text of the message from the input (the abstract message
term).  No printing is done here.  In this phase the user can change the
phrasing or the language of the messages.

   The result of the first phase is created in the form of a
"format-command list".  This is a list whose elements are
"format-commands", or the atom 'nl' denoting the end of a line.  A
format-command describes a piece of text not extending over a line
boundary and it can be one of the following:

'FORMATSTRING-ARGS'
'format(FORMATSTRING, ARGS)'
     This indicates that the message text should appear as if printed by
          format(FORMATSTRING, ARGS).

'write_term(TERM, OPTIONS)'
     This indicates that the message text should appear as if printed by
          write_term(TERM, OPTIONS).

'write_term(TERM)'
     Equivalent to 'write_term(TERM, OPTIONS)' where OPTIONS is the
     actual value of the Prolog flag 'toplevel_print_options'.

   As an example, let us see what happens in case of the toplevel call
'_ =:= 3'.  An instantiation error is raised by the Prolog system, which
is caught, and the abstract message term
'error(instantiation_error,instantiation_error(_=:=3,1))' is
generated--the first argument is the goal, and the second argument is
the position of the uninstantiated variable within the goal.  In the
first phase of message processing this is converted to the following
format-command list:
     ['Instantiation error'-[],' in argument ~d of ~q'-[1,=:= /2],nl,
      'goal:  '-[],write_term(_=:=3),nl]

   A minor transformation, so-called _line splitting_ is performed on
the message text before it is handed over to the second phase.  The
format-command list is broken up along the 'nl' atoms into a list of
lines, where each line is a list of format-commands.  We will use the
term format-command lines to refer to the result of this transformation.

   In the example above, the result of this conversion is the following:
     [['Instantiation error'-[],' in argument ~d of ~q'-[1,=:= /2]],
      ['goal:  '-[],write_term(_=:=3)]]
   The above format-command lines term is the input of the second phase
of message processing.

   The second phase is called the _message printing phase_, this is
where the message is actually displayed.  The severity of the message is
used here to prefix each line of the message with some characters
indicating the type of the message, as listed above.

   The user can change the exact method of printing (e.g. redirection of
messages to a stream, a window, or using different prefixes, etc.)
through appropriate hooks.

   In our example the following lines are printed by the second phase of
processing:
     ! Instantiation error in argument 1 of =:= /2
     ! goal:  _=:=3

   The user can override the default message processing mechanism in the
following two ways:
   * A global method is to define the hook predicate
     'portray_message/2', which is the first thing called by message
     processing.  If this hook exists and succeeds, then it overrides
     all other processing--nothing further is done by 'print_message/2'.

   * If a finer method of influencing the behavior of message processing
     is needed, then there are several further hooks provided, which
     affect only one phase of the process.  These are described in the
     following paragraphs.


File: sicstus.info,  Node: Message Generation Phase,  Next: Message Printing Phase,  Prev: Message Phases,  Up: Message Processing

4.16.1.2 Message Generation Phase
.................................

The default message generation predicates are located in the
'library('SU_messages')' file, in the ''SU_messages'' module, together
with other message and query related predicates.  This is advantageous
when these predicates have to be changed as a whole (for example when
translating all messages to another language), because this can be done
simply by replacing the file 'library('SU_messages')' by a new one.

   In the message generation phase three alternative methods are tried:

   * First the hook predicate 'generate_message_hook/3' is executed, if
     it succeeds, then it is assumed to deliver the output of this
     phase.

   * Next the default message generation is invoked via
     ''SU_messages':generate_message/3'.

   * In the case that neither of the above methods succeed, a built-in
     fall-back message generation method is used.

   The hook predicate 'generate_message_hook/3' can be used to override
the default behavior, or to handle new messages defined by the
programmer that do not fit the default message generation schemes.  The
latter can also be achieved by adding new clauses to the extendible
''SU_messages':generate_message/3' predicate.

   If both the hook and the default method refuses to handle the
message, then the following simple format-command list is generated from
the abstract message term MESSAGE:
     ['~q'-[MESSAGE],nl]
   This will result in displaying the abstract message term itself, as
if printed by 'writeq/1'.

   For messages of the severity 'silent' the message generation phase is
skipped, and the '[]' format-command list is returned as the output.


File: sicstus.info,  Node: Message Printing Phase,  Prev: Message Generation Phase,  Up: Message Processing

4.16.1.3 Message Printing Phase
...............................

By default this phase is handled by the built-in predicate
'print_message_lines/3'.  Each line of the message is prefixed with a
string depending on the severity, and is printed to 'user_error'.  The
'query' severity is special--no newline is printed after the last line
of the message.

   This behavior can be overridden by defining the hook predicate
'message_hook/3', which is called with the severity of the message, the
abstract message term and its translation to format-command lines.  It
can be used to make smaller changes, for example by calling
'print_message_lines/3' with a stream argument other than 'user_error',
or to implement a totally different display method such as using dialog
windows for messages.

   For messages of the severity 'silent' the message printing phase
consists of calling the hook predicate 'message_hook/3' only.  Even if
the hook fails, no printing is done.


File: sicstus.info,  Node: Message Handling Predicates,  Next: Query Processing,  Prev: Message Processing,  Up: ref-msg

4.16.2 Message Handling Predicates
----------------------------------

'print_message(+SEVERITY, +MESSAGE)   hookable'

     Portrays or else writes MESSAGE of a given SEVERITY on the standard
     error stream.  *Note mpg-ref-print_message::.

'portray_message(+SEVERITY, +MESSAGE)   hook'
'user:portray_message(+SEVERITY, +MESSAGE)'

     Tells 'print_message/2' what to do.

'generate_message_hook(+MESSAGE, -L0, -L)   hook'
'user:generate_message_hook(+MESSAGE, -L0, -L)'

     A way for the user to override the call to
     ''SU_messages':generate_message/3' in the message generation phase
     in 'print_message/2'.

''SU_messages':generate_message(+MESSAGE, -L0, -L)   extendible'

     Predefined message generation rules.

'message_hook(+SEVERITY, +MESSAGE, +LINES)   hook'
'user:message_hook(+SEVERITY, +MESSAGE, +LINES)'

     Overrides the call to 'print_message_lines/3' in 'print_message/2'.
     A way for the user to intercept the abstract message term MESSAGE
     of type SEVERITY, whose translation is LINES, before it is actually
     printed.

'print_message_lines(+STREAM, +SEVERITY, +LINES)'

     Print the LINES to STREAM, preceding each line with a prefix
     defined by SEVERITY.

'goal_source_info(+AGOAL, -GOAL, -SOURCEINFO)'

     Decomposes the annotated goal AGOAL into a GOAL proper and the
     SOURCEINFO descriptor term, indicating the source position of the
     goal.


File: sicstus.info,  Node: Query Processing,  Next: Query Handling Predicates,  Prev: Message Handling Predicates,  Up: ref-msg

4.16.3 Query Processing
-----------------------

All user input in the Prolog system is handled by a single predicate:
     ask_query(QUERYCLASS, QUERY, HELP, ANSWER)

   QUERYCLASS, described below, specifies the form of the query
interaction.  QUERY is an abstract message term specifying the query
text, HELP is an abstract message term used as a help message in certain
cases, and ANSWER is the (abstract) result of the query.

   'ask_query/4' is a built-in predicate, so that users can invoke it to
have their own queries processed in the same way as the system queries.

   The processing of queries is highly customizable.  For example, this
allows changing the language of the input expected from the user, or to
make queries appear in dialog windows rather than on the terminal.

* Menu:

* Query Classes:: Query Classes
* Query Phases:: Phases of Query Processing
* Query Hooks:: Hooks in Query Processing
* Default Input Methods:: Default Input Methods
* Default Map Methods:: Default Map Methods
* Default Query Classes:: Default Query Classes


File: sicstus.info,  Node: Query Classes,  Next: Query Phases,  Up: Query Processing

4.16.3.1 Query Classes
......................

Queries posed by the system can be classified according to the kind of
input they expect, the way the input is processed, etc.  Queries of the
same kind form a _query class_.

   For example, queries requiring a yes/no answer form a query class
with the following characteristics:

   * the text ' (y or n) ' is used as the prompt;

   * a single line of text is input;

   * if the first non-whitespace character of the input is 'y' or 'n'
     (possibly in capitals), then the query returns the atom 'yes' or
     'no', respectively, as the abstract answer;

   * otherwise a help message is displayed and the query is repeated.

   There are built-in query classes for reading in yes/no answers,
toplevel queries, debugger commands, etc.

   A query class is characterized by a ground Prolog term, which is
supplied as the first argument to the query processing predicate
'ask_query/4'.  The characteristics of a query class are normally
described by the extendible predicate
     'SU_messages':query_class(QUERYCLASS, PROMPT, INPUTMETHOD,
                               MAPMETHOD, FAILUREMODE).

   The arguments of the 'query_class' predicate have the following
meaning:
PROMPT
     an atom to be used for prompting the user.

INPUTMETHOD
     a non-variable term, which specifies how to obtain input from the
     user.

     For example, a built-in input method is described by the atom
     'line'.  This requests that a line is input from the user, and the
     code-list is returned.  Another built-in input method is
     'term(OPTIONS)'; here, a Prolog term is read and returned.

     The input obtained using INPUTMETHOD is called "raw input", as it
     may undergo further processing.

     In addition to the built-in input methods, the user can define
     his/her own extensions.

MAPMETHOD
     a non-variable term, which specifies how to process the raw input
     to get the abstract answer to the query.

     For example, the built-in map method 'char([yes-"yY", no-"nN"])'
     expects a code-list as raw input, and gives the answer term 'yes'
     or 'no' depending on the first non-whitespace character of the
     input.  For another example, the built-in map method '=' requests
     that the raw input itself be returned as the answer term--this is
     often used in conjunction with the input method 'term(OPTIONS)'.

     In addition to the built-in map methods the user can define his/her
     own extensions.

FAILUREMODE
     This is used only when the mapping of raw input fails, and the
     query must be repeated.  This happens for example if the user typed
     a character other than 'y' or 'n' in case of the 'yes_or_no' query
     class.  FAILUREMODE determines what to print before re-querying the
     user.  Possible values are:

     'help_query'
          print a help message, then print the text of the query again

     'help'
          only print the help message

     'query'
          only print the text of the query

     'none'
          do not print anything


File: sicstus.info,  Node: Query Phases,  Next: Query Hooks,  Prev: Query Classes,  Up: Query Processing

4.16.3.2 Phases of Query Processing
...................................

Query processing is done in several phases, described below.  We will
illustrate what is done in each phase through a simple example: the
question put to the user when the solution to the toplevel query 'X is
1+1' is displayed, requesting a decision whether to find alternative
answers or not:
     | ?- X is 1+1.

     X = 2 ? no
     Please enter ";" for more choices; otherwise, <return>
      ? ;

   We focus on the query 'X = 2 ? ' in the above script.

   The example query belongs to the class 'next_solution', its text is
described by the message term 'solutions([binding("X",2)])', and its
help text by the message term 'bindings_help'.  Accordingly, such a
query is executed by calling:
     ask_query(next_solution,               /* QUERYCLASS */
               solutions([binding("X",2)]), /* QUERY */
               bindings_help,               /* HELP */
               ANSWER)

   In general, execution of 'ask_query(QUERYCLASS, QUERY, HELP, ANSWER)'
consists of the following phases:

_Preparation phase_
     The abstract message terms QUERY (for the text of the query) and
     HELP (for the help message) are converted to format-command lines
     via the message generation and line splitting phases (*note Message
     Processing::).  Let us call the results of the two conversions
     QUERYLINES and HELPLINES, respectively.  The text of the query,
     QUERYLINES is printed immediately (via the message printing phase,
     using 'query' severity).  HELPLINES may be printed later, and
     QUERYLINES printed again, in case of invalid user input.

     The characteristics of QUERYCLASS (described in the previous
     subsubsection) are retrieved to control the exact behavior of the
     further phases.

     In our example, the following parameters are sent in the
     preparation phase:

     QUERYLINES    =   '[[],['~s = '-["X"],write_term(2)]]'
     HELPLINES     =
       '[['Please enter ";" for more choices; otherwise, <return>'-[]]]'
     PROMPT        =   '' ? ''
     INPUTMETHOD   =   'line'
     MAPMETHOD     =   'char([yes-";", no-[0'\n]])'
     FAILUREMODE   =   'help'

     QUERYLINES is displayed immediately, printing:
          X = 2

     (Note that the first element of QUERYLINES is '[]', therefore the
     output is preceded by a newline.  Also note that no newline is
     printed at the end of the last line, because the 'query' severity
     is used.)

     The subsequent phases will be called repeatedly until the mapping
     phase succeeds in generating an answer.

_Input phase_
     By default, the input phase is implemented by the extendible
     predicate
          'SU_messages':query_input(INPUTMETHOD, PROMPT, RAWINPUT).

     This phase uses the PROMPT and INPUTMETHOD characteristics of the
     query class.  INPUTMETHOD specifies the method of obtaining input
     from the user.  This method is executed, and the result (RAWINPUT)
     is passed on to the next phase.

     The use of PROMPT may depend on INPUTMETHOD.  For example, the
     built-in input method 'line' prints the prompt unconditionally,
     while the input method 'term(_)' passes PROMPT to 'prompt/2'.

     In the example, first the ' ? ' prompt is displayed.  Next, because
     INPUTMETHOD is 'line', a line of input is read, and the code-list
     is returned in RAWINPUT.  Supposing that the user typed ' no<RET>',
     RAWINPUT becomes '" no"' = '[32,110,111]'.

_Mapping phase_
     By default, the mapping phase is implemented by the extendible
     predicate
          'SU_messages':query_map(MAPMETHOD, RAWINPUT,
                                  RESULT, ANSWER).

     This phase uses the MAPMETHOD parameter to control the method of
     converting the raw input to the abstract answer.

     In some cases RAWINPUT is returned as it is, but otherwise it has
     to be processed (parsed) to generate the answer.

     The conversion process may have two outcomes indicated in the
     RESULT returned:
        * success, in which case the query processing is completed with
          the ANSWER term returned;

        * failure, the query has to be repeated.

     In the latter case a message describing the cause of failure may be
     returned, to be printed before the query is repeated.

     In our example, the map method is 'char([yes-";", no-[0'\n]])'.
     The mapping phase fails for the RAWINPUT passed on by the previous
     phase of the example, as the first non-whitespace character is 'n',
     which does not match any of the given characters.

_Query restart phase_
     This phase is executed only if the mapping phase returned with
     failure.

     First, if a message was returned by the mapping, then it is
     printed.  Subsequently, if requested by the FAILUREMODE parameter,
     then the help message HELPLINES and/or the text of the query
     QUERYLINES is printed.

     The query is then repeated--the input and mapping phase will be
     called again to try to get a valid answer.

     In the above example, the user typed an invalid character, so the
     mapping failed.  The 'char(_)' mapping does not return any message
     in case of failure.  The FAILUREMODE of the query class is 'help',
     so the help message HELPLINES is printed, but the query is not
     repeated:
          Please enter ";" for more choices; otherwise, <return>

     Having completed the query restart phase, the example script
     continues by re-entering the input phase: the prompt ' ? ' is
     printed, another line is read, and is processed by the mapping
     phase.  If the user types the character ';' this time, then the
     mapping phase returns successfully and gives the abstract answer
     term 'yes'.


File: sicstus.info,  Node: Query Hooks,  Next: Default Input Methods,  Prev: Query Phases,  Up: Query Processing

4.16.3.3 Hooks in Query Processing
..................................

As explained above, the major parts of query processing are implemented
in the ''SU_messages'' module in the file 'library('SU_messages')'
through the following extendible predicates:
   * ''SU_messages':query_class(+QUERYCLASS, -PROMPT, -INPUTMETHOD,
     -MAPMETHOD, -FAILUREMODE)'

   * ''SU_messages':query_input(+INPUTMETHOD, +PROMPT, -RAWINPUT)'

   * ''SU_messages':query_map(+MAPMETHOD, +RAWINPUT, -RESULT, -ANSWER)'

   This is to enable the user to change the language used, the
processing done, etc., simply by changing or replacing the
'library('SU_messages')' file.

   To give more control to the user and to make the system more robust
(for example if the ''SU_messages'' module is corrupt) the so-called
_four step procedure_ is used in the above three cases--obtaining the
query class parameters, performing the query input and performing the
mapping.  The four steps of this procedure, described below, are tried
in the given order until the first one that succeeds.  Note that if an
exception is raised within the first three steps, then a warning is
printed and the step is considered to have failed.

   * First, a hook predicate is tried.  The name of the hook is derived
     from the name of the appropriate predicate by appending '_hook' to
     it, e.g. 'user:query_class_hook/5' in case of the query class.  If
     this hook predicate exists and succeeds, then it is assumed to have
     done all necessary processing, and the following steps are skipped.

   * Second, the predicate in the ''SU_messages'' module is called (this
     is the default case, these are the predicates listed above).
     Normally this should succeed, unless the module is corrupt, or an
     unknown query-class/input-method/map-method is encountered.  These
     predicates are extendible, so new classes and methods can be added
     easily by the user.

   * Third, as a fall-back, a built-in minimal version of the predicates
     in the original ''SU_messages'' is called.  This is necessary
     because the 'library('SU_messages')' file is modifiable by the
     user, therefore vital parts of the Prolog system (e.g. the toplevel
     query) could be damaged.

   * If all the above steps fail, then nothing more can be done, and an
     exception is raised.


File: sicstus.info,  Node: Default Input Methods,  Next: Default Map Methods,  Prev: Query Hooks,  Up: Query Processing

4.16.3.4 Default Input Methods
..............................

The following INPUTMETHOD types are implemented by the default
''SU_messages':query_input(INPUTMETHOD, PROMPT, RAWINPUT)' (and these
are the input methods known to the third, fall-back step):

'line'
     The PROMPT is printed, a line of input is read using 'read_line/2'
     and the code-list is returned as RAWINPUT.

'term(OPTIONS)'
     PROMPT is set to be the prompt (cf. 'prompt/2'), and a Prolog term
     is read by 'read_term/2' using the given OPTIONS, and is returned
     as RAWINPUT.

'FINALTERM^term(TERM,OPTIONS)'
     A Prolog term is read as above, and is unified with TERM.
     FINALTERM is returned as RAWINPUT.  For example, the
     'T-Vs^term(T,[variable_names(Vs)])' input method will return the
     term read, paired with the list of variable names.


File: sicstus.info,  Node: Default Map Methods,  Next: Default Query Classes,  Prev: Default Input Methods,  Up: Query Processing

4.16.3.5 Default Map Methods
............................

The following MAPMETHOD types are known to
''SU_messages':query_map(MAPMETHOD, RAWINPUT, RESULT, ANSWER)' and to
the built-in fall-back mapping:

'char(PAIRS)'
     In this map method RAWINPUT is assumed to be a code-list.

     PAIRS is a list of 'NAME-ABBREVIATIONS' pairs, where NAME is a
     ground term, and ABBREVIATIONS is a code-list.  The first
     non-whitespace character of RAWINPUT is used for finding the
     corresponding name as the answer, by looking it up in the
     abbreviation lists.  If the character is found, then RESULT is
     'success', and ANSWER is set to the NAME found; otherwise, RESULT
     is 'failure'.

'='
     No conversion is done, ANSWER is equal to RAWINPUT and RESULT is
     'success'.

'debugger'
     This map method is used when reading a single line debugger
     command.  It parses the debugger command and returns the
     corresponding abstract command term.  If the parse is unsuccessful,
     then the answer 'unknown(Line,Warning)' is returned.  This is to
     allow the user to extend the debugger command language via
     'debugger_command_hook/2', see *note Debug Commands::.

     The details of this mapping can be obtained from the
     'library('SU_messages')' file.

     Note that the fall-back version of this mapping is simplified, it
     only accepts parameterless debugger commands.


File: sicstus.info,  Node: Default Query Classes,  Prev: Default Map Methods,  Up: Query Processing

4.16.3.6 Default Query Classes
..............................

Most of the default query classes are designed to support some specific
interaction with the user within the Prolog development environment.
The full list of query classes can be inspected in the file
'library('SU_messages')'.  Here, we only describe the two classes
defined by ''SU_messages':query_class/5' that may be of general use:

QUERYCLASS    'yes_or_no'          'yes_no_proceed'
PROMPT        '' (y or n) ''       '' (y, n, p, s, a, or ?) ''
INPUTMETHOD   'line'               'line'
MAPMETHOD     'char([yes-"yY",     'char([yes-"yY", no-"nN", proceed-"pP",
              no-"nN"])'           suppress-"sS", abort-"aA"])'
FAILUREMODE   'help_query'         'help_query'


File: sicstus.info,  Node: Query Handling Predicates,  Next: Message Summary,  Prev: Query Processing,  Up: ref-msg

4.16.4 Query Handling Predicates
--------------------------------

'ask_query(+QUERYCLASS, +QUERY, +HELP, -ANSWER)   hookable'

     Prints the question QUERY, then reads and processes user input
     according to QUERYCLASS, and returns the result of the processing,
     the abstract answer term ANSWER.  The HELP message is printed in
     case of invalid input.  *Note mpg-ref-ask_query::.

'query_hook(+QUERYCLASS, +QUERY, +QUERYLINES, +HELP, +HELPLINES, -ANSWER)   hook'
'user:query_hook(+QUERYCLASS, +QUERY, +QUERYLINES, +HELP, +HELPLINES, -ANSWER)'

     Called by 'ask_query/4' before processing the query.  If this
     predicate succeeds, then it is assumed that the query has been
     processed and nothing further is done.

'query_class_hook(+QUERYCLASS, -PROMPT, -INPUTMETHOD, -MAPMETHOD, -FAILUREMODE)   hook'
'user:query_class_hook(+QUERYCLASS, -PROMPT, -INPUTMETHOD, -MAPMETHOD, -FAILUREMODE)'

     Provides the user with a method of overriding the call to
     ''SU_messages':query_class/5' in the preparation phase of query
     processing.  This way the default query class characteristics can
     be changed.

''SU_messages':query_class(+QUERYCLASS, -PROMPT, -INPUTMETHOD, -MAPMETHOD, -FAILUREMODE)   extendible'

     Predefined query class characteristics table.

''SU_messages':query_abbreviation(+QUERYCLASS, -PROMPT, -PAIRS)   extendible'

     Predefined query abbreviation table.

'query_input_hook(+INPUTMETHOD, +PROMPT, -RAWINPUT)   hook'
'user:query_input_hook(+INPUTMETHOD, +PROMPT, -RAWINPUT)'

     Provides the user with a method of overriding the call to
     ''SU_messages':query_input/3' in the input phase of query
     processing.  This way the implementation of the default input
     methods can be changed.

''SU_messages':query_input(+INPUTMETHOD, +PROMPT, -RAWINPUT)   extendible'

     Predefined query input methods.

'query_map_hook(+MAPMETHOD, +RAWINPUT, -RESULT, -ANSWER)   hook'
'user:query_map_hook(+MAPMETHOD, +RAWINPUT, -RESULT, -ANSWER)'

     Provides the user with a method of overriding the call to
     ''SU_messages':query_map/4' in the mapping phase of query
     processing.  This way the implementation of the default map methods
     can be changed.

''SU_messages':query_map(+MAPMETHOD, +RAWINPUT, -RESULT, -ANSWER)   extendible'

     Predefined query map methods.


File: sicstus.info,  Node: Message Summary,  Prev: Query Handling Predicates,  Up: ref-msg

4.16.5 Predicate Summary
------------------------

'ask_query(+QUERYCLASS, +QUERY, +HELP, -ANSWER)   hookable'
     Prints the question QUERY, then reads and processes user input
     according to QUERYCLASS, and returns the result of the processing,
     the abstract answer term ANSWER.  The HELP message is printed in
     case of invalid input.

'user:message_hook(+M,+S,+L)   hook'
     intercept the printing of a message

''SU_messages':generate_message(+M,?SO,?S)   extendible'
     determines the mapping from a message term into a sequence of lines
     of text to be printed

'user:generate_message_hook(+M,?S0,?S)   hook'
     intercept message before it is given to
     ''SU_messages':generate_message/3'

'goal_source_info(+AGOAL, -GOAL, -SOURCEINFO)'
     Decomposes the annotated goal AGOAL into a GOAL proper and the
     SOURCEINFO descriptor term, indicating the source position of the
     goal.

'user:portray_message(+SEVERITY,+MESSAGE)   hook'
     Tells 'print_message/2' what to do.

'print_message(+S,+M)   hookable'
     print a message M of severity S

'print_message_lines(+S,+P,+L)'
     print the message lines L to stream S with prefix P

''SU_messages':query_abbreviation(+T,-P)   extendible'
     specifies one letter abbreviations for responses to queries from
     the Prolog system

'user:query_hook(+QUERYCLASS, +QUERY, +QUERYLINES, +HELP, +HELPLINES, -ANSWER)   hook'
     Called by 'ask_query/4' before processing the query.  If this
     predicate succeeds, then it is assumed that the query has been
     processed and nothing further is done.

''SU_messages':query_class(+QUERYCLASS, -PROMPT, -INPUTMETHOD, -MAPMETHOD, -FAILUREMODE)   extendible'
     Access the parameters of a given QUERYCLASS.

'user:query_class_hook(+QUERYCLASS, -PROMPT, -INPUTMETHOD, -MAPMETHOD, -FAILUREMODE)   hook'
     Provides the user with a method of overriding the call to
     ''SU_messages':query_class/5' in the preparation phase of query
     processing.  This way the default query class characteristics can
     be changed.

''SU_messages':query_input(+INPUTMETHOD, +PROMPT, -RAWINPUT)   extendible'
     Implements the input phase of query processing.

'user:query_input_hook(+INPUTMETHOD, +PROMPT, -RAWINPUT)   hook'
     Provides the user with a method of overriding the call to
     ''SU_messages':query_input/3' in the input phase of query
     processing.  This way the implementation of the default input
     methods can be changed.

''SU_messages':query_map(+MAPMETHOD, +RAWINPUT, -RESULT, -ANSWER)   extendible'
     Implements the mapping phase of query processing.

'user:query_map_hook(+MAPMETHOD, +RAWINPUT, -RESULT, -ANSWER)   hook'
     Provides the user with a method of overriding the call to
     ''SU_messages':query_map/4' in the mapping phase of query
     processing.  This way the implementation of the default map methods
     can be changed.


File: sicstus.info,  Node: ref-oth,  Prev: ref-msg,  Up: Prolog Intro

4.17 Other Topics
=================

This section describes topics that do not fit elsewhere.

* Menu:

* System Properties and Environment Variables:: System Properties and Environment Variables


File: sicstus.info,  Node: System Properties and Environment Variables,  Up: ref-oth

4.17.1 System Properties and Environment Variables
--------------------------------------------------

SICStus Prolog stores some information in named variables called system
properties.  System properties are used since release 4.1, whereas
previous releases used environment variables.

   The default value when reading a system property is taken from the
corresponding environment variable.  This makes system properties
largely backward compatible with how environment variables were used in
previous releases.  Any exceptions to this rule are explicitly mentioned
in the documentation.

   You can obtain the value of system properties and environment
variables using 'system:environ/[2,3]' (*note lib-system::) and
'SP_getenv()'.

   Some system properties affect the SICStus Prolog initialization
process and must therefore be set before SICStus Prolog has been
initialized.  There are three ways to affect the initial values of
system properties:

  1. Set the corresponding environment variable.

     System properties get their default value from the environment so
     this is often a convenient method.  It was the only method
     available prior to release 4.1.

  2. Pass the '-DVAR=VALUE' option to the 'sicstus' command line tool.
     *Note too-sicstus::.

  3. Pass an option block to 'SP_initialize()' if you initialize the
     SICStus runtime from C. *Note Initializing the Prolog Engine::.

   Looking up system properties follows the platform convention for
environment variables.  This means that the lookup is case sensitive on
UNIX-like platforms and case insensitive on Windows.

   On UNIX-like systems, the environment is assumed to use the UTF-8
character encoding; on Windows, the native Unicode encoding is used.

   SICStus reads and copies the process environment during
initialization, e.g. in 'SP_initialize()'.  Any subsequent changes to
the proces environment will not be detected by SICStus.  Note that, at
least on UNIX-like systems, changing the process environment, e.g. using
'setenv()', has undefined behavior when the process has multiple
threads, which is the case for any process running SICStus.

   While copying the environment, each entry in the environment is
normalized as follows:
   * If it does not contain an equal sign, then the entry is ignored.
   * On Windows only, if it starts with an equal sign but has no other
     equal signs, then the entry is ignored.
   * If the entry consists of valid UTF-8, then it is kept as is.  This
     is always true on Windows where a Unicode encoding is used
     internally by the operating system.
   * If the entry does not consist of valid UTF-8, then it is treated as
     Latin-1 and converted to UTF-8.  This cannot happen on Windows.
   * On Windows only, if the entry starts with an equal sign, then the
     equal sign is treated as part of the variable name.

   In particular, on UNIX-like systems, this means that the environment
should preferably be in UTF-8.

4.17.1.1 System Properties Set by SICStus Prolog
................................................

The following system properties are set automatically on startup.

'SP_APP_DIR'
     The absolute path to the directory that contains the executable.
     Also available as the 'application' file search path.

'SP_APP_PATH'
     The absolute path to the executable.  Unlike 'SP_APP_DIR', this
     system property may not be available under all circumstances.

'SP_RT_DIR'
     The full path to the directory that contains the SICStus runtime.
     If the application was linked statically to the SICStus runtime,
     then 'SP_RT_DIR' is the same as 'SP_APP_DIR'.  Also available as
     the 'runtime' file search path.

'SP_RT_PATH'
     The absolute path to the SICStus runtime.  Unlike 'SP_RT_DIR', this
     system property may not be available under all circumstances, e.g.
     if the runtime is not a shared library.

'SP_LIBRARY_DIR'
     The absolute path to the directory that contains the SICStus
     library files.  Also available as the initial value of the
     'library' file search path.

'SP_TEMP_DIR'
     A directory suitable for storing temporary files.  It is
     particularly useful with the 'open/4' option
     'if_exists(generate_unique_name)'.  Also available as the 'temp'
     file search path.

'SP_STARTUP_DIR'
     During initialization the 'SP_STARTUP_DIR' system property will be
     set to the working directory used by SICStus.

     Note that this system property can also be set prior to
     initialization, in order to tell SICStus which working directory to
     use.  See below.

4.17.1.2 System Properties Affecting Initialization
...................................................

The following system properties can be set before starting SICStus
Prolog.

   Some of these override the default sizes of certain areas.  For
variables ending with 'SIZE', the size is in bytes, but may be followed
by 'K', 'M', or 'G' meaning 2**10, 2**20 and 2**30 respectively.

   Boolean values true and false are represented by 'yes' and 'no',
respectively.

   *Note Memory Use and Garbage Collection: ref-mgc.  for more
information about the properties that affect memory management.

'SP_PATH'
     Can be used to specify the location of the Runtime Library.  In
     most cases there is no need to use it, but see *note CPL Notes::.

'SP_STARTUP_DIR'
     The value of this system property, if set, is used as the initial
     working directory.  Note that this system property is also set
     automatically during initialization; see above.

     This value of this system property is _not_ read from the
     corresponding environment variable.

'SP_ALLOW_CHDIR'

     If this system property is set to 'no', then SICStus will not
     change the process's working directory when the SICStus working
     directory changes.  This is useful when embedding SICStus and would
     probably be the better default behavior except for backwards
     compatibility.

'GLOBALSTKSIZE'
     Controls the initial size of the global stack.  *Please note*: The
     global stack will not be subsequently trimmed to a size smaller
     than this initial size.

'LOCALSTKSIZE'
     Controls the initial size of the local stack.  *Please note*: The
     local stack will not be subsequently trimmed to a size smaller than
     this initial size.

'CHOICESTKSIZE'
     Controls the initial size of the choicepoint stack.  *Please note*:
     The choicepoint stack will not be subsequently trimmed to a size
     smaller than this initial size.

'TRAILSTKSIZE'
     Controls the initial size of the trail stack.  *Please note*: The
     trail stack will not be subsequently trimmed to a size smaller than
     this initial size.

'GROWTHFACTOR   since release 4.0.8'
     Meaningful values are between 10 and 100; the default is 62.
     Controls the rate at which the Prolog stacks grow when they are
     expanded.  These stacks are stored in two data areas: one holding
     the global and local stacks; another one holding the choicepoint
     and trail stacks.  In addition, both data areas hold some memory
     reserved for the garbage collector.

     The sizes of the two data areas are constrained to take certain
     discrete values only.  The initial size as well as the size after
     expansion is constrained to be W*((1+G)^N) kilobytes, rounded up to
     an integral number of words, where W is the word length in bits, G
     is 'GROWTHFACTOR'/100, and N is an integer.

'PROLOGINITSIZE'
     Controls the size of Prolog's initial memory allocation.  Only used
     by the default memory allocator (*note SP_set_memalloc_hooks:
     cpg-ref-SP_set_memalloc_hooks.).  *Please note*: This initially
     allocated memory will be kept by the Prolog process until
     'SP_deinitialize()' is called or the process exits.

'PROLOGMAXSIZE'
     Defines an upper bound on the amount of memory that Prolog will
     use.  If not set, then Prolog will try to use the available address
     space.  Only used by the default memory allocator (*note
     SP_set_memalloc_hooks: cpg-ref-SP_set_memalloc_hooks.).  Thus if
     Prolog needs to allocate memory beyond this bound, then a memory
     resource error will be raised.

'PROLOGINCSIZE'
     Controls the amount of memory Prolog asks the operating system for
     in any given memory expansion.  Only used by the default memory
     allocator (*note SP_set_memalloc_hooks:
     cpg-ref-SP_set_memalloc_hooks.).

'PROLOGKEEPSIZE'
     Defines a lower bound on the amount of memory retained by
     'trimcore/0'.  By default, Prolog gets memory from the O/S as the
     user program executes, whereas 'trimcore/0' endeavors to return
     free memory back to the O/S. If the programmer knows that her
     program, once it has grown to a certain size, then is likely to
     need as much memory for future computations, she can advise Prolog
     not to return all the free memory back to the operating system by
     setting this variable.  'trimcore/0' only endeavors to return
     memory that is allocated above and beyond 'PROLOGKEEPSIZE'; the
     rest will be kept.  Only used by the default memory allocator
     (*note SP_set_memalloc_hooks: cpg-ref-SP_set_memalloc_hooks.).
     *Please note*: The initially allocated memory will be kept by the
     Prolog process forever, so it is not meaningful to set
     'PROLOGKEEPSIZE' smaller than 'PROLOGINITSIZE'.

'SP_ULIMIT_DATA_SEGMENT_SIZE'
     Sets the maximum size of the data segment of the Prolog process.
     The value can be 'unlimited' or a numeric value as described in the
     first paragraph in this section.  A numeric value of zero (0) is
     equivalent to 'unlimited'.  Not used under Windows.

'SP_USE_MALLOC'
     If 'yes', then 'malloc()' et al. will be used for memory management
     instead of the default memory allocator.  This is sometimes useful,
     e.g$: with debugging tools like 'valgrind'.

     *Please note*: Enabling 'malloc()' allocation is not compatible
     with JIT compilation.

'SP_JIT   since release 4.3'

     Affects whether the JIT (Just In Time) compiler should be used to
     compile Prolog code inte native (machine) code.  One of:

     'yes'
          JIT compilation is enabled and happens automatically.  This is
          the default on platforms that support JIT compilation.
     'no'
          JIT compilation is enabled but does not happen automatically.
          Currently, there is no documented way to JIT compile
          predicates manually.
     'disabled'
          JIT compilation is disabled completely.  Please report if you
          encounter any reason to disable the JIT compiler.

          JIT compilation may need to be disabled on certain
          security-hardened operating systems, e.g. because they do not
          permit memory to be both writeable and executable.

     This system property is ignored on platforms that do not support
     the JIT compiler.

'SP_JIT_COUNTER_LIMIT   since release 4.3'

     Determines how many times a predicate can be called before it is
     JIT compiled.  The default is 0.

     The heuristics used in order to decide when, and whether, a
     predicate should be JIT compiled, is subject to change without
     notice.  In particular, this system property may be treated
     differently in some future release.

'SP_JIT_CLAUSE_LIMIT   since release 4.3'

     Sets an upper bound on the number of clauses of a predicate for JIT
     compilation to be attempted.  The default is 1024.

'SP_SPTI_PATH   since release 4.3'

     Specify a plugin that will be told when predicates are JIT
     compiled.  The details of writing or using such plugins are
     currently not documented, and subject to change without notice.

     There are two predefined plugins,
     'verbose'
          Write verbose information when a predicate is JIT compiled.
          This can be useful when troubleshooting problems with JIT
          compilation, e.g. if some predicate takes too long to
          JIT-compile.

          This plugin can be activated by passing
          '-DSP_SPTI_PATH=verbose' to 'sicstus'.

     'oprofile'

          Tell OProfile profiler about the location and name of the JIT
          compiled predicates.  This makes it possible to use OProfile
          for getting accurate and low-overhead profiling info about JIT
          compiled code.  Information about using OProfile for profiling
          jitted code is available at the OProfile site,
          <http://oprofile.sourceforge.net/>.

          This plugin can be activated either by passing
          '-DSP_SPTI_PATH=oprofile' to 'sicstus', or, once SICStus has
          started, with the goal 'use_module(library(oprofile))'.

          OProfile integration is only available on Linux.

4.17.1.3 Other System Properties
................................

In addition some system properties are read during normal execution.  In
this case the system property is typically not meant to be explicitly
set, instead the value is intended to be taken from the corresponding
environment variable.  Examples of such system properties include 'PATH'
and 'HOME'.


File: sicstus.info,  Node: Debug Intro,  Next: Mixing C and Prolog,  Prev: Prolog Intro,  Up: Top

5 Debugging
***********

This chapter describes the debugging facilities that are available in
development systems.  The purpose of these facilities is to provide
information concerning the control flow of your program.

   The main features of the debugging package are as follows:

   * The "Procedure Box" model of Prolog execution, which provides a
     simple way of visualizing control flow, especially during
     backtracking.  Control flow is viewed at the predicate level,
     rather than at the level of individual clauses.

   * The ability to exhaustively trace your program or to selectively
     set "spypoints".  Spypoints allow you to nominate interesting
     predicates at which, for example, the program is to pause so that
     you can interact.

   * The ability to set advice-points.  An advice-point allows you to
     carry out some actions at certain points of execution,
     independently of the tracing activity.  Advice-points can be used,
     e.g. for checking certain program invariants (cf. the assert
     facility of the C programming language), or for gathering profiling
     or branch coverage information.  Spypoints and advice-points are
     collectively called breakpoints.

   * The wide choice of control and information options available during
     debugging.

   The Procedure Box model of execution is also called the Byrd Box
model after its inventor, Lawrence Byrd.

   Much of the information in this chapter is also in Chapter eight of
[Clocksin & Mellish 81], which is recommended as an introduction.

   Unless otherwise stated, the debugger prints goals using
'write_term/3' with the value of the Prolog flag
'debugger_print_options'.

   The debugger is not available in runtime systems and the predicates
defined in this chapter are undefined; *note Runtime Systems::.

* Menu:

* Procedure Box:: The Procedure Box Control Flow Model
* Basic Debug:: Basic Debugging Predicates
* Plain Spypoint:: Plain Spypoints
* Debug Format:: Format of Debugging Messages
* Debug Commands:: Commands Available during Debugging
* Advanced Debugging:: Advanced Debugging -- an Introduction
* Breakpoint Predicates:: Breakpoint Handling Predicates
* Breakpoint Processing:: The Processing of Breakpoints
* Breakpoint Conditions:: Breakpoint Conditions
* Consult:: Consulting during Debugging
* Exceptions Debug:: Catching Exceptions
* Debug Summary:: Predicate Summary


File: sicstus.info,  Node: Procedure Box,  Next: Basic Debug,  Up: Debug Intro

5.1 The Procedure Box Control Flow Model
========================================

During debugging, the debugger prints out a sequence of goals in various
states of instantiation in order to show the state the program has
reached in its execution.  However, in order to understand what is
occurring it is necessary to understand when and why the debugger prints
out goals.  As in other programming languages, key points of interest
are predicate entry and return, but in Prolog there is the additional
complexity of backtracking.  One of the major confusions that novice
Prolog programmers have to face is the question of what actually happens
when a goal fails and the system suddenly starts backtracking.  The
Procedure Box model of Prolog execution views program control flow in
terms of movement about the program text.  This model provides a basis
for the debugging mechanism in development systems, and enables the user
to view the behavior of the program in a consistent way.

   Let us look at an example Prolog predicate :

                *--------------------------------------*
        Call    |                                      |    Exit
     ---------> +  descendant(X,Y) :- offspring(X,Y).  + --------->
                |                                      |
                |  descendant(X,Z) :-                  |
     <--------- +     offspring(X,Y), descendant(Y,Z). + <---------
        Fail    |                                      |    Redo
                *-------------------+------------------*
                                    |
     <------------------------------+
        Exception

   The first clause states that Y is a descendant of X if Y is an
offspring of X, and the second clause states that Z is a descendant of X
if Y is an offspring of X and if Z is a descendant of Y.  In the diagram
a box has been drawn around the whole predicate and labeled arrows
indicate the control flow in and out of this box.  There are five such
arrows, which we shall look at in turn.

CALL
     This arrow represents initial invocation of the predicate.  When a
     goal of the form 'descendant(X,Y)' is required to be satisfied,
     control passes through the CALL port of the descendant box with the
     intention of matching a component clause and then satisfying the
     subgoals in the body of that clause.  Note that this is independent
     of whether such a match is possible; i.e. first the box is called,
     and then the attempt to match takes place.  Textually we can
     imagine moving to the code for descendant when meeting a call to
     descendant in some other part of the code.

EXIT
     This arrow represents a successful return from the predicate.  This
     occurs when the initial goal has been unified with one of the
     component clauses and the subgoals have been satisfied.  Control
     now passes out of the EXIT port of the descendant box.  Textually
     we stop following the code for descendant and go back to the place
     we came from.

REDO
     This arrow indicates that a subsequent goal has failed and that the
     system is backtracking in an attempt to find alternatives to
     previous solutions.  Control passes through the REDO port of the
     descendant box.  An attempt will now be made to resatisfy one of
     the component subgoals in the body of the clause that last
     succeeded; or, if that fails, to completely rematch the original
     goal with an alternative clause and then try to satisfy any
     subgoals in the body of this new clause.  Textually we follow the
     code backwards up the way we came looking for new ways of
     succeeding, possibly dropping down on to another clause and
     following that if necessary.

FAIL
     This arrow represents a failure of the initial goal, which might
     occur if no clause is matched, or if subgoals are never satisfied,
     or if any solution produced is always rejected by later processing.
     Control now passes out of the FAIL port of the descendant box and
     the system continues to backtrack.  Textually we move back to the
     code that called this predicate and keep moving backwards up the
     code looking for choicepoints.

EXCEPTION
     This arrow represents an exception that was raised in the initial
     goal, either by a call to 'throw/1' or 'raise_exception/1' or by an
     error in a built-in predicate.  *Note ref-ere::.  Control now
     passes out of the EXCEPTION port of the descendant box and the
     system continues to pass the exception to outer levels.  Textually
     we move back to the code that called this predicate and keep moving
     backwards up the code looking for a call to 'catch/3' or
     'on_exception/3'.

   In terms of this model, the information we get about the procedure
box is only the control flow through these five ports.  This means that
at this level we are not concerned with identifying the matching clause,
and how any subgoals are satisfied, but rather we only wish to know the
initial goal and the final outcome.  However, it can be seen that
whenever we are trying to satisfy subgoals, what we are actually doing
is passing through the ports of _their_ respective boxes.  If we were to
follow this, then we would have complete information about the control
flow inside the procedure box.

   Note that the box we have drawn round the predicate should really be
seen as an "invocation box".  That is, there will be a different box for
each different invocation of the predicate.  Obviously, with something
like a recursive predicate, there will be many different CALLS and EXITS
in the control flow, but these will be for different invocations.  Since
this might get confusing each invocation box is given a unique integer
identifier.

   In addition to the five basic ports discussed above, there are two
more ports for invocations involving a blocked goal:

BLOCK
     This port is passed through when a goal is blocked.
UNBLOCK
     This port is passed through when a previously blocked goal is
     unblocked.


File: sicstus.info,  Node: Basic Debug,  Next: Plain Spypoint,  Prev: Procedure Box,  Up: Debug Intro

5.2 Basic Debugging Predicates
==============================

Development systems provide a range of built-in predicates for control
of the debugging facilities.  The most basic predicates are as follows:

'debug   development'

     Switches the debugger on, and ensures that the next time control
     reaches a spypoint, it will be activated.  In basic usage this
     means that a message will be produced and you will be prompted for
     a command.  In order for the full range of control flow information
     to be available it is necessary to have the debugger on from the
     start.  When it is off the system does not remember invocations
     that are being executed.  (This is because it is expensive and not
     required for normal running of programs.)  You can switch DEBUG
     MODE on in the middle of execution, either from within your program
     or after a '^C' (see 'trace/0' below), but information prior to
     this will be unavailable.  *Note mpg-ref-debug::.

'zip   development'

     Same as 'debug/0', except no debugging information is being
     collected, and so is almost as fast as running with the debugger
     switched off.  *Note mpg-ref-zip::.

'trace   development'

     Switches the debugger on, and ensures that the next time control
     enters an invocation box, a message will be produced and you will
     be prompted for a command.  The effect of 'trace/0' can also be
     achieved by typing 't' after a '^C' interruption of a program.

     At this point you have a number of options.  *Note Debug
     Commands::.  In particular, you can just type <RET> to creep (or
     single-step) into your program.  If you continue to creep through
     your program, then you will see every entry and exit to/from every
     invocation box, including compiled code, except for code belonging
     to hidden modules (*note ref-mod::).  You will notice that the
     debugger stops at all ports.  However, if this is not what you
     want, then the next predicate gives full control over the ports at
     which you are prompted.  *Note mpg-ref-trace::.

'leash(+MODE)   development'

     Leashing Mode is set to MODE.  Leashing Mode determines the ports
     of invocation boxes at which you are to be prompted when you creep
     through your program.  At unleashed ports a tracing message is
     still output, but program execution does not stop to allow user
     interaction.  Note that 'leash/1' does not apply to spypoints, the
     leashing mode of these can be set using the advanced debugger
     features; *note Advanced Debugging::.  Block and Unblock ports
     cannot be leashed.  MODE can be a subset of the following,
     specified as a list of the following:

     'call'
          Prompt on Call.

     'exit'
          Prompt on Exit.

     'redo'
          Prompt on Redo.

     'fail'
          Prompt on Fail.

     'exception'
          Prompt on Exception.

     The following shorthands are also allowed:

     'leash(all)'
          Same as 'leash([exception,call,exit,redo,fail])'.

     'leash(half)'
          Same as 'leash([exception,call,redo])'.

     'leash(loose)'
          Same as 'leash([exception,call])'.

     'leash(tight)'
          Same as 'leash([exception,call,redo,fail])'.

     'leash(off)'
          Same as 'leash([])'.

     The initial value of LEASHING MODE is
     '[call,exit,redo,fail,exception]' (full leashing).  *Note
     mpg-ref-leash::.

'nodebug   development'
'notrace   development'
'nozip   development'

     Switches the debugger off.  Any spypoints set will be kept but will
     never be activated.

'debugging   development'

     Prints information about the current debugging state.  This will
     show:

       1. Whether undefined predicates are being trapped.
       2. What breakpoints have been set (see below).
       3. What mode of leashing is in force (see above).
   *Note mpg-ref-debugging::.


File: sicstus.info,  Node: Plain Spypoint,  Next: Debug Format,  Prev: Basic Debug,  Up: Debug Intro

5.3 Plain Spypoints
===================

For programs of any size, it is clearly impractical to creep through the
entire program.  Spypoints make it possible to stop the program whenever
it gets to a particular predicate of interest.  Once there, one can set
further spypoints in order to catch the control flow a bit further on,
or one can start creeping.

   In this section we discuss the simplest form of spypoints, the "plain
spypoints".  The more advanced forms, the "conditional" and "generic
spypoints" will be discussed later; *note Advanced Debugging::.

   Setting a plain spypoint on a predicate indicates that you wish to
see all control flow through the various ports of its invocation boxes,
except during skips.  When control passes through any port of an
invocation box with a spypoint set on it, a message is output and the
user is asked to interact.  Note that the current mode of leashing does
not affect plain spypoints: user interaction is requested on _every_
port.

   Spypoints are set and removed by the following built-in predicates.
The first two are also standard operators:

'spy :SPEC   development'

     Sets plain spypoints on all the predicates given by the generalized
     predicate spec SPEC.

     Examples:

          | ?- spy [user:p, m:q/2, m:q/3].
          | ?- spy m:[p/1, q/1].

     If you set some spypoints when the debugger is switched off, then
     it will be automatically switched on, entering zip mode.  *Note
     mpg-ref-spy::.

'nospy :SPEC   development'

     Similar to 'spy SPEC' except that all the predicates given by SPEC
     will have all previously set spypoints removed from them (including
     conditional spypoints; *note Creating Breakpoints::).  *Note
     mpg-ref-nospy::.

'nospyall   development'

     Removes all the spypoints that have been set, including the
     conditional and generic ones.  *Note mpg-ref-nospyall::.

   The commands available when you arrive at a spypoint are described
later.  *Note Debug Commands::.


File: sicstus.info,  Node: Debug Format,  Next: Debug Commands,  Prev: Plain Spypoint,  Up: Debug Intro

5.4 Format of Debugging Messages
================================

We shall now look at the exact format of the message output by the
system at a port.  All trace messages are output to the standard error
stream, using the 'print_message/2' predicate; *note ref-msg::.  This
allows you to trace programs while they are performing file I/O. The
basic format is as follows:

     N S    23     F6 Call: T foo(hello,there,_123) ?

   N is only used at Exit ports and indicates whether the invocation
could backtrack and find alternative solutions.  Unintended
nondeterminacy is a source of inefficiency, and this annotation can help
spot such efficiency bugs.  It is printed as '?', indicating that
'foo/3' could backtrack and find alternative solutions, or ' '
otherwise.

   S is a spypoint indicator.  If there is a plain spypoint on 'foo/3',
then it is printed as '+'.  In case of conditional and generic spypoints
it takes the form '*' and '#', respectively.  Finally, it is printed as
' ', if there is no spypoint on the predicate being traced.

   The first number is the unique invocation identifier.  It is
increasing regardless of whether or not debugging messages are output
for the invocations (provided that the debugger is switched on).  This
number can be used to cross correlate the trace messages for the various
ports, since it is unique for every invocation.  It will also give an
indication of the number of procedure calls made since the start of the
execution.  The invocation counter starts again for every fresh
execution of a command, and it is also reset when retries (see later)
are performed.

   Just before the second number is an optional "frame marker", printed
as '@' if present.  This marks the location of the current frame, the
meaning of which is explained in the next section.

   The second number is the "current depth"; i.e. the number of direct
ancestors this goal has, for which a procedure box has been built by the
debugger.

   The next word specifies the particular port (Call, Exit, Redo, Fail,
or Exception).

   T is a subterm trace.  This is used in conjunction with the '^'
command (set subterm), described below.  If a subterm has been selected,
then T is printed as the sequence of commands used to select the
subterm.  Normally, however, T is printed as ' ', indicating that no
subterm has been selected.

   The goal is then printed so that you can inspect its current
instantiation state.

   The final '?' is the prompt indicating that you should type in one of
the commands allowed (*note Debug Commands::).  If this particular port
is unleashed, then you will not get this prompt since you have specified
that you do not wish to interact at this point.

   At Exception ports, the trace message is preceded by a message about
the pending exception, formatted as if it would arrive uncaught at the
top-level.

   Note that calls that are compiled inline are not traced.

   Block and Unblock ports are exceptions to the above debugger message
format.  A message

            S -  -  Block: p(_133)

indicates that the debugger has encountered a blocked goal, i.e. one
which is temporarily suspended due to insufficiently instantiated
arguments (*note ref-sem-sec::).  By default, no interaction takes place
at this point, and the debugger simply proceeds to the next goal in the
execution stream.  The suspended goal will be eligible for execution
once the blocking condition ceases to exist, at which time a message

            S -  -  Unblock: p(_133)

is printed.  Although Block and Unblock ports are unleashed by default
in trace mode, you can make the debugger interact at these ports by
using conditional spypoints.


File: sicstus.info,  Node: Debug Commands,  Next: Advanced Debugging,  Prev: Debug Format,  Up: Debug Intro

5.5 Commands Available during Debugging
=======================================

This section describes the particular commands that are available when
the system prompts you after printing out a debugging message.  All the
commands are one or two letter mnemonics, among which some can be
optionally followed by an argument.  They are read from the standard
input stream with any blanks being completely ignored up to the end of
the line (<RET>).

   While you are typing commands at a given port, the debugger maintains
a notion of _current frame_ of the ancestor stack.  The "current goal",
referred to by many commands, is the goal of the current frame.  The
current frame is initially at the bottom of the ancestor stack, but can
be moved by certain commands.  If the current frame is above the bottom
of the stack, then the port indicator, displayed in front of the current
goal, is replaced by the word Ancestor.

   The only command that you really have to remember is 'h' (followed by
<RET>).  This provides help in the form of the following list of
available commands.

         RET   creep            c      creep
         l     leap             z      zip
         s     skip             s <i>  skip i
         o     out              o <n>  out n
         q     q-skip           q <i>  q-skip i
         r     retry            r <i>  retry i
         f     fail             f <i>  fail i
         j<p>  jump to port     j<p><i>jump to port i
         d     display          w      write
         p     print            p <n>  print partial
         g     ancestors        g <n>  ancestors n
         t     backtrace        t <n>  backtrace n
         [     frame up         ]      frame down
         [ <i> frame i          ] <i>  frame i
         v     variables        v <i>  variables i
         &     blocked goals    & <n>  nth blocked goal
         n     nodebug          =      debugging
         +     spy this         *      spy conditionally
         -     nospy this       \ <i>  remove brkpoint
         D <i> disable brkpoint E <i>  enable brkpoint
         a     abort            b      break
         @     command          u      unify
         e     raise exception  .      find this
         <     reset printdepth < <n>  set printdepth
         ^     reset subterm    ^ <n>  set subterm
         ?     help             h      help

'c'
'<RET>'
     "creep" causes the debugger to single-step to the very next port
     and print a message.  Then if the port is leashed (*note Basic
     Debug::), then the user is prompted for further interaction.
     Otherwise, it continues creeping.  If leashing is off, then creep
     is the same as "leap" (see below) except that a complete trace is
     printed on the standard error stream.

'l'
     "leap" causes the debugger to resume running your program, only
     stopping when a spypoint is reached (or when the program
     terminates).  Leaping can thus be used to follow the execution at a
     higher level than exhaustive tracing.  All you need to do is to set
     spypoints on an evenly spread set of pertinent predicates, and then
     follow the control flow through these by leaping from one to the
     other.  Debugging information is collected while leaping, so when a
     spypoint is reached, it is possible to inspect the ancestor goals,
     or creep into them upon entry to Redo ports.

'z'
     "zip" is like "leap", except no debugging information is being
     collected while zipping, resulting in significant savings in memory
     and execution time.

's'
     "skip" is only valid for Call and Redo ports.  It skips over the
     entire execution of the predicate.  That is, you will not see
     anything until control comes back to this predicate (at either the
     Exit port or the Fail port).  Skip is particularly useful while
     creeping since it guarantees that control will be returned after
     the (possibly complex) execution within the box.  If you skip, then
     no message at all will appear until control returns.  This includes
     calls to predicates with spypoints set; they will be masked out
     during the skip.  No debugging information is being collected while
     skipping.

     If you supply an integer argument, then this should denote an
     invocation number of an ancestral goal.  The system tries to get
     you to the Exit or Fail port of the invocation box you have
     specified.

'o'
     "out" is a shorthand for skipping to the Exit or Fail port of the
     immediate ancestor goal.  If you supply an integer argument N, then
     it denotes skipping to the Exit or Fail port of the Nth ancestor
     goal.

'q'
     "quasi-skip" is like a combination of "zip" and "skip": execution
     stops when either control comes back to this predicate, or a
     spypoint is reached.  No debugging information is being collected
     while quasi-skipping.

     An integer argument can be supplied as for "skip".

'r'
     "retry" can be used at any port (although at the Call port it has
     no effect).  It transfers control back to the Call port of the box.
     This allows you to restart an invocation when, for example, you
     find yourself leaving with some weird result.  The state of
     execution is exactly the same as when you originally called,
     (unless you use side-effects in your program; i.e. asserts etc.
     will not be undone).  When a retry is performed the invocation
     counter is reset so that counting will continue from the current
     invocation number regardless of what happened before the retry.
     This is in accord with the fact that you have, in executional
     terms, returned to the state before anything else was called.

     If you supply an integer argument, then it should denote an
     invocation number of an ancestral goal.  The system tries to get
     you to the Call port of the box you have specified.  It does this
     by continuously failing until it reaches the right place.
     Unfortunately this process cannot be guaranteed: it may be the case
     that the invocation you are looking for has been cut out of the
     search space by cuts ('!') in your program.  In this case the
     system fails to the latest surviving Call port before the correct
     one.

'f'
     "fail" can be used at any of the four ports (although at the Fail
     port it has no effect).  It transfers control to the Fail port of
     the box, forcing the invocation to fail prematurely.

     If you supply an integer after the command, then it is taken as
     specifying an invocation number and the system tries to get you to
     the Fail port of the invocation box you have specified.  It does
     this by continuously failing until it reaches the right place.
     Unfortunately this process cannot be guaranteed: it may be the case
     that the invocation you are looking for has been cut out of the
     search space by cuts ('!') in your program.  In this case the
     system fails to the latest surviving Fail port before the correct
     one.

'j<p>'
     "jump to port" transfers control back to the prescribed port <P>.
     Here, <P> is one of: 'c', 'e', 'r', 'f', standing for Call, Exit,
     Redo and Fail ports.  Takes an optional integer argument, an
     invocation number.

     Jumping to a Call port is the same as retrying it, i.e. 'jc' is the
     same as the 'r' debugger command; and similarly 'jf' is the same as
     'f'.

     The 'je' "jump to Exit port" command transfers control back to the
     Exit port of the box.  It can be used at a Redo or an Exit port
     (although at the latter it has no effect).  This allows you to
     restart a computation following an Exit port, which you first leapt
     over, but because of its unexpected failure you arrived at the Redo
     port.  If you supply an integer argument, then it should denote an
     _exact_ invocation number of an exited invocation present in the
     backtrace, and then the system will get you to the specified Exit
     port.  The debugger requires here an exact invocation number so
     that it does not jump too far back in the execution (if an Exit
     port is not present in the backtrace, it may be be a better choice
     to jump to the preceding Call port, rather than to continue looking
     for another Exit port).

     The 'jr' "jump to Redo port" command transfers control back to the
     Redo port of the box.  It can be used at an Exit or a Redo port
     (although at the latter it has no effect).  This allows you to
     force the goal in question to try to deliver another solution.  If
     you supply an integer argument, then it should denote an _exact_
     invocation number of an exited invocation present in the backtrace,
     and then the system will get you to the specified Redo port.

'd'
     "display goal" displays the current goal using 'display/1'.  See
     Write (below).

'p'
     "print goal" displays the current goal using 'print/1'.  An
     argument will override the default printdepth, treating 0 as
     infinity.

'w'
     "write goal" displays the current goal using 'writeq/1'.

'g'
     "print ancestor goals" provides you with a list of ancestors to the
     current goal, i.e. all goals that are hierarchically above the
     current goal in the calling sequence.  You can always be sure of
     jumping to the Call or Fail port of any goal in the ancestor list
     (by using retry etc).  If you supply an integer N, then only that
     number of ancestors will be printed.  That is to say, the last N
     ancestors will be printed counting back from the current goal.
     Each entry is displayed just as they would be in a trace message,
     except the current frame is indicated by a '@' in front of the
     invocation number.

't'
     "print backtrace" is the same as the above, but also shows any
     goals that have exited nondeterminately and their ancestors.  This
     information shows where there are outstanding choices that the
     program could backtrack to.  If you supply an integer N, then only
     that number of goals will be printed.

     Ancestors to the current goal are annotated with the 'Call:' port,
     as they have not yet exited, whereas goals that have exited are
     annotated with the 'Exit:' port.  You can always be sure of jumping
     to the Exit or Redo port of any goal shown to be exited in the
     backtrace listing.

     The backtrace is a tree rather than a stack: to find the parent of
     a given goal with depth indicator D, look for the closest goal
     above it with depth indicator D-1.

'[   since release 4.2'
     "frame up": moves the frame up one step.  If you supply an
     argument, then it should denote an invocation number of an existing
     goal.

']   since release 4.2'
     "frame down": moves the frame down one step.  If you supply an
     argument, then it should denote an invocation number of an existing
     goal.

'v   since release 4.2'
     "print variable bindings" endeavors to print the variable bindings
     of the clause containing the current goal.  This is available for
     both compiled and interpreted code, if the source code was
     originally loaded with the 'source_info' Prolog flag switched on.
     The coverage is usually better for compiled code.  If you supply an
     argument, then it should denote an invocation number of an existing
     goal.

     Just like the top-level, the debugger displays variable bindings as
     well as any goals that are blocked on a variable found among those
     bindings, and prompts for the same one-letter commands as the
     top-level does; *note Queries::.  To return to the debugger, simply
     type 'RET'.

'&'
     "print blocked goals" prints a list of the goals that are currently
     blocked in the current debugging session together with the variable
     that each such goal is blocked on (*note ref-sem-sec::).  The goals
     are enumerated from 1 and up.  If you supply an integer N, then
     only that goal will be printed.  Each entry is preceded by the goal
     number followed by the variable name.

'n'
     "nodebug" switches the debugger off.  Note that this is the correct
     way to switch debugging off at a trace point.  You cannot use the
     '@' or 'b' commands because they always return to the debugger.

'='
     "debugging" outputs information concerning the status of the
     debugging package.  See the built-in predicate 'debugging/0'.

'+'
     "spy this" sets a plain spypoint on the current goal.

'*'
     "spy this conditionally" sets a conditional spypoint on the current
     goal.  Prompts for the CONDITIONS, and calls the
          spy(FUNC, CONDITIONS)
     goal, where FUNC is the predicate spec of the current invocation.
     For 'spy/2', *note Breakpoint Predicates::.

'-'
     "nospy this" removes all spypoints applicable to the current goal.
     Equivalent to 'nospy FUNC', where FUNC is the predicate spec of the
     current invocation.

'\'
     "remove this" removes the spypoint that caused the debugger to
     interact at the current port.  With an argument N, it removes the
     breakpoint with identifier N.  Equivalent to
     'remove_breakpoints(BID)', where BID is the current breakpoint
     identifier, or the supplied argument (*note Breakpoint
     Predicates::).

'D'
     "disable this" disables the spypoint that caused the debugger to
     interact at the current port.  With an argument N, it disables the
     breakpoint with identifier N.  Equivalent to
     'disable_breakpoints(BID)', where BID is the current breakpoint
     identifier, or the supplied argument (*note Breakpoint
     Predicates::).

'E'
     "enable this" enables all specific spypoints for the predicate at
     the current port.  With an argument N, it enables the breakpoint
     with identifier N.  Equivalent to 'enable_breakpoints(BID)', where
     BID is the breakpoint identifiers for the current predicate, or the
     supplied argument (*note Breakpoint Predicates::).

'.'
     "find this" outputs information about where the predicate being
     called is defined.

'a'
     "abort" causes an abort of the current execution.  All the
     execution states built so far are destroyed and you are put right
     back at the top-level.  (This is the same as the built-in predicate
     'abort/0'.)

'b'
     "break" calls the built-in predicate 'break/0', thus putting you at
     a recursive top-level with the execution so far sitting underneath
     you.  When you end the break ('^D') you will be reprompted at the
     port at which you broke.  The new execution is completely separate
     from the suspended one; the invocation numbers will start again
     from 1 during the break.  The debugger is temporarily switched off
     as you call the break and will be re-switched on when you finish
     the break and go back to the old execution.  However, any changes
     to the leashing or to spypoints will remain in effect.

'@'
     "command" gives you the ability to call arbitrary Prolog goals.  It
     is effectively a one-off "break" (see above).  The initial message
     '| :- ' will be output on the standard error stream, and a command
     is then read from the standard input stream and executed as if you
     were at top-level.  If the term read is of form 'PATTERN ^ BODY',
     then PATTERN is unified with the current goal and BODY is executed.
     *Please note*:
       1. If BODY is compound, then it should be parenthesized.
       2. If the current goal has a module qualifier, then PATTERN
          should not include the module qualifier.

'u'
     "unify" is available at the Call port and gives you the option of
     providing a solution to the goal from the standard input stream
     rather than executing the goal.  This is convenient e.g. for
     providing a "stub" for a predicate that has not yet been written.
     A prompt will be output on the standard error stream, and the
     solution is then read from the standard input stream and unified
     with the goal.  If the term read in is of the form 'HEAD :- BODY',
     then HEAD will be unified with the current goal, and BODY will be
     executed in its place.

'e'
     "raise exception" is available at all ports.  A prompt will be
     output on the standard error stream, and an exception term is then
     read from the standard input stream and raised in the program being
     debugged.

'<'
     This command, without arguments, resets the printdepth to 10.  With
     an argument of N, the printdepth is set to N, treating 0 as
     infinity.  This command works by changing the value of the
     'debugger_print_options' Prolog flag.

'^'
     While at a particular port, a current "subterm" of the current goal
     is maintained.  It is the current subterm that is displayed,
     printed, or written when prompting for a debugger command.  Used in
     combination with the printdepth, this provides a means for
     navigating in the current goal for focusing on the part of
     interest.  The current subterm is set to the current goal when
     arriving at a new port.  This command, without arguments, resets
     the current subterm to the current goal.  With an argument of N (>
     0), the current subterm is replaced by its N:th subterm.  With an
     argument of 0, the current subterm is replaced by its parent term.
     With multiple arguments separated by whitespace, the arguments are
     applied from left to right.

'?'
'h'
     "help" displays the table of commands given above.

   The user can define new debugger commands or modify the behavior of
the above ones using the 'user:debugger_command_hook/2' hook predicate,
*note Breakpoint Predicates::.


File: sicstus.info,  Node: Advanced Debugging,  Next: Breakpoint Predicates,  Prev: Debug Commands,  Up: Debug Intro

5.6 Advanced Debugging -- an Introduction
=========================================

This section gives an overview of the advanced debugger features.  These
center around the notion of breakpoint.  Breakpoints can be classified
as either spypoints (a generalization of the plain spypoint introduced
earlier) or advice-points (e.g. for checking program invariants
independently from tracing).  The first five subsections will deal with
spypoints only.  Nevertheless we will use the term breakpoint, whenever
a statement is made that applies to both spypoints and advice-points.

   *note Breakpoint Processing:: describes the breakpoint processing
mechanism in full detail.  Reference style details of built-in
predicates dealing with breakpoints are given in *note Breakpoint
Predicates:: and in *note Breakpoint Conditions::.

* Menu:

* Creating Breakpoints:: Creating Breakpoints
* Processing Breakpoints:: Processing Breakpoints
* Breakpoint Tests:: Breakpoint Tests
* Specific and Generic Breakpoints:: Specific and Generic Breakpoints
* Breakpoint Actions:: Breakpoint Actions
* Advice-points:: Advice-points
* Built-in Predicates for Breakpoint Handling:: Built-in Predicates for Breakpoint Handling
* Accessing Past Debugger States:: Accessing Past Debugger States
* Storing User Information  in the Backtrace:: Storing User Information  in the Backtrace
* Hooks Related to Breakpoints:: Hooks Related to Breakpoints
* Programming Breakpoints:: Programming Breakpoints


File: sicstus.info,  Node: Creating Breakpoints,  Next: Processing Breakpoints,  Up: Advanced Debugging

5.6.1 Creating Breakpoints
--------------------------

Breakpoints can be created using the 'add_breakpoint/2' built-in
predicate.  Its first argument should contain the description of the
breakpoint, the so called "breakpoint spec".  It will return the
"breakpoint identifier" (BID) of the created breakpoint in its second
argument.  For example:

     | ?- add_breakpoint(pred(foo/2), BID).
     % Plain spypoint for user:foo/2 added, BID=1
     BID = 1

   Here, we have a simple breakpoint spec, prescribing that the debugger
should stop at all ports of all invocations of the predicate 'foo/2'.
Thus the above goal actually creates a _plain spypoint_, exactly as '?-
spy foo/2.' does.

   A slightly more complicated example follows:

     | ?- add_breakpoint([pred(foo/2),line('/myhome/bar.pl',123)], _).
     % Conditional spypoint for user:foo/2 added, BID=1

   This breakpoint will be activated only for those calls of 'foo/2'
that occur in line 123 of the Prolog program file ''/myhome/bar.pl''.
Because of the additional condition, this is called a _conditional
spypoint_.

   The breakpoint identifier (BID) returned by 'add_breakpoint/2' is an
integer, assigned in increasing order, i.e. more recent breakpoints
receive higher identifier values.  When looking for applicable
breakpoints, the debugger tries the breakpoints in descending order of
BIDs, i.e. the most recent applicable breakpoint is used.  Breakpoint
identifiers can be used for referring to breakpoints to be deleted,
disabled or enabled (see later).

   Generally, the breakpoint spec is a pair 'TESTS-ACTIONS'.  Here, the
TESTS part describes the conditions under which the breakpoint should be
activated, while the ACTIONS part contains instructions on what should
be done at activation.  The test part is built from tests, while the
action part from actions and tests.  Test, actions and composite
constructs built from these are generally referred to as "breakpoint
conditions", or simply conditions.

   The action part can be omitted, and then the breakpoint spec consists
of tests only.  For spypoints, the default action part is
'[show(print),command(ask)]'.  This instructs the debugger to print the
goal in question and then ask the user what to do next, exactly as
described in *note Debug Format::.  To illustrate other possibilities
let us explain the effect of the '[show(display),command(proceed)]'
action part: this will use 'display/1' for presenting the goal (just as
the 'd' debugger command does, *note Debug Commands::), and will then
proceed with execution without stopping (i.e. the spypoint is
unleashed).


File: sicstus.info,  Node: Processing Breakpoints,  Next: Breakpoint Tests,  Prev: Creating Breakpoints,  Up: Advanced Debugging

5.6.2 Processing Breakpoints
----------------------------

We first give a somewhat simplified sketch of how the debugger treats
the breakpoints.  This description will be refined in the sequel.

   The debugger allows us to prescribe some activities to be performed
at certain points of execution, namely at the ports of procedure boxes.
In principle, the debugger is entered at each port of each procedure
invocation.  It then considers the current breakpoints one by one, most
recent first.  The first breakpoint for which the evaluation of the test
part succeeds is then activated, and the execution continues according
to its action part.  The activated breakpoint "hides" the remaining
(older) ones, i.e. those are not tried here.  If none of the current
breakpoints is activated, then the debugger behaves according to the
actual debugging mode (trace, debug or zip).

   Both the test and the action part can be simple or composite.
Evaluating a simple test amounts to checking whether it holds in the
current state of execution, e.g. 'pred(foo/2)' holds if the debugger is
at a port of predicate 'foo/2'.

   Composite conditions can be built from simple ones by forming lists,
or using the ',', ';', '->', and '\+' operators, with the usual meaning
of conjunction, disjunction, if-then-else and negation.  A list of
conditions is equivalent to a conjunction of the same conditions.  For
example, the condition '[pred(foo/2), \+port(fail)]' will hold for all
ports of 'foo/2', except for the Fail port.


File: sicstus.info,  Node: Breakpoint Tests,  Next: Specific and Generic Breakpoints,  Prev: Processing Breakpoints,  Up: Advanced Debugging

5.6.3 Breakpoint Tests
----------------------

This section gives a tour of the most important simple breakpoint tests.
In all examples here the action part will be empty.  Note that the
examples are independent, so if you want to try out these, then you
should get rid of the old breakpoints (e.g. using '?- nospyall.') before
you enter a new one.

   The 'goal(...)' test is a generalization of the 'pred(...)' test, as
it allows us to check the arguments of the invocation.  For example:

     | ?- add_breakpoint(goal(foo(1,_)), _).
     % Conditional spypoint for user:foo/2 added, BID=1

   The 'goal(G)' breakpoint test specifies that the breakpoint should be
applied only if the current goal is an instance of 'G', i.e. 'G' and the
current goal can be unified without substituting any variables in the
latter.  This unification is then carried out.  The 'goal(G)' condition
is thus equivalent to the 'subsumes(G,CURRENTGOAL)' test ('subsumes/2'
is defined in 'library(terms)', *note lib-terms::).

   In the above example the debugger will stop if 'foo/2' is called with
'1' as its first argument, but not if the first argument is, say, '2',
nor if it is a variable.

   You can use non-anonymous variables in the 'goal' test, and then put
further constraints on these variables using the 'true' condition:

     | ?- add_breakpoint([goal(foo(X,_)),true(X>1)], _).
     % Conditional spypoint for user:foo/2 added, BID=1

   Here the first test, 'goal', specifies that we are only interested in
invocations of 'foo/2', and names the first argument of the goal as 'X'.
The second, the 'true/1' test, specifies a further condition stated as a
Prolog goal: 'X' is greater than '1' (we assume here that the argument
is numeric).  Thus this breakpoint will be applicable if and only if the
first argument of 'foo/2' is _greater_ than '1'.  Generally, an
arbitrary Prolog goal can be placed inside the 'true' test: the test
will succeed if and only if the goal completes successfully.

   Any variable instantiations in the test part will be undone before
executing the action part, as the evaluation of the test part is
enclosed in a double negation ('\+ \+ (...)').  This ensures that the
test part has no effect on the variables of the current goal.

   Both the 'pred' and the 'goal' tests may include a module name.  In
fact, the first argument of 'add_breakpoint' is module name expanded,
and the (explicit or implicit) module name of this argument is then
inherited by default by the 'pred', 'goal', and 'true' tests.  Notice
the module qualification inserted in front of the breakpoint spec of the
last example, as shown in the output of the 'debugging/0' built-in
predicate:

     | ?- debugging.
     (...)
     Breakpoints:
           1 *  user:foo/2 if user:[goal(foo(A,B)),true(A>1)]

   As no explicit module qualifications were given in the tests, this
breakpoint spec is transformed to the following form:

     [goal(user:foo(A,B)),true(user:(A>1))]

   For exported predicates, a 'pred' or 'goal' test will be found
applicable for all invocations of the predicate, irrespective of the
module the call occurs in.  When you add the breakpoint you can use the
defining or an importing module name, but this information is not
remembered: the module name is "normalized", i.e. it is changed to the
defining module.  The example below shows this: although the spypoint is
placed on 'user:append', the message and the breakpoint list both
mention 'lists:append'.

     | ?- use_module(library(lists)).
     (...)
     % module lists imported into user
     (...)
     | ?- spy user:append.
     % Plain spypoint for lists:append/3 added, BID=1
     | ?- debugging.
     (...)
     Breakpoints:
           1 +  lists:append/3

   Note that the debugger does not stop inside a library predicate when
doing an exhaustive trace.  This is because the library modules are
declared hidden (*note ref-mod::), and no trace is produced for calls
inside hidden modules that invoke predicates defined in hidden modules.
However, a spypoint is always shown in the trace, even if it occurs in a
hidden module:

      +      1      1 Call: append([1,2],[3,4],_531) ? <RET>
      +      2      2 Call: lists:append([2],[3,4],_1182) ? <RET>
      +      3      3 Call: lists:append([],[3,4],_1670) ? <RET>
      +      3      3 Exit: lists:append([],[3,4],[3,4]) ? <RET>
     (...)

   You can narrow a breakpoint to calls from within a particular module
by using the 'module' test, e.g.

     | ?- add_breakpoint([pred(append/3),module(user)], _).
     % The debugger will first zip -- showing spypoints (zip)
     % Conditional spypoint for lists:append/3 added, BID=1
     % zip
     | ?- append([1,2], [3,4], L).
      *      1      1 Call: append([1,2],[3,4],_531) ? <RET>
      *      1      1 Exit: append([1,2],[3,4],[1,2,3,4]) ? <RET>
     L = [1,2,3,4]

   With this spypoint, the debugger will only stop at the invocations of
'append/3' from the 'user' module.

   Note that calling module information is not kept by the compiler for
the built-in predicates, therefore the 'module' test will always unify
its argument with 'prolog' in case of compiled calls to built-in
predicates.

   There are two further interesting breakpoint tests related to
invocations: 'inv(Inv)' and 'depth(Depth)'.  These unify their arguments
with the invocation number and the depth, respectively (the two numbers
shown at the beginning of each trace message).  Such tests are most
often used in more complex breakpoints, but there may be some simple
cases when they are useful.

   Assume you put a plain spypoint on 'foo/2', and start leaping through
your program.  After some time, you notice some inconsistency at an Exit
port, but you cannot go back to the Call port for retrying this
invocation, because of side-effects.  So you would like to restart the
whole top-level goal and get back to the Call port of the suspicious
goal as fast as possible.  Here is what you can do:

     | ?- spy foo/2.
     % Plain spypoint for user:foo/2 added, BID=1
     | ?- debug, foo(23, X).
     % The debugger will first leap -- showing spypoints (debug)
      +      1      1 Call: foo(23,_414) ? l
     (...)
      +     81     17 Call: foo(7,_9151) ? l
      +     86     18 Call: foo(6,_9651) ? l
      +     86     18 Exit: foo(6,8) ? -
     % Plain spypoint for user:foo/2, BID=1, removed (last)
            86     18 Exit: foo(6,8) ? *
     Placing spypoint on user:foo/2 with conditions: inv(86).
     % Conditional spypoint for user:foo/2 added, BID=1
      *     86     18 Exit: foo(6,8) ? a
     % Execution aborted
     % source_info
     | ?- debug, foo(23, X).
     % The debugger will first leap -- showing spypoints (debug)
      *     86     18 Call: foo(6,_2480) ? <RET>

   When you reach the Exit port of the suspicious invocation (number
86), you remove the plain spypoint (via the '-' debugger command), and
add a conditional one using the '*' debugger command.  This
automatically includes 'pred(foo/2)' among the conditions and displays
the prompt 'Placing spypoint ... with conditions:', requesting further
ones.  You enter here the 'inv' test with the invocation number in
question, resulting in a breakpoint with the '[pred(foo/2),inv(86)]'
conditions.  If you restart the original top-level goal in debug mode,
then the debugger immediately positions you at the invocation with the
specified number.

   Note that when the debugger executes a "skip" or a "zip" command, no
procedure boxes are built.  Consequently, the invocation and depth
counters are not incremented.  If "skip" and/or "zip" commands were used
during the first execution, then the suspicious invocation gets an
invocation number higher than 86 in the second run.  Therefore it is
better to supply the 'inv(I),true(I>=86)' condition to the '*' debugger
command, which will bring you to the first call of 'foo/2' at, or after
invocation number 86 (which still might not be the suspicious
invocation).

   In the examples, the 'inv' test was used both with a numeric and a
variable argument ('inv(86)' and 'inv(I)').  This is possible because
the debugger _unifies_ the given feature with the argument of the test.
This holds for most tests, we will mention the exceptions.

   Another similar example: if you suspect that a given predicate goes
into an infinite recursion, and would like the execution to stop when
entering this predicate somewhere inside the recursion, then you can do
the following:

     | ?- add_breakpoint([pred(foo/2),depth(_D),true(_D>=100)], _).
     % Conditional spypoint for user:foo/2 added, BID=1
     % zip,source_info
     | ?- debug, foo(200, X).
     % The debugger will first leap -- showing spypoints (debug)
      *    496    100 Call: foo(101,_12156) ?

   The above breakpoint spec will cause the debugger to stop at the
first invocation of 'foo/2' at depth 100 or greater.  Note again that
debug mode has to be entered for this to work (in zip mode no debugging
information is kept, so the depth does not change).

   We now continue with tests that restrict the breakpoint to an
invocation at a specific place in the code.

   Assume file '/home/bob/myprog.pl' contains the following Prolog
program:

                                                _% /home/bob/myprog.pl_
     p(X, U) :-                               % line 1
             q(X, Y),                         % line 2
             q(Y, Z),                         % line 3
             (   \+ q(Z, _)                   % line 4
             ->  q(Z+1, U)                    % line 5
             ;   q(Z+2, U)                    % line 6
             ).                               % ...

     q(X, Y) :-
             X < 10, !, Y is X+1.             % line 10
     q(X, Y) :-
             Y is X+2.                        % line 12

   If you are interested only in the last invocation of 'q/2' within
'p/2', then you can use the following breakpoint:

     | ?- add_breakpoint([pred(q/2),line('/home/bob/myprog.pl',6)], _).
     % Conditional spypoint for user:q/2 added, BID=1

   Generally, the test 'line(File,Line)' holds if the current invocation
was in line number 'Line' of a file whose absolute name is 'File'.  This
test (as well as the 'line/1' and 'file/1' tests; see below) require the
presence of source information: the file in question had to be consulted
or compiled with the 'source_info' Prolog flag switched on (i.e. set to
'on' or 'emacs').

   If e.g. 'q/2' is called only from a single file, then the file name
need not be mentioned and a 'line/1' test suffices: 'line(6)'.  On the
other hand, if we are interested in all invocations of a predicate
within a file, then we can omit the line number and use the 'file(File)'
test.

   For Prolog programs that are interpreted (consulted or asserted),
further positioning information can be obtained, even in the absence of
source information.  The test 'parent_pred(Pred)' unifies the module
name expanded 'Pred' with a predicate spec (of form
'MODULE:PREDNAME/ARITY') identifying the predicate in which the current
invocation resides.  The test 'parent_pred(Pred,N)' will additionally
unify 'N' with the serial number of the clause containing the current
goal.

   For example, assuming the above 'myprog.pl' file is consulted, the
breakpoint below will cause the execution to stop when the call of
'is/2' in the second clause of 'q/2' is reached:

     | ?- add_breakpoint([pred(is/2),parent_pred(q/2,2)], _).
     % Conditional spypoint for prolog:is/2 added, BID=1
     * Predicate prolog:is/2 compiled inline, breakable only in interpreted code
     % zip,source_info
     | ?- p(20, X).
     in scope of a goal at line 12 in /home/bob/myprog.pl
      *      1      1 Call: _579 is 20+2 ?

   Notice the warning issued by 'add_breakpoint/2': there are some
built-in predicates (e.g. arithmetic, 'functor/3', 'arg/3', etc.), for
which the compiler generates specific inline translation, rather than
the generic predicate invocation code.  Therefore compiled calls to such
predicates are not visible to the debugger.

   More exact positioning information can be obtained for interpreted
programs by using the 'parent_clause(Cl,Sel,I)' test.  This unifies 'Cl'
with the clause containing the current invocation, while 'Sel' and 'I'
both identify the current invocation within the body of this clause.
'Sel' is unified with a "subterm selector", while 'I' with the serial
number of the call.  This test has the variants 'parent_clause/[1,2]',
in which only the 'Cl' argument, or the 'Cl,Sel' arguments are present.

   As an example, two further alternatives of putting a breakpoint on
the last call of 'q/2' within 'myprog.pl' (line 6) are shown below,
together with a listing showing the selectors and call serial numbers
for the body of 'p/2':

     | ?- add_breakpoint([pred(q/2),parent_clause((p(_,_):-_),[2,2,2])],_).

     | ?- add_breakpoint([pred(q/2),parent_clause((p(_,_):-_),_,5)],_).

     p(X, U) :-                 % line  % call no.  % subterm selector
             q(X, Y),           %  2        1       [1]
             q(Y, Z),           %  3        2       [2,1]
             (   \+ q(Z, _)     %  4        3       [2,2,1,1,1]
             ->  q(Z+1, U)      %  5        4       [2,2,1,2]
             ;   q(Z+2, U)      %  6        5       [2,2,2]
             ).                 %  7

   Here, the first argument of the 'parent_clause' test ensures that the
current invocation is in (the only clause of) 'p/2'.  If 'p/2' had more
clauses, then we would have to use an additional test, say
'parent_pred(user:p/2,1)', and then the first argument of
'parent_clause' could be an anonymous variable.

   In the examples so far the breakpoint tests referred only to the goal
in question.  Therefore, the breakpoint was found applicable at all
ports of the procedure box of the predicate.  We can distinguish between
ports using the 'port' breakpoint test:

     | ?- add_breakpoint([pred(foo/2),port(call)], _).

   With this breakpoint, the debugger will stop at the Call port of
'foo/2', but not at other ports.  Note that the 'port(call)' test can be
simplified to 'call' -- 'add_breakpoint/2' will recognize this as a port
name, and treat it as if it were enclosed in a 'port/1' functor.

   Here are two equivalent formulations for a breakpoint that will cause
the debugger to stop only at the Call and Exit ports of 'foo/2':

     | ?- add_breakpoint([pred(foo/2),(call;exit)], _).

     | ?- add_breakpoint([pred(foo/2),port(P),true((P=call;P=exit(_)))], _).

   In both cases we have to use disjunction.  In the first example we
have a disjunctive breakpoint condition of the two simple tests
'port(call)' and 'port(exit)' (with the 'port' functor omitted).  In the
second case the disjunction is inside the Prolog test within the 'true'
test.

   Notice that the two examples refer to the Exit port differently.
When you use 'port(P)', where 'P' is a variable, then, at an exit port,
'P' will be unified with either 'exit(nondet)' or 'exit(det)', depending
on the determinacy of the exited predicate.  However, for convenience,
the test 'port(exit)' will also succeed at Exit ports.  So in the first
example above, 'exit' can be replaced by 'exit(_)', but the 'exit(_)' in
the second cannot be replaced by 'exit'.

   Finally, there is a subtle point to note with respect to activating
the debugger at non Call ports.  Let us look at the following
breakpoint:

     | ?- add_breakpoint([pred(foo/2),fail], _).

   The intention here is to have the debugger stop at only the Fail port
of 'foo/2'.  This is very useful if 'foo/2' is not supposed to fail, but
we suspect that it does.  The above breakpoint will behave as expected
when the debugger is leaping, but not while zipping.  This is because
for the debugger to be able to stop at a non Call port, a procedure box
has to be built at the Call port of the given invocation.  However, no
debugging information is collected in zip mode by default, i.e.
procedure boxes are not built.  Later we will show how to achieve the
required effect, even in zip mode.


File: sicstus.info,  Node: Specific and Generic Breakpoints,  Next: Breakpoint Actions,  Prev: Breakpoint Tests,  Up: Advanced Debugging

5.6.4 Specific and Generic Breakpoints
--------------------------------------

In all the examples so far a breakpoint was put on a specific predicate,
described by a 'goal' or 'pred' test.  Such breakpoints are called
"specific", as opposed to "generic" ones.

   Generic breakpoints are the ones that do not specify a concrete
predicate.  This can happen when the breakpoint spec does not contain
'goal' or 'pred' tests at all, or their argument is not sufficiently
instantiated.  Here are some examples of generic breakpoints:

     | ?- add_breakpoint(line('/home/bob/myprog.pl',6), _).
     % Generic spypoint added, BID=1
     | ?- add_breakpoint(pred(foo/_), _).
     % Generic spypoint added, BID=2
     | ?- add_breakpoint([goal(G),true((arg(1,G,X),X==bar))], _).
     % Generic spypoint added, BID=3

   The first breakpoint will stop at all calls in line 6 of the given
file, the second at all calls of a predicate 'foo', irrespective of the
number of arguments, while the third one will stop at any predicate with
'bar' as its first argument.  However, there is an additional implicit
condition: the module name expansion inserts the type-in module as the
default module name in the 'goal' and 'pred' conditions.  Consequently,
the second and third breakpoint applies only to predicates in the
type-in module ('user' by default).  If you would like the breakpoint to
cover all modules, then you have to include an anonymous module prefix
in the argument of the 'goal' or 'pred' test:

     | ?- add_breakpoint(pred(_:foo/_), _).
     % Generic spypoint added, BID=1
     % zip
     | ?- add_breakpoint([goal(_:G),true((arg(1,G,X),X==bar))], _).
     % Generic spypoint added, BID=2

   Generic breakpoints are very powerful, but there is a price to pay:
the zip mode is slowed down considerably.

   As said earlier, in principle the debugger is entered at each port of
each procedure invocation.  As an optimization, the debugger can request
the underlying Prolog engine to run at full speed and invoke the
debugger only when one of the specified predicates is called.  This
optimization is used in zip mode, provided there are no generic
breakpoints.  In the presence of generic breakpoints, however, the
debugger has to be entered at each call, to check their applicability.
Consequently, with generic breakpoints, zip mode execution will not give
much speed-up over debug mode, although its space requirements will
still be much lower.

   It is therefore advisable to give preference to specific breakpoints
over generic ones, whenever possible.  For example, if your program
includes predicates 'foo/2' and 'foo/3', then it is much better to
create two specific breakpoints, rather than a single generic one with
conditions '[pred(foo/_),...]'.

   'spy/2' is a built-in predicate that will create specific breakpoints
only.  Its first argument is a generalized predicate spec, much like in
'spy/1', and the second argument is a breakpoint spec.  'spy/2' will
expand the first argument to one or more predicate specs, and for each
of these will create a breakpoint, with a 'pred' condition added to the
_test_ part of the supplied breakpoint spec.  For example, in the
presence of predicates 'foo/2' and 'foo/3'

     | ?- spy(foo/_, file(...))

is equivalent to:

     | ?- add_breakpoint([pred(foo/2),file(...)], _),
          add_breakpoint([pred(foo/3),file(...)], _).

   Note that with 'spy/[1,2]' it is not possible to put a breakpoint on
a (yet) undefined predicate.  On the other hand, 'add_breakpoint/2' is
perfectly capable of creating such breakpoints, but warns about them.

