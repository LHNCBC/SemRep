This is sicstus.info, produced by makeinfo version 5.2 from
sicstus.texi.

INFO-DIR-SECTION SICStus Prolog
START-INFO-DIR-ENTRY
* SICStus Prolog Manual: (sicstus).			SICStus Prolog User's Manual.
END-INFO-DIR-ENTRY

Generated March 15, 2018.


File: sicstus.info,  Node: CLPQR Why Disequations,  Next: CLPQR Monash Examples,  Prev: CLPQR Projection,  Up: lib-clpqr

10.11.6 Why Disequations
------------------------

A beautiful example of disequations at work is due to [Colmerauer 90].
It addresses the task of tiling a rectangle with squares of
all-different, a priori unknown sizes.  Here is a translation of the
original 'Prolog-III' program to clp(Q,R):
                                  _% library('clpqr/examples/squares')_
     filled_rectangle(A, C) :-
       { A >= 1 },
       distinct_squares(C),
       filled_zone([-1,A,1], _, C, []).

     distinct_squares([]).
     distinct_squares([B|C]) :-
       { B > 0 },
       outof(C, B),
       distinct_squares(C).

     outof([],     _).
     outof([B1|C], B) :-
       { B =\= B1 },       % *** note disequation ***
       outof(C, B).

     filled_zone([V|L], [W|L], C0, C0) :-
       { V=W,V >= 0 }.
     filled_zone([V|L], L3, [B|C], C2) :-
       { V < 0 },
       placed_square(B, L, L1),
       filled_zone(L1, L2, C, C1),
       { Vb=V+B },
       filled_zone([Vb,B|L2], L3, C1, C2).

     placed_square(B, [H,H0,H1|L], L1) :-
       { B > H, H0=0, H2=H+H1 },
       placed_square(B, [H2|L], L1).
     placed_square(B, [B,V|L], [X|L]) :-
       { X=V-B }.
     placed_square(B, [H|L], [X,Y|L]) :-
       { B < H, X= -B, Y=H-B }.
   There are no tilings with less than nine squares except the trivial
one where the rectangle equals the only square.  There are eight
solutions for nine squares.  Six further solutions are rotations of the
first two.
     clp(q) ?- [library('clpqr/examples/squares')].
     clp(q) ?- filled_rectangle(A, Squares).

     A = 1,
     Squares = [1] ? ;

     A = 33/32,
     Squares = [15/32,9/16,1/4,7/32,1/8,7/16,1/32,5/16,9/32] ? ;

     A = 69/61,
     Squares = [33/61,36/61,28/61,5/61,2/61,9/61,25/61,7/61,16/61] ? <RET>
Depending on your hardware, the above query may take a few minutes.
Supplying the knowledge about the minimal number of squares beforehand
cuts the computation time by a factor of roughly four:
     clp(q) ?- length(Squares, 9), filled_rectangle(A, Squares).

     A = 33/32,
     Squares = [15/32,9/16,1/4,7/32,1/8,7/16,1/32,5/16,9/32] ? ;

     A = 69/61,
     Squares = [33/61,36/61,28/61,5/61,2/61,9/61,25/61,7/61,16/61] ? <RET>


File: sicstus.info,  Node: CLPQR Monash Examples,  Next: CLPQR MIP,  Prev: CLPQR Why Disequations,  Up: lib-clpqr

10.11.7 Monash Examples
-----------------------

This collection of examples has been distributed with the Monash
University Version of clp(R) [Heintze et al.  87], and its inclusion
into this distribution was kindly permitted by Roland Yap.

   Assuming you are using clp(R):
     clp(r) ?- [library('clpqr/examples/monash/rkf45')].

     clp(r) ?- go.
     Point    0.00000 :    0.75000    0.00000
     Point    0.50000 :    0.61969    0.47793
     Point    1.00000 :    0.29417    0.81233
     Point    1.50000 :   -0.10556    0.95809
     Point    2.00000 :   -0.49076    0.93977
     Point    2.50000 :   -0.81440    0.79929
     Point    3.00000 :   -1.05440    0.57522

     Iteration finished
     ------------------
      439  derivative evaluations


File: sicstus.info,  Node: CLPQR MIP,  Next: CLPQR Implementation Architecture,  Prev: CLPQR Monash Examples,  Up: lib-clpqr

10.11.8 A Mixed Integer Linear Optimization Example
---------------------------------------------------

The predicates 'bb_inf/[3,5]' implement a simple Branch and Bound search
algorithm for Mixed Integer Linear (MIP) Optimization examples.  Serious
MIP is not trivial.  The implementation 'library('clpqr/bb.pl')' is to
be understood as a starting point for more ambitious users who need
control over branching, or who want to add cutting planes, for example.

   Anyway, here is a small problem from miplib, a collection of MIP
models, housed at Rice University:
     NAME:         flugpl
     ROWS:         18
     COLUMNS:      18
     INTEGER:      11
     NONZERO:      46
     BEST SOLN:    1201500 (opt)
     LP SOLN:      1167185.73
     SOURCE:       Harvey M. Wagner
                   John W. Gregory (Cray Research)
                   E. Andrew Boyd (Rice University)
     APPLICATION:  airline model
     COMMENTS:     no integer variables are binary

                                      _% library('clpqr/examples/mip')_
     example(flugpl, Obj, Vs, Ints, []) :-
       Vs = [ Anm1,Anm2,Anm3,Anm4,Anm5,Anm6,
              Stm1,Stm2,Stm3,Stm4,Stm5,Stm6,
              UE1,UE2,UE3,UE4,UE5,UE6],
       Ints = [Stm6, Stm5, Stm4, Stm3, Stm2,
               Anm6, Anm5, Anm4, Anm3, Anm2, Anm1],

       Obj =    2700*Stm1 + 1500*Anm1 + 30*UE1
              + 2700*Stm2 + 1500*Anm2 + 30*UE2
              + 2700*Stm3 + 1500*Anm3 + 30*UE3
              + 2700*Stm4 + 1500*Anm4 + 30*UE4
              + 2700*Stm5 + 1500*Anm5 + 30*UE5
              + 2700*Stm6 + 1500*Anm6 + 30*UE6,

       allpos(Vs),
       {  Stm1 = 60, 0.9*Stm1 +1*Anm1 -1*Stm2 = 0,
          0.9*Stm2 +1*Anm2 -1*Stm3 = 0, 0.9*Stm3 +1*Anm3 -1*Stm4 = 0,
          0.9*Stm4 +1*Anm4 -1*Stm5 = 0, 0.9*Stm5 +1*Anm5 -1*Stm6 = 0,
          150*Stm1 -100*Anm1 +1*UE1 >= 8000,
          150*Stm2 -100*Anm2 +1*UE2 >= 9000,
          150*Stm3 -100*Anm3 +1*UE3 >= 8000,
          150*Stm4 -100*Anm4 +1*UE4 >= 10000,
          150*Stm5 -100*Anm5 +1*UE5 >= 9000,
          150*Stm6 -100*Anm6 +1*UE6 >= 12000,
          -20*Stm1 +1*UE1 =< 0, -20*Stm2 +1*UE2 =< 0, -20*Stm3 +1*UE3 =< 0,
          -20*Stm4 +1*UE4 =< 0, -20*Stm5 +1*UE5 =< 0, -20*Stm6 +1*UE6 =< 0,
          Anm1 =< 18, 57 =< Stm2, Stm2 =< 75, Anm2 =< 18,
          57 =< Stm3, Stm3 =< 75, Anm3 =< 18, 57 =< Stm4,
          Stm4 =< 75, Anm4 =< 18, 57 =< Stm5, Stm5 =< 75,
          Anm5 =< 18, 57 =< Stm6, Stm6 =< 75, Anm6 =< 18
        }.

       allpos([]).
       allpos([X|Xs]) :- {X >= 0}, allpos(Xs).

   We can first check whether the relaxed problem has indeed the quoted
infimum:
     clp(r) ?- example(flugpl, Obj, _, _, _), inf(Obj, Inf).

     Inf = 1167185.7255923203

   Computing the infimum under the additional constraints that 'Stm6',
'Stm5', 'Stm4', 'Stm3', 'Stm2', 'Anm6', 'Anm5', 'Anm4', 'Anm3', 'Anm2',
'Anm1' assume integer values at the infimum is computationally harder,
but the query does not change much:
     clp(r) ?- example(flugpl, Obj, _, Ints, _),
               bb_inf(Ints, Obj, Inf, Vertex, 0.001).

     Inf = 1201500.0000000005,
     Vertex = [75.0,70.0,70.0,60.0,60.0,0.0,12.0,7.0,16.0,6.0,6.0]


File: sicstus.info,  Node: CLPQR Implementation Architecture,  Prev: CLPQR MIP,  Up: lib-clpqr

10.11.9 Implementation Architecture
-----------------------------------

The system consists roughly of the following components:
   * A polynomial normal form expression simplification mechanism.
   * A solver for linear equations [Holzbaur 92a].
   * A simplex algorithm to decide linear inequalities [Holzbaur 94].

* Menu:

* CLPQR Fragments and Bits:: Fragments and Bits
* CLPQR Bugs:: Bugs


File: sicstus.info,  Node: CLPQR Fragments and Bits,  Next: CLPQR Bugs,  Up: CLPQR Implementation Architecture

10.11.9.1 Fragments and Bits
............................

_Rationals._  The internal data structure for rational numbers is
'rat(NUM,DEN)'.  DEN is always positive, i.e. the sign of the rational
number is the sign of NUM.  Further, NUM and DEN are relative prime.
Note that integer N looks like 'rat(N,1)' in this representation.  You
can control printing of terms with 'user:portray/1'.

   _Partial Evaluation, Compilation._  Once one has a working solver, it
is obvious and attractive to run the constraints in a clause definition
at read time or compile time and proceed with the answer constraints in
place of the original constraints.  This gets you constant folding and
in fact the full algebraic power of the solver applied to the avoidance
of computations at runtime.  The mechanism to realize this idea is to
use 'dump/3' for the expansion of '{}/1', via the goal and term
expansion hook predicates.

   _Asserting with Constraints._  If you use the database, then the
clauses you assert might have constraints associated with their
variables.  You should use 'projecting_assert/1' instead of 'assert/1'
in order to ensure that only the relevant and projected constraints get
stored in the database.

     | ?- {A+B=<33}, projecting_assert(test(A,B)).

     {A+B=<33}

     | ?- listing(test).
     test(A, B) :-
             {A+B=<rat(33,1)}

     | ?- test(A,B).

     {A+B=<33}


File: sicstus.info,  Node: CLPQR Bugs,  Prev: CLPQR Fragments and Bits,  Up: CLPQR Implementation Architecture

10.11.9.2 Bugs
..............

   * The fuzzy comparison of floats is the source for all sorts of
     weirdness.  If a result in R surprises you, then try to run the
     program in Q before you send me a bug report.

   * The projector for floundered nonlinear relations keeps too many
     variables.  Its output is rather unreadable.

   * Disequations are not projected properly.

   * This list is probably incomplete.


File: sicstus.info,  Node: lib-codesio,  Next: lib-csv,  Prev: lib-clpqr,  Up: The Prolog Library

10.12 I/O on Lists of Character Codes--'library(codesio)'
=========================================================

This package defines I/O predicates that read from, or write to, a
code-list.  There are also predicates to open a stream referring to a
code-list.  The stream may be used with general Stream I/O predicates.

   Exported predicates:

'format_to_codes(+FORMAT, :ARGUMENTS, -CODES)'
'format_to_codes(+FORMAT, :ARGUMENTS, ?S0, ?S)'

     Prints ARGUMENTS into a code-list using 'format/3'.  CODES is
     unified with the list, alternatively S0 and S are unified with the
     list and its end, respectively.
'write_to_codes(+TERM, -CODES)'
'write_to_codes(+TERM, ?S0, ?S)'

     A specialized 'format_to_codes/[3,4]'.  Writes TERM into a
     code-list using 'write/2'.  CODES is unified with the list.
     Alternatively, S0 and S are unified with the list and its end,
     respectively.
'write_term_to_codes(+TERM, -CODES, +OPTIONS)'
'write_term_to_codes(+TERM, ?S0, ?S, +OPTIONS)'

     A specialized 'format_to_codes/[3,4]'.  Writes TERM into a
     code-list using 'write_term/3' and OPTIONS.  CODES is unified with
     the list.  Alternatively, S0 and S are unified with the list and
     its end, respectively.
'read_from_codes(+CODES, -TERM)'

     Reads TERM from CODES using 'read/2'.  The CODES must, as usual, be
     terminated by a FULL-STOP, i.e. a '.', possibly followed by
     LAYOUT-TEXT.
'read_term_from_codes(+CODES, -TERM, +OPTIONS)'

     Reads TERM from CODES using 'read_term/3' and OPTIONS.  The CODES
     must, as usual, be terminated by a FULL-STOP, i.e. a '.', possibly
     followed by LAYOUT-TEXT.
'open_codes_stream(+CODES, -STREAM)'

     STREAM is opened as an input stream to an existing code-list.  The
     stream may be read with the Stream I/O predicates and must be
     closed using 'close/1'.  The list is copied to an internal buffer
     when the stream is opened and must therefore be a ground code-list
     at that point.
'with_output_to_codes(:GOAL, -CODES)'
'with_output_to_codes(:GOAL, ?S0, ?S)'
'with_output_to_codes(:GOAL, -STREAM, ?S0, ?S)'

     GOAL is called with the 'current_output' stream set to a new
     stream.  This stream writes to an internal buffer, which is, after
     the successful execution of GOAL, converted to a list of character
     codes.  CODES is unified with the list, alternatively S0 and S are
     unified with the list and its end, respectively.
     'with_output_to_codes/4' also passes the stream in the STREAM
     argument.  It can be used only by GOAL for writing.


File: sicstus.info,  Node: lib-csv,  Next: lib-comclient,  Prev: lib-codesio,  Up: The Prolog Library

10.13 I/O on Comma-Separated Values (CSV) Files and Strings--'library(csv)'
===========================================================================

This library module provides some utilities for Comma-Separated Values
(CSV) files and strings.  In this context, a file is a sequence of
_records_, and a record is a sequence of _fields_.  In a CSV file,
fields are separated by commas, and each record is terminated by <RET>.

   This module does not report any syntax errors.  In the event of
prematurely terminated input file, the current field and record will be
terminated silently.

   Then a CSV record is read, it will yield a list of fields of the
following form:

'integer(NUMBER,CODES)'
     Stands for the integer NUMBER, where 'number_codes(NUMBER,CODES)'
     holds, and CODES is the list of character codes actually read.

'float(NUMBER,CODES)'
     Stands for the float NUMBER, where 'number_codes(NUMBER,CODES)'
     holds, and CODES is the list of character codes actually read.

'string(CODES)'
     Stands for the text string (list of character codes) CODES, and
     'number_codes(NUMBER,CODES)' does not hold.

   When a CSV records is written, the CODES argument of the above terms
is used, but the following fields are also allowed:

'integer(NUMBER)'
     Stands for the integer NUMBER.

'float(NUMBER)'
     Stands for the float NUMBER.

'atom(ATOM)'
     Stands for the atom ATOM.

   Adapted to the conventions of this manual, RFC 4180 specifies the
following.  Where this module relaxes the requirements, that is
explicitly mentioned:

  1. Each record is located on a separate line, delimited by a line
     break.  For example:
          aaa,bbb,ccc <RET>
          zzz,yyy,xxx <RET>

  2. The last record in the file may or may not have an ending line
     break.  For example:
          aaa,bbb,ccc <RET>
          zzz,yyy,xxx

  3. There may be an optional header line appearing as the first line of
     the file with the same format as normal record lines.  This header
     will contain names corresponding to the fields in the file and
     should contain the same number of fields as the records in the rest
     of the file.  For example:
          field_name,field_name,field_name <RET>
          aaa,bbb,ccc <RET>
          zzz,yyy,xxx <RET>
     This module does not attempt to detect a header line nor treat it
     in any special way.

  4. Within the header and each record, there may be one or more fields,
     separated by commas.  Each record should contain the same number of
     fields throughout the file.  Spaces are considered part of a field
     and should not be ignored.  The last field in the record must not
     be followed by a comma, so if the record ends with a comma, the
     last field is treated as empty.  For example, the following is
     treated as four fields:
          aaa,bbb,ccc,
     This module does not require or check that each record contains the
     same number of fields.

  5. Each field may or may not be enclosed in double quotes.  If fields
     contain line breaks (<RET>), double quotes or commas, then they
     should be enclosed in double quotes, otherwise the double quotes
     may be omitted.  For example:
          "aaa","bbb","ccc" <RET>
          "aaa","b <RET>
          bb","ccc" <RET>
          zzz,yyy,xxx
     If an unenclosed field is immediately followed by a '"', (or vice
     versa), then this module treats that as a new enclosed (or
     unenclosed) field to be read and appended to the field read so far.

  6. If double quotes are used to enclose fields, then a double quote
     appearing inside a field must be escaped by preceding it with
     another double quote.  For example:
          "aaa","b""bb","ccc"

   Exported predicates:

'read_record(-RECORD)'
'read_record(+STREAM, -RECORD)'

     Reads a single record from the stream STREAM, which defaults to the
     current input stream, and unifies it with RECORD.  On end of file,
     RECORD is unified with 'end_of_file'.
'read_records(-RECORDS)'
'read_records(+STREAM, -RECORDS)'

     Reads records from the stream STREAM, which defaults to the current
     input stream, up to the end of the stream, and unifies them with
     RECORDS.
'read_record_from_codes(-RECORD, +CODES)'
'read_record_from_codes(-RECORD, +CODES, -SUFFIX)'

     Reads a record from the code-list CODES.  In the arity 2 variant,
     there must be no trailing character codes after the record.  In the
     arity 3 variant, any trailing character codes are unified with
     SUFFIX, which can be used for reading subsequent records.
'write_record(+RECORD)'
'write_record(+STREAM, +RECORD)'

     Writes a single record to the stream STREAM, which defaults to the
     current output stream.
'write_records(+RECORDS)'
'write_records(+STREAM, +RECORDS)'

     Writes records to the stream STREAM, which defaults to the current
     output stream.
'write_record_to_codes(+RECORD, -CODES)'

     Writes a single record to the code-list CODES, without the
     terminating <RET>.


File: sicstus.info,  Node: lib-comclient,  Next: lib-fdbg,  Prev: lib-csv,  Up: The Prolog Library

10.14 COM Client--'library(comclient)'
======================================

This library provides rudimentary access to COM automation objects.  As
an example it is possible to manipulate Microsoft Office applications
and Internet Explorer.  It is not possible, at present, to build COM
objects using this library.

   Feedback is very welcome.  Please contact SICStus support
(<sicstus-support@sics.se>) if you have suggestions for how this library
could be improved.

* Menu:

* Preliminaries::               Preliminaries
* Terminology::                 Terminology
* COM Client Predicates::       Predicate Reference
* COM Client Examples::         Examples


File: sicstus.info,  Node: Preliminaries,  Next: Terminology,  Up: lib-comclient

10.14.1 Preliminaries
---------------------

In most contexts both atoms and code-lists are treated as strings.  With
the wide character support available in release 3.8 and later, is should
now be possible to pass UNICODE atoms and strings successfully to the
COM interface.


File: sicstus.info,  Node: Terminology,  Next: COM Client Predicates,  Prev: Preliminaries,  Up: lib-comclient

10.14.2 Terminology
-------------------

"ProgID"
     A human readable name for an object class, typically as an atom,
     e.g. ''Excel.Application''.

"CLSID (Class Identifier)"
     A globally unique identifier of a class, typically as an atom, e.g.
     ''{00024500-0000-0000-C000-000000000046}''.

     Where it makes sense a PROGID can be used instead of the
     corresponding CLSID.

"IID (Interface Identifier)"
     A globally unique identifier of an interface.  Currently only the
     ''IDispatch'' interface is used so you do not have to care about
     this.

"IName (Interface Name)"
     The human readable name of an interface, e.g. ''IDispatch''.

     Where it makes sense an INAME can be used instead of the
     corresponding IID.

"Object"
     A COM-object (or rather a pointer to an interface).

"ComValue"
     A value that can be passed from COM to SICStus Prolog.  Currently
     numeric types, booleans (treated as 1 for 'true', 0 for 'false'),
     strings, and COM objects.

"ComInArg"
     A value that can be passed as an input argument to COM, currently
     one of:
     atom
          Passed as a string (BSTR)
     numeric
          Passed as the corresponding number
     list
          A code-list is treated as a string.
     COM object
          A compound term referring to a COM object.
     compound
          Other compound terms are presently illegal but will be used to
          extend the permitted types.

"SimpleCallSpec"
     Denotes a single method and its arguments.  As an example, to call
     the method named 'foo' with the arguments '42' and the string
     '"bar"' the SIMPLECALLSPEC would be the compound term
     'foo(42,'bar')' or, as an alternative, 'foo(42,"bar")'.

     The arguments of the compound term are treated as follows:
     "ComInArg"
          See above
     "variable"
          The argument is assumed to be output.  The variable is bound
          to the resulting value when the method returns.

     "mutable"
          The argument is assumed to be input/output.  The value of the
          mutable is passed to the method and when the method returns
          the mutable is updated with the corresponding return value.

"CallSpec"
     Either a SimpleCallSpec or a list of CallSpecs.  If it is a list
     then all but the last SimpleCallSpec are assumed to denote method
     calls that return a COM-object.  So for instance the VB statement
     'app.workbooks.add' can be expressed either as:
          comclient_invoke_method_proc(App, [workbooks, add])
     or as
          comclient_invoke_method_fun(App, workbooks, WorkBooks),
          comclient_invoke_method_proc(WorkBooks, add),
          comclient_release(WorkBooks)


File: sicstus.info,  Node: COM Client Predicates,  Next: COM Client Examples,  Prev: Terminology,  Up: lib-comclient

10.14.3 Predicate Reference
---------------------------

'comclient_garbage_collect'

     Release Objects that are no longer reachable from SICStus Prolog.
     To achieve this the predicate 'comclient_garbage_collect/0'
     performs an atom garbage collection, i.e.
     'garbage_collect_atoms/0', so it should be used sparingly.
'comclient_is_object(+OBJECT)'

     Succeeds if OBJECT "looks like" an object.  It does not check that
     the object is (still) reachable from SICStus Prolog, see
     'comclient_valid_object/1'.  Currently an object looks like
     ''$comclient_object'(STUFF)' where STUFF is some prolog term.  Do
     not rely on this representation!
'comclient_valid_object(+OBJECT)'

     Succeeds if OBJECT is an object that is still available to SICStus
     Prolog.
'comclient_equal(+OBJECT1, +OBJECT2)'

     Succeeds if OBJECT1 and OBJECT2 are the same object.  (It succeeds
     if their ''IUnknown'' interfaces are identical)
'comclient_clsid_from_progid(+PROGID, -CLSID).'

     Obtain the CLSID corresponding to a particular PROGID.  Uses the
     Win32 routine 'CLSIDFromProgID'.  You rarely need this since you
     can use the ProgID directly in most cases.
'comclient_progid_from_clsid(+CLSID, -PROGID).'

     Obtain the PROGID corresponding to a particular CLSID.  Uses the
     Win32 routine 'ProgIDFromCLSID'.  Rarely needed.  The PROGID
     returned will typically have the version suffix appended.

     Example, to determine what version of 'Excel.Application' is
     installed:
          | ?- comclient_clsid_from_progid('Excel.Application, CLSID),
               comclient_progid_from_clsid(CLSID, ProgID).
          CLSID = '{00024500-0000-0000-C000-000000000046}',
          ProgID = 'Excel.Application.8'
'comclient_iid_from_name(+INAME, -IID)'

     Look in the registry for the IID corresponding to a particular
     Interface.  Currently of little use.
          | ?- comclient_iid_from_name('IDispatch', IID).
          IID = '{00020400-0000-0000-C000-000000000046}'
'comclient_name_from_iid(+IID, -INAME)'

     Look in the registry for the name corresponding to a particular
     IID.  Currently of little use.
'comclient_create_instance(+ID, -OBJECT)'

     Create an instance of the Class identified by the CLSID or ProgID
     ID.
          comclient_create_instance('Excel.Application', App)
     Corresponds to 'CoCreateInstance'.
'comclient_get_active_object(+ID, -OBJECT)'

     Retrieves a running object of the Class identified by the CLSID or
     ProgID ID.
          comclient_get_active_object('Excel.Application', App)
     An exception is thrown if there is no suitable running object.
     Corresponds to 'GetActiveObject'.
'comclient_invoke_method_fun(+OBJECT, +CALLSPEC, -COMVALUE)'

     Call a method that returns a value.  Also use this to get the value
     of properties.

'comclient_invoke_method_proc(+OBJECT, +CALLSPEC)'

     Call a method that does not return a value.
'comclient_invoke_put(+OBJECT, +CALLSPEC, +COMINARG)'

     Set the property denoted by CALLSPEC to COMVALUE.  Example:
     'comclient_invoke_put(App, visible, 1)'
'comclient_release(+OBJECT)'

     Release the object and free the datastructures used by SICStus
     Prolog to keep track of this object.  After releasing an object the
     term denoting the object can no longer be used to access the object
     (any attempt to do so will raise an exception).
          *Please note*: The same COM-object can be represented by
          different prolog terms.  A COM object is not released from
          SICStus Prolog until all such representations have been
          released, either explicitly by calling 'comclient_release/1'
          or by calling 'comclient_garbage_collect/0'.

          You cannot use 'OBJ1 == OBJ2' to determine whether two
          COM-objects are identical.  Instead use 'comclient_equal/2'.
'comclient_is_exception(+EXCEPTIONTERM)'

     Succeeds if EXCEPTIONTERM is an exception raised by the comclient
     module.
          catch(<some code>,
                Exception,
                ( comclient_is_exception(E) ->
                   handle_com_related_errors(E)
                ; otherwise -> % Pass other exceptions upwards
                   throw(E)
                ))
'comclient_exception_code(+EXCEPTIONTERM, -ERRORCODE)'

'comclient_exception_culprit(+EXCEPTIONTERM, -CULPRIT)'

'comclient_exception_description(+EXCEPTIONTERM, -DESCRIPTION)'

     Access the various parts of a comclient exception.  The ERRORCODE
     is the 'HRESULT' causing the exception.  CULPRIT is a term
     corresponding to the call that gave an exception.  DESCRIPTION, if
     available, is either a term ''EXCEPINFO'(...)' corresponding to an
     'EXCEPINFO' structure or ''ARGERR'(MethodName, ArgNumber)'.

     The 'EXCEPINFO' has six arguments corresponding to, and in the same
     order as, the arguments of the 'EXCEPINFO' struct.


File: sicstus.info,  Node: COM Client Examples,  Prev: COM Client Predicates,  Up: lib-comclient

10.14.4 Examples
----------------

The following example launches Microsoft Excel, adds a new worksheet,
fill in some fields and finally clears the worksheet and quits _Excel_
     :- use_module(library(comclient)).
     :- use_module(library(lists)).

     test :-
        test('Excel.Application').

     test(ProgID) :-
        comclient_create_instance(ProgID, App),
        %% Visuall Basic: app.visible = 1
        comclient_invoke_put(App, visible, 1),
        %% VB: app.workbooks.add
        comclient_invoke_method_proc(App, [workbooks, add]),
        %% VB: with app.activesheet
        comclient_invoke_method_fun(App, activesheet, ActiveSheet),

        Rows = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15],
        Cols = Rows,
        %% VB: .cells i,j . value = i+j/100
        (
          member(I, Rows),
          member(J, Cols),
          ValIJ is I+J/100,

          comclient_invoke_put(ActiveSheet, [cells(I,J),value], ValIJ),
          fail
        ; true
        ),
        (
          member(I, Rows),
          member(J, Cols),
          %% retrieve cell values
          comclient_invoke_method_fun(ActiveSheet, [cells(I,J), value],CellValue),
          format(user_error, '~nCell(~w,~w) = ~w', [I,J,CellValue]),
          fail
        ; true
        ),

        Range = 'A1:O15',
        format(user_error, '~Npress return to clear range (~w)', [Range]),
        flush_output(user_error),
        get_code(_),

        %% VB: .range A1:O15 .Clear
        comclient_invoke_method_proc(ActiveSheet, [range(Range),clear]),

        %% Avoid Excel query "do you want to save..."
        %%  VB: app.activeworkbook.saved = 1
        comclient_invoke_put(App, [activeworkbook,saved], 1),

        format(user_error, '~Npress return to quit \'~w\'', [ProgID]),
        flush_output(user_error),
        get_code(_),

        %% VB: app.quit
        comclient_invoke_method_proc(App, quit),

        comclient_release(ActiveSheet),
        comclient_release(App).



File: sicstus.info,  Node: lib-fdbg,  Next: lib-file_systems,  Prev: lib-comclient,  Up: The Prolog Library

10.15 Finite Domain Constraint Debugger--'library(fdbg)'
========================================================

* Menu:

* FDBG Introduction:: Introduction
* FDBG Concepts:: Concepts
* FDBG Basics:: Basics
* FDBG Advanced Usage:: Advanced Usage


File: sicstus.info,  Node: FDBG Introduction,  Next: FDBG Concepts,  Up: lib-fdbg

10.15.1 Introduction
--------------------

FDBG is a CLP(FD) debugger for SICStus Prolog.  Its main purpose is to
enable the CLP programmer to trace the changes of domains of variables.
See [Hanak et al.  04].

   FDBG defines the following prefix operator:

     :- op(400, fy, #).

   The presence of FDBG affects the translation and execution, but not
the semantics, of subsequently loaded arithmetic constraints.


File: sicstus.info,  Node: FDBG Concepts,  Next: FDBG Basics,  Prev: FDBG Introduction,  Up: lib-fdbg

10.15.2 Concepts
----------------

In this section, several concepts and terms are defined.  These terms
will later be heavily used in the documentation; therefore, it is
important that you understand them well.

* Menu:

* FDBG Events:: Events
* FDBG Labeling Levels:: Labeling Levels
* FDBG Visualizers:: Visualizers
* FDBG Names of Terms:: Names of Terms
* FDBG Selectors:: Selectors
* FDBG Name Auto-Generation:: Name Auto-Generation
* FDBG Legend:: Legend
* FDBG The fdbg_output Stream:: The 'fdbg_output' Stream


File: sicstus.info,  Node: FDBG Events,  Next: FDBG Labeling Levels,  Up: FDBG Concepts

10.15.2.1 Events
................

An FDBG event can (currently) belong to one of the two following major
classes:

"constraint event"
     A constraint is woken.

"labeling event"
     Three events belong to this class, namely:

        * the labeling of an FD variable is started
        * an FD variable gets constrained
        * the labeling of an FD variable fails, i.e. all elements of its
          domain have been tried and caused failure

   These events are intercepted by the FDBG core.  When any of them
occurs, the appropriate visualizer (*note FDBG Visualizers::) gets
called with a representation of the event (a Prolog term) as extra
arguments.


File: sicstus.info,  Node: FDBG Labeling Levels,  Next: FDBG Visualizers,  Prev: FDBG Events,  Up: FDBG Concepts

10.15.2.2 Labeling Levels
.........................

In this subsection we give three definitions regarding the labeling
procedure.

"labeling session"
     This term denotes the whole labeling procedure that starts with the
     call of 'labeling/2' or an equivalent predicate and finishes by
     exiting this predicate.  Normally, there is at most one labeling
     session per run.

"labeling attempt"
     One choicepoint of a labeling session.  Exactly one variable is
     associated with a labeling attempt, although this is not
     necessarily true vice versa.  For example in 'enum' mode labeling,
     a single labeling attempt tries every possible value, but in 'step'
     mode labeling, several binary choicepoints are created.

"labeling step"
     The event of somehow constraining the domain of a variable.  This
     usually means either setting the variable to a specific value or
     limiting it with a lower or an upper bound.

   As you can see there is a hierarchical relation among these
definitions: a labeling session consists of several labeling attempts,
which, in turn, might consist of several labeling steps.

   A "labeling event", on the other hand, can either be a labeling step,
or the start of a labeling attempt, or the failure of the same.  *Note
FDBG Events::.


File: sicstus.info,  Node: FDBG Visualizers,  Next: FDBG Names of Terms,  Prev: FDBG Labeling Levels,  Up: FDBG Concepts

10.15.2.3 Visualizers
.....................

A visualizer is a Prolog predicate reacting to FDBG events (*note FDBG
Events::).  It is called directly by the FDBG core when any FDBG event
occurs.  It is called "visualizer", because usually it should present
the events to the user, but in general it can do any kind of processing,
like checking invariants, etc.

   For all major event classes, a different visualizer type is used.
The set of visualizers you would like to use for a session is specified
in the option list of 'fdbg_on/1' (*note FDBG Options::), when FDBG is
switched on.

   A specific visualizer can have several arguments, some are supplied
by the FDBG core, the rest (if any) should be specified when FDBG is
switched on.  Note that the obligatory arguments will be appended to the
_end_ of the user defined argument list.

   The set of built-in visualizers installed by default (*note FDBG
Options::) is the following:

   * for constraint awakenings: 'fdbg_show'
   * for labeling events: 'fdbg_label_show'

   For details on built-in visualizers, *note FDBG Built-In
Visualizers::.


File: sicstus.info,  Node: FDBG Names of Terms,  Next: FDBG Selectors,  Prev: FDBG Visualizers,  Up: FDBG Concepts

10.15.2.4 Names of Terms
........................

FDBG provides a service to assign names to Prolog terms for later
reference.  A name is an atom and it is usually associated with a
compound term containing constraint variables, or with a single
variable.  In the former case, each variable appearing in the compound
term is also assigned a name automatically by FDBG. This auto-assigned
name is derived from the name of the term; *note FDBG Name
Auto-Generation::.

   Perhaps the most useful utilization of names is "annotation", another
service of FDBG. Here, each variable appearing in a Prolog term is
replaced with a compound term describing it (i.e. containing its name,
the variable itself, and some data regarding its domain).  During
annotation, unnamed constraint variables are also given a unique
"anonymous" name automatically, these names begin with a 'fdvar' prefix.
*Note FDBG Writing Visualizers::.

   The names will be used by the built-in visualizers when referring to
constraint variables, and they can also be used to retrieve the terms
assigned to them in user defined visualizers.  *Note FDBG Visualizers::.


File: sicstus.info,  Node: FDBG Selectors,  Next: FDBG Name Auto-Generation,  Prev: FDBG Names of Terms,  Up: FDBG Concepts

10.15.2.5 Selectors
...................

A "selector" is a Prolog term denoting a (path to a) subterm of a given
term T.  Let SUBTERM(T,S) denote the subterm of T wrt. a selector S, and
let N denote an integer.  A selector then takes one of the following
forms:

S            SUBTERM(T,S)
'[]'         T
'[...,N]'    Nth argument of the compound term SUBTERM(T,'[...]')
'[...,#N]'   Nth element of the list SUBTERM(T,'[...]')


File: sicstus.info,  Node: FDBG Name Auto-Generation,  Next: FDBG Legend,  Prev: FDBG Selectors,  Up: FDBG Concepts

10.15.2.6 Name Auto-Generation
..............................

There are two cases when a name is automatically generated.

  1. When a name is assigned to a compound term by the user, each
     variable appearing in it is assigned a so called "derived" name,
     which is created by appending a variant of the selector of the
     variable to the original name.  For example, the call:
          fdbg_assign_name(bar(A, [B, C], foobar(D, E)), foo)
     will create the following name/term entries:

     NAME        TERM/VARIABLE                    SELECTOR
     'foo'       'bar(A, [B, C], foobar(D, E))'   '[]'
     'foo_1'     'A'                              '[1]'
     'foo_2_1'   'B'                              '[2,#1]'
     'foo_2_2'   'C'                              '[2,#2]'
     'foo_3_1'   'D'                              '[3,1]'
     'foo_3_2'   'E'                              '[3,2]'

     *Note FDBG Naming Terms::.

  2. If, during the annotation of a term (*note FDBG Annotation::) an
     unnamed constraint variable is found, then it is assigned a unique
     "anonymous" name.  This name consists of the prefix 'fdvar', an
     underscore character, and an integer.  The integer is automatically
     incremented when necessary.


File: sicstus.info,  Node: FDBG Legend,  Next: FDBG The fdbg_output Stream,  Prev: FDBG Name Auto-Generation,  Up: FDBG Concepts

10.15.2.7 Legend
................

The "legend" is a list of variables and their domains, usually appearing
after a description of the current constraint.  This is necessary
because the usual visual representation of a constraint contains only
the _names_ of the variables in it (*note FDBG Annotation::), and does
not show anything about their domain.  The legend links these names to
the corresponding domains.  The legend also shows the changes of the
domains made by the constraint.  Finally, the legend may contain some
conclusions regarding the behavior of the constraint, like failure or
side-effects.

   The format of the legend is somewhat customizable by defining a hook
function; *note FDBG Customizing Output::.  The default format of the
legend is the following:

     list_2 = 0..3
     list_3 = 0..3
     list_4 = 0..3
     fdvar_2 = 0..3 -> 1..3

   Here, we see four variables, with initial domains 0..3, but the
domain of the (previously unnamed) variable 'fdvar_2' is narrowed by the
constraint (not shown here) to 1..3.

   A legend is automatically printed by the built-in visualizer
'fdbg_show', but it can be easily printed from user defined visualizers
too.


File: sicstus.info,  Node: FDBG The fdbg_output Stream,  Prev: FDBG Legend,  Up: FDBG Concepts

10.15.2.8 The 'fdbg_output' Stream
..................................

The 'fdbg_output' is a stream alias created when FDBG is switched on and
removed when it is switched off.  All built-in visualizers write to this
stream, and the user defined visualizers should do the same.


File: sicstus.info,  Node: FDBG Basics,  Next: FDBG Advanced Usage,  Prev: FDBG Concepts,  Up: lib-fdbg

10.15.3 Basics
--------------

Here, we describe the set of FDBG services and commands necessary to do
a simple debugging session.  No major modification of your CLP(FD)
program is necessary to use FDBG this way.  Debugging more complicated
programs, on the other hand, might also require user written extensions
to FDBG, since the wallpaper trace produced by the built-in visualizer
'fdbg_show' could be too detailed and therefore hard to analyze.  *Note
FDBG Advanced Usage::.

* Menu:

* FDBG Options:: FDBG Options
* FDBG Naming Terms:: Naming Terms
* FDBG Built-In Visualizers:: Built-In Visualizers
* FDBG Debugger Commands:: New Debugger Commands
* FDBG Annotation:: Annotating Programs
* FDBG An Example Session:: An Example Session


File: sicstus.info,  Node: FDBG Options,  Next: FDBG Naming Terms,  Up: FDBG Basics

10.15.3.1 FDBG Options
......................

FDBG is switched on and off with the predicates:

'fdbg_on'
'fdbg_on(:OPTIONS)'
     Turns on FDBG by putting advice-points on several predicates of the
     CLP(FD) module.  OPTIONS is a list of options; *note FDBG
     Options::.  The empty list is the default value.

     'fdbg_on/[0,1]' can be called safely several times consecutively;
     only the first call will have an effect.

'fdbg_off'
     Turns the debugger off by removing the previously installed
     advice-points.

   'fdbg_on/1' accepts the following options:

'file(FILENAME, MODE)'
     Tells FDBG to attach the stream alias 'fdbg_output' to the file
     called FILENAME opened in mode MODE.  MODE can either be 'write' or
     'append'.  The file specified is opened on a call to 'fdbg_on/1'
     and is closed on a call to 'fdbg_off/0'.

'socket(HOST, PORT)'
     Tells FDBG to attach the stream alias 'fdbg_output' to the socket
     connected to HOST on port PORT.  The specified socket is created on
     a call to 'fdbg_on/1' and is closed on a call to 'fdbg_off/0'.

'stream(STREAM)'
     Tells FDBG to attach the stream alias 'fdbg_output' to the stream
     STREAM.  The specified stream remains open after calling
     'fdbg_off/0'.

     If none of the above three options is used, then the stream alias
     'fdbg_output' is attached to the current output stream.
      

'constraint_hook(GOAL)'
     Tells FDBG to extend GOAL with two (additional) arguments and call
     it on the exit port of the constraint dispatcher.

'no_constraint_hook'
     Tells FDBG not to use any constraint hook.

     If none of the above two options is used, then the default is
     'constraint_hook(fdbg:fdbg_show)'.
      

'labeling_hook(GOAL)'
     Tells FDBG to extend GOAL with three (additional) arguments and
     call it on any of the three labeling events.

'no_labeling_hook'
     Tells FDBG not to use any labeling hook.

     If none of the above two options is used, then the default is
     'labeling_hook(fdbg:fdbg_label_show)'.

   For both 'constraint_hook' and 'labeling_hook', GOAL should be a
visualizer, either built-in (*note FDBG Built-In Visualizers::) or user
defined.  More of these two options may appear in the option list, in
which case they will be called in their order of occurrence.

   *Note FDBG Writing Visualizers::.  for more details on these two
options.


File: sicstus.info,  Node: FDBG Naming Terms,  Next: FDBG Built-In Visualizers,  Prev: FDBG Options,  Up: FDBG Basics

10.15.3.2 Naming Terms
......................

Naming is a procedure of associating names with terms and variables;
*note FDBG Names of Terms::.  Three predicates are provided to assign
and retrieve names, these are the following:

'fdbg_assign_name(+TERM, ?NAME)'
     Assigns the atom NAME to TERM, and a derived name to each variable
     appearing in TERM.  If NAME is a variable, then use a default
     (generated) name, and return it in NAME.  *Note FDBG Name
     Auto-Generation::.

'fdbg_current_name(?TERM, ?NAME)'
     Retrieves TERM associated with NAME, or enumerates all term-name
     pairs.

'fdbg_get_name(+TERM, -NAME)'
     Returns the name associated to TERM in NAME, if it exists.
     Otherwise, silently fails.


File: sicstus.info,  Node: FDBG Built-In Visualizers,  Next: FDBG Debugger Commands,  Prev: FDBG Naming Terms,  Up: FDBG Basics

10.15.3.3 Built-In Visualizers
..............................

The default visualizers are generic predicates to display FDBG events
(*note FDBG Events::) in a well readable form.  These visualizers
naturally do not exploit any problem specific information--to have more
"fancy" output, you have to write your own visualizers; *note FDBG
Writing Visualizers::.  To use these visualizers, pass them in the
appropriate argument to 'fdbg_on/1'; *note FDBG Options::, or call them
directly from user defined visualizers.

'fdbg_show(+CONSTRAINT, +ACTIONS)'
     This visualizer produces a trace output of all woken constraints,
     in which a line showing the constraint is followed by a legend
     (*note FDBG Legend::) of all the variables appearing in it, and
     finally an empty line to separate events from each other.  The
     usual output will look like this:

          <fdvar_1>#=0
              fdvar_1 = inf..sup -> {0}
              Constraint exited.

     Here, we can see an arithmetical constraint being woken.  It
     narrows 'fdvar_1' to a domain consisting of the singleton value 0,
     and since this is the narrowest domain possible, the constraint
     does not have anything more to do: it exits.

     Note that when you pass 'fdbg_show' as an option, you should omit
     the two arguments, like in:

          fdbg_on([..., constraint_hook(fdbg_show), ...]).

'fdbg_label_show(+EVENT, +LABELID, +VARIABLE)'
     This visualizer produces a wallpaper trace output of all labeling
     events.  It is best used together with 'fdbg_show/2'.  Each
     labeling event produces a single line of output, some of them are
     followed by an empty line, some others are always followed by
     another labeling action and therefore the empty line is omitted.
     Here is a sample output of 'fdbg_label_show/3':

          Labeling [9, <list_1>]: starting in range 0..3.
          Labeling [9, <list_1>]: step: <list_1> = 0

     What we see here is the following:

        * The prefix 'Labeling' identifies the event.
        * The number in the brackets (9) is a unique identification
          number belonging to a labeling attempt.  Only _one_ labeling
          step with this number can be in effect at a time.  This number
          in fact is the invocation number of the predicate doing the
          labeling for that variable.
        * The name in the brackets ('<list_1>') identifies the variable
          currently being labeled.  Note that several identification
          numbers might belong to the same variable, depending on the
          mode of labeling.
        * The text after the colon specifies the actual labeling event.
          This string can be:

             - "starting in range RANGE."  meaning the starting of a
               labeling attempt in range RANGE
             - "MODE: NARROWING."  meaning a labeling step in mode MODE.
               NARROWING is the actual narrowing done in the labeling
               step.  MODE is one of the following:

               'step'
                    meaning 'step' mode labeling
               'indomain_up'
                    meaning 'enum' mode labeling or a direct call to
                    'indomain/1'
               'indomain_down'
                    meaning 'enum,down' mode labeling
               'bisect'
                    meaning 'bisect' mode labeling
               'dual'
                    when the domain contains exactly two values and the
                    labeling attempt is nothing more than a selection
                    between them

             - "failed."  meaning the labeling attempt failed.

     Note that when you pass 'fdbg_label_show/3' as an option, you
     should omit the three arguments, like in

          fdbg_on([..., labeling_hook(fdbg_label_show), ...]).


File: sicstus.info,  Node: FDBG Debugger Commands,  Next: FDBG Annotation,  Prev: FDBG Built-In Visualizers,  Up: FDBG Basics

10.15.3.4 New Debugger Commands
...............................

The Prolog debugger is extended by FDBG. The '&' debugger is modified,
and two new commands are added:

'&'
'& N'
     This debugger command is extended so that the annotated form of
     domain variables is also printed when listing the variables with
     blocked goals.

'A'
'A SELECTOR'
     Annotates and prints the current goal and a legend of the variables
     appearing in it.  If a selector is specified, then the subterm
     specified by it is assumed to be an action list, and is taken into
     account when displaying the legend.  For example:

          23  2 Exit: clpfd:dispatch_global_fast(no_threat(2,_1001,1),0,0,
                      [exit,_1001 in_set[[3|3]]]) ? A [2,4]

          clpfd:dispatch_global_fast(no_threat(2,<board_2>,1),0,0,
                                     [exit,<board_2> in_set[[3|3]]])
              board_2 = 1..4 -> {3}
              Constraint exited.

'W NAME=SELECTOR'
     Assigns the atom NAME to the variable specified by the SELECTOR.
     For example:

          7      15 Call: bar(4, [_101,_102,_103]) ? W foo=[2,#2]

     This would assign the name 'foo' to '_102', being the second
     element of the second argument of the current goal.


File: sicstus.info,  Node: FDBG Annotation,  Next: FDBG An Example Session,  Prev: FDBG Debugger Commands,  Up: FDBG Basics

10.15.3.5 Annotating Programs
.............................

In order to use FDBG efficiently, you have to make some changes to your
CLP(FD) program.  Fortunately the calls you have to add are not
numerous, and when FDBG is turned off they do not decrease efficiency
significantly or modify the behavior of your program.  On the other
hand, they are necessary to make FDBG output easier to understand.

   Assign names to the more important and more frequently occurring
variables by inserting 'fdbg_assign_name/2' calls at the beginning of
your program.  It is advisable to assign names to variables in larger
batches (i.e. as lists or compound terms) with a single call.

   Use predefined labeling predicates if possible.  If you define your
own labeling predicates and you want to use them even in the debugging
session, then you should follow these guidelines:

  1. Add a call to 'clpfd:fdbg_start_labeling(+VAR)' at the beginning of
     the predicate doing a labeling attempt, and pass the currently
     labeled variable as an argument to the call.

  2. Call 'clpfd:fdbg_labeling_step(+VAR, +STEP)' before each labeling
     step.  STEP should be a compound term describing the labeling step,
     this will be

       a. printed "as is" by the built-in visualizer as the mode of the
          labeling step (*note FDBG Built-In Visualizers::)--you can use
          'portray/1' to determine how it should be printed;
       b. passed as 'step(STEP)' to the user defined labeling
          visualizers in their EVENT argument; *note FDBG Writing
          Visualizers::.

   This way FDBG can inform you about the labeling events created by
your labeling predicates exactly like it would do in the case of
internal labeling.  If you ignore these rules, then FDBG will not be
able to distinguish labeling events from other FDBG events any more.


File: sicstus.info,  Node: FDBG An Example Session,  Prev: FDBG Annotation,  Up: FDBG Basics

10.15.3.6 An Example Session
............................

The problem of magic sequences is a well known constraint problem.  A
magic sequence is a list, where the I-th item of the list is equal to
the number of occurrences of the number I in the list, starting from
zero.  For example, the following is a magic sequence:

     [1,2,1,0]

   The CLP(FD) solution can be found in
'library('clpfd/examples/magicseq')', which provides a couple of
different solutions, one of which uses the 'global_cardinality/2'
constraint.  We'll use this solution to demonstrate a simple session
with FDBG.

   First, the debugger is imported into the user module:

     | ?- use_module(library(fdbg)).
     % loading /home/matsc/sicstus3/Utils/x86-linux-glibc2.2/lib/sicstus-3.9.1/library/fdbg.po...
     % module fdbg imported into user

     [...]

     % loaded /home/matsc/sicstus3/Utils/x86-linux-glibc2.2/lib/sicstus-3.9.1/library/fdbg.po in module fdbg, 220 msec 453936 bytes

     | ?- use_module(library(clpfd)).
     [...]

   Then, the magic sequence solver is loaded:

     | ?- [library('clpfd/examples/magicseq')].
     % consulting /home/matsc/sicstus3/Utils/x86-linux-glibc2.2/lib/sicstus-3.9.1/library/clpfd/examples/magicseq.pl...
     %  module magic imported into user
     %  module clpfd imported into magic
     % consulted /home/matsc/sicstus3/Utils/x86-linux-glibc2.2/lib/sicstus-3.9.1/library/clpfd/examples/magicseq.pl in module magic, 30 msec 9440 bytes

   Now we turn on the debugger, telling it to save the trace in
'fdbg.log'.

     | ?- fdbg_on([file('fdbg.log',write)]).
     % The clp(fd) debugger is switched on

   To produce a well readable trace output, a name has to be assigned to
the list representing the magic sequence.  To avoid any modifications to
the source code, the name is assigned by a separate call before calling
the magic sequence finder predicate:

     | ?- length(L,4), fdbg_assign_name(L,list), magic_demo(4,L).
     L = [1,2,1,0] ? ;
     L = [2,0,2,0] ? ;

     no

     *Please note*: the call to 'length/2' is necessary; otherwise, 'L'
     would be a single variable instead of a list of four variables when
     the name is assigned.

   Finally we turn the debugger off:

     | ?- fdbg_off.
     % The clp(fd) debugger is switched off

   The output of the sample run can be found in 'fdbg.log'.  Here, we
show selected parts of the trace.  In each block, the woken constraint
appears on the first line, followed by the corresponding legend.

   In the first selected block, 'scalar_product/4' removes infeasible
domain values from 'list_4', adjusting its upper bound.  The legend
shows the domains before and after pruning.  Note also that the
constraint is rewritten to a more readable form:

     <list_2>+2*<list_3>+3*<list_4>#=<list_1>+<list_2>+<list_3>+<list_4>
         list_1 = 0..3
         list_2 = 0..3
         list_3 = 0..3
         list_4 = 0..3 -> 0..1

   The following block shows the initial labeling events, trying the
value 0 for 'list_1':

     Labeling [9, <list_1>]: starting in range 0..3.
     Labeling [9, <list_1>]: indomain_up: <list_1> = 0

   This soon leads to a dead end:

     <list_1>=0
         list_1 = 0..3 -> {0}
         Constraint exited.

     <list_2>+2*<list_3>+3*<list_4>#=<list_2>+<list_3>+<list_4>
         list_2 = 0..3
         list_3 = 0..3 -> {0}
         list_4 = 0..1 -> {0}
         Constraint exited.

     <list_2>+<list_3>+<list_4>#=4
         list_2 = 0..3
         list_3 = {0}
         list_4 = {0}
         Constraint failed.

   We backtrack on 'list_1', trying instead the value 1.  This leads to
the following propagation steps and to the first solution.  In these
propagation steps, the constraint exits, which means that it holds no
matter what value any remaining variable takes (like 'list_2' in the
second step):

     Labeling [9, <list_1>]: indomain_up: <list_1> = 1

     <list_1>=1
         list_1 = 0..3 -> {1}
         Constraint exited.

     <list_2>+2*<list_3>+3*<list_4>#=1+<list_2>+<list_3>+<list_4>
         list_2 = 0..3
         list_3 = 0..3 -> {1}
         list_4 = 0..1 -> {0}
         Constraint exited.

     1+<list_2>+<list_3>+<list_4>#=4
         list_2 = 0..3 -> {2}
         list_3 = {1}
         list_4 = {0}
         Constraint exited.

     global_cardinality([1,<list_2>,<list_3>,<list_4>],[0-1,1-<list_2>,2-<list_3>,3-<list_4>],[consistency(domain)])
         list_2 = {2}
         list_3 = {1}
         list_4 = {0}
         Constraint exited.

   Then, we backtrack again on 'list_1', which leads to the second
solution after a chain of propagation steps:

     Labeling [9, <list_1>]: indomain_up: <list_1> = 2

     [...]

     global_cardinality([2,<list_2>,<list_3>,<list_4>],[0-2,1-<list_2>,2-<list_3>,3-<list_4>],[consistency(domain)])
         list_2 = {0}
         list_3 = {2}
         list_4 = {0}
         Constraint exited.

   Then we backtrack on 'list_1' yet another time, but no more solutions
are found:

     Labeling [9, <list_1>]: indomain_up: <list_1> = 3

     [...]

     <list_2>+2*<list_3>+3*<list_4>#=3+<list_2>+<list_3>+<list_4>
         list_2 = {0}
         list_3 = {1}
         list_4 = {0}
         Constraint failed.

     Labeling [9, <list_1>]: failed.


File: sicstus.info,  Node: FDBG Advanced Usage,  Prev: FDBG Basics,  Up: lib-fdbg

10.15.4 Advanced Usage
----------------------

Sometimes the output of the built-in visualizer is inadequate.  There
might be cases when only minor changes are necessary to produce a more
readable output; in other cases, the trace output should be completely
reorganized.  FDBG provides two ways of changing the appearance of the
output by defining hook predicates.  In this section, these predicates
will be described in detail.

* Menu:

* FDBG Customizing Output:: Customizing Output
* FDBG Writing Visualizers:: Writing Visualizers
* FDBG Writing Legend Printers:: Writing Legend Printers
* FDBG Showing Selected Constraints (simple version):: Showing Selected Constraints (simple version)
* FDBG Showing Selected Constraints (advanced version):: Showing Selected Constraints (advanced version)
* FDBG Debugging Global Constraints:: Debugging Global Constraints


File: sicstus.info,  Node: FDBG Customizing Output,  Next: FDBG Writing Visualizers,  Up: FDBG Advanced Usage

10.15.4.1 Customizing Output
............................

The printing of variable names is customized by defining the following
hook predicate.

'fdbg:fdvar_portray(NAME, VAR, FDSET)   hook'
     This hook predicate is called whenever an annotated constraint
     variable (*note FDBG Annotation::) is printed.  NAME is the
     assigned name of the variable VAR, whose domain _will be_ FDSET as
     soon as the narrowings of the current constraint take effect.  The
     _current_ domain is not passed to the hook, but it can be easily
     determined with a call to 'fd_set/2'.  (Although these two sets may
     be the same if the constraint did not narrow it.)

     If 'fdbg:fdvar_portray/3' is undefined or fails, then the default
     representation is printed, which is NAME between angle brackets.

   The printing of legend lines is customized by defining the following
hook predicate.

'fdbg:legend_portray(NAME, VAR, FDSET)   hook'
     This hook is called for each line of the legend by the built-in
     legend printer.  The arguments are the same as in the case of
     'fdbg:fdvar_portray/3'.  Note that a prefix of four spaces and a
     closing newline character is always printed by FDBG.

     If 'fdbg:fdvar_portray/3' is undefined or fails, then the default
     representation is printed, which is

          NAME = RANGENOW [ -> RANGEAFTER ]

     The arrow and RANGEAFTER are only printed if the constraint
     narrowed the domain of VAR.

   The following example will print a list of all possible values
instead of the range for each variable in the legend:

     :- multifile fdbg:legend_portray/3.
     fdbg:legend_portray(Name, Var, Set) :-
             fd_set(Var, Set0),
             fdset_to_list(Set0, L0),
             fdset_to_list(Set, L),
             (   L0 == L
             ->  format('~p = ~p', [Name, L])
             ;   format('~p = ~p -> ~p', [Name, L0, L])
             ).


File: sicstus.info,  Node: FDBG Writing Visualizers,  Next: FDBG Writing Legend Printers,  Prev: FDBG Customizing Output,  Up: FDBG Advanced Usage

10.15.4.2 Writing Visualizers
.............................

For more complicated problems you might want to change the output more
drastically.  In this case you have to write and use your own
visualizers, which could naturally be problem specific, not like
'fdbg_show/2' and 'fdbg_label_show/3'.  As we described earlier,
currently there are two types of visualizers:

"constraint visualizer"

          MYGLOBALVISUALIZER([+ARG1, +ARG2, ...] +CONSTRAINT, +ACTIONS)

     This visualizer is passed in the 'constraint_hook' option.  It must
     take at least two arguments, the last two of which being:

     CONSTRAINT
          the constraint that was handled by the dispatcher
     ACTIONS
          the action list returned by the dispatcher

     Other arguments can be used for any purpose, for example to select
     the verbosity level of the visualizer.  This way you do not have to
     modify your code if you would like to see less or more information.
     Note however, that the two obligatory arguments must appear at the
     _end_ of the argument list.

     When passing as an option to 'fdbg_on/1', only the optional
     arguments have to be specified; the two mandatory arguments should
     be omitted.  *Note FDBG Debugging Global Constraints::.  for an
     example.

"labeling visualizer"

          MYLABELINGVISUALIZER([+ARG1, +ARG2, ...] +EVENT, +ID, +VAR)

     This visualizer is passed in the 'labeling_hook' option.  It must
     have at least three arguments, the last three of which being:

     EVENT
          a term representing the labeling event, can be one of the
          following:

          start
               labeling has just started for a variable
          fail
               labeling has just failed for a variable
          step(STEP)
               variable has been constrained in a labeling step
               described by the compound term STEP, which is either
               created by 'library(clpfd)''s labeling predicates (in
               this case, simply print it--FDBG will know how to handle
               it) or by you; *note FDBG Annotation::.

     ID
          identifies the labeling session, i.e. binds step and fail
          events to the corresponding start event
     VAR
          the variable being the subject of labeling

   The failure of a visualizer is ignored and multiple choices are cut
by FDBG. Exceptions, on the other hand, are not caught.

   FDBG provides several predicates to ease the work of the visualizer
writers.  These predicates are the following:

'fdbg_annotate(+TERM0, -TERM, -VARIABLES)'
'fdbg_annotate(+TERM0, +ACTIONS, -TERM, -VARIABLES)'
     Replaces each constraint variable in TERM0 by a compound term
     describing it and returns the result in TERM.  Also, collects these
     compound terms into the list VARIABLES.  These compound terms have
     the following form:

          fdvar(NAME, VAR, FDSET)

     NAME
          is the name of the variable (auto-generated, if necessary;
          *note FDBG Name Auto-Generation::)
     VAR
          is the variable itself
     FDSET
          is the domain of the variable _after_ narrowing with ACTIONS,
          if specified; otherwise, it is the _current_ domain of the
          variable

'fdbg_legend(+VARS)'
     Prints a legend of VARS, which is a list of 'fdvar/3' compound
     terms returned by 'fdbg_annotate/[3,4]'.

'fdbg_legend(+VARS, +ACTIONS)'
     Prints a legend of VARS followed by some conclusions regarding the
     constraint (exiting, failing, etc.)  based on ACTIONS.


File: sicstus.info,  Node: FDBG Writing Legend Printers,  Next: FDBG Showing Selected Constraints (simple version),  Prev: FDBG Writing Visualizers,  Up: FDBG Advanced Usage

10.15.4.3 Writing Legend Printers
.................................

When you write your own visualizers, you might not be satisfied with the
default format of the legend.  Therefore you might want to write your
own legend printer, replacing 'fdbg_legend/[1,2]'.  This should be quite
straightforward based on the variable list returned by
'fdbg_annotate/[3,4]'.  Processing the rest of the action list and
writing conclusions about the constraint behavior is not that easy
though.  To help your work, FDBG provides a predicate to transform the
raw action list to a more readable form:

'fdbg_transform_actions(+ACTIONS, +VARS, -TRANSFORMEDACTIONS)'
     This will do the following transformations to ACTIONS, returning
     the result in TRANSFORMEDACTIONS:

       1. remove all actions concerning variables in VARS (the list
          returned by 'fdbg_annotate/[3,4]');
       2. remove multiple 'exit' and/or 'fail' commands;
       3. remove all ground actions, translating those that will cause
          failure into 'fail(ACTION)';
       4. substitute all other narrowings with an 'fdvar/3' compound
          term per variable.

     The transformed action list may contain the following terms:

     'exit'
          the constraint exits

     'fail'
          the constraint fails due to a 'fail' action

     'fail(ACTION)'
          the constraint fails because of ACTION

     'call(GOAL)'
          ACTIONS originally contained this action.  FDBG cannot do
          anything with that but to inform the user about it.

     'fdvar(NAME, VAR, FDSET)'
          ACTIONS also narrowed some variables that did not appear in
          the VARS list, this is one of them.  The meaning of the
          arguments is the usual, described in *note FDBG Writing
          Visualizers::.  This should normally not happen.

     'ANYTHINGELSE'
          ACTIONS contained unrecognized actions too, these are copied
          unmodified.  This should not happen!


File: sicstus.info,  Node: FDBG Showing Selected Constraints (simple version),  Next: FDBG Showing Selected Constraints (advanced version),  Prev: FDBG Writing Legend Printers,  Up: FDBG Advanced Usage

10.15.4.4 Showing Selected Constraints (simple version)
.......................................................

Sometimes the programmer is not interested in every constraint, only
some selected ones.  Such a filter can be easily implemented with a
user-defined visualizer.  Suppose that you are interested in the
constraints 'all_different/[1,2]' and 'all_distinct/[1,2]' only:

     %% spec_filter(+Constraint, +Actions):  Call fdbg_show for all constraints
     %%   for which interesting_event(Constraint) succeeds.
     %%
     %%   Use this filter by giving the constraint_hook(spec_filter) option to
     %%   fdbg_on.
     spec_filter(Constraint, Actions) :-
             interesting_event(Constraint),
             fdbg_show(Constraint, Actions).

     interesting_event(all_different(_)).
     interesting_event(all_different(_,_)).
     interesting_event(all_distinct(_)).
     interesting_event(all_distinct(_,_)).

   Here is a session using the visualizer.  Note that the initialization
part ('domain/3' events), are filtered out, leaving only the
'all_distinct/[1,2]' constraints:

     | ?- [library('clpfd/examples/suudoku')].
     [...]
     | ?- fdbg_on([constraint_hook(spec_filter)]).
     % The clp(fd) debugger is switched on
     % advice
     | ?- suudoku([], 1, domain).
     all_distinct([1,<fdvar_1>,<fdvar_2>,8,<fdvar_3>,
                    4,<fdvar_4>,<fdvar_5>,<fdvar_6>],[consistency(domain)])
         fdvar_1 = 1..9 -> (2..3)\/(5..7)\/{9}
         fdvar_2 = 1..9 -> (2..3)\/(5..7)\/{9}
         fdvar_3 = 1..9 -> (2..3)\/(5..7)\/{9}
         fdvar_4 = 1..9 -> (2..3)\/(5..7)\/{9}
         fdvar_5 = 1..9 -> (2..3)\/(5..7)\/{9}
         fdvar_6 = 1..9 -> (2..3)\/(5..7)\/{9}

     [...]

     all_distinct([7,6,2,5,8,4,1,3,9],[consistency(domain)])
         Constraint exited.
     1 5 6 8 9 4 3 2 7
     9 2 8 7 3 1 4 5 6
     4 7 3 2 6 5 9 1 8
     3 6 2 4 1 7 8 9 5
     7 8 9 3 5 2 6 4 1
     5 1 4 9 8 6 2 7 3
     8 3 1 5 4 9 7 6 2
     6 9 7 1 2 3 5 8 4
     2 4 5 6 7 8 1 3 9
     yes
     % advice
     | ?- fdbg_off.
     % The clp(fd) debugger is switched off

   Note that failure of 'spec_filter/2' does not cause any unwanted
output.


File: sicstus.info,  Node: FDBG Showing Selected Constraints (advanced version),  Next: FDBG Debugging Global Constraints,  Prev: FDBG Showing Selected Constraints (simple version),  Up: FDBG Advanced Usage

10.15.4.5 Showing Selected Constraints (advanced version)
.........................................................

Suppose that you want to give the constraints that you are interested in
as an argument to the visualizer, instead of defining them in a table.
The following visualizer implements this.

     %% filter_events(+CtrSpecs, +Constraint, +Actions):  This predicate will
     %%   only show constraint events if they match an element in the list CtrSpecs,
     %%   or if CtrSpecs is wrapped in -/1, all the non-matching events will
     %%   be shown.
     %%   CtrSpecs can contain the following types of elements:
     %%     ctr_name             - matches all constraints of the given name
     %%     ctr_name/arity       - matches constraints with the given name and arity
     %%     ctr_name(...args...) - matches constraints unifyable with the given term
     %%
     %%   For the selected events fdbg_show(Constraint, Actions) is called.
     %%   This visualizer can be specified when turning fdbg on, e.g.:
     %%     fdbg_on([constraint_hook(filter_events([count/4]))]), or
     %%     fdbg_on([constraint_hook(filter_events(-[in_set]))]).
     filter_events(CtrSpecs, Constraint, Actions) :-
             filter_events(CtrSpecs, fdbg_show, Constraint, Actions).

     %% filter_events(+CtrSpecs, +Visualizer, +Constraint, +Actions):  Same as
     %%   the above predicate, but the extra argument Visualizer specifies the
     %%   predicate to be called for the selected events (in the same form as
     %%   in the constraint_hook option, i.e. without the last two arguments). E.g.
     %%     fdbg_on([constraint_hook(filter_events([count/4],my_show))]).
     filter_events(-CtrSpecs, Visualizer, Constraint, Actions) :- !,
             \+ show_constraint(CtrSpecs, Constraint),
             call(Visualizer, Constraint, Actions).
     filter_events(CtrSpecs, Visualizer, Constraint, Actions) :-
             show_constraint(CtrSpecs, Constraint),
             call(Visualizer, Constraint, Actions).

     show_constraint([C|_], Constraint) :-
             matches(C, Constraint), !.
     show_constraint([_|Cs], Constraint) :-
             show_constraint(Cs, Constraint).

     matches(Name/Arity, Constraint) :- !,
             functor(Constraint, Name, Arity).
     matches(Name, Constraint) :-
             atom(Name), !,
             functor(Constraint, Name, _).
     matches(C, Constraint) :-
             C = Constraint.

   Here is a session using the visualizer, filtering out everything but
'all_distinct/2' constraints:

     | ?- [library('clpfd/examples/suudoku')].
     [...]
     | ?- fdbg_on([constraint_hook(filter_events([all_distinct/2]))]).
     % The clp(fd) debugger is switched on
     % advice
     | ?- suudoku([], 1, domain).
     all_distinct([1,<fdvar_1>,<fdvar_2>,8,<fdvar_3>,
                    4,<fdvar_4>,<fdvar_5>,<fdvar_6>],[consistency(domain)])
         fdvar_1 = 1..9 -> (2..3)\/(5..7)\/{9}
         fdvar_2 = 1..9 -> (2..3)\/(5..7)\/{9}
         fdvar_3 = 1..9 -> (2..3)\/(5..7)\/{9}
         fdvar_4 = 1..9 -> (2..3)\/(5..7)\/{9}
         fdvar_5 = 1..9 -> (2..3)\/(5..7)\/{9}
         fdvar_6 = 1..9 -> (2..3)\/(5..7)\/{9}

     [...]

     all_distinct([7,6,2,5,8,4,1,3,9],[consistency(domain)])
         Constraint exited.
     1 5 6 8 9 4 3 2 7
     9 2 8 7 3 1 4 5 6
     4 7 3 2 6 5 9 1 8
     3 6 2 4 1 7 8 9 5
     7 8 9 3 5 2 6 4 1
     5 1 4 9 8 6 2 7 3
     8 3 1 5 4 9 7 6 2
     6 9 7 1 2 3 5 8 4
     2 4 5 6 7 8 1 3 9
     yes
     % advice
     | ?- fdbg_off.
     % The clp(fd) debugger is switched off

   In the next session, all constraints named 'all_distinct' are
ignored, irrespective of arity.  Also, we explicitly specified the
visualizer to be called for the events that are kept (here, we have
written the default, 'fdbg_show', so the actual behavior is not
changed).

     | ?- [library('clpfd/examples/suudoku')].
     [...]
     | ?- fdbg_on([constraint_hook(filter_events(-[all_distinct],fdbg_show))]).
     % The clp(fd) debugger is switched on
     % advice
     | ?- suudoku([], 1, domain).
     domain([1,<fdvar_1>,<fdvar_2>,8,<fdvar_3>, ...,
             <fdvar_50>,<fdvar_51>,9],1,9)
         fdvar_1 = inf..sup -> 1..9
         fdvar_2 = inf..sup -> 1..9
         ...
         fdvar_50 = inf..sup -> 1..9
         fdvar_51 = inf..sup -> 1..9
         Constraint exited.

     [...]
     1 5 6 8 9 4 3 2 7
     9 2 8 7 3 1 4 5 6
     4 7 3 2 6 5 9 1 8
     3 6 2 4 1 7 8 9 5
     7 8 9 3 5 2 6 4 1
     5 1 4 9 8 6 2 7 3
     8 3 1 5 4 9 7 6 2
     6 9 7 1 2 3 5 8 4
     2 4 5 6 7 8 1 3 9
     yes
     % advice
     | ?- fdbg_off.
     % The clp(fd) debugger is switched off

   In the last session, we specify a list of constraints to ignore,
using a pattern to select the appropriate constraints.  Since all
constraints in the example match one of the items in the given list, no
events are printed.

     | ?- [library('clpfd/examples/suudoku')].
     [...]
     | ?- fdbg_on([constraint_hook(filter_events(-[domain(_,1,9),all_distinct]))]).
     % The clp(fd) debugger is switched on
     % advice
     | ?- suudoku([], 1, domain).
     1 5 6 8 9 4 3 2 7
     9 2 8 7 3 1 4 5 6
     4 7 3 2 6 5 9 1 8
     3 6 2 4 1 7 8 9 5
     7 8 9 3 5 2 6 4 1
     5 1 4 9 8 6 2 7 3
     8 3 1 5 4 9 7 6 2
     6 9 7 1 2 3 5 8 4
     2 4 5 6 7 8 1 3 9
     yes
     % advice
     | ?- fdbg_off.
     % The clp(fd) debugger is switched off


File: sicstus.info,  Node: FDBG Debugging Global Constraints,  Prev: FDBG Showing Selected Constraints (advanced version),  Up: FDBG Advanced Usage

10.15.4.6 Debugging Global Constraints
......................................

Missing pruning and excessive pruning are the two major classes of bugs
in the implementation of global constraints.  Since CLP(FD) is an
incomplete constraint solver, missing pruning is mainly an efficiency
concern (but _ground_ instances for which the constraint does not hold
should be rejected).  Excessive pruning, however, means that some valid
combinations of values are pruned away, leading to missing solutions.
The following exported predicate helps spotting excessive pruning in
user-defined global constraints:

'fdbg_guard(:GOAL, +CONSTRAINT, +ACTIONS)'
     A constraint visualizer that does no output, but notifies the user
     by calling GOAL if a solution is lost through domain narrowings.
     Naturally you have to inform 'fdbg_guard/3' about the solution in
     question--stating which variables should have which values.  To use
     'fdbg_guard/3', first:

       1. Set it up as a visualizer by calling:

               fdbg_on([..., constraint_hook(fdbg_guard(GOAL)), ...])

          As usual, the two other arguments will be supplied by the FDBG
          core when calling 'fdbg_guard/3'.

       2. At the beginning of your program, form a pair of lists 'XS-VS'
          where XS is the list of variables and VS is the list of values
          in question.  This pair should then be assigned the name
          'fdbg_guard' using:
               | ?- fdbg_assign_name(XS-VS, fdbg_guard).

     When these steps have been taken, 'fdbg_guard/3' will watch the
     domain changes of XS done by each constraint C.  Whenever VS is in
     the domains of XS at entry to C, but not at exit from C, GOAL is
     called with three more arguments:

     VARIABLE LIST
          a list of 'VARIABLE-VALUE' terms for which VALUE was removed
          from the domain of VARIABLE
     CONSTRAINT
          the constraint that was handled by the dispatcher
     ACTIONS
          the action list returned by the dispatcher

   We will now show an example using 'fdbg_guard/3'.  First, we will
need a few extra lines of code:

     %% print_and_trace(MissValues, Constraint, Actions):  To be used as a Goal for
     %%   fdbg_guard to call when the given solution was removed from the domains
     %%   of the variables.
     %%
     %%   MissValues is a list of Var-Value pairs, where Value is the value that
     %%   should appear in the domain of Var, but has been removed.  Constraint is
     %%   the current constraint and Actions is the list of actions returned by it.
     %%
     %%   This predicate prints MissValues in a textual form, then shows the current
     %%   (culprit) constraint (as done by fdbg_show/2), then turns on the Prolog
     %%   tracer.
     print_and_trace(MissValues, Constraint, Actions) :-
             print(fdbg_output, '\nFDBG Guard:\n'),
             display_missing_values(MissValues),
             print(fdbg_output, '\nCulprit constraint:\n\n'),
             fdbg_show(Constraint, Actions),
             trace.

     display_missing_values([]).
     display_missing_values([Var-Val|MissVals]) :-
             fdbg_annotate(Var,AVar,_),
             format(fdbg_output, '  ~d was removed from ~p~n', [Val,AVar]),
             display_missing_values(MissVals).

   Suppose that we have written the following N Queens program, using a
global constraint 'no_threat/3' with a bug in it:

     :- use_module(library(fdbg)).
     :- use_module(library(clpfd)).

     queens(L, N) :-
             length(L, N),
             domain(L, 1, N),
             constrain_all(L),
             labeling([enum], L).

     constrain_all([]).
     constrain_all([X|Xs]):-
             constrain_between(X,Xs,1),
             constrain_all(Xs).

     constrain_between(_X,[],_N).
     constrain_between(X,[Y|Ys],N) :-
             no_threat(X,Y,N),
             N1 is N+1,
             constrain_between(X,Ys,N1).

     no_threat(X,Y,I) :-
             fd_global(no_threat(X,Y,I), 0, [val(X),val(Y)]).

     :- multifile clpfd:dispatch_global/4.
     clpfd:dispatch_global(no_threat(X,Y,I), S, S, Actions) :-
             ground(X), !,
             remove_threat(Y, X, I, NewYSet),
             Actions = [exit, Y in_set NewYSet].
     clpfd:dispatch_global(no_threat(X,Y,I), S, S, Actions) :-
             ground(Y), !,
             remove_threat(X, Y, I, NewXSet),
             Actions = [exit, X in_set NewXSet].
     clpfd:dispatch_global(no_threat(_,_,_), S, S, []).

     remove_threat(X, V, I, Set) :-
             Vp is V+I+1,   % Bug introduced here
     %       Vp is V+I,     % Good code
             Vn is V-I,
             fd_set(X, Set0),
             list_to_fdset([Vn, V, Vp], VSet),
             fdset_subtract(Set0, VSet, Set).

     missing(L, Tuple) :-
          length(Tuple, N),
          length(L, N),
          domain(L, 1, N),
          lex_chain([[2,4,1,3],L]),
          fdbg_assign_name(L-Tuple, fdbg_guard),
          fdbg_assign_name(L, board),
          fdbg_on([constraint_hook(fdbg_guard(print_and_trace))]),
          queens(L, N).

   We will now use 'print_and_trace/3' as an argument to the
'fdbg_guard' visualizer to handle the case when a solution has been
removed by a constraint.  The bug shown above causes three invalid
solutions to be found instead of the two correct solutions '[2,4,1,3]'
and '[3,1,4,2]'.  The constraint:

     'lex_chain([[2,4,1,3],L]),'

constraints the search to solutions lexicographically greater than or
equal to the first correct solution, and FDBG is told to watch for its
disappearance.  At some point, the buggy constraint removes it, and
'fdbg_guard/3' calls the given predicate.  This prints the cause of
waking (the value that should not have been removed by the constraint),
prints the constraint itself, then switches the Prolog debugger to trace
mode.  At this point, we type 'A' (*note FDBG Debugger Commands::) to
print the annotated form of the goal containing the culprit constraint.
Finally, we type 'A [2,4]' to print the same information, but taking
into account the action list, which is the 4th argument of the 2nd
argument of the module prefixed goal.  For clarity, the labeling events
were not turned off in the session below.

   This example shows how FDBG can be used to narrow down what causes
invalid pruning.

     | ?- missing(L, [2,4,1,3]).
     % The clp(fd) debugger is switched on
     Labeling [8, <board_1>]: starting in range 2..4.
     Labeling [8, <board_1>]: indomain_up: <board_1> = 2


     FDBG Guard:
       4 was removed from <board_2>

     Culprit constraint:

     user:no_threat(2,<board_2>,1)
         board_2 = 1..4 -> {3}
         Constraint exited.

     % The debugger will first creep -- showing everything (trace)
            11      2 Exit:
            clpfd:dispatch_global_fast(no_threat(2,_1511,1),0,0,
            [exit,_1511 in_set[[3|3]]],
            global('$mutable'(0,0),no_threat(2,_1511,1),'$mutable'(11,596),
            _10779,user:no_threat(2,_1511,1))) ? A

     clpfd:dispatch_global_fast(no_threat(2,<board_2>,1),0,0,
             [exit,<board_2> in_set[[3|3]]],global($mutable(0,0),no_threat(2,<board_2>,1),
             $mutable(11,596),<fdvar_1>,user:no_threat(2,<board_2>,1)))
         board_2 = 1..4
         fdvar_1 = inf..sup

            11      2 Exit:
            clpfd:dispatch_global_fast(no_threat(2,_1511,1),0,0,
            [exit,_1511 in_set[[3|3]]],
            global('$mutable'(0,0),no_threat(2,_1511,1),'$mutable'(11,596),
            _23859,user:no_threat(2,_1511,1))) ? A [2,4]

     clpfd:dispatch_global_fast(no_threat(2,<board_2>,1),0,0,
             [exit,<board_2> in_set[[3|3]]],global($mutable(0,0),no_threat(2,<board_2>,1),
             $mutable(11,596),<fdvar_1>,user:no_threat(2,<board_2>,1)))
         board_2 = 1..4 -> {3}
         fdvar_1 = inf..sup
         Constraint exited.

            11      2 Exit:
            clpfd:dispatch_global_fast(no_threat(2,_1511,1),0,0,
            [exit,_1511
            in_set[[3|3]]],global('$mutable'(0,0),no_threat(2,_1511,1),'$mutable'(11,596),
            _23859,user:no_threat(2,_1511,1))) ? a
     % Execution aborted
     % advice,source_info
     | ?- fdbg_off.
     % The clp(fd) debugger is switched off


File: sicstus.info,  Node: lib-file_systems,  Next: lib-gauge,  Prev: lib-fdbg,  Up: The Prolog Library

10.16 Accessing Files And Directories--'library(file_systems)'
==============================================================

This module provides operations on files and directories, such as
renaming, deleting, opening, checking permissions, accessing members of.

   The following principles have been observed:

   * An absolute distinction is drawn between files and directories.
     The set of operations one can usefully perform on a directory is
     different from the set one can perform on a file: for example,
     having write permission to a directory allows the user to create
     new files in it, not to rewrite the entire directory!  If any
     routine in this package tells you that a "file" exists, you can be
     sure that it means a file and not a directory (and vice versa for
     "directory" exists).
   * The directory scanning routines do not actually open the files they
     find.  Thus finer discriminations, such as that between source and
     object code, are not made.
   * All paths are expanded as if by 'absolute_file_name/3'.
   * Every predicate acts like a genuine logical relation insofar as it
     possibly can.
   * If anything goes wrong, the predicates raise an error exception.
     Any time that a predicate fails quietly, it should mean "this
     question is meaningful, but the answer is no".
   * The directory scanning routines insist that the directory argument
     name a searchable directory.
   * On Unix-like systems, symbolic links are followed by default and
     symbolic links that can not be followed are treated as
     non-existing.  This means 'file_exists/1' will fail if passed such
     a "broken" link and that neither 'file_members_of_directory/1' nor
     'directory_members_of_directory/1' et al. will return such a link.

     On Windows, symbolic links (and other reparse points) are _not_
     followed when enumerating directory contents with
     'file_members_of_directory/1' nor
     'directory_members_of_directory/1' et al. and are not returned for
     these predicates.

     The behavior for symbolic links (and reparse points) may change on
     all platforms in the future to ensure a well defined and consistent
     behavior on all platforms.

     To see _all_ members of a directory you can use
     'absolute_file_name/3' with a 'glob('*')' option.

   The "property" routines use the same simplistic access control model
as that used by the 'absolute_file_name/3' 'access/1'-option.  *Note
mpg-ref-absolute_file_name::, for details.

   Exported predicates:

'rename_file(+OLDNAME, +NEWNAME)'

     OLDNAME must identify an existing file, which will be renamed to
     NEWNAME.  The details of just when this can be done are
     operating-system dependent.  Typically it is only possible to
     rename within the same file system.
'rename_directory(+OLDNAME, +NEWNAME)'

     OLDNAME must identify an existing directory, which will be renamed
     to NEWNAME.  The details of just when this can be done are
     operating-system dependent.  Typically it is only possible to
     rename empty directories within the same file system.
'delete_file(+OLDNAME)'

     OLDNAME must identify an existing file, which will be deleted.
'delete_directory(+DIRECTORY)'
'delete_directory(+DIRECTORY, +OPTIONS)'

     DIRECTORY must identify an existing directory, which will be
     deleted, if empty.  OPTIONS should be a list of at most one term of
     the form:
     'if_nonempty(VALUE)'
          Defines what to do if the directory is nonempty.  One of:
          'ignore'
               The predicate simply succeeds, deleting nothing.
          'fail'
               The predicate simply fails, deleting nothing.
          'error'
               The predicate raises a permisison error.
          'delete'
               The predicate recursively deletes the directory and its
               contents.
'directory_exists(+DIRECTORY)'
'directory_exists(+DIRECTORY, +MODE)'

     is true when DIRECTORY is an existing directory that is accessible
     according to MODE.  MODE defaults to 'exist'.

     This is more or less equivalent to 'absolute_file_name(FILE, _,
     [file_type(directory),access([exist|MODE]),file_errors(fail)])'.
'make_directory(+DIRECTORY)'

     DIRECTORY is expanded, as if by 'absolute_file_name/3', and the
     resulting directory is created.
'file_exists(+FILE)'
'file_exists(+FILE, +MODE)'

     is true when FILE is an existing file that is accessible according
     to MODE.  MODE defaults to 'exist'.

     This is more or less equivalent to 'absolute_file_name(FILE, _,
     [access([exist|MODE]),file_errors(fail)])'.
'file_must_exist(+FILE)'
'file_must_exist(+FILE, +MODE)'

     is like 'file_exists(FILE[, MODE])' except that if the file is
     _not_ accessible it reports an error.

     This is more or less equivalent to 'absolute_file_name(FILE, _,
     [access([exist|MODE]),file_errors(error)])'.
'directory_must_exist(+FILE)'
'directory_must_exist(+FILE, +MODE)'

     is like 'file_must_exists(FILE[, MODE])', but for directories.

     This is more or less equivalent to 'absolute_file_name(FILE, _,
     [file_type(directory),access([exists|MODE]),file_errors(error)])'.
'close_all_streams'

     closes all the streams (other than the standard streams) which are
     currently open.  The time to call this is after an 'abort/0'.  Note
     that 'current_stream/3' does not notice the standard streams.
'directory_member_of_directory(?BASENAME, ?FULLNAME)'

     is true when BASENAME is the name of a subdirectory of the current
     directory (other than '.'  or '..')  and FULLNAME is its absolute
     name.

     This uses 'absolute_file_name/3' with the 'glob/1' option.
'directory_member_of_directory(+DIRECTORY, ?BASENAME, ?FULLNAME)'

     is true when DIRECTORY is a name (not necessarily the absolute
     name) of a directory, BASENAME is the name of a subdirectory of
     that directory (other than '.'  or '..')  and FULLNAME is its
     absolute name.

     This uses 'absolute_file_name/3' with the 'glob/1' option.
'directory_member_of_directory(+DIRECTORY, +PATTERN, ?BASENAME, ?FULLNAME)'

     is true when DIRECTORY is a name (not necessarily the absolute
     name) of a directory, BASENAME is the name of a directory of that
     directory (other than '.'  or '..')  which matches the given
     PATTERN, and FULLNAME is the absolute name of the subdirectory.

     This uses 'absolute_file_name/3' with a 'glob(PATTERN)' option.
'directory_members_of_directory(-SET)'

     is true when SET is a set of BASENAME-FULLNAME pairs being the
     relative and absolute names of subdirectories of the current
     directory.

     This uses 'absolute_file_name/3' with the 'glob/1' option.
'directory_members_of_directory(+DIRECTORY, -SET)'
     is true when SET is a set of BASENAME-FULLNAME pairs being the
     relative and absolute names of subdirectories of the given
     DIRECTORY.  DIRECTORY need not be absolute; the FULLNAMES will be
     regardless.

     This uses 'absolute_file_name/3' with the 'glob/1' option.
'directory_members_of_directory(+DIRECTORY, +PATTERN, -SET)'
     is true when SET is a set of BASENAME-FULLNAME pairs being the
     relative and absolute names of subdirectories of the given
     DIRECTORY, such that each BASENAME matches the given Pattern.

     This uses 'absolute_file_name/3' with a 'glob(PATTERN)' option.
'file_member_of_directory(?BASENAME, ?FULLNAME)'

     is true when BASENAME is the name of a file in the current
     directory and FULLNAME is its absolute name.

     This uses 'absolute_file_name/3' with the 'glob/1' option.
'file_member_of_directory(+DIRECTORY, ?BASENAME, ?FULLNAME)'
     is true when DIRECTORY is a name (not necessarily the absolute
     name) of a directory, BASENAME is the name of a file in that
     directory, and FULLNAME is its absolute name.

     This uses 'absolute_file_name/3' with the 'glob/1' option.
'file_member_of_directory(+DIRECTORY, +PATTERN, ?BASENAME, ?FULLNAME)'
     is true when DIRECTORY is a name (not necessarily the absolute
     name) of a directory, BASENAME is the name of a file in that
     directory which matches the given PATTERN, and FULLNAME is its
     absolute name.

     This uses 'absolute_file_name/3' with a 'glob(PATTERN)' option.
'file_members_of_directory(-SET)'

     is true when SET is a set of BASENAME-FULLNAME pairs being the
     relative and absolute names of the files in the current directory.

     This uses 'absolute_file_name/3' with the 'glob/1' option.
'file_members_of_directory(+DIRECTORY, -SET)'
     is true when SET is a set of BASENAME-FULLNAME pairs being the
     relative and absolute names of the files in the given DIRECTORY.
     DIRECTORY need not be absolute; the FULLNAMES will be regardless.

     This uses 'absolute_file_name/3' with the 'glob/1' option.
'file_members_of_directory(+DIRECTORY, +PATTERN, -SET)'
     is true when SET is a set of BASENAME-FULLNAME pairs being the
     relative and absolute names of subdirectories of the given
     DIRECTORY, such that each BASENAME matches the given PATTERN.

     This uses 'absolute_file_name/3' with a 'glob(PATTERN)' option.
'directory_property(+DIRECTORY, ?PROPERTY)'

     is true when DIRECTORY is a name of a directory, and PROPERTY is a
     boolean property which that directory possesses, e.g.
              directory_property(., searchable).

     The current set of file and directory properties include:
     'readable'
     'writable'
     'executable'
     'searchable'

          Tries to determine whether the process has permission to read,
          write, execute (only for files) or search (only for
          directories) the file.

     'size_in_bytes'
          The size, in bytes, of the file.  Not available for
          directories.

     'create_timestamp'
     'modify_timestamp'
     'access_timestamp'

          The time of creation, last modification or last access
          expressed as a timestamp.  A "timestamp" is an integer
          expressing the time interval, in seconds, since the "Epoch".
          The "Epoch" is the time zero hours, zero minutes, zero
          seconds, on January 1, 1970 Coordinated Universal Time (UTC).

          The timestamp is what should be used when comparing
          information between files since it is independent of locale
          issues like time zone and daylight savings time etc.

     'create_localtime'
     'modify_localtime'
     'access_localtime'

          The same as the corresponding '..._timestamp' values passed
          through 'system:datime/2', i.e. expressed as local time and
          split up in the components year, month, day, hour, minute,
          seconds.

     'set_user_id'
     'set_group_id'
     'save_text'

          True if the set-uid, set-group-id, save-text bits,
          respectively, are set for the file.  Always false on Windows.

     'who_can_read'
     'who_can_write'
     'who_can_execute'
     'who_can_search'

          A list containing the subset of '[user,group,other]' for the
          process classes that can, respectively, read, write, execute
          (only for files) or search (only for directories.

     'owner_user_id'
     'owner_group_id'

          The id of the owner and group of the file.  The id is an
          integer on UNIX and an atom (expressed as a string security
          identifier) on Windows.

     'owner_user_name'
     'owner_group_group'

          The atom containing the name of the files owner and group
          respectively.  On Windows a name like ''DOMAIN\NAME'' will be
          used.

          If for some reason the name cannot be found it will fall back
          to using the same value as 'owner_user_id' and
          'owner_group_id'.

     Other properties may be added in the future.  You can backtrack
     through the available properties by calling 'file_property/3' or
     'directory_property/3' with an uninstantiated PROPERTY argument.

'directory_property(+DIRECTORY, ?PROPERTY, ?VALUE)'
     is true when DIRECTORY is a name of a directory, PROPERTY is a
     property of directories, and VALUE is DIRECTORY's PROPERTY VALUE.
     See 'directory_property/2', above, for a list of properties.
'file_property(+FILE, ?PROPERTY)'

     is true when FILE is a name of a file, and PROPERTY is a boolean
     property which that file possesses, e.g.
              file_property('foo.txt', readable).
     See 'directory_property/2', above, for a list of properties.
'file_property(+FILE, ?PROPERTY, ?VALUE)'
     is true when FILE is a name of a file, PROPERTY is a property of
     files, and VALUE is FILE's PROPERTY VALUE.  See
     'directory_property/2', above, for a list of properties.
'current_directory(-DIRECTORY)'
'current_directory(-DIRECTORY, +NEWDIRECTORY)'

     DIRECTORY is unified with the current working directory and the
     working directory is set to NEWDIRECTORY.


File: sicstus.info,  Node: lib-gauge,  Next: lib-heaps,  Prev: lib-file_systems,  Up: The Prolog Library

10.17 The Gauge Profiling Tool--'library(gauge)'
================================================

The Gauge library package is a graphical interface to the SICStus
built-in predicates 'profile_data/1' and 'profile_reset/0'.  *Note
Execution Profiling::.  for more information about execution profiling.
The interface is based on Tcl/Tk (*note lib-tcltk::).

   The SICStus IDE (*note SPIDER::) can also show profiling information.
This makes the Gauge library largely obsolescent.

'view   since release 4.2'

     Creates a graphical user interface for viewing the profile data
     accumulated so far.  When the display first comes up it is blank
     except for the control panel.  A screen shot is shown below.


 [image src="images/gauge.png" text="" ]
                    Gauge graphical user interface

   The menus and buttons on the control panel are used as follows:

_Specification_
     Selects what statistics to display.  One of:

     _Calls_
          The number of times a predicate was called.

     _Instructions_
          The number of abstract instructions executed, plus two times
          the number of choice point accesses.

     _Choicepoints_
          Number of choicepoints accessed (saved or restored).

_Sort Order_
     Selects the sort order of the histogram.  One of:

     _Alphabetic_
          Sort the bars in alphabetic order.

     _Descending values_
          Sort the bars by descending values.

     _Ascending values_
          Sort the bars by ascending values.

     _Top 40_
          Show just the 40 highest values in descending order.

_Scale_
     Controls the scaling of the bars.  One of:

     _Linear_
          Display values with a linear scale.

     _Logarithmic_
          Display values with a logarithmic scale.

_Show_
     Controls whether to show bars with zero counts.  One of:

     _All_
          Show all values in the histogram.

     _No zero values_
          Show only non-zero values.

_Font_
     The font used in the histogram chart.

_Calculate_
     Calculates the values according to the current settings.  The
     values are displayed in a histogram.

_Reset_
     The execution counters of the selected predicates and clauses are
     reset.

_Print_
     A choice of printing the histogram on a Postscript printer, or to a
     file.

_Help_
     Shows a help text.

_Quit_
     Quits Gauge and closes its windows.

   By clicking on the bars of the histogram, the figures are displayed
in the _Value Info_ window.


File: sicstus.info,  Node: lib-heaps,  Next: lib-jasper,  Prev: lib-gauge,  Up: The Prolog Library

10.18 Heap Operations--'library(heaps)'
=======================================

A heap is a labelled binary tree where the key of each node is less than
or equal to the keys of its sons.  The point of a heap is that we can
keep on adding new elements to the heap and we can keep on taking out
the minimum element.  If there are N elements total, the total time is
O(N LG N).  If you know all the elements in advance, you are better off
doing a merge-sort, but this file is for when you want to do say a
best-first search, and have no idea when you start how many elements
there will be, let alone what they are.

   A heap is represented as a triple 'heap(N,Free,Tree)' where N is the
number of elements in the tree, FREE is a list of integers which
specifies unused positions in the tree, and TREE is a tree made of:
'heap'
     terms for empty subtrees and
'heap(KEY,DATUM,LSON,RSON)'
     terms for the rest

   The nodes of the tree are notionally numbered like this:

                                     1
                      2				    3
              4               6               5               7
          8      12      10     14       9       13      11     15
       ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..
   The idea is that if the maximum number of elements that have been in
the heap so far is M, and the tree currently has K elements, the tree is
some subtreee of the tree of this form having exactly M elements, and
the FREE list is a list of M-K integers saying which of the positions in
the M-element tree are currently unoccupied.  This free list is needed
to ensure that the cost of passing N elements through the heap is O(N LG
M) instead of O(N LG N).  For M say 100 and N say 10^4 this means a
factor of two.  The cost of the free list is slight.  The storage cost
of a heap in a copying Prolog is 2K+3M words.  Exported predicates:

'add_to_heap(+OLDHEAP, +KEY, +DATUM, -NEWHEAP)'
'add_to_heap/4 (heaps)'
     inserts the new KEY-DATUM pair into the heap.  The insertion is not
     stable, that is, if you insert several pairs with the same KEY it
     is not defined which of them will come out first, and it is
     possible for any of them to come out first depending on the history
     of the heap.
'delete_from_heap(+OLDHEAP, +KEY, -DATUM, -NEWHEAP)'
'delete_from_heap/4 (heaps)'
     deletes a single KEY-DATUM pair from the OLDHEAP producing a
     NEWHEAP.  This is useful if you want to e.g.  change the priority
     of Datum.
'get_from_heap(+OLDHEAP, -KEY, -DATUM, -NEWHEAP)'
'get_from_heap/4 (heaps)'
     returns the KEY-DATUM pair in OLDHEAP with the smallest KEY, and
     also a NEWHEAP which is the OLDHEAP with that pair deleted.
'heap_size(+HEAP, -SIZE)'
'heap_size/2 (heaps)'
     reports the number of elements currently in the heap.
'heap_to_list(+HEAP, -LIST)'
'heap_to_list/2 (heaps)'
     returns the current set of KEY-DATUM pairs in the HEAP as a LIST,
     sorted into ascending order of KEYS.
'list_to_heap(+LIST, -HEAP)'
'list_to_heap/2 (heaps)'
     takes a proper list of KEY-DATUM pairs (such as 'keysort/2' could
     be used to sort) and forms them into a heap.
'empty_heap(?HEAP)'
'empty_heap/1 (heaps)'
     is true when HEAP represents an empty heap.  There is only one way
     it can be true.
'is_heap(+HEAP)'
'is_heap/1 (heaps)'
     is true when HEAP is a well formed heap.  For this to be true, the
     size must be right and the tree must satisfy the heap condition.
'min_of_heap(+HEAP, -KEY, -DATUM)'
'min_of_heap/3 (heaps)'
     returns the KEY-DATUM pair at the top of the heap (which is of
     course the pair with the smallest KEY), but does not remove it from
     the heap.  It fails if the heap is empty.
'min_of_heap(+HEAP, -KEY1, -DATUM1, -KEY2, -DATUM2)'
'min_of_heap/5 (heaps)'
     returns the smallest (KEY1) and second smallest (KEY2) pairs in the
     heap, without deleting them.  It fails if the heap does not have at
     least two elements.
'portray_heap(+HEAP)'
'portray_heap/1 (heaps)'
     writes a heap to the current output stream in a pretty format so
     that you can easily see what it is.  Note that a heap written out
     this way can _not_ be read back in.  The point of this predicate is
     that you can add a clause
              portray(X) :- is_heap(X), !, portray_heap(X).


File: sicstus.info,  Node: lib-jasper,  Next: lib-linda,  Prev: lib-heaps,  Up: The Prolog Library

10.19 Jasper Interface--'library(jasper)'
=========================================

* Menu:

* Jasper Overview:: Jasper Overview
* Getting Started:: Getting Started
* Calling Prolog from Java:: Calling Prolog from Java
* Jasper Package Class Reference:: Jasper Package Class Reference
* Java Exception Handling:: Java Exception Handling
* SPTerm and Memory:: SPTerm and Memory
* Java Threads:: Java Threads
* The Jasper Library: The Jasper Library


File: sicstus.info,  Node: Jasper Overview,  Next: Getting Started,  Up: lib-jasper

10.19.1 Jasper Overview
-----------------------

Jasper is a bi-directional interface between Java and SICStus.  The
Java-side of the interface consists of a Java package ('se.sics.jasper')
containing classes representing the SICStus runtime system ('SICStus',
'SPTerm', etc).  The Prolog part is designed as a library module
('library(jasper)').

   The library module 'library(jasper)' (*note The Jasper Library::)
provides functionality for controlling the loading and unloading the JVM
(Java Virtual Machine), method call functionality ('jasper_call/4'), and
predicates for managing object references.

   Jasper can be used in two modes, depending on which system acts as
"Parent Application".  If Java is the parent application, then the
SICStus runtime kernel will be loaded into the JVM using the
'System.loadLibrary()' method (this is done indirectly when
instantiating a 'SICStus' object).  In this mode, SICStus is loaded as a
runtime system (*note Runtime Systems::).

   As of release 3.9, it is possible to use Jasper in multi threaded
mode.  This means that several Java threads can call SICStus runtime via
a server thread.  The communication between the client threads and the
server thread is hidden from the programmer, and the API is based on
Java 'Interfaces', which are implemented both by the multi thread
capable classes and the pre-3.9 classes, which are restricted to single
threaded mode.  The decision whether to run in single thread mode or in
multi threaded mode can thus be left until runtime.

   If SICStus is the parent application, then Java will be loaded as a
foreign resource using the query 'use_module(library(jasper))'.  The
Java engine is initialized using 'jasper_initialize/[1,2]'.

   * Some of the information in this chapter is a recapitulation of the
     information in *note Mixing C and Prolog::.  The intention is that
     this chapter should be possible to read fairly independently.
   * Before proceeding, please read *note Jasper Notes: (relnotes)Jasper
     Notes.  It contains important information about requirements,
     availability, installation tips, limitations, and how to access
     other (online) Jasper/Java resources.


File: sicstus.info,  Node: Getting Started,  Next: Calling Prolog from Java,  Prev: Jasper Overview,  Up: lib-jasper

10.19.2 Getting Started
-----------------------

*Note Java: (relnotes)Getting Started.  for a detailed description of
how to get started using the interface.  It addresses issues such as
finding SICStus from within Java and vice versa, setting the classpath
correctly, etc.  If you have trouble in getting started with Jasper,
then read that chapter before contacting SICStus Support.


File: sicstus.info,  Node: Calling Prolog from Java,  Next: Jasper Package Class Reference,  Prev: Getting Started,  Up: lib-jasper

10.19.3 Calling Prolog from Java
--------------------------------

Calling Prolog from Java is done by using the Java package
'se.sics.jasper'.  This package contains a set of Java classes, which
can be used to create and manipulate terms, ask queries and request one
or more solutions.  The functionality provided by this set of classes is
basically the same as the functionality provided by the C-Prolog
interface (*note Mixing C and Prolog::).

   It is possible to debug the Prolog code using the Prolog debugger,
either from the command line or from the SICStus Prolog IDE (SPIDER),
see *note Examples of Debugging Runtime Systems::.

   The usage is easiest described by some examples.

* Menu:

* Single Threaded Example:: Single Threaded Example
* Multi Threaded Example:: Multi Threaded Example
* Another Multi Threaded Example (Prolog Top-Level):: Another Multi Threaded Example (Prolog Top-Level)


File: sicstus.info,  Node: Single Threaded Example,  Next: Multi Threaded Example,  Up: Calling Prolog from Java

10.19.3.1 Single Threaded Example
.................................

The following is a Java version of the 'train' example.  *Note Train
Example::.  for information about how the 'train.sav' file is created.

   This code demonstrates the use of Jasper in single threaded mode.  In
this mode only one thread can access the SICStus runtime via a 'SICStus'
object.

                                                       _// Simple.java_
     import se.sics.jasper.SICStus;
     import se.sics.jasper.Query;
     import java.util.HashMap;

     public class Simple
     {
         public static void main(String argv[]) {

             SICStus sp;
             Query query;
             HashMap WayMap = new HashMap();

             try {
                 sp = new SICStus(argv,null);

     	    sp.restore("train.sav");

                 query = sp.openPrologQuery("connected('rebro', 'Stockholm',
                                            Way, Way).",
                                      WayMap);

                 try {
                     while (query.nextSolution()) {
                         System.out.println(WayMap);
                     }
                 } finally {
                     query.close();
                 }
             }
             catch ( Exception e ) {
                 e.printStackTrace();
             }
         }
     }

   It is assumed that the reader has read the section on *note Getting
Started::, which describes how to get the basics up and running.

   This is how the example works:

  1. Before any predicates can be called, the SICStus runtime system
     must be initialized.  This is done by instantiating the 'SICStus'
     class.  Each SICStus object correspond to one independent copy of
     the SICStus runtime system (a rather heavy-weight entity).

     In this example, we have specified 'null' as the second argument to
     'SICStus'.  This instructs SICStus to search for 'sprt.sav' using
     its own internal methods.

  2. Queries are made through method 'query'.  The arguments to this
     method are a string specifying a Prolog goal, and a 'Map', which
     will contain a mapping of variable names to bindings.  This method
     is for finding a single solution.  Note that the string is read by
     the Prolog reader, so it must conform to the syntax rules for
     Prolog, including the terminating period.  There are two more
     methods for making queries: 'queryCutFail', for side-effects only,
     and 'openQuery' to produce several solutions through backtracking.

  3. The next step is to load the Prolog code.  This is done by the
     method 'restore'.  Corresponds to 'SP_restore()' in the
     C-interface.  *Note Loading Prolog Code::.  Note that this method
     must be called before any other SICStus method is called.  See the
     HTML Jasper documentation for details.

  4. The 'openQuery' method returns a reference to a query, an object
     implementing the 'Query' interface.  To obtain solutions, the
     method 'nextSolution' is called with no arguments.  'nextSolution'
     returns 'true' as long as there are more solutions, and the example
     above will print the value of the Map 'WayMap' until there are no
     more solutions.  Note that the query must be closed, even if
     'nextSolution' has indicated that there are no more solutions.


File: sicstus.info,  Node: Multi Threaded Example,  Next: Another Multi Threaded Example (Prolog Top-Level),  Prev: Single Threaded Example,  Up: Calling Prolog from Java

10.19.3.2 Multi Threaded Example
................................

Following is a Java version of the 'train' example.

   This is a multi threaded version of the 'train' example.  In this
mode several threads can access the SICStus runtime via a 'Prolog
interface'.  The static method 'Jasper.newProlog()' returns an object
that implements a 'Prolog interface'.  A thread can make queries by
calling the query-methods of the Prolog object.  The calls will be sent
to a separate server thread that does the actual call to SICStus
runtime.

                                                  _// MultiSimple.java_
     import se.sics.jasper.Jasper;
     import se.sics.jasper.Query;
     import se.sics.jasper.Prolog;
     import java.util.HashMap;

     public class MultiSimple
     {
         class Client extends Thread
         {
             Prolog jp;
             String qs;

             Client(Prolog p,String queryString)
             {
                 jp = p;
                 qs = queryString;
             }
             public void run()
             {
                 HashMap WayMap = new HashMap();
                 try {
                     synchronized(jp) {
                         Query query = jp.openPrologQuery(qs, WayMap);
                         try {
                             while (query.nextSolution()) {
                                 System.out.println(WayMap);
                             }
                         } finally {
                             query.close();
                         }
                     }
                 } catch ( Exception e ) {
                     e.printStackTrace();
                 }
             }
         }
         {
             try {
                 Prolog jp = Jasper.newProlog(argv,null,"train.sav");

                 Client c1 =
                     new Client(jp,"connected('rebro', 'Hallsberg',
                                Way1, Way1).");
                 c1.start();
                 // The prolog variable names are different from above
                 // so we can tell which query gives what solution.
                 Client c2 =
                     new Client(jp,"connected('Stockholm', 'Hallsberg',
                                Way2, Way2).");
                 c2.start();
             }
             catch ( Exception e ) {
                 e.printStackTrace();
             }
         }

         public static void main(String argv[])
         {
             new MultiSimple(argv);
         }
     }

  1. The 'Prolog' object 'jp' is the interface to SICStus.  It
     implements the methods of 'interface Prolog', making it possible to
     write quite similar code for single threaded and multi threaded
     usage of Jasper.  The static method 'Jasper.newProlog()' returns
     such an object.

  2. In this example, the Prolog code is loaded by the server thread
     just after creating the SICStus object (which is invisible to the
     user).  The third argument to the method 'Jasper.newProlog' is the
     .sav file to restore.  Two threads are then started, which will
     make different queries with the 'connected' predicate.

  3. 'openPrologQuery' is not recommended in multi threaded mode, but if
     you must use it from more than one Java thread, then you should
     enclose the call to 'openPrologQuery' and the closing of the query
     in a single synchronized block, synchronizing on the Prolog object.
     *Note SPTerm and Memory::.  for details on one of the reasons why
     this is necessary.


File: sicstus.info,  Node: Another Multi Threaded Example (Prolog Top-Level),  Prev: Multi Threaded Example,  Up: Calling Prolog from Java

10.19.3.3 Another Multi Threaded Example (Prolog Top-Level)
...........................................................

This is another multi threaded version of the 'train' example (*note
Train Example::).

   In this example, Prolog is the toplevel and Java is invoked via
'library(jasper)'.

                                                 _// MultiSimple2.java_
     import se.sics.jasper.Jasper;
     import se.sics.jasper.Query;
     import se.sics.jasper.Prolog;
     import se.sics.jasper.SICStus;
     import java.util.ArrayList;
     import java.util.HashMap;
     import java.util.ListIterator;

     public class MultiSimple2
     {
         class Client extends Thread
         {
             Prolog jp;
             SICStus sp;
             String qs;

             Client(Prolog p, SICStus s, String queryString)
             {
                 jp = p;
                 sp = s;
                 qs = queryString;
             }
             public void run()
             {
                 HashMap WayMap = new HashMap();
                 try {
                     synchronized(jp) {
                         Query query = jp.openPrologQuery(qs, WayMap);
                         try {
                             while (query.nextSolution()) {
                                 System.out.println(WayMap);
                             }
                         } finally {
                             query.close();
                         }
                     }
                 } catch ( Exception e ) {
                     e.printStackTrace();
                 }
             }
         }
         class Watcher extends Thread
         {
             SICStus mySp;
             ArrayList threadList = new ArrayList(2);

             public boolean add(Client cl)
             {
                 return threadList.add((Object)cl);
             }
             boolean at_least_one_is_alive(ArrayList tl)
             {
                 ListIterator li = tl.listIterator();
                 boolean f = false;
                 while (li.hasNext()) {
                     boolean alive = ((Client)(li.next())).isAlive();
                     f = f || alive;
                 }
                 return f;
             }
             public void run()
             {
                 while (at_least_one_is_alive(threadList)) {
                     try {
                         this.sleep(1000);
                     } catch (InterruptedException ie) {
                         System.err.println("Watcher interrupted.");
                     }
                 }
                 mySp.stopServer();
             }
             Watcher(SICStus sp)
             {
                 mySp = sp;
             }
         }
         public void CallBack()
         {
             try {
                 SICStus sp = SICStus.getCaller(); // get the SICStus object
                 sp.load("train.ql");
                 Prolog jp = sp.newProlog(); // Create a new Prolog Interface
                 Client c1 =
                     new Client(jp, sp,
                                "connected('rebro', 'Hallsberg', Way1, Way1).");
                 c1.start();
                 // The prolog variable names in the Map are different from above so
                 // we can tell which query gives what solution.
                 Client c2 =
                     new Client(jp, sp,
                                "connected('Stockholm', 'Hallsberg', Way2, Way2).");
                 c2.start();
                 Watcher w = new Watcher(sp);
                 w.add(c1);
                 w.add(c2);
                 w.start();
                 sp.startServer();   // And finally start the server. This
                                     //  method call does not return until
                                     //  some other thread calls sp.stopServer().
             }
             catch ( Exception e ) {
                 e.printStackTrace();
             }
         }

     }
                                                    _% multisimple2.pl_
     :- use_module(library(jasper)).
     main:-
             jasper_initialize(JVM),
             jasper_new_object(JVM,
                               'MultiSimple2',
                               init,
                               init,
                               Obj),
             jasper_call(JVM,
                         method('', 'CallBack', [instance]),
                         'CallBack'(+object('')),
                         'CallBack'(Obj)).


  1. This example is similar to the previous multi threaded example
     *Note Multi Threaded Example::, but in this case Prolog is the
     top-level.

  2. Since a SICStus object already exists when the java method
     'CallBack' is called, we cannot use 'Jasper.newProlog' to obtain a
     'Prolog' interface.  Instead we can use the 'SICStus' method
     'getCaller' to get a handle on the 'SICStus' object.

  3. In this example we cannot use the 'restore' method to load the
     Prolog saved-state, since it unloads all foreign resources.  This
     includes 'library(jasper)' from which the call to Java was made.
     Instead the method 'SICStus.load' can be used to load a compiled
     Prolog file.  See the HTML Jasper documentation for details on this
     method.  *Note ref-lod-lod::.  for how to create a '.ql' file.

  4. The rest of the example is similar to the previous multi threaded
     example with the addition of a watcher class, which is used to
     monitor the client threads.  This is necessary if the method
     'startServer' is to return.  See the HTML Jasper documentation on
     the methods 'SICStus.startServer' and 'SICStus.stopServer'.


File: sicstus.info,  Node: Jasper Package Class Reference,  Next: Java Exception Handling,  Prev: Calling Prolog from Java,  Up: lib-jasper

10.19.4 Jasper Package Class Reference
--------------------------------------

Detailed documentation of the classes in the 'jasper' package can be
found in the HTML documentation installed with SICStus and also on the
SICStus documentation page
(<http://sicstus.sics.se/documentation.html>).

     *Please note*: None of the 'se.sics.jasper' methods are thread
     safe, unless explicitly mentioned, they can only be called from the
     thread that created the SICStus object.  (This is different from
     how 'se.sics.jasper' worked in release 3.8.)

   As of release 3.9, Jasper supports multi threaded mode.  Several Java
threads can access SICStus runtime through a server thread that does the
actual calls.

   The API is defined by three 'interfaces': 'Prolog', 'Query' and
'Term'.  The methods of these 'interfaces' are implemented by inner
classes of the 'Jasper' server.  Instances of these inner classes are
returned by methods of the class 'Jasper' and can then be used from
multiple threads by the Java programmer.

   In multi threaded mode the Java programmer obtains an object
implementing the 'interface Prolog'.  That interface has methods similar
to the methods of the 'SICStus' class described below.  'Interface
Query' and 'interface Term' have the same relations to 'class SPQuery'
and 'class SPTerm', respectively.  In addition the 'SICStus' class, the
'SPQuery' class and the 'SPTerm' class all implement the above
interfaces.  The methods of the interfaces are preferred over the old
methods.

   See the HTML documentation for details on the methods of the
'interfaces'.

   *Note Jasper Notes: (relnotes)Jasper Notes.  for limitations in multi
threaded Jasper.

 -- Method on SICStus: boolean query '(String module, String name,
          SPTerm args[])'
     Call NAME with ARGS (a vector of 'SPTerm' objects).  Like
     'once(Module:Name(Args...))'.

     Returns 'true' if the call succeeded, 'false' if the call failed,
     i.e. there were no solutions.

     Introduced in release 3.8.5.

 -- Method on SICStus: boolean query '(String goal, Map varMap)'
     Call a goal specified as a string.

     'goal'
          The textual representation of the goal to execute, with
          terminating period.

     'varMap'
          A map from variable names to SPTerm objects.  Used both for
          passing variable bindings into the goal and to obtain the
          bindings produced by the goal.  May be null.

          On success, the values of variables with names that do not
          start with underscore ('_') will be added to the map.

     Returns 'true' if the call succeeded, 'false' if the call failed,
     i.e. there were no solutions.

          HashMap varMap = new HashMap();

          varMap.put("File", new SPTerm(sp, "datafile.txt"));

          if (sp.query("see(File),do_something(Result),seen.", varMap)) {
             System.out.println("Result==" +
                                ((SPTerm)varMap.get("Result")).toString());
          } else {
             System.out.println("Failed);
          }

     Introduced in release 3.8.5.

 -- Method on SICStus: boolean query '(SPPredicate pred, SPTerm args[])'
     Obsolescent version of 'SICStus::query()' above.

 -- Method on SICStus: boolean queryCutFail '(String module, String
          name, SPTerm args[])'
     Call NAME with ARGS for side-effect only.

     As 'SICStus.query()' it only finds the first solution, and then it
     cuts away all other solutions and fails.

     It corresponds roughly to the following Prolog code:
             ( \+ call(Module:Name(Args...)) -> fail; true )
     Introduced in release 3.8.5.

 -- Method on SICStus: boolean queryCutFail '(String goal, Map varMap)'
     Call a goal specified as a string, for side-effect only.  The map
     is only used for passing variable bindings _into_ the goal.  See
     'query' for details

     Introduced in release 3.8.5.
 -- Method on SICStus: boolean queryCutFail '(SPPredicate pred, SPTerm
          args[])'
     Obsolescent version of 'queryCutFail' above.

 -- Method on SICStus: SPQuery openQuery '(String module, String name,
          SPTerm args[])'
     Sets up a query (an object of class 'SPQuery'), which can later be
     asked to produce solutions.  You must _close_ an opened query when
     no more solutions are required; see below.

     It corresponds roughly to the following Prolog code:
             ( true     % just calling openQuery does not call the predicate

             ; % failing (nextSolution) will backtrack for more solutions
               call(Module:Name(Args...))
             )

     Introduced in release 3.8.5.

 -- Method on SICStus: boolean openQuery '(String goal, Map varMap)'
     Sets up a query specified as a string.  See 'openQuery' and 'query'
     for details.

     Introduced in release 3.8.5.

 -- Method on SICStus: SPQuery openQuery '(SPPredicate pred, SPTerm
          args[])'
     Obsolescent version of 'openQuery' above.

   The following methods are used to obtain solutions from an opened
query and to tell the SICStus runtime system that no more answers are
required.

 -- Method on SPQuery: boolean nextSolution ()
     Obtain the next solution.  Returns 'true' on success and 'false' if
     there were no more solutions.  When you are no longer interested in
     any more solutions, you should call 'SPQuery.close' or
     'SPQuery.cut' to _close_ the query.

     Returns 'true' if a new solution was produced, 'false' if there
     were no more solutions.  This corresponds roughly to 'fail/0'.
     *Note SPTerm and Memory::.  for additional details.

 -- Method on SPQuery: close ()
     Cut and fail away any previous solution to the query.  After
     closing a query object, you should not use it anymore.  This
     corresponds roughly to '!, fail'.  *Note SPTerm and Memory::.  for
     additional details.

 -- Method on SPQuery: cut ()
     Cut, but do not fail away, any previous solution.  After closing a
     query object with 'cut', you should not use it anymore.  This
     corresponds roughly to '!'.  *Note SPTerm and Memory::.  for
     additional details.


File: sicstus.info,  Node: Java Exception Handling,  Next: SPTerm and Memory,  Prev: Jasper Package Class Reference,  Up: lib-jasper

10.19.5 Java Exception Handling
-------------------------------

Exceptions are handled seamlessly between Java and Prolog.  This means
that exceptions can be thrown in Prolog and caught in Java and the other
way around.  For example, if a predicate called from Java throws an
exception with 'throw/1' and the predicate itself does not catch the
exception, then the Java-method that performed the query,
'queryCutFail()' for example, will throw an exception (of class
'SPException') containing the exception term.  Symmetrically, a
Java-exception thrown (and not caught) in a method called from Prolog
will cause the corresponding predicate ('simple/2' in the example above)
to throw an exception consisting of the exception object (in the
internal Prolog representation of a Java object).  *Note Handling Java
Exceptions::.  for examples of catching Java exceptions in Prolog.


File: sicstus.info,  Node: SPTerm and Memory,  Next: Java Threads,  Prev: Java Exception Handling,  Up: lib-jasper

10.19.6 SPTerm and Memory
-------------------------

Java and Prolog have quite different memory management policies.  In
Java, memory is reclaimed when the garbage collector can determine that
no code will ever use the object occupying the memory.  In Prolog, the
garbage collector additionally reclaims memory upon failure (such as the
failure implied in the use of 'SPQuery.close()' and
'SPQuery::nextSolution()').  This mismatch in the notion of memory
lifetime can occasionally cause problems.

* Menu:

* Lifetime of SPTerms and Prolog Memory:: Lifetime of SPTerms and Prolog Memory
* Preventing SPTerm Memory Leaks:: Preventing SPTerm Memory Leaks


File: sicstus.info,  Node: Lifetime of SPTerms and Prolog Memory,  Next: Preventing SPTerm Memory Leaks,  Up: SPTerm and Memory

10.19.6.1 Lifetime of SPTerms and Prolog Memory
...............................................

There are three separate memory areas involved when manipulating Prolog
terms from Java using 'SPTerm' objects.  These areas have largely
independent life times.

  1. The 'SPTerm' object itself.
  2. Creating 'SPTerm' object also tells Prolog to allocate an
     SP_term_ref.  SP_term_refs have a life-time that is independent of
     the lifetime of the corresponding SPTerm object.
  3. Any Prolog terms allocated on the Prolog heap.  An 'SPTerm' refer
     to a Prolog term indirectly via a SP_term_ref.

   A SP_term_ref REF (created as a side-effect of creating a 'SPTerm'
object) will be reclaimed if either:
   * Java returns to Prolog.  This may never happen, especially if Java
     is the top-level application.
   * Assume there exists a still open query Q that was opened before the
     SP_term_ref REF was created.  The SP_term_ref REF will be reclaimed
     if the query Q is closed (using 'Q.close()' or 'Q.cut()') or if
     'Q.nextSolution()' is called.

   An 'SPTerm' object will be invalidated (and eventually reclaimed by
the garbage collector) if the corresponding SP_term_ref is reclaimed as
above.  If passed an invalidated SP_term_ref, then most methods will
throw an 'IllegalTermException' exception.

   A Prolog term (allocated on the Prolog heap) will be deallocated
when:
   * Assume there exists a still open query Q that was openend before
     the term was created.  The memory of the term will be reclaimed if
     the query Q is closed using 'Q.close()' or if 'Q.nextSolution()' is
     called.  The memory is not reclaimed if the query is closed with
     'Q.cut()'.

     *Please note*: it is possible to get a 'SPTerm' object and its
     SP_term_ref to refer to deallocated Prolog terms, in effect
     creating "dangling" pointers in cases where the 'SPTerm' would
     ordinarily still be valid.  This will be detected and invalidate
     the 'SPTerm':
          {
            SPTerm old = new SPTerm(sp);
            SPQuery q;

            q = sp.openQuery(....);
            ...
            old.consFunctor(...);  // allocate a Prolog term _newer_ than q
            ...
            q.nextSolution(); // or q.close()
            // *error:*
            // The SP_term_ref in q refers to an invalid part of the Prolog heap
            // the SPTerm old will be invalidated by q.nextSolution()
          }


File: sicstus.info,  Node: Preventing SPTerm Memory Leaks,  Prev: Lifetime of SPTerms and Prolog Memory,  Up: SPTerm and Memory

10.19.6.2 Preventing SPTerm Memory Leaks
........................................

Some uses of 'SPTerm' will leak memory on the Prolog side.  This happens
if a new 'SPTerm' object is allocate, but Java neither returns to Prolog
nor backtracks (using the method 'close', 'cut' or 'nextSolution') into
a query opened before the allocation of the 'SPTerm' object.

   As of release 3.8.5, it is possible to explicitly delete a 'SPTerm'
object using the 'SPTerm.delete()' method.  The 'delete()' method
invalidates the SPTerm object and makes the associated SP_term_ref
available for re-use.

   Another way to ensure that all SP_term_refs are deallocated is to
open a dummy query only for this purpose.  The following code
demonstrates this:

     // Always synchronize over creation and closing of SPQuery objects
     synchronized (sp) {
         // Create a dummy query that invokes true/0
         SPQuery context = sp.openQuery("user","true",new SPTerm[]{});
         // All SP_term_refs created after this point will be reclaimed by
         // Prolog when doing context.close() (or context.cut())

         try {           // ensure context is always closed
             SPTerm tmp = new SPTerm(sp); // created _after_ context
             int i = 0;

             while (i++ < 5) {
                 // re-used instead of doing tmp = new SPTerm(sp,"...");
                 tmp.putString("Iteration #" + i + "\n");
                 // e.g. user:write('Iteration #1\n')
                 sp.queryCutFail("user", "write", new SPTerm[]{tmp});
             }
         }
         finally {
             // This will invalidate tmp and make Prolog
             // reclaim the corresponding SP_term_ref
             context.close(); // or context.cut() to retain variable bindings.
         }
     }


File: sicstus.info,  Node: Java Threads,  Next: The Jasper Library,  Prev: SPTerm and Memory,  Up: lib-jasper

10.19.7 Java Threads
--------------------

None of the pre-3.9 methods in 'se.sics.jasper' are thread safe.  They
can only be called from the thread that created the SICStus object.
(This is different from how 'se.sics.jasper' used to work in release
3.8.)

   As of 3.9 there are two ways to set up for calls to SICStus from
multiple threads.

   One way is to use the static method 'newProlog' in the class
'Jasper':

 -- Method on Jasper: Prolog newProlog '(String argv[], String
          bootPath)'
     Creates a 'Prolog' interface object.  Starts a server thread, which
     will serve that 'Prolog'.  The server thread takes care of all
     interaction with the Prolog runtime, making sure that all calls to
     the Prolog runtime will be done from one and the same thread.

   See the HTML documentation on the 'interface Prolog' for details on
what methods are available for a client thread.

   Another way is to create a SICStus object and use the following
methods:

 -- Method on SICStus: Prolog newProlog '()'
     Returns the 'Prolog' interface for this SICStus object.  Creates a
     server and a client ('Prolog') interface for this SICStus object.
     The server may be started by calling 'startServer()'

 -- Method on SICStus: startServer '()'
     Start serving requests from a Prolog client.  This method does not
     return until another thread calls 'stopServer()'.  Before calling
     this method you should call 'newProlog()' and hand the result over
     to another Thread.

 -- Method on SICStus: stopServer '()'
     Stops the server.  Calling this method causes the Thread running in
     the 'startServer()' method to return.

   As with the first method, the 'interface Prolog' defines the methods
available for the client threads.


File: sicstus.info,  Node: The Jasper Library,  Prev: Java Threads,  Up: lib-jasper

10.19.8 The Jasper Library
--------------------------

The Jasper library module is the Prolog interface to the Java VM. It
corresponds to the 'se.sics.jasper' package in Java.  It is loaded by
executing the query:

     | ?- use_module(library(jasper)).

   The Jasper library fully supports multiple SICStus runtimes in a
process.

   Jasper cannot be used when the SICStus runtime is statically linked
to the executable, such as when using 'spld --static'.

   The following functionality is provided:

   * Initializing the Java VM using the _JNI Invocation API_
     ('jasper_initialize/[1,2]', 'jasper_deinitialize/1').
   * Creating and deleting Java objects directly from Prolog
     ('jasper_new_object/5').
   * Method calls ('jasper_call/4').

   * Global and local (object) reference management
     ('jasper_create_global_ref/3', 'jasper_delete_global_ref/2',
     'jasper_delete_local_ref/2').  Global references are used to
     prevent the JVM from garbage collecting a Java object referenced
     from Prolog.
   * There is also a sub-directory containing example programs
     ('library('jasper/examples')').

* Menu:

* Jasper Method Call Example:: Jasper Method Call Example
* Jasper Library Predicates:: Jasper Library Predicates
* Conversion between Prolog Arguments and Java Types:: Conversion between Prolog Arguments and Java Types
* Global vs. Local References:: Global vs. Local References
* Handling Java Exceptions:: Handling Java Exceptions
* Deprecated Jasper API:: Deprecated Jasper API


File: sicstus.info,  Node: Jasper Method Call Example,  Next: Jasper Library Predicates,  Up: The Jasper Library

10.19.8.1 Jasper Method Call Example
....................................

We begin with a small example.

                                                       _// Simple.java_
     import se.sics.jasper.*;

     public class Simple {
       private String instanceDatum = "this is instance data";

       static int simpleMethod(int value) {
         return value*42;
       }

       public String getInstanceData(String arg) {
         return instanceDatum + arg;
       }
     }

   Compile 'Simple.java' (UNIX):
     % javac -deprecation \
       -classpath <installdir>/lib/sicstus-4.4.1/bin/jasper.jar Simple.java

   Under Windows this may look like (the command should go on a single
line):
     C:\> c:\jdk1.2.2\bin\javac -deprecation
      -classpath "D:\Program Files\SICStus Prolog 4.4.1\bin\jasper.jar" Simple.java

   The option '-deprecation' is always a good idea, it makes 'javac'
warn if your code use deprecated methods.

                                                          _% simple.pl_
     :- use_module(library(jasper)).
     main :-
        %% Replace '/my/java/dir' below with the path containing
        %% 'Simple.class', e.g. to look in the current directory use
        %% classpath(['.']).
        %% You can also use the CLASSPATH environment variable and call
        %% jasper_initialize(JVM)
        %% Under Windows it may look like classpath(['C:/MyTest'])
        jasper_initialize([classpath(['/my/java/dir'])],JVM),

        format('Calling a static method...~n',[]),
        jasper_call(JVM,
                    method('Simple','simpleMethod',[static]), % Which method
                    simple_method(+integer,[-integer]), % Types of arguments
                    simple_method(42,X)), % The arguments.
        format('simpleMethod(~w) = ~w~n',[42,X]),

        format('Creating an object...~n',[]),
        jasper_new_object(JVM, 'Simple', init, init, Object),

        format('Calling an instance method on ~w...~n',[Object]),
        jasper_call(JVM,
                    method('Simple','getInstanceData',[instance]),
                    %% first arg is the instance to call
                    get_instance_data(+object('Simple'), +string,[-string]),
                    get_instance_data(Object, 'foobar', X1)),
        format('getInstanceData(~w) = ~w~n',['foobar',X1]).

   Then, run SICStus:

     % echo "[simple],main." | sicstus
     SICStus 4.4.1 ...
     Licensed to SICS
     % consulting /home1/jojo/simple.pl...
     [...]
     % consulted /home1/jojo/simple.pl in module user, 100 msec 26644 bytes
     Calling a static method...
     simpleMethod(42) = 1764
     Creating an object...
     Calling and instance method on $java_object(135057576)...
     getInstanceData(foobar) = this is instance datafoobar

   This example performed three things.

   * The static method 'simpleMethod' was called with argument '42', and
     returned the square of '42', '1764'.
   * An object of class 'Simple' was created.
   * The method 'getInstanceData' was executed on the object just
     created.  The method took an atom as an argument and appended the
     atom to a string stored as a field in the object, yielding "this is
     instance datafoobar".


File: sicstus.info,  Node: Jasper Library Predicates,  Next: Conversion between Prolog Arguments and Java Types,  Prev: Jasper Method Call Example,  Up: The Jasper Library

10.19.8.2 Jasper Library Predicates
...................................

'jasper_initialize(-JVM)'
'jasper_initialize(+OPTIONS, -JVM)'

     Loads and initializes the Java VM. JVM is a reference to the Java
     VM. OPTIONS is a list of options.  The options can be of the
     following types:

     'classpath(<classpath>)'
          If '<classpath>' is an atom, then it will be added
          (unmodified) to the Java VM's classpath.  If '<classpath>' is
          a list, then each element will be expanded using
          'absolute_file_name/2' and concatenated using the Java VM's
          path-separator.  Example:
               classpath([library('jasper/examples'),'$HOME/joe'])
          In addition to the classpaths specified here, Jasper will
          automatically add 'jasper.jar' to the classpath together with
          the contents of the 'CLASSPATH' environment variable.

     'if_exists(OPTION)'
          This option determines what happens if a JVM has already been
          initialized, either through a previous call to
          'jasper_initialize' or because Prolog have been called from
          Java.  If a JVM already exists, then the other options are
          ignored.
          'ok'
               The default.  Argument JVM is bound to the existing JVM.
          'fail'
               The call to 'jasper_initialize/2' fails.
          'error'
               The call to 'jasper_initialize/2' throws an exception
               ('java_exception(SOME TEXT)').

     'if_not_exists(OPTION)'
          This option determines what happens if a JVM has not already
          been initialized.
          'ok'
               The default.  The remaining options are used to
               initialize the JVM.
          'fail'
               The call to 'jasper_initialize/2' fails.
          'error'
               The call to 'jasper_initialize/2' throws an exception
               ('java_exception(SOME TEXT)').

          As an example, to access the currently running JVM and to give
          an error if there is no running JVM use
          'jasper_initialize([if_exists(ok),if_not_exists(error)],
          JVM)'.

     'OPTION'
          The option is an atom that will be passed directly to the Java
          VM as an option.  This enables the user to send additional
          options to the Java VM. Example:
               jasper_initialize(['-Dkenny.is.dead=42'],JVM),
     In addition to the options specified by the user, Jasper adds a
     couple of options on its own in order for Java to find the Jasper
     classes and the Jasper native library.

     There is currently no support for creating multiple JVMs (few JDKs,
     if any, supports this).

'jasper_deinitialize(+JVM)'

     De-initialize Java.  Do Not call this, current versions of the JVM
     does not support deinitialization.

'jasper_call(+JVM,+METHOD,+TYPEINFO,+ARGS)'

     Calls a Java static or instance method.

     JVM
          A reference to the Java VM, as obtained by
          'jasper_initialize/[1,2]'.

     METHOD

          A term of the form 'method(CLASSNAME, METHODNAME, FLAGS)' that
          identifies the method to call.

          CLASSNAME
               This is the "Fully Qualified Classname" of the class (for
               example, 'java/lang/String') of the object or where to
               look for the static method.  Note that you need to
               surround the atom with single quotes since it contains
               '/' characters.  The class is ignored when calling
               instance methods but should still be an atom, e.g. ''''.
          NAME
               This is the name of the method, as an atom.
          FLAGS
               This is the singleton list '[instance]' for instance
               methods and '[static]' for static methods.

     TYPEINFO
          Information about the argument types and the argument
          conversion that should be applied.  *Note Conversion between
          Prolog Arguments and Java Types::.  for more information on
          specifying argument types.

          Note that for an instance method the first argument must be an
          object reference (specified with '+object(CLASS)').  In this
          case the class is ignored but should still be an atom, e.g.
          ''''.

     ARGS
          A term with one position for each argument to the method.  For
          an instance method the first argument is the instance.

'jasper_new_object(+JVM,+CLASSNAME,+TYPEINFO,+ARGS,-OBJECT)'

     Creates a new Java object.

     See 'jasper_call/4' above for an explanation of the arguments JVM,
     CLASSNAME, TYPEINFO and ARGS.
     CLASSNAME
          An an atom containing the _fully qualified classname_
     TYPEINFO
          TYPEINFO has the same format as for a static void method.
     ARGS
          A term with one position for each argument to the constructor.
     OBJECT
          This argument is bound to a (local) reference to the created
          object.  *Note Global vs. Local References::.

     As an example, the following code creates a 'java/lang/Integer'
     object initialized from a string of digits.  It then calls the
     instance method 'doubleValue' to obtain the floating point
     representation of the Integer.

          | ?- Chars = "4711",
               %% get existing JVM
               jasper_initialize([if_not_exists(error)], JVM),
               jasper_new_object(JVM, 'java/lang/Integer',
                                 init(+chars), init(Chars), S),
               jasper_call(JVM,
                           method('java/lang/Integer', doubleValue, [instance]),
                           to_double(+object('java/lang/Integer'), [-double]),
                           to_double(S,X)).

          S = '$java_object'(135875344),
          X = 4711.0,  % note that this is now a floating point number
          JVM = '$jvm'(1076414148),
          Chars = [52,55,49,49]  % a.k.a. "4711"


'jasper_create_global_ref(+JVM,+REF,-GLOBALREF)'

     Creates a global reference (GLOBALREF) for a (non-null) Java object
     (REF).  *Note Global vs. Local References::.

'jasper_delete_global_ref(+JVM,+GLOBALREF)'

     Destroys a global reference.  *Note Global vs. Local References::.

'jasper_create_local_ref(+JVM,+REF,-LOCALREF)'

     Creates a local reference (LOCALREF) for a (non-null) Java object
     (REF).  *Note Global vs. Local References::.  Rarely needed.

'jasper_delete_local_ref(+JVM,+GLOBALREF)'

     Destroys a local reference.  *Note Global vs. Local References::.

'jasper_is_jvm(+JVM)'

     Succeeds if JVM is a reference to a Java Virtual Machine.

'jasper_is_object(+OBJECT)'
'jasper_is_object(+JVM,+OBJECT)'

     Succeeds if OBJECT is a reference to a Java object.  The
     representation of Java object _will_ change so use
     'jasper_is_object/1' to recognize objects instead of relying on the
     internal representation.  Currently the JVM argument is ignored.
     If, and when, multiple JVMs becomes a possibility
     'jasper_is_object/2' will verify that OBJECT is an object in a
     particular JVM.

'jasper_is_same_object(+JVM,+OBJECT1,+OBJECT2)'

     Succeeds if OBJECT1 and OBJECT2 refers to the same Java object (or
     both are null object references).  The same object may be
     represented by two different terms in Prolog so '==/2' can _not_ be
     used to reliably detect if two object references refer to the same
     object.

'jasper_is_instance_of(+JVM,+OBJECT,+CLASSNAME)'

     Succeeds if OBJECT is an instance of class CLASSNAME; fails
     otherwise.  CLASSNAME is a fully qualified classname; see
     'jasper_call/4'.

'jasper_object_class_name(+JVM,+OBJECT,-CLASSNAME)'

     Returns the fully qualified name of the class of +OBJECT as an
     atom.

'jasper_null(+JVM,-NULLREF)'

     Create a null object reference.

'jasper_is_null(+JVM,+REF)'

     Succeeds if REF is a null object reference, fails otherwise, e.g.
     if REF is not an object reference.


File: sicstus.info,  Node: Conversion between Prolog Arguments and Java Types,  Next: Global vs. Local References,  Prev: Jasper Library Predicates,  Up: The Jasper Library

10.19.8.3 Conversion between Prolog Arguments and Java Types
............................................................

The following table lists the possible values of arguments of the
argument type specification to 'jasper_call/4' and 'jasper_new_object/5'
(*note Jasper Library Predicates::).  The value specifies which
conversion between corresponding Prolog argument and Java type will take
place.

   There is currently no mechanism for specifying Java arrays in this
way.

   In the following the package prefix ('java/lang' or 'se/sics/jasper')
has been left out for brevity.

   For several of the numerical types there is the possibility that the
target type cannot accurately represent the source type, e.g. when
converting from a Prolog integer to a Java byte.  The behavior in such
cases is unspecified.

'Prolog: +integer'
'Java: int'

     The argument should be a number.  It is converted to a Java 'int',
     a 32 bit signed integer.

'Prolog: +byte'
'Java: byte'

     The argument should be a number.  It is converted to a Java 'byte'.

'Prolog: +short'
'Java: short'

     The argument should be a number.  It is converted to a Java
     'short', a 16 bit signed integer.

'Prolog: +long'
'Java: long'

     The argument should be a number.  It is converted to a Java 'long',
     a 64-bit signed integer.

     In releases prior to 3.9.1, the value was truncated to 32 bits when
     passed between Java and Prolog.  This is no longer the case.

'Prolog: +float'
'Java: float'

     The argument should be a number.  It is converted to a Java
     'float'.

'Prolog: +double'
'Java: double'

     The argument should be a number.  It is converted to a Java
     'double'.

'Prolog: +term'
'Java: SPTerm'

     The argument can be any term.  It is passed to Java as an object of
     the class 'SPTerm'.

'Prolog: +object(CLASS)'
'Java: CLASS'

     The argument should be the Prolog representation of a Java object
     of class CLASS.  Unless it is the first argument in a non-static
     method (in which case is it treated as the object on which the
     method should be invoked), it is passed to the Java method as an
     object of class 'Class'.

'Prolog: +atom   obsolescent'
'Java: SPCanonicalAtom'
     The argument should be an atom.  The Java method will be passed an
     object of class 'SPCanonicalAtom'.  Often '+string', see below, is
     more useful.

'Prolog: +boolean'
'Java: boolean'

     The argument should be an atom in {'true','false'}.  The Java
     method will receive a 'boolean'.

'Prolog: +chars'
'Java: String'

     The argument should be a code-list.  The Java method will receive
     an object of class 'String'.

'Prolog: +codes'
'Java: String'

     '+codes' is an alias for '+chars'.

'Prolog: +string'
'Java: String'

     The argument should be an atom.  The Java method will receive an
     object of class 'String'.

'Note.'
     When using '+chars', '+codes' or '+string' the automatic type
     conversion mechanism will also create a type signature of the form
     java/lang/String.  If you want to call a method that accepts a
     String object as a parameter, but has different signature, then the
     method lookup will fail.  A workaround is to explicitly create a
     String object and then call the method.  For example:
          :- use_module(library(jasper)).

          main :-
              jasper_initialize([],JVM),
              jasper_new_object(JVM,
          		      'java/lang/String',
          		      init(+chars),
          		      init("hamburger"),
          		      H),
              Str = "urge",
              jasper_new_object(JVM,
           		      'java/lang/String',
           		      init(+chars),
           		      init(Str),
           		      S),
              jasper_call(JVM,
          		method('', contains, [instance]),
          		contains(+object(''),
          			+object('java/lang/CharSequence'),
          			[-boolean]),
          		contains(H, S, B)),
              format('Contains? ~a~n', [B]).

'Prolog: -atom   obsolescent'
'Java: SPTerm'
     The Java method will receive an object of class 'SPTerm', which
     should be set to an atom (e.g. using 'SPTerm.putString').  The
     argument will be bound to the value of the atom when the method
     returns.  Often '-term', see below, is more useful.

'Prolog: -chars'
'Java: StringBuffer'

     The Java method will receive an (empty) object of type
     'StringBuffer', which can be modified.  The argument will be bound
     to a code-list of the 'StringBuffer' object.

'Prolog: -codes'
'Java: StringBuffer'

     '-codes' is an alias for '-chars'.

'Prolog: -string'
'Java: StringBuffer'

     The Java method will receive an object of type 'StringBuffer',
     which can be modified.  The argument will be bound to an atom
     converted from the 'StringBuffer' object.

'Prolog: -term'
'Java: SPTerm'

     The Java method will receive an object of class 'SPTerm', which can
     be set to a term (e.g. using 'SPTerm.consFunctor').  The argument
     will be bound to the term when the method returns.

'Prolog: [-integer]'
'Java: int M()'

     The Java method should return an 'int'.  The value will be
     converted to a Prolog integer.

'Prolog: [-byte]'
'Java: byte M()'

     The Java method should return a 'byte'.  The value will be
     converted to a Prolog integer.

'Prolog: [-short]'
'Java: short M()'

     The Java method should return a 'short'.  The value will be
     converted to a Prolog integer.

'Prolog: [-long]'
'Java: long M()'

     The Java method should return a 'long', a 64 bit signed integer.
     The value will be converted to a Prolog integer.

'Prolog: [-float]'
'Java: float M()'

     The Java method should return a 'float'.  The value will be
     converted to a Prolog float.

'Prolog: [-double]'
'Java: double M()'

     The Java method should return a 'double'.  The value will be
     converted to a Prolog float.

'Prolog: [-term]'
'Java: SPTerm M()'

     The Java method should return an object of class 'SPTerm', which
     will be converted to a Prolog term.

'Prolog: [-object(CLASS)]'
'Java: SPTerm M()'

     The Java method should return an object of class CLASS, which will
     be converted to the internal Prolog representation of the Java
     object.

'Prolog: [-atom]  obsolescent'
'Java: SPTerm M()'

     The Java method should return an object of class 'SPCanonicalAtom',
     which will be converted to a Prolog atom.  Often '[-term]', see
     above, is more useful.

'Prolog: [-boolean]'
'Java: boolean M()'

     The Java should return a 'boolean'.  The value will be converted to
     a Prolog atom in {'true','false'}.

'Prolog: [-chars]'
'Java: String M()'

     The Java method should return an object of class 'String', which
     will be converted to a code-list.

'Prolog: [-codes]'
'Java: String M()'

     '[-codes]' is an alias for '[-chars]'.

'Prolog: [-string]'
'Java: String M()'

     The Java method should return an object of class 'String', which
     will be converted to an atom.


File: sicstus.info,  Node: Global vs. Local References,  Next: Handling Java Exceptions,  Prev: Conversion between Prolog Arguments and Java Types,  Up: The Jasper Library

10.19.8.4 Global vs. Local References
.....................................

It is important to understand the rules determining the life-span of
Java object references.  These are similar in spirit to the SP_term_refs
of the C-Prolog interface, but since they are used to handle Java
objects instead of Prolog terms they work a little differently.

   Java object references (_currently_ represented in Prolog as
''$java_object'/1' terms) exist in two flavors: _local_ and _global_.
Their validity are governed by the following rules.

  1. A local reference is valid until Prolog returns to Java or the
     reference is deleted with 'jasper_delete_local_ref/2'.  It is only
     valid in the (native) thread in which is was created.  As a rule of
     thumb a local reference can be used safely as long as it is not
     saved away using 'assert/3' or similar.

     Since local references are _never_ reclaimed until Prolog returns
     to Java (which may never happen) you should typically call
     'jasper_delete_local_ref/2' when your code is done with an object.

  2. A global reference is valid until explicitly freed.  It can be used
     from any native thread.
  3. All objects returned by Java methods are converted to local
     references.
  4. Java exceptions not caught by Java are thrown as Prolog exceptions
     consisting of a _global_ reference to the exception object, see
     *note Handling Java Exceptions::.

   Local references can be converted into global references
('jasper_create_global_ref/3').  When the global reference is no longer
needed, it should be delete using 'jasper_delete_global_ref/2'.

   For a more in-depth discussion of global and local references,
consult the JNI Documentation
(http://java.sun.com/products/jdk/1.2/docs/guide/jni/index.html).

   Using a local (or global) reference that has been deleted (either
explicitly or by returning to Java) is illegal and will generally lead
to crashes.  This is a limitation of the Java Native Interface used to
implement the low level interface to Java.


File: sicstus.info,  Node: Handling Java Exceptions,  Next: Deprecated Jasper API,  Prev: Global vs. Local References,  Up: The Jasper Library

10.19.8.5 Handling Java Exceptions
..................................

If a Java method throws an exception, e.g. by using 'throw new
Exception("...")' and the exception is not caught by Java, then it is
passed on as a Prolog exception.  The thrown term is a _global_
reference to the Exception object.  The following example code
illustrates how to handle Java exceptions in Prolog:

     exception_example(JVM, ...) :-
        catch(
              %% Call Java method that may raise an exception
              jasper_call(JVM, ...),
              Excp,
              (
                ( is_java_exception(JVM, Excp)
                -> print_exception_info(JVM, Excp)
                ; throw(Excp)       % pass non-Java exceptions to caller
                )
              )
             ).

     is_java_exception(_JVM, Thing) :- var(Thing), !, fail.
     is_java_exception(_JVM, Thing) :-
        Thing = java_exception(_),      % misc error in Java/Prolog glue
        !.
     is_java_exception(JVM, Thing) :-
        jasper_is_object(JVM, Thing),
        jasper_is_instance_of(JVM, Thing, 'java/lang/Throwable').
     print_exception_info(_JVM, java_exception(Message)) :- !,
        format(user_error, '~NJasper exception: ~w~n', [Message]).
     print_exception_info(JVM, Excp) :-
        /*
        // Approximate Java code
        {
           String messageChars = excp.getMessage();
        }
        */
        jasper_call(JVM,
                    method('java/lang/Throwable', 'getMessage', [instance]),
                    get_message(+object('java/lang/Throwable'), [-chars]),
                    get_message(Excp, MessageChars)),
        /* // Approximate Java code
        {
           StringWriter stringWriter = new StringWriter();
           PrintWriter printWriter =  new PrintWriter(stringWriter);
           excp.printStackTrace(printWriter);
           printWriter.close();
           stackTraceChars = StringWriter.toString();
        }
        */
        jasper_new_object(JVM, 'java/io/StringWriter',
                          init, init, StringWriter),
        jasper_new_object(JVM, 'java/io/PrintWriter',
                          init(+object('java/io/Writer')),
                          init(StringWriter), PrintWriter),
        jasper_call(JVM,
                    method('java/lang/Throwable', 'printStackTrace', [instance]),
                    print_stack_trace(+object('java/lang/Throwable'),
                                      +object('java/io/PrintWriter')),
                    print_stack_trace(Excp, PrintWriter)),
        jasper_call(JVM,
                    method('java/io/PrintWriter','close',[instance]),
                    close(+object('java/io/PrintWriter')),
                    close(PrintWriter)),
        jasper_call(JVM,
                    method('java/io/StringWriter','toString',[instance]),
                    to_string(+object('java/io/StringWriter'),[-chars]),
                    to_string(StringWriter, StackTraceChars)),
        jasper_delete_local_ref(JVM, PrintWriter),
        jasper_delete_local_ref(JVM, StringWriter),
        %% ! exceptions are thrown as global references
        jasper_delete_global_ref(JVM, Excp),
        format(user_error, '~NJava Exception: ~s\nStackTrace: ~s~n',
               [MessageChars, StackTraceChars]).


File: sicstus.info,  Node: Deprecated Jasper API,  Next: Deprecated Argument Conversions,  Prev: Handling Java Exceptions,  Up: The Jasper Library

10.19.8.6 Deprecated Jasper API
...............................

* Menu:

* Deprecated Argument Conversions:: Deprecated Argument Conversions
* Deprecated Jasper Predicates:: Deprecated Jasper Predicates

The information in this section is only of interest to those that need
to read or modify code that used 'library(jasper)' before release 3.8.5.

   A different way of doing method call and creating objects was used in
versions of 'library(jasper)' predating release 3.8.5.  Use of these
facilities are strongly discouraged although they are still available in
the interest of backward compatibility.

   The old method call predicates are 'jasper_call_static/6' and
'jasper_call_instance/6' as well as the old way of calling
'jasper_new_object/5'.


File: sicstus.info,  Node: Deprecated Argument Conversions,  Up: Deprecated Jasper API

10.19.8.7 Deprecated Argument Conversions
.........................................

The pre release 3.8.5 method call predicates in this library use a
specific form of argument lists containing conversion information so the
predicates know how to convert the input arguments from Prolog datatypes
to Java datatypes.  This is similar to the (new) mechanism described in
*note Conversion between Prolog Arguments and Java Types::.  The
argument lists are standard Prolog lists containing terms on the
following form:

'jboolean(X)'
     X is the atom 'true' or 'false', representing a Java 'boolean'
     primitive type.
'jbyte(X)'
     X is an integer, which is converted to a Java 'byte'.
'jchar(X)'
     X is an integer, which is converted to a Java 'char'.
'jdouble(X)'
     X is a float, which is converted to a Java 'double'.
'jfloat(X)'
     X is a float, which is converted to a Java 'float'.
'jint(X)'
     X is an integer, which is converted to a Java 'int'.
'jlong(X)'
     X is an integer, which is converted to a Java 'long'.
'jshort(X)'
     X is an integer, which is converted to a Java 'short'.
'jobject(X)'
     X is a reference to a Java object, as returned by
     'jasper_new_object/5' (*note Jasper Library Predicates::).
'jstring(X)'
     X is an atom, which is converted to a Java 'String'.

   If the Prolog term does not fit in the corresponding Java data type
('jbyte(4711)', for example), then the result is undefined.


File: sicstus.info,  Node: Deprecated Jasper Predicates,  Up: Deprecated Jasper API

10.19.8.8 Deprecated Jasper Predicates
......................................

'jasper_new_object(+JVM,+CLASS,+TYPESIG,+ARGS,-OBJECT)   obsolescent'

     Creates a new Java object.
     JVM
          A reference to the Java VM, as obtained by
          'jasper_initialize/[1,2]'.
     CLASS
          An an atom containing the _fully qualified classname_ (i.e.
          package name separated with '/', followed by the class name),
          for example 'java/lang/String', 'se/sics/jasper/SICStus'.
     TYPESIG
          The _type signature_ of the class constructor.  A type
          signature is a string that uniquely defines a method within a
          class.  For a definition of type signatures, see the JNI
          Documentation
          (http://java.sun.com/products/jdk/1.2/docs/guide/jni/index.html).
     ARGS
          A list of argument specifiers.  *Note Deprecated Argument
          Conversions::.
     OBJECT
          A term on the form ''$java_object'(X)', where X is a Java
          object reference.  This is the Prolog handle to the Java
          object.  *Note Global vs. Local References::.


File: sicstus.info,  Node: lib-linda,  Next: lib-lists,  Prev: lib-jasper,  Up: The Prolog Library

10.20 Process Communication--'library(linda/[server,client])'
=============================================================

Linda is a concept for process communication.

   For an introduction and a deeper description, see [Carreiro &
Gelernter 89a] or [Carreiro & Gelernter 89b], respectively.

   One process is running as a server and one or more processes are
running as clients.  The processes are communicating with sockets and
supports networks.

   The server is in principle a blackboard on which the clients can
write ('out/1'), read ('rd/1') and remove ('in/1') data.  If the data is
not present on the blackboard, then the predicates suspend the process
until they are available.

   There are some more predicates besides the basic 'out/1', 'rd/1' and
'in/1'.  The 'in_noblock/1' and 'rd_noblock/1' does not suspend if the
data is not available--they fail instead.  A blocking fetch of a
conjunction of data can be done with 'in/2' or 'rd/2'.

   Example: A simple producer-consumer.  In client 1:
     producer :-
            produce(X),
            out(p(X)),
            producer.

     produce(X) :- .....

   In client 2:

     consumer :-
            in(p(A)),
            consume(A),
            consumer.

     consume(A) :- .....

   Example: Synchronization

            ...,
            in(ready),  %Waits here until someone does out(ready)
            ...,

   Example: A critical region

            ...,
            in(region_free),  % wait for region to be free
            critical_part,
            out(region_free), % let next one in
            ...,

   Example: Reading global data

            ...,
            rd(data(Data)),
            ...,

     or, without blocking:
            ...,
            rd_noblock(data(Data)) ->
                  do_something(Data)
            ;     write('Data not available!'),nl
            ),
            ...,

   Example: Waiting for one of several events

            ...,
            in([e(1),e(2),...,e(n)], E),
     %  Here is E instantiated to the first tuple that became available
            ...,

* Menu:

* lib-linda-server:: Linda Server
* lib-linda-client:: Linda Client


File: sicstus.info,  Node: lib-linda-server,  Next: lib-linda-client,  Up: lib-linda

10.20.1 Linda Server
--------------------

The server is the process running the "blackboard process".  It is an
ordinary SICStus process, which can be run on a separate machine if
necessary.

   To load the package, enter the query

     | ?- use_module(library('linda/server')).

and start the server with 'linda/[0,1]'.

'linda'

     Starts a Linda-server in this SICStus.  The network address is
     written to the current output stream as HOST:PORTNUMBER.

'linda(:OPTIONS)'
     Starts a Linda-server in this SICStus.  Each option on the list
     OPTIONS is one of
     'ADDRESS-GOAL'
          where ADDRESS must be unifiable with HOST:PORT and GOAL must
          be instantiated to a goal.

          When the linda server is started, HOST and PORT are bound to
          the server host and port respectively and the goal GOAL is
          called.  A typical use of this would be to store the
          connection information in a file so that the clients can find
          the server to connect to.

          For backward compatibility, if OPTIONS is not a list, then it
          is assumed to be an option of the form 'ADDRESS-GOAL'.

          Before release 3.9.1, GOAL needed an explicit module prefix to
          ensure it was called in the right module.  This is no longer
          necessary since 'linda/1' is now a meta-predicate.

     'accept_hook(CLIENT,STREAM,GOAL)'
          When a client attempts to connects to the server CLIENT and
          STREAM will be bound to the IP address of the client and the
          socket stream connected to the client, respectively.  The GOAL
          is then called, and if it succeeds, then the client is allowed
          to connect.  If GOAL fails, then the server will close the
          stream and ignore the connection request.  A typical use of
          this feature would be to restrict the addresses of the clients
          allowed to connect.  If you require bullet proof security,
          then you would probably need something more sophisticated.

     Example:
          | ?- linda([(Host:Port)-mypred(Host,Port), 
                      accept_hook(C,S,should_accept(C,S))]).

     will call 'mypred/2' when the server is started.  'mypred/2' could
     start the client-processes, save the address for the clients etc.
     Whenever a client attempts to connect from a host with IP address
     ADDR, a bi-directional socket stream STREAM will be opened to the
     client, and 'should_accept(ADDR,STREAM)' will be called to
     determine if the client should be allowed to connect.


File: sicstus.info,  Node: lib-linda-client,  Prev: lib-linda-server,  Up: lib-linda

10.20.2 Linda Client
--------------------

The clients are one or more SICStus processes that have connection(s) to
the server.

   To load the package, enter the query

     | ?- use_module(library('linda/client')).

   Some of the following predicates fail if they do not receive an
answer from the Linda-server in a reasonable amount of time.  That time
is set with the predicate 'linda_timeout/2'.

'linda_client(+ADDRESS)'

     Establishes a connection to a Linda-server specified by ADDRESS.
     The ADDRESS is of the format HOST:PORTNUMBER as given by
     'linda/[0,1]'.

     It is not possible to be connected to two Linda-servers at the same
     time.

     This predicate can fail due to a timeout.

'close_client'

     Closes the connection to the server.

'shutdown_server/0'

     Sends a Quit signal to the server, which immediately stops
     accepting new connections before 'shutdown_server/0' returns.  The
     server continues running after receiving this signal, processing
     requests from existing clients, until such time as all the clients
     have closed their connections.  It is up to the clients to tell
     each other to quit.  When all the clients are done, the server
     stops (i.e. 'linda/[0,1]' succeeds).  Courtesy of Malcolm Ryan.
     Note that 'close_client/0' should be called _after_
     'shutdown_server/0'.  'shutdown_server/0' will raise an error if
     there is no connection between the client and the server.

     The behavior of 'shutdown_server/0' changed in SICStus Prolog 4.2.
     In previous releases the server continued to accept new connections
     after being told to shutdown.  Now it immediately stops listening
     for new connections and releases the listening socket and these
     server actions happens before the client returns from
     'shutdown_server/0'.

'linda_timeout(?OLDTIME, ?NEWTIME)'

     This predicate controls Linda's timeout.  OLDTIME is unified with
     the old timeout and then timeout is set to NEWTIME.  The value is
     either 'off' or of the form SECONDS:MILLISECONDS.  The former value
     indicates that the timeout mechanism is disabled, that is, eternal
     waiting.  The latter form is the TIMEOUT-TIME.

'out(+TUPLE)'

     Places the tuple TUPLE in Linda's tuple-space.

'in(?TUPLE)'

     Removes the tuple TUPLE from Linda's tuple-space if it is there.
     If not, then the predicate blocks until it is available (that is,
     someone performs an 'out/1').

'in_noblock(?TUPLE)'

     Removes the tuple TUPLE from Linda's tuple-space if it is there.
     If not, then the predicate fails.

     This predicate can fail due to a timeout.

'in(+TUPLELIST, ?TUPLE)'

     As 'in/1' but succeeds when either of the tuples in TUPLELIST is
     available.  TUPLE is unified with the fetched tuple.  If that
     unification fails, then the tuple is _not_ reinserted in the
     tuple-space.

'rd(?TUPLE)'

     Succeeds if TUPLE is available in the tuple-space, suspends
     otherwise until it is available.  Compare this with 'in/1': the
     tuple is _not_ removed.

'rd_noblock(?TUPLE)'

     Succeeds if TUPLE is available in the tuple-space, fails otherwise.

     This predicate can fail due to a timeout.

'rd(+TUPLELIST, ?TUPLE)'
     As 'in/2' but does not remove any tuples.

'bagof_rd_noblock(?TEMPLATE, +TUPLE, ?BAG)'

     BAG is the list of all instances of TEMPLATE such that TUPLE exists
     in the tuple-space.

     The behavior of variables in TUPLE and TEMPLATE is as in 'bagof/3'.
     The variables could be existentially quantified with '^/2' as in
     'bagof/3'.

     The operation is performed as an atomic operation.

     This predicate can fail due to a timeout.

     Example: Assume that only one client is connected to the server and
     that the tuple-space initially is empty.
          | ?- out(x(a,3)), out(x(a,4)), out(x(b,3)), out(x(c,3)).

          | ?- bagof_rd_noblock(C-N, x(C,N), L).

          C = _32,
          L = [a-3,a-4,b-3,c-3],
          N = _52

          | ?- bagof_rd_noblock(C, N^x(C,N), L).

          C = _32,
          L = [a,a,b,c],
          N = _48



File: sicstus.info,  Node: lib-lists,  Next: lib-logarr,  Prev: lib-linda,  Up: The Prolog Library

10.21 List Operations--'library(lists)'
=======================================

This library module provides operations on lists.  Exported predicates:

'select(?ELEMENT, ?SET, ?RESIDUE)'

     is true when SET is a list, ELEMENT occurs in SET, and RESIDUE is
     everything in SET except ELEMENT (things stay in the same order).
'selectchk(+ELEMENT, +SET, ?RESIDUE)'

     is to 'select/3' what 'memberchk/2' is to 'member/2'.  That is, it
     locates the first occurrence of ELEMENT in SET, and deletes it,
     giving RESIDUE.  It is steadfast in RESIDUE.
'append(+LISTOFLISTS, -LIST)'

     is true when LISTOFLISTS is a list [L1,...,LN] of lists, LIST is a
     list, and appending L1, ..., LN together yields LIST.  LISTOFLISTS
     _must_ be a proper list.  Additionally, either LIST should be a
     proper list, or each of L1, ..., LN should be a proper list.  The
     behavior on non-lists is undefined.  LISTOFLISTS must be proper
     because for any given solution, infinitely many more can be
     obtained by inserting nils ([]) into LISTOFLIST.  Could be defined
     as:

          append(Lists, Appended) :-
          	(   foreach(List,Lists),
          	    fromto(Appended,S0,S,[])
          	do  append(List, S, S0)
          	).
'append(?PREFIX, ?TAIL1, ?LIST1, ?TAIL2, ?LIST2)'
     is true when 'append(PREFIX, TAIL1, LIST1)' and 'append(PREFIX,
     TAIL2, LIST2)' are both true.  You could call 'append/3' twice, but
     that is order- dependent.  This will terminate if PREFIX is a
     proper list or if either LIST1 or LIST2 is a proper list.
'correspond(?X, ?XLIST, ?YLIST, ?Y)'

     is true when XLIST and YLIST are lists, X is an element of XLIST, Y
     is an element of YLIST, and X and Y are in similar places in their
     lists.  No relation is implied between other elements of XLIST and
     YLIST.  For a similar predicate without the cut, see 'select/4'.
'delete(+LIST, +KILL, -RESIDUE)'

     is true when LIST is a list, in which KILL may or may not occur,
     and RESIDUE is a copy of LIST with all elements equal to KILL
     deleted.  To extract a single copy of KILL, use 'select(KILL, LIST,
     RESIDUE)'.  If LIST is not proper, 'delete/3' will _fail_.  KILL
     and the elements of LIST should be sufficiently instantiated for
     '\=' to be sound.  Could be defined as:

          delete(List, Kill, Residue) :-
          	(   foreach(X,List),
          	    fromto(Residue,S0,S,[]),
          	    param(Kill)
          	do  (X = Kill -> S0 = S ; S0 = [X|S])
          	).
'delete(+LIST, +KILL, +COUNT, -RESIDUE)'
     is true when LIST is a list, in which KILL may or may not occur,
     and COUNT is a non-negative integer, and RESIDUE is a copy of LIST
     with the first COUNT elements equal to KILL deleted.  If LIST has
     fewer than COUNT elements equal to COUNT, all of them are deleted.
     If LIST is not proper, 'delete/4' may _fail_.  KILL and the
     elements of LIST should be sufficiently instantiated for '\=' to be
     sound.
'is_list(+LIST)'

     succeeds when LIST is a proper list.  That is, LIST is nil ([]) or
     a cons cell ([HEAD|TAIL]) whose TAIL is a proper list.  A variable,
     or a list whose final tail is a variable, or a cyclic list, will
     fail this test.
'keys_and_values(?[K1-V1,...,KN-VN], ?[K1,...,KN], ?[V1,...,VN])'

     is true when its arguments look like the picture above.  It is
     meant for splitting a list of KEY-VALUE pairs (such as 'keysort/2'
     wants and produces) into separate lists of KEYS and of VALUES.  It
     may just as well be used for building a list of pairs from a pair
     of lists.  In fact one usually wants just the keys or just the
     values, but you can supply '_' as the other argument.  For example,
     suppose you wanted to sort a list without having duplicates
     removed.  You could do
              keys_and_values(RawPairs, RawKeys, _),
              keysort(RawPairs, OrdPairs),
              keys_and_values(OrdPairs, OrdKeys, _).
     Could be defined as:

          keys_and_values([], [], []).
          keys_and_values([Key-Value|Pairs], [Key|Keys], [Value|Values]) :-
          	keys_and_values(Pairs, Keys, Values).
'last(+LIST, -LAST)'

     is true when LIST is a LIST and LAST is its last element.  There is
     also a 'last(?FORE, ?LAST, ?LIST)' whose argument order matches
     append/3.  This could be defined as
              last(L, X) :- append(_, [X], L).
'nextto(?X, ?Y, ?LIST)'

     is true when X and Y appear side-by-side in LIST.  It could be
     written as
              nextto(X, Y, List) :- append(_, [X,Y|_], List).
     It may be used to enumerate successive pairs from the list.  LIST
     should be proper, otherwise 'nextto/3' will generate it.
'nth0(?N, ?LIST, ?ELEM)'

     is true when ELEM is the Nth member of LIST, counting the first as
     element 0.  That is, throw away the first N elements and unify ELEM
     with the next.  E.g.  'nth0(0, [H|T], H)'.  Either N should be an
     integer, or LIST should be proper.
'nth1(?N, ?LIST, ?ELEMENT)'

     is true when ELEM is the NTH member of LIST, counting the first as
     element 1.  That is, throw away the first N-1 elements and unify
     ELEM with the next element (the NTH).  E.g.  'nth1(1, [H|T], H)'.
     This is just like 'nth0/3' except that it counts from 1 instead of
     0.  Either N should be an integer, or LIST should be proper.
'nth0(?N, ?LIST, ?ELEM, ?REST)'
     unifies ELEM with the NTH element of LIST, counting from 0, and
     REST with the other elements.  It can be used to select the NTH
     element of LIST (yielding ELEM and REST), or to insert ELEM
     _before_ the NTH (counting from 0) element of REST, when it yields
     LIST, e.g.  'nth0(2, List, c, [a,b,d,e])' unifies LIST with
     '[a,b,c,d,e]'.  This can be seen as inserting ELEM _after_ the NTH
     element of REST if you count from 1 rather than 0.  Either N should
     be an integer, or LIST or REST should be proper.
'nth1(?N, ?LIST, ?ELEM, ?REST)'
     unifies ELEM with the NTH element of LIST, counting from 1, and
     REST with the other elements.  It can be used to select the NTH
     element of LIST (yielding ELEM and REST), or to insert ELEM
     _before_ the NTH (counting from 1) element of REST, when it yields
     LIST, e.g.  'nth1(2, List, b, [a,c,d,e])' unifies LIST with
     '[a,b,c,d,e]'.  Either N should be an integer, or LIST or REST
     should be proper.
'one_longer(?LONGER, ?SHORTER)'

     is true when
              length(Longer,N), length(Shorter,M), succ(M,N)
     for some integers M, N.  It was written to make '{nth0,nth1}/4'
     able to find the index, just as 'same_length/2' is useful for
     making things invertible.
'perm(+LIST, ?PERM)'

     is true when LIST and PERM are permutations of each other.  The
     main use of 'perm/2' is to generate permutations.  You should not
     use this predicate in new programs; use 'permutation/2' instead.
     LIST must be a proper list.  PERM may be partly instantiated.
'permutation(?LIST, ?PERM)'

     is true when LIST and PERM are permutations of each other.  Unlike
     'perm/2', it will work even when LIST is not a proper list.  Any
     way, it works by generating permutations of LIST and unifying them
     with PERM.  Be careful: this is quite efficient, but the number of
     permutations of an N-element list is N!, and even for a 7-element
     list that is 5040.
'perm2(?A,?B, ?C,?D)'

     is true when {A,B} = {C,D}.  It is very useful for writing pattern
     matchers over commutative operators.
'proper_length(+LIST, ?LENGTH)'

     succeeds when LIST is a proper list, binding LENGTH to its length.
     That is, 'is_list(List), length(List, Length)'.  Will fail for
     cyclic lists.
'remove_dups(+LIST, ?PRUNED)'

     removes duplicated elements from LIST, which should be a proper
     list.  If LIST has non-ground elements, PRUNED may contain elements
     which unify; two elements will remain separate iff there is a
     substitution which makes them different.  E.g.  [X,X] -> [X] but
     [X,Y] -> [X,Y].  The surviving elements, by ascending standard
     order, is unified with PRUNED.
'reverse(?LIST, ?REVERSED)'

     is true when LIST and REVERSED are lists with the same elements but
     in opposite orders.  Either LIST or REVERSED should be a proper
     list: given either argument the other can be found.  If both are
     incomplete 'reverse/2' can backtrack forever trying ever longer
     lists.
'rev(+LIST, ?REVERSED)'

     is a version of 'reverse/2' which only works one way around.  Its
     LIST argument must be a proper list whatever REVERSED is.  You
     should use 'reverse/2' in new programs, though 'rev/2' is faster
     when it is safe to use it.
'same_length(?LIST1, ?LIST2)'

     is true when LIST1 and LIST2 are both lists and have the same
     number of elements.  No relation between the values of their
     elements is implied.  It may be used to generate either list given
     the other, or indeed to generate two lists of the same length, in
     which case the arguments will be bound to lists of length 0, 1, 2,
     ...  If either LIST1 or LIST2 is bound to a proper list,
     same_length is determinate and terminating.
'same_length(?LIST1, ?LIST2, ?LENGTH)'
     is true when LIST1 and LIST2 are both lists, LENGTH is a
     non-negative integer, and both LIST1 and LIST2 have exactly LENGTH
     elements.  No relation between the elements of the lists is
     implied.  If LENGTH is instantiated, or if either LIST1 or LIST2 is
     bound to a proper list, same_length is determinate and terminating.
'select(?X, ?XLIST, ?Y, ?YLIST)'

     is true when X is the KTH member of XLIST and Y the KTH element of
     YLIST for some K, and apart from that XLIST and YLIST are the same.
     You can use it to replace X by Y or vice versa.  Either XLIST or
     YLIST should be a proper list.
'selectchk(?X, +XLIST, ?Y, +YLIST)'

     is to 'select/4' as 'memberhck/2' is to 'member/2'.  That is, it
     finds the first K such that X unifies with the KTH element of XLIST
     and Y with the KTH element of YLIST, and it commits to the bindings
     thus found.  If you have KEYS and VALUES in "parallel" lists, you
     can use this to find the VALUE associated with a particular KEY
     (much better methods exist).  Except for argument order, this is
     identical to 'correspond/4', but 'selectchk/4' is a member of a
     coherent family.  Note that the arguments are like the arguments of
     'memberchk/2', twice.
'shorter_list(?SHORT, ?LONG)'

     is true when SHORT is a list is strictly shorter than LONG.  LONG
     doesn't have to be a proper list provided it is long enough.  This
     can be used to generate lists shorter than LONG, lengths 0, 1, 2...
     will be tried, but backtracking will terminate with a list that is
     one element shorter than LONG.  It cannot be used to generate lists
     longer than SHORT, because it doesn't look at all the elements of
     the longer list.
'subseq(?SEQUENCE, ?SUBSEQUENCE, ?COMPLEMENT)'

     is true when SUBSEQUENCE and COMPLEMENT are both subsequences of
     the list SEQUENCE (the order of corresponding elements being
     preserved) and every element of SEQUENCE which is not in
     SUBSEQUENCE is in the COMPLEMENT and vice versa.  That is,
     'length(Sequence) = length(SubSequence)+length(Complement)', e.g.
     'subseq([1,2,3,4], [1,3,4], [2])'.  This was written to generate
     subsets and their complements together, but can also be used to
     interleave two lists in all possible ways.
'subseq0(+SEQUENCE, ?SUBSEQUENCE)'

     is true when SUBSEQUENCE is a subsequence of SEQUENCE, but may be
     SEQUENCE itself.  Thus 'subseq0([a,b], [a,b])' is true as well as
     'subseq0([a,b], [a])'.  SEQUENCE must be a proper list, since there
     are infinitely many lists with a given SUBSEQUENCE.
          ?- setof(X, subseq0([a,b,c],X), Xs).
          Xs = [[],[a],[a,b],[a,b,c],[a,c],[b],[b,c],[c]]
          ?- bagof(X, subseq0([a,b,c,d],X), Xs).
          Xs = [[a,b,c,d],[b,c,d],[c,d],[d],[],[c],[b,d],[b],[b,c],[a,c,d],
                [a,d],[a],[a,c],[a,b,d],[a,b],[a,b,c]]
'subseq1(+SEQUENCE, ?SUBSEQUENCE)'

     is true when SUBSEQUENCE is a proper subsequence of SEQUENCE, that
     is it contains at least one element less.  SEQUENCE must be a
     proper list, as SUBSEQUENCE does not determine SEQUENCE.
'sumlist(+NUMBERS, ?TOTAL)'

     is true when NUMBERS is a list of integers, and TOTAL is their sum.
     NUMBERS should be a proper list.  Could be defined as:

          sumlist(Numbers, Total) :-
          	(   foreach(X,Numbers),
          	    fromto(0,S0,S,Total)
          	do  S is S0+X
          	).
'transpose(?X, ?Y)'

     is true when X is a list of the form
     [[X11,...,X1M],...,[XN1,...,XNM]] and Y is its transpose, that is,
     Y = [[X11,...,XN1],...,[X1M,...,XNM]] We insist that both lists
     should have this rectangular form, so that the predicate can be
     invertible.  For the same reason, we reject empty arrays with M = 0
     or N = 0.
'append_length(?PREFIX, ?SUFFIX, ?LIST, ?LENGTH)'

     is true when
              append(Prefix, Suffix, List), length(Prefix, Length).
     The normal use of this is to split a LIST into a PREFIX of a given
     LENGTH and the corresponding SUFFIX, but it can be used any way
     around provided that LENGTH is instantiated, or PREFIX is a proper
     list, or LIST is a proper list.
'append_length(?SUFFIX, ?LIST, ?LENGTH)'
     is true when there exists a list PREFIX such that
     'append_length(PREFIX, SUFFIX, LIST, LENGTH)' is true.  When you
     don't want to know the PREFIX, you should call this predicate,
     because it doesn't construct the PREFIX argument, which
     'append_length/4' would do.
'prefix_length(?LIST, ?PREFIX, ?LENGTH)'

     is true when
              prefix(List, Prefix) &
              length(Prefix, Length).
     The normal use of this is to find the first LENGTH elements of a
     given LIST, but it can be used any way around provided that LENGTH
     is instantiated, or PREFIX is a proper list, or LIST is a proper
     list.  It is identical in effect to 'append_length(Prefix, _, List,
     Length)'.
'proper_prefix_length(?LIST, ?PREFIX, ?LENGTH)'

     is true when
              proper_prefix(List, Prefix) &
              length(Prefix, Length).
     The normal use of this is to find the first LENGTH elements of a
     given LIST, but it can be used any way around provided that LENGTH
     is instantiated, or PREFIX is a proper list, or LIST is a proper
     list.  It is logically equivalent to 'prefix(Prefix, List, Length),
     Length > 0'.
'suffix_length(+LIST, ?SUFFIX, ?LENGTH)'

     is true when
              suffix(List, Suffix) &
              length(Suffix, Length).
     The normal use of this is to return the last LENGTH elements of a
     given LIST.  For this to be sure of termination, LIST must be a
     proper list.  The predicate suffix/2 has the same requirement.  If
     LENGTH is instantiated or SUFFIX is a proper list, this predicate
     is determinate.
'proper_suffix_length(+LIST, ?SUFFIX, ?LENGTH)'

     is true when
              proper_suffix(List, Suffix) &
              length(Suffix, Length).
     The normal use of this is to return the last LENGTH elements of a
     given LIST.  For this to be sure of termination, LIST must be a
     proper list.  The predicate proper_suffix/2 has the same If LENGTH
     is instantiated or SUFFIX is a proper list, this predicate is
     determinate.
'rotate_list(+AMOUNT, ?LIST, ?ROTATED)'

     is true when LIST and ROTATED are lists of the same length, and
              append(Prefix, Suffix, List) &
              append(Suffix, Prefix, Rotated) &
              (   Amount >= 0 & length(Prefix, Amount)
              |   Amount =< 0 & length(Suffix, Amount)
              ).
     That is to say, LIST rotated LEFT by AMOUNT is ROTATED.  If either
     LIST or ROTATED is bound to a proper list, rotate_list is
     determinate.
'rotate_list(?LIST, ?ROTATED)'
     is true when 'rotate_list(1, List, Rotated)', but is a bit less
     heavy-handed.  'rotate_list(X, Y)' rotates X left one place
     yielding Y.  'rotate_list(Y, X)' rotates X right one place yielding
     Y.  Either LIST or ROTATED should be a proper list, in which case
     rotate_list is determinate and terminating.
'sublist(+WHOLE, ?PART, ?BEFORE, ?LENGTH, ?AFTER)'

     is true when
        * WHOLE is a list - it must be proper already
        * PART is a list
        * WHOLE = ALPHA || PART || OMEGA
        * 'length(ALPHA, BEFORE)'
        * 'length(PART, LENGTH)'
        * 'length(OMEGA, AFTER)'
'cons(?HEAD, ?TAIL, ?LIST)'

     is true when HEAD is the head of LIST and TAIL is its tail.  i.e.
     'append([Head], Tail, List)'.  No restrictions.
'last(?FORE, ?LAST, ?LIST)'

     is true when LAST is the last element of LIST and FORE is the list
     of preceding elements, e.g.  'append(Fore, [Last], List)'.  FORE or
     LAST should be proper.  It is expected that LIST will be proper and
     FORE unbound, but it will work in reverse too.
'head(?LIST, ?HEAD)'

     is true when LIST is a non-empty list and HEAD is its head.  A list
     has only one head.  No restrictions.
'tail(?LIST, ?TAIL)'

     is true when LIST is a non-empty list and TAIL is its tail.  A list
     has only one tail.  No restrictions.
'prefix(?LIST, ?PREFIX)'

     is true when LIST and PREFIX are lists and PREFIX is a prefix of
     LIST.  It terminates if either argument is proper, and has at most
     N+1 solutions.  Prefixes are enumerated in ascending order of
     length.
'proper_prefix(?LIST, ?PREFIX)'

     is true when LIST and PREFIX are lists and PREFIX is a proper
     prefix of LIST.  That is, PREFIX is a prefix of LIST but is not
     LIST itself.  It terminates if either argument is proper, and has
     at most N solutions.  Prefixes are enumerated in ascending order of
     length.
'suffix(?LIST, ?SUFFIX)'

     is true when LIST and SUFFIX are lists and SUFFIX is a suffix of
     LIST.  It terminates only if LIST is proper, and has at most N+1
     solutions.  Suffixes are enumerated in descending order of length.
'proper_suffix(?LIST, ?SUFFIX)'

     is true when LIST and SUFFIX are lists and SUFFIX is a proper
     suffix of LIST.  That is, SUFFIX is a suffix of LIST but is not
     LIST itself.  It terminates only if LIST is proper, and has at most
     N solutions.  Suffixes are enumerated in descending order of
     length.
'segment(?LIST, ?SEGMENT)'

     is true when LIST and SEGMENT are lists and SEGMENT is a segment of
     LIST.  That is, LIST = _ <> SEGMENT <> _ .  Terminates only if LIST
     is proper.  If SEGMENT is proper it enumerates all solutions.  If
     neither argument is proper, it would have to diagonalise to find
     all solutions, but it doesn't, so it is then incomplete.  If
     SEGMENT is proper, it has at most N+1 solutions.  Otherwise, it has
     at most (1/2)(N+1)(N+2) solutions.
'proper_segment(?LIST, ?SEGMENT)'

     is true when LIST and SEGMENT are lists and SEGMENT is a proper
     segment of LIST.  It terminates only if LIST is proper.  The only
     solution of 'segment/2' which is not a solution of
     'proper_segment/2' is 'segment(List,List)'.  So 'proper_segment/2'
     has one solution fewer.
'cumlist(:PRED, +[X1,...,XN], ?V0, ?[V1,...,VN])'
'cumlist(:PRED, +[X1,...,XN], +[Y1,...,YN], ?V0, ?[V1,...,VN])'
'cumlist(:PRED, +[X1,...,XN], +[Y1,...,YN], +[Z1,...,ZN], ?V0, ?[V1,...,VN])'

     'cumlist/4' maps a ternary predicate PRED down the list [X1,...,XN]
     just as 'scanlist/4' does, and returns a list of the results.  It
     terminates when the lists runs out.  If PRED is bidirectional, it
     may be used to derive [X1...XN] from V0 and [V1...VN], e.g.
     'cumlist(plus, [1,2,3,4], 0, /* -> */ [1,3,6,10])' and
     'cumlist(plus, [1,1,1,1], /* <- */ 0, [1,2,3,4])'.  Could be
     defined as:

          cumlist(Pred, Xs, V0, Cum) :-
          	(   foreach(X,Xs),
          	    foreach(V,Cum),
          	    fromto(V0,V1,V,_),
          	    param(Pred)
          	do  call(Pred,X,V1,V)
          	).

          cumlist(Pred, Xs, Ys, V0, Cum) :-
          	(   foreach(X,Xs),
          	    foreach(Y,Ys),
          	    foreach(V,Cum),
          	    fromto(V0,V1,V,_),
          	    param(Pred)
          	do  call(Pred,X,Y,V1,V)
          	).

          cumlist(Pred, Xs, Ys, Zs, V0, Cum) :-
          	(   foreach(X,Xs),
          	    foreach(Y,Ys),
          	    foreach(Z,Zs),
          	    foreach(V,Cum),
          	    fromto(V0,V1,V,_),
          	    param(Pred)
          	do  call(Pred,X,Y,Z,V1,V)
          	).
'maplist(:PRED, +LIST)'

     succeeds when PRED(X) succeeds for each element X of LIST.  LIST
     should be a proper list.  Could be defined as:

          maplist(Pred, Xs) :-
          	(   foreach(X,Xs),
          	    param(Pred)
          	do  call(Pred, X)
          	).
'maplist(:PRED, +OLDLIST, ?NEWLIST)'
     succeeds when PRED(OLD,NEW) succeeds for each corresponding OLD in
     OLDLIST, NEW in NEWLIST.  Either OLDLIST or NEWLIST should be a
     proper list.  Could be defined as:

          maplist(Pred, Xs, Ys) :-
          	(   foreach(X,Xs),
          	    foreach(Y,Ys),
          	    param(Pred)
          	do  call(Pred, X, Y)
          	).
'maplist(:PRED, +XS, ?YS, ?ZS)'
     is true when XS, YS, and ZS are lists of equal length, and PRED(X,
     Y, Z) is true for corresponding elements X of XS, Y of YS, and Z of
     ZS.  At least one of XS, YS, and ZS should be a proper list.  Could
     be defined as:

          maplist(Pred, Xs, Ys, Zs) :-
          	(   foreach(X,Xs),
          	    foreach(Y,Ys),
          	    foreach(Z,Zs),
          	    param(Pred)
          	do  call(Pred, X, Y, Z)
          	).
'map_product(Pred, Xs, Ys, PredOfProduct)'

     Just as 'maplist(P, Xs, L)' is the analogue of Miranda's
              let L = [ P x | x <- Xs ]
     so 'map_product(P, Xs, Ys, L)' is the analogue of Miranda's
              let L = [ P x y | x <- Xs; y <- Ys ]
     That is, if XS = [X1,...,XM], YS = [Y1,...,YN], and P(XI,YJ,ZIJ), L
     = [Z11,...,Z1N,Z21,...,Z2N,...,ZM1,...,ZMN].  It is as if we formed
     the cartesian product of XS and YS and applied P to the (XI,YJ)
     pairs.  XS and YS should be proper lists.  Could be defined as:

          map_product(Pred, Xs, Ys, Zs) :-
          	(   foreach(X,Xs),
          	    fromto(Zs,S0,S,[]),
          	    param([Ys,Pred])
          	do  (   foreach(Y,Ys),
          		fromto(S0,[Z|S1],S1,S),
          		param([X,Pred])
          	    do  call(Pred, X, Y, Z)
          	    )
          	).
'scanlist(:PRED, [X1,...,XN], ?V1, ?V)'
'scanlist(:PRED, [X1,...,XN], [Y1,...,YN], ?V1, ?V)'
'scanlist(:PRED, [X1,...,XN], [Y1,...,YN], [Z1,...,ZN], ?V1, ?V)'

     'scanlist/4' maps a ternary relation PRED down a list.  The
     computation is PRED(X1,V1,V2), PRED(X2,V2,V3), ..., PRED(XN,VN,V)
     So if PRED is 'plus/3', 'scanlist(plus, [X1,...,Xn], 0, V)' puts
     the sum of the list elements in V.  Note that the order of the
     arguments passed to Pred is the same as the order of the arguments
     following Pred.  This also holds for scanlist/5 and scanlist/6,
     e.g.  scanlist(Pred, Xs, Ys, Zs, V1, V) calls Pred(X3,Y3,Z3,V3,V4).
     Could be defined as:

          scanlist(Pred, Xs, V0, V) :-
          	(   foreach(X,Xs),
          	    fromto(V0,V1,V2,V),
          	    param(Pred)
          	do  call(Pred, X, V1, V2)
          	).

          scanlist(Pred, Xs, Ys, V0, V) :-
          	(   foreach(X,Xs),
          	    foreach(Y,Ys),
          	    fromto(V0,V1,V2,V),
          	    param(Pred)
          	do  call(Pred, X, Y, V1, V2)
          	).

          scanlist(Pred, Xs, Ys, Zs, V0, V) :-
          	(   foreach(X,Xs),
          	    foreach(Y,Ys),
          	    foreach(Z,Zs),
          	    fromto(V0,V1,V2,V),
          	    param(Pred)
          	do  call(Pred, X, Y, Z, V1, V2)
          	).
'some(:PRED, +LIST)'

     succeeds when PRED(ELEM) succeeds for some ELEM in LIST.  It will
     try all ways of proving PRED for each ELEM, and will try each ELEM
     in the LIST.  'somechk/2' is to 'some/2' as 'memberchk/2' is to
     'member/2'.
              member(X,L)     <-> some(=(X), L).
              memberchk(X, L) <-> somechk(=(X), L).
              some(Pred,L)    <-> member(X, L), call(Pred,X).
     This acts on backtracking like member/2; List should be a proper
     list.
'some(:PRED, +[X1,...,XN], ?[Y1,...,YN])'
     is true when PRED(XI, YI) is true for some I.
'some(:PRED, +[X1,...,XN], ?[Y1,...,YN], ?[Z1,...,ZN])'
     is true when PRED(XI, YI, ZI) is true for some I.
'somechk(:PRED, +[X1,...,XN])'

     is true when PRED(XI) is true for some I, and it commits to the
     first solution it finds (like 'memberchk/2').
'somechk(:PRED, +[X1,...,XN], ?[Y1,...,YN])'
     is true when PRED(XI, YI) is true for some I, and it commits to the
     first solution it finds (like 'memberchk/2').
'somechk(:PRED, +[X1,...,XN], ?[Y1,...,YN], ?[Z1,...,ZN])'
     is true when PRED(XI, YI, ZN) is true for some I, and it commits to
     the first solution it finds (like 'memberchk/2').
'convlist(:REWRITE, +OLDLIST, ?NEWLIST)'

     is a sort of hybrid of 'maplist/3' and 'include/3'.  Each element
     of NEWLIST is the image under REWRITE of some element of OLDLIST,
     and order is preserved, but elements of OLDLIST on which REWRITE is
     undefined (fails) are not represented.  Thus if 'foo(K,X,Y) :-
     integer(X), Y is X+K.' then 'convlist(foo(1), [1,a,0,joe(99),101],
     [2,1,102]).'  OLDLIST should be a proper list.  Could be defined
     as:

          convlist(Pred, Xs, News) :-
          	(   foreach(X,Xs),
          	    fromto(News,S0,S,[]),
          	    param(Pred)
          	do  (call(Pred,X,N) -> S0 = [N|S] ; S0 = S)
          	).
'exclude(:PRED, +XS, ?SUBLIST)'
'exclude(:PRED, +XS, +YS, ?SUBLIST)'
'exclude(:PRED, +XS, +YS, +ZS, ?SUBLIST)'

     succeeds when SUBLIST is the sublist of XS containing all the
     elements XI[,YI[,ZI]] for which PRED(XI[,YI[,ZI]]) is _false_.
     That is, it removes all the elements satisfying PRED.  XS, YS or ZS
     should be a proper list.  Could be defined as:

          exclude(Pred, Xs, News) :-
          	(   foreach(X,Xs),
          	    fromto(News,S0,S,[]),
          	    param(Pred)
          	do  (call(Pred,X) -> S0 = S ; S0 = [X|S])
          	).

          exclude(Pred, Xs, Ys, News) :-
          	(   foreach(X,Xs),
          	    foreach(Y,Ys),
          	    fromto(News,S0,S,[]),
          	    param(Pred)
          	do  (call(Pred,X,Y) -> S0 = S ; S0 = [X|S])
          	).

          exclude(Pred, Xs, Ys, Zs, News) :-
          	(   foreach(X,Xs),
          	    foreach(Y,Ys),
          	    foreach(Z,Zs),
          	    fromto(News,S0,S,[]),
          	    param(Pred)
          	do  (call(Pred,X,Y,Z) -> S0 = S ; S0 = [X|S])
          	).
'include(:PRED, +XS, ?SUBLIST)'
'include(:PRED, +XS, +YS, ?SUBLIST)'
'include(:PRED, +XS, +YS, +ZS, ?SUBLIST)'

     succeeds when SUBLIST is the sublist of XS containing all the
     elements XI[,YI[,ZI]] for which PRED(XI[,YI[,ZI]]) is _true_.  That
     is, it retains all the elements satisfying PRED.  XS, YS or ZS
     should be a proper list.  Could be defined as:

          include(Pred, Xs, News) :-
          	(   foreach(X,Xs),
          	    fromto(News,S0,S,[]),
          	    param(Pred)
          	do  (call(Pred,X) -> S0 = [X|S] ; S0 = S)
          	).

          include(Pred, Xs, News) :-
          	(   foreach(X,Xs),
          	    fromto(News,S0,S,[]),
          	    param(Pred)
          	do  (call(Pred,X) -> S0 = [X|S] ; S0 = S)
          	).

          include(Pred, Xs, Ys, News) :-
          	(   foreach(X,Xs),
          	    foreach(Y,Ys),
          	    fromto(News,S0,S,[]),
          	    param(Pred)
          	do  (call(Pred,X,Y) -> S0 = [X|S] ; S0 = S)
          	).

          include(Pred, Xs, Ys, Zs, News) :-
          	(   foreach(X,Xs),
          	    foreach(Y,Ys),
          	    foreach(Z,Zs),
          	    fromto(News,S0,S,[]),
          	    param(Pred)
          	do  (call(Pred,X,Y,Z) -> S0 = [X|S] ; S0 = S)
          	).
'partition(:PRED, +LIST, ?LESS, ?EQUAL, ?GREATER)'

     is a relative of 'include/3' and 'exclude/3' which has some
     pretensions to being logical.  For each X in LIST, we call
     PRED(X,R), and route X to LESS, EQUAL, or GREATER according as R is
     '<', '=', or '>' .
'group(:PRED, +LIST, ?FRONT, ?BACK)'

     is true when 'append(Front, Back, List), maplist(Pred, Front)', and
     FRONT is as long as possible.
'group(:PRED, +KEY, +LIST, ?FRONT, ?BACK)'
     is true when 'append(Front, Back, List), maplist(call(Pred,Key),
     Front)', and FRONT is as long as possible.  Strictly speaking we
     don't need it; 'group(call(Pred,Key), List, Front, Back)' would do
     just as well.
'group(:PRED, +LIST, ?LISTOFLISTS)'
     is true when 'append(ListOfLists, List)', each element of
     LISTOFLISTS has the form [HEAD|TAIL] such that 'group(Pred, Head,
     Tail, Tail, [])', and each element of LISTOFLISTS is as long as
     possible.  For example, if you have a keysorted list, and define
     'same_key(K-_, K-_)', then 'group(same_key, List, Buckets)' will
     divide LIST up into BUCKETS of pairs having the same key.
'ordered(+LIST)'

     is true when LIST is a list of terms [T1,T2,...,TN] such that for
     all K in 2..N TK-1 '@=<' TK, i.e.  T1 '@=<' T2 '@=<' T3 ...  The
     output of 'keysort/2' is always ordered, and so is that of
     'sort/2'.  Beware: just because a list is ordered does not mean
     that it is the representation of an ordered set; it might contain
     duplicates.
'ordered(+P, +[T1,T2,...,TN])'
     is true when P(T1,T2) & P(T2,T3) & ... That is, if you take P as a
     "comparison" predicate like '@=<', the list is ordered.  This is
     good for generating prefixes of sequences, e.g.  'L = [1,_,_,_,_],
     ordered(times(2), L)' yields 'L = [1,2,4,8,16]'.
'max_member(?XMAX, +[X1,...,XN])'

     unifies XMAX with the maximum (in the sense of '@=<') of X1,...,XN.
     The list should be proper.  If it is empty, the predicate fails
     quietly.  Could be defined as:

          max_member(Maximum, [Head|Tail]) :-
          	(   foreach(X,Tail),
          	    fromto(Head,M0,M,Maximum)
          	do  (X@=<M0 -> M = M0 ; M = X)
          	).
'min_member(?XMIN, +[X1,...,XN])'

     unifies XMIN with the minimum (in the sense of '@=<') of X1,...,XN.
     The list should be proper.  If it is empty, the predicate fails
     quietly.  Could be defined as:

          min_member(Minimum, [Head|Tail]) :-
          	(   foreach(X,Tail),
          	    fromto(Head,M0,M,Minimum)
          	do  (M0@=<X -> M = M0 ; M = X)
          	).
'max_member(:P, ?XMAX, +[X1,...,XN])'
     unifies XMAX with the maximum element of [X1,...,XN], as defined by
     the comparison predicate P, which should act like '@=<' .  The list
     should be proper.  If it is empty, the predicate fails quietly.
     Could be defined as:

          max_member(Pred, Maximum, [Head|Tail]) :-
          	(   foreach(X,Tail),
          	    fromto(Head,M0,M,Maximum),
          	    param(Pred)
          	do  (call(Pred,X,M0) -> M = M0 ; M = X)
          	).
'min_member(:P, ?XMIN, +[X1,...,XN])'
     unifies XMIN with the minimum element of [X1,...,XN], as defined by
     the comparison predicate P, which should act like '@=<' .  The list
     should be proper.  If it is empty, the predicate fails quietly.
     Could be defined as:

          min_member(Pred, Minimum, [Head|Tail]) :-
          	(   foreach(X,Tail),
          	    fromto(Head,M0,M,Minimum),
          	    param(Pred)
          	do  (call(Pred,M0,X) -> M = M0 ; M = X)
          	).
'select_min(?ELEMENT, +SET, ?RESIDUE)'

     unifies ELEMENT with the smallest (in the sense of '@=<') element
     of SET, and RESIDUE with a list of all the other elements.
'select_min(:PRED, ?ELEMENT, +SET, ?RESIDUE)'
     find the least ELEMENT of SET, i.e.  PRED(ELEMENT,X) for all X in
     SET.
'select_max(?ELEMENT, +SET, ?RESIDUE)'

     unifies ELEMENT with the (leftmost) maximum element of the SET, and
     RESIDUE to the other elements in the same order.
'select_max(:PRED, ?ELEMENT, +SET, ?RESIDUE)'
     find the greatest ELEMENT of SET, i.e.  PRED(X,ELEMENT) for all X
     in SET.
'increasing_prefix(?SEQUENCE, ?PREFIX, ?SUFFIX)'
     is true when 'append(Prefix, Suffix, Sequence)' and PREFIX,
     together with the first element of SUFFIX, forms a monotone
     non-decreasing sequence, and no longer Prefix will do.
     Pictorially,
          Sequence = [x1,...,xm,xm+1,...,xn]
          Prefix   = [x1,...,xm]
          Suffix     = [xm+1,...,xn]
          x1 <= x2 <= ... <= xm <= xm+1
          not xm+1 <= xm+2
     This is perhaps a surprising definition; you might expect that the
     first element of SUFFIX would be included in PREFIX.  However, this
     way, it means that if Sequence is a strictly decreasing sequence,
     the PREFIX will come out empty.
'increasing_prefix(:ORDER, ?SEQUENCE, ?PREFIX, ?SUFFIX)'

     is the same as 'increasing_prefix/3', except that it uses the
     binary relation ORDER in place of '@=<'.
'decreasing_prefix(?SEQUENCE, ?PREFIX, ?SUFFIX)'
'decreasing_prefix(:ORDER, ?SEQUENCE, ?PREFIX, ?SUFFIX)'

     is the same, except it looks for a decreasing prefix.  The order is
     the converse of the given order.  That is, where
     'increasing_prefix/[3,4]' check X(R)Y, these routines check Y(R)X.
'clumps(+ITEMS, -CLUMPS)'

     is true when CLUMPS is a list of lists such that
        * 'append(Clumps, Items)'
        * for each CLUMP in CLUMPS, all the elements of CLUMP are
          identical ('==')
     ITEMS must be a proper list of terms for which sorting would have
     been sound.  In fact, it usually is the result of sorting.
'keyclumps(+PAIRS, ?CLUMPS)'

     is true when PAIRS is a list of pairs and CLUMPS a list of lists
     such that
        * 'append(Clumps, Pairs)'
        * for each CLUMP in CLUMPS, all of the KEY-VALUE pairs in CLUMP
          have identical ('==') KEYS.
     PAIRS must be a proper list of pairs for which keysorting would
     have been sound.  In fact, it usually is the result of keysorting.
'clumped(+ITEMS, ?COUNTS)'

     is true when COUNTS is a list of ITEM-COUNT pairs such that if
     'clumps(Items, Clumps)', then each ITEM-COUNT pair in COUNTS
     corresponds to an element [ITEM/*1*/,...,ITEM/*COUNT*/] of CLUMPS.
     ITEMS must be a proper list of terms for which sorting would have
     been sound.  In fact, it usually is the result of sorting.
'keyclumped(+PAIRS, ?GROUPS)'

     is true when PAIRS is a list of KEY-ITEM pairs and GROUPS is a list
     of KEY-ITEMS pairs such that if 'keyclumps(Pairs, Clumps)', then
     for each K-[I1,...,IN] pair in GROUPS there is a [K-I1,...,K-IN]
     clump in CLUMPS.  PAIRS must be a proper list of pairs for which
     keysorting would have been sound.  In fact, it usually is the
     result of keysorting.


File: sicstus.info,  Node: lib-logarr,  Next: lib-objects,  Prev: lib-lists,  Up: The Prolog Library

10.22 Array Operations--'library(logarr)'
=========================================

This libary module provides extendible arrays with logarithmic access
time.  *Please note:* the atom '$' is used to indicate an unset element,
and the functor '$/4' is used to indicate a subtree.  In general, array
elements whose principal function symbol is '$' will not work.

   Exported predicates:

     new_array(-A) returns a new empty array A.
'is_array(+A)'
     checks whether A is an array.
'alist(+ARRAY, -LIST)'
     returns a list of pairs INDEX-ELEMENT of all the elements of ARRAY
     that have been set.
'aref(+INDEX, +ARRAY, -ELEMENT)'
     unifies ELEMENT with ARRAY[INDEX], or fails if ARRAY[INDEX] has not
     been set.
'arefa(+INDEX, +ARRAY, -ELEMENT)'
     is as 'aref/3', except that it unifies ELEMENT with a new array if
     ARRAY[INDEX] is undefined.  This is useful for multidimensional
     arrays implemented as arrays of arrays.
'arefl(+INDEX, +ARRAY, -ELEMENT)'
     is as 'aref/3', except that ELEMENT appears as '[]' for undefined
     cells.
'aset(+INDEX, +ARRAY, +ELEMENT, -NEWARRAY)'
     unifies NEWARRAY with the result of setting ARRAY[INDEX] to
     ELEMENT.


File: sicstus.info,  Node: lib-objects,  Next: lib-odbc,  Prev: lib-logarr,  Up: The Prolog Library

10.23 The Objects Package--'library(objects)'
=============================================

* Menu:

* obj-exp::                             Exported Predicates
* obj-glo::                             Glossary
* obj-bas::                             Introduction
* obj-scl::                             Simple Classes
* obj-inh::                             Inheritance
* obj-tcl::                             Term Classes
* obj-tech::                            Technical Details

The SICStus Objects package enables programmers to write object-oriented
programs in SICStus Prolog.  The objects in SICStus Objects are
modifiable data structures that provide a clean and efficient
alternative to storing data in the Prolog database.


File: sicstus.info,  Node: obj-bas,  Next: obj-scl,  Prev: obj-glo,  Up: lib-objects

10.23.1 Introduction
--------------------

* Menu:

* obj-bas-uobj::                        Using SICStus Objects
* obj-bas-def::                         Defining Classes
* obj-bas-ucl::                         Using Classes
* obj-bas-la::                          Looking Ahead

The SICStus Objects package enables programmers to write object-oriented
programs in SICStus Prolog.  The objects in SICStus Objects are
modifiable data structures that provide a clean and efficient
alternative to storing data in the Prolog database.

   This user's guide is neither an introduction to object-oriented
programming nor an introduction to SICStus Prolog.  A number of small,
sample programs are described in this manual, and some larger programs
are in the 'demo' directory.


File: sicstus.info,  Node: obj-bas-uobj,  Next: obj-bas-def,  Up: obj-bas

10.23.1.1 Using SICStus Objects
...............................

One of the basic ideas of object-oriented programming is the
encapsulation of data and procedures into objects.  Each object belongs
to exactly one class, and an object is referred to as an instance of its
class.  A class definition determines the following things for its
objects:

   * slots, where an object holds data
   * messages, the commands that can be sent to an object
   * methods, the procedures the object uses to respond to the messages

   All interaction with an object is by sending it messages.  The
command to send a message to an object has the form

     OBJECT MESSAGEOP MESSAGE

where OBJECT is an object, MESSAGEOP is one of the message operators
('<<', '>>', or '<-') and MESSAGE is a message defined for the object's
class.  Roughly speaking, the '>>' message operator is used for
extracting information from an object, '<<' is for storing information
into an object, and '<-' is for any other sort of operation.

   For example, using the point class defined in the next section, it
would be possible to give the following command, which demonstrates all
three message operators.

     | ?- create(point, PointObj),
          PointObj >> x(InitX),
          PointObj >> y(InitY),
          PointObj << x(2.71828),
          PointObj << y(3.14159),
          PointObj <- print(user_output),
          nl(user_output).

     (2.71828,3.14159)
     PointObj = point(23461854),
     InitX = 1.0,
     InitY = 2.0

   First it binds the variable 'PointObj' to a newly created 'point'
object.  Then, the two get messages (sent with the '>>' operator) fetch
the initial values of the point's 'x' and 'y' slots, binding the
variables 'InitX' and 'InitY' to these values.  Next, the two put
messages (sent with the '<<' operator) assign new values to the object's
'x' and 'y' slots.  Finally, the send message (sent with the '<-'
operator) instructs the point object to print itself to the
'user_output' stream, followed by a newline.  Following the goal, we see
the point has been printed in a suitable form.  Following this, the
values of 'PointObj', 'InitX', and 'InitY' are printed as usual for
goals entered at the top-level prompt.

   Because this goal is issued at the top-level prompt, the values of
the variables 'PointObj', 'InitX' and 'InitY' are not retained after the
command is executed and their values are displayed, as with any goal
issued at the top-level prompt.  However, the point object still exists,
and it retains the changes made to its slots.  Hence, objects, like
clauses asserted to the Prolog database, are more persistent than Prolog
variables.

   Another basic idea of object-oriented programming is the notion of
inheritance.  Rather than defining each class separately, a new class
can inherit the properties of a more general superclass.  Or, it can be
further specialized by defining a new subclass, which inherits its
properties.  (C++ uses the phrase "base class" where we use
"superclass."  It also uses "derived class" where we use "subclass.")

   SICStus Objects uses term expansion to translate object-oriented
programs into ordinary Prolog.  (This is the same technique that Prolog
uses for its DCG grammar rules.)  As much as possible is done at compile
time.  Class definitions are used to generate Prolog clauses that
implement the class's methods.  Message commands are translated into
calls to those Prolog clauses.  And, inheritance is resolved at
translation time.

   SICStus Objects consists of two modules, 'obj_decl' and 'objects'.
The 'obj_decl' module is used at compile time to translate the
object-oriented features of SICStus Objects.  Any file that defines
classes or sends messages should include the command

     :- load_files(library(obj_decl),
                   [when(compile_time), if(changed)]).

   The 'objects' module provides runtime support for SICStus Objects
programs.  A file that sends messages or asks questions about what
classes are defined or to what class an object belongs should include
the command:

     :- use_module(library(objects)).

   You will probably include both in most files that define and use
classes.

   *Please note:* A file that loads 'library(obj_decl)' currently cannot
recursively load another file that loads 'library(obj_decl)', because
that would confuse the internal database being used by the package.

   If you use the foreign resource linker, 'splfr', on a Prolog file
that uses the 'objects' package, then you must pass it the '--objects'
option.  This will make 'splfr' understand the package's syntax
extensions.


File: sicstus.info,  Node: obj-bas-def,  Next: obj-bas-ucl,  Prev: obj-bas-uobj,  Up: obj-bas

10.23.1.2 Defining Classes
..........................

A class definition can restrict the values of any slot to a particular
C-style type.  It can specify whether a slot is "private" (the default,
meaning that it cannot be accessed except by that methods of that
class), "protected" (like "private", except that the slot can also be
accessed by subclasses of the class), or "public" (meaning get and put
methods for the slot are generated automatically), and it can specify an
initial value.  The class definition also may contain method clauses,
which determine how instances of the class will respond to messages.  A
class definition may also specify one or more superclasses and which
methods are to be inherited.

   The point object created in the previous example had two floating
point slots, named 'x' and 'y', with initial values of 1.0 and 2.0,
respectively.  As we have seen, the 'point' class also defined put and
get methods for 'x' and 'y', as well as a send method for printing the
object.  The put and get methods for 'x' and 'y' can be automatically
generated simply by declaring the slots 'public', but the 'print' method
must be explicitly written.  In addition, in order to be able to create
instances of this class, we must define a 'create' method, as explained
in *note obj-scl-meth::.  We also provide a second 'create' method,
taking two arguments, allowing us to specify an 'x' and 'y' value when
we first create a point object.

     :- class point =
             [public x:float = 1.0,
              public y:float = 2.0].

     Self <- create.

     Self <- create(X, Y) :-
             Self << x(X),
             Self << y(Y).

     Self <- print(Stream) :-
             Self >> x(X),
             Self >> y(Y),
             format(Stream, '(~w,~w)', [X,Y]).

     :- end_class point.

   The variable name 'Self' in these clauses is arbitrary--any variable
to the left of the message operator in the head of a method clause
refers to the instance of the class receiving the message.


File: sicstus.info,  Node: obj-bas-ucl,  Next: obj-bas-la,  Prev: obj-bas-def,  Up: obj-bas

10.23.1.3 Using Classes
.......................

Given this definition, the following command creates an instance of the
point class, assigning values to its 'x' and 'y' slots, and prints a
description of the point.

     | ?- create(point(3,4), PointObj),
          PointObj <- print(user_output).

   The print message prints '(3.0,4.0)'.  The variable 'PointObj' is
bound to a Prolog term of the form

     point(ADDRESS)

where ADDRESS is essentially a pointer to the object.

   In general, an object belonging to a class CLASSNAME will be
represented by a Prolog term of the form

     CLASSNAME(ADDRESS)

   The name CLASSNAME must be an atom.  This manual refers to such a
term as if it were the object, not just a pointer to the object.  Users
are strongly discouraged from attempting to do pointer arithmetic with
the address.

   After execution of this command, the point object still exists, but
the variable 'PointObj' can no longer be used to access it.  So, while
objects resemble clauses asserted into the Prolog database in their
persistence, there is no automatic way to search for an object.  Objects
are not automatically destroyed when they are no longer needed.  And,
there is no automatic way to save an object from one Prolog session to
the next.  It is the responsibility of the programmer to keep track of
objects, perhaps calling the 'destroy/1' predicate for particular
objects that are no longer needed or asserting bookkeeping facts into
the Prolog database to keep track of important objects.


File: sicstus.info,  Node: obj-bas-la,  Prev: obj-bas-ucl,  Up: obj-bas

10.23.1.4 Looking Ahead
.......................

The next few sections of this manual describe the SICStus Objects
package in greater detail.  In particular, they describe how to define
classes, their methods and their slots, and how to reuse class
definitions via inheritance.  Small sample programs and program
fragments are provided for most of the features described.

   Experienced Prolog programmers may choose to skip over these sections
and look at the sample programs in this package's demo directory,
referring to the reference pages as necessary.  Everyone is encouraged
to experiment with the sample programs before writing their own
programs.


File: sicstus.info,  Node: obj-scl,  Next: obj-inh,  Prev: obj-bas,  Up: lib-objects

10.23.2 Simple Classes
----------------------

* Menu:

* obj-scl-scp::                         Scope of a Class Definition
* obj-scl-slt::                         Slots
* obj-scl-meth::                        Methods

This section is about simple classes that inherit nothing--neither slots
nor methods--from more general superclasses.  Everything about these
classes is given directly in their definitions, so they are the best
starting point for programming with SICStus Objects.

   The use of inheritance in defining classes is described in the next
section.  Classes that inherit properties from superclasses are called
derived classes in some systems, such as C++.  In general, the use of
inheritance extends the properties of the simple classes in this
section.


File: sicstus.info,  Node: obj-scl-scp,  Next: obj-scl-slt,  Up: obj-scl

10.23.2.1 Scope of a Class Definition
.....................................

A simple class definition begins with a statement of the form

     :- class CLASSNAME = [SLOTDEF, ...].

   The class's slots are described in the list of SLOTDEF terms.  It is
possible, though not often useful, to define a class with no slots, by
specifying the empty list.  In that case the '=' and the list may be
omitted.

   The class's methods are defined following the 'class/1' directive, by
Prolog clauses.  Most of this section is about defining and using
methods.

   The class definition ends with any of the following:

     :- end_class CLASSNAME.

or

     :- end_class.

or the next 'class/1' directive or the end of the file.  The CLASSNAME
argument to 'end_class/1' must match the class name in the corresponding
'class/1' directive.  It is not possible to nest one class definition
inside another.


File: sicstus.info,  Node: obj-scl-slt,  Next: obj-scl-meth,  Prev: obj-scl-scp,  Up: obj-scl

10.23.2.2 Slots
...............

A slot description has the form

     VISIBILITY SLOTNAME:SLOTTYPE = INITIALVALUE

where VISIBILITY and '= INITIALVALUE' are optional.  Each slot of a
class must have a distinct name, given by the atom SLOTNAME.  The
VISIBILITY, SLOTTYPE and INITIALVALUE parts of the slot description are
described separately.

Visibility
----------

A slot's visibility is either private, protected, or public.  If its
visibility is not specified, then the slot is private.  The following
example shows all four possibilities:

     :- class example = [w:integer,
                         private   x:integer,
                         protected y:integer,
                         public    z:integer]

   Slot 'z' is public, 'y' is protected, and both 'x' and 'w' are
private.

   Direct access to private slots is strictly limited to the methods of
the class.  Any other access to such slots must be accomplished through
these methods.  Making slots private will allow you later to change how
you represent your class, adding and removing slots, without having to
change any code that uses your class.  You need only modify the methods
of the class to accomodate that change.  This is known as "information
hiding".

   Protected slots are much like private slots, except that they can
also be directly accessed by subclasses.  This means that if you wish to
modify the representation of your class, then you will need to examine
not only the class itself, but also its subclasses.

   Public slots, in contrast, can be accessed from anywhere.  This is
accomplished through automatically generated get and put methods named
for the slot and taking one argument.  In the example above, our
'example' class would automatically support a get and put method named
'z/1'.  Note, however, that unlike other object oriented programming
languages that support them, public slots in SICStus Objects do not
violate information hiding.  This is because you may easily replace a
public slot with your own get and put methods of the same name.  In this
sense, a public slot is really only a protected slot with automatically
generated methods to fetch and store its contents.

   Within a method clause, any of the class's slots can be accessed via
the 'fetch_slot/2' and 'store_slot/2' predicates.  These are the only
way to access private and protected slots.  They may be used to define
get and put methods for the class, which provide controlled access to
the protected slots.  But, they can only be used within the method
clauses for the class, and they can only refer to slots of the current
class and protected and public slots of superclasses.

   In the slot description, 'public', 'protected' and 'private' are used
as prefix operators.  The 'obj_decl' module redefines the prefix
operator 'public', as follows:

     :- op(600, fy, [public]).

   Unless you use the obsolete 'public/1' directive in your Prolog
programs, this should cause no problems.

Types
-----

A slot's type restricts the kinds of values it may contain.  The slot is
specified in the slot description by one of the following Prolog terms
with the corresponding meaning.  Most of these will be familiar, but the
last four, 'address', 'term', CLASS and 'pointer(TYPE)', require some
additional explanation:

'integer'
     signed integer, large enough to hold a pointer

'integer_64   since release 4.3'
     64-bit signed integer

'integer_32'
     32-bit signed integer

'integer_16'
     16-bit signed integer

'integer_8'
     8-bit signed integer

'unsigned'
     unsigned integer, large enough to hold a pointer

'unsigned_64   since release 4.3'
     64-bit unsigned integer

'unsigned_32'
     32-bit unsigned integer

'unsigned_16'
     16-bit unsigned integer

'unsigned_8'
     8-bit unsigned integer

'float'
     64-bit floating point number

'float_32'
     32-bit floating point number

'atom'
     Prolog atom

'address'
     Pointer.  The 'address' type is intended for use with foreign code.
     A slot of this type might store an address returned from a foreign
     function.  That address might, in turn, be used in calling another
     foreign function.  Hence, most Prolog programmers can safely ignore
     this type.

'term'
     Prolog term.  The 'term' type is for general Prolog terms.  Such a
     slot can hold any of the other types.  However, if you know a slot
     will be used to hold only values of a particular type, then it is
     more efficient to specify that type in the class definition.

     Storing a term containing free variables is similar to asserting a
     clause containing free variables into the Prolog database.  The
     free variables in the term are replaced with new variables in the
     stored copy.  And, when you fetch the term from the slot, you are
     really fetching a copy of the term, again with new variables.

'CLASS'
     where CLASS is the name of a defined class.  The class type is for
     any object in a class defined with SICStus Objects.  Such a slot
     holds an object of its class or one of that class's descendants, or
     the 'null' object.

'pointer(TYPE)'
     where TYPE is an atom.  The pointer type is intended for use with
     the Structs Package.  It is similar to the 'address' type, except
     that access to this slot yields, and update to this slot expects, a
     term of arity 1 whose functor is TYPE and whose argument is the
     address.  Again, most Prolog programmers can safely ignore this
     type.

Initial Values
--------------

A slot description may optionally specify an initial value for the slot.
The initial value is the value of the slot in every instance of the
class, when the object is first created.  The initial value must be a
constant of the correct type for the slot.

   If an initial value is not specified, then a slot is initialized to a
value that depends on its type.  All numbers are initialized to 0, of
the appropriate type.  Atom and term slots are initialized to the empty
atom ('''').  Addresses and pointers are initialized to null pointers.
And, objects are initialized to the 'null' object.

   More complicated initialization--not the same constant for every
instance of the class--must be performed by create methods, which are
described later.

The 'null' object
-----------------

The 'null' object is a special object that is not an instance of any
class, but that can be stored in a slot intended for any class of
object.  This is very much like the 'NULL' pointer in C. This is useful
when you do not yet have an object to store in a particular slot.

   In Prolog, the 'null' is represented by the atom 'null'.

   Note that because the 'null' object is not really an object of any
class, you cannot determine its class with 'class_of/2'.  Unless noted
otherwise, when we write of an "object" in this document, we do not
include the 'null' object.


File: sicstus.info,  Node: obj-scl-meth,  Prev: obj-scl-slt,  Up: obj-scl

10.23.2.3 Methods
.................

Some methods are defined by method clauses, between the 'class/1'
directive and the end of the class's definition.  Others are generated
automatically.  There are three kinds of messages in SICStus Objects,
distinguished by the message operator they occur with:

'>>'
     A get message, which is typically used to fetch values from an
     object's slots.

'<<'
     A put message, which is typically used to store values in an
     object's slots.

'<-'
     A send message, which is used for other operations on or involving
     an object.

   SICStus Objects automatically generates some get and put methods.
And, it expects particular message names with the send operator for
create and destroy methods.  For the most part, however, you are free to
use any message operators and any message names that seem appropriate.

   A method clause has one of these message operators as the principal
functor of its head.  Its first argument, written to the left of the
message operator, is a variable.  By convention, we use the variable
'Self'.  Its second argument, written to the right of the message
operator, is a term whose functor is the name of the message and whose
arguments are its arguments.

   For example, in the class whose definition begins as follows, a
0-argument send message named 'increment' is defined.  No parentheses
are needed in the clause head, because the precedence of the '<-'
message operator is lower than that of the ':-' operator.

     :- class counter = [public count:integer = 0].

     Self <- increment :-
             Self >> count (X0),
             X1 is X0 + 1,
             Self << count (X1).

   Its definition uses the automatically generated get and put methods
for the public slot 'count'.

   It may look as though this technique is directly adding clauses to
the '>>/2', '<</2' and '<-/2' predicates, but the method clauses are
transformed by term expansion, at compile time.  However, the method
clauses have the effect of extending the definitions of those
predicates.

   Methods are defined by Prolog clauses, so it is possible for them to
fail, like Prolog predicates, and it is possible for them to be
nondeterminate, producing multiple answers, upon backtracking.  The rest
of this section describes different kinds of methods.

Get and Put Methods
-------------------

Get and put methods are generated automatically for each of a class's
public slots.  These are 1-argument messages, named after the slots.

   In the point class whose definition begins with

     :- class point =
             [public x:float=0,
              public y:float=0].

the get and put methods are automatically generated for the 'x' and 'y'
slots.  If the class defines a 'create/0' method, then the command

     | ?- create(point, PointObj),
          PointObj >>  x(OldX),
          PointObj >>  y(OldY),
          PointObj <<  x(3.14159),
          PointObj <<  y(2.71828).

creates a point object and binds both 'OldX' and 'OldY' to 0.0E+00, its
initial slot values.  Then, it changes the values of the 'x' and 'y'
slots to 3.14159 and 2.71828, respectively.  The variable 'PointObj' is
bound to the point object.

   It is possible, and sometimes quite useful, to create get and put
methods for slots that do not exist.  For example, it is possible to add
a polar coordinate interface to the point class by defining get and put
methods for 'r' and 'theta', even though there are no 'r' and 'theta'
slots.  The get methods might be defined as follows:

     Self >> r(R) :-
             Self >> x(X),
             Self >> y(Y),
             R is sqrt(X*X + Y*Y).

     Self >> theta(T) :-
             Self >> x(X),
             Self >> y(Y),
             T is atan(Y/X).

   The put methods are left as an exercise.

   In the rational number class whose definition begins with:

     :- class rational =
             [public num:integer,
              public denom:integer].

get and put methods are automatically generated for the 'num' and
'denom' slots.  It might be reasonable to add a get method for 'float',
which would provide a floating point approximation to the rational in
response to that get message.  This is left as an exercise.

   It is also possible to define get and put methods that take more than
one argument.  For example, it would be useful to have a put method for
the point class that sets both slots of a point object.  Such a method
could be defined by

     Self << point(X,Y) :-
             Self << x(X),
             Self << y(Y).

   Similarly, a 2-argument get method for the rational number class
might be defined as

     Self >> (N/D) :-
             Self >> num(N),
             Self >> denom(D).

   Note that the name of the put message is '(/)/2', and that the
parentheses are needed because of the relative precedences of the '>>'
and '/' operators.

   Put messages are used to store values in slots.  Get messages,
however, may be used either to fetch a value from a slot or to test
whether a particular value is in a slot.  For instance, the following
command tests whether the 'do_something/2' predicate sets the point
object's 'x' and 'y' slots to 3.14159 and 2.71828, respectively.

     | ?- create(point, PointObj),
          do_something(PointObj),
          PointObj >> x(3.14159),
          PointObj >> y(2.71828).

   The 'fetch_slot/2' predicate can similarly be used to test the value
of a slot.

   The effects of a put message (indeed, of any message) are not undone
upon backtracking.  For example, the following command fails:

     | ?- create(point, PointObj),
          PointObj << x(3.14159),
          PointObj << y(2.71828),
          fail.

   But, it leaves behind a point object with 'x' and 'y' slots
containing the values 3.14159 and 2.71828, respectively.  In this,
storing a value in an object's slot resembles storing a term in the
Prolog database with 'assert/1'.

   Some care is required when storing Prolog terms containing unbound
variables in term slots.  For example, given the class definition that
begins with

     :- class prolog_term = [public p_term:term].

     Self <- create.

the following command would succeed:

     | ?- create(prolog_term, TermObj),
          TermObj << p_term(foo(X,Y)),
          X = a,
          Y = b,
          TermObj >> p_term(foo(c,d)).

   The reason is that the free variables in 'foo(X,Y)' are renamed when
the term is stored in the 'prolog_term' object's 'p_term' slot.  This is
similar to what happens when such a term is asserted to the Prolog
database:

     | ?- retractall(foo(_,_)),
          assert(foo(X,Y)),
          X = a,
          Y = b,
          foo(c,d).

   However, this goal would fail, because 'c' and 'd' cannot be unified:

     | ?- create(prolog_term, TermObj),
          TermObj << p_term(foo(X,X)),
          TermObj >> p_term(foo(c,d)).

Direct Slot Access
------------------

Get and put methods are not automatically generated for private and
protected slots.  Those slots are accessed by the 'fetch_slot/2' and
'store_slot/2' predicates, which may only appear in the body of a method
clause and which always operate on the object to which the message is
sent.  It is not possible to access the slots of another object with
these predicates.

   You may declare a slot to be private or protected in order to limit
access to it.  However, it is still possible, and frequently useful, to
define get and put methods for such a slot.

   For example, if numerator and denominator slots of the rational
number class were private rather than public, then it would be possible
to define put methods to ensure that the denominator is never 0 and that
the numerator and denominator are relatively prime.  The get methods
merely fetch slot values, but they need to be defined explicitly, since
the slots are private.  The new definition of the rational number class
might start as follows:

     :- class rational =
             [num:integer=0,
              denom:integer=1].

     Self >> num(N) :-
             fetch_slot(num, N).

     Self >> denom(D) :-
             fetch_slot(denom, D).

     Self >> (N/D) :-
             Self >> num(N),
             Self >> denom(D).

   One of the put methods for the class might be

     Self << num(NO) :-
             fetch_slot(denom, DO)
             reduce(NO, DO, N, D),
             store_slot(num, N),
             store_slot(denom, D).

where the 'reduce/4' predicate would be defined to divide 'NO' and 'DO'
by their greatest common divisor, producing 'N' and 'D', respectively.

   The definition of 'reduce/4' and the remaining put methods is left as
an exercise.  The put methods should fail for any message that attempts
to set the denominator to 0.

Send Methods
------------

Messages that do something more than fetch or store slot values are
usually defined as send messages.  While the choice of message operators
is (usually) up to the programmer, choosing them carefully enhances the
readability of a program.

   For example, print methods might be defined for the point and
rational number classes, respectively, as

     Self <- print(Stream) :-
             Self >> x(X),
             Self >> y(Y),
             format(Stream, "(~w,~w)", [X, Y]).

and

     Self <- print(Stream) :-
             fetch_slot(num, N),
             fetch_slot(denom, D),
             format(Stream, "~w/~w", [N, D]).

   These methods are used to access slot values.  But, the fact that the
values are printed to an output stream makes it more reasonable to
define them as send messages than get messages.

   Frequently send methods modify slot values.  For example, the point
class might have methods that flip points around the x and y axes,
respectively:

     Self <- flip_x :-
             Self >> y(Y0),
             Y1 is -1 * Y0,
             Self << y(Y1).

     Self <- flip_y :-
             Self >> x(X0),
             X1 is -1 * X0,
             Self << x(X1).

   And, the rational number class might have a method that swaps the
numerator and denominator of a rational number object.  It fails if the
numerator is 0.

     Self <- invert :-
             fetch_slot(num, N)
             N =\= 0,
             fetch_slot(denom, D)
             store_slot(num, D),
             store_slot(denom, N).

   These methods modify slot values, but they do not simply store values
that are given in the message.  Hence, it is more reasonable to use the
send operator.

   It is possible for a method to produce more than one answer.  For
example, the class whose definition begins with

     :- class interval =
             [public lower:integer,
              public upper:integer].

might define a send method

     Self <- in_interval(X) :-
             Self >> lower(L),
             Self >> upper(U),
             between(L, U, X).

which uses the 'between/3' predicate from 'library(between)'.  The
'in_interval' message will bind 'X' to each integer, one at a time,
between the lower and upper slots, inclusive.  It fails if asked for too
many answers.

   The rest of this section describes particular kinds of send messages.

Create and Destroy Methods
--------------------------

Objects are created with the 'create/2' predicate.  When you define a
class, you must specify all the ways that instances of the class can be
created.  The simplest creation method is defined as

     Self <- create.

   If this method were defined for CLASS, then the command

     | ?- create(CLASS, Object).

would create an instance of CLASS and bind the variable 'Object' to that
instance.  All slots would receive their (possibly default) initial
values.

   More generally, if the definition for CLASS contains a create method

     Self <- create(ARGUMENTS) :-
             BODY.

then the command

     | ?- create(CLASS(ARGUMENTS), OBJECT).

will create an instance of CLASS and execute the BODY of the create
method, using the specified ARGUMENTS.  The variable OBJECT is bound to
the new instance.

   If a simple class definition has no create methods, then it is
impossible create instances of the class.  While the absence of create
methods may be a programmer error, that is not always the case.
Abstract classes, which are classes that cannot have instances, are
often quite useful in defining a class hierarchy.

   Create methods can be used to initialize slots in situations when
specifying initial slot values will not suffice.  (Remember that initial
values must be specified as constants at compile time).  The simplest
case uses the arguments of the create message as initial slot values.
For example, the definition of the point class might contain the
following create method.

     Self <- create(X,Y) :-
             Self << x(X),
             Self << y(Y).

   If used as follows

     | ?- create(point(3.14159, 2.71828), PointObj),
          PointObj >> x(X),
          PointObj >> y(Y).

then it would give 'X' and 'Y' the values of 3.14159 and 2.71828,
respectively.

   In some cases, the create method might compute the initial values.
The following (partial) class definition uses the 'date/1' predicate
from 'library(date)' to initialize its year, month and day slots.

     :- class date_stamp =
             [year:integer,
              month:integer,
              day:integer].

     Self <- create :-
             date(date(Year, Month, Day)),
             store_slot(year, Year),
             store_slot(month, Month),
             store_slot(day, Day).

   All three slots are private, so it will be necessary to define get
methods in order to retrieve the time information.  If no put methods
are defined, however, then the date cannot be modified after the
'date_stamp' object is created (unless some other method for this class
invokes 'store_slot/2' itself).

   Create methods can do more than initialize slot values.  Consider the
'named_point' class, whose definition begins as follows:

     :- class named_point =
             [public name:atom,
              public x:float=1,
              public y:float=0].

     Self <- create(Name, X, Y) :-
             Self << name(Name),
             Self << x(X),
             Self << y(Y),
             assert(name_point(Name, Self)).

   Not only does the 'create/3' message initialize the slots of a new
'named_point' object, but it also adds a 'name_point/2' fact to the
Prolog database, allowing each new object to be found by its name.
(This create method does not require the 'named_point' object to have a
unique name.  Defining a 'uniq_named_point' class is left as an
exercise.)

   An object is destroyed with the 'destroy/1' command.  Unlike
'create/2', 'destroy/1' does not require that you define a 'destroy'
method for a class.  However, 'destroy/1' will send a destroy message
(with no arguments) to an object before it is destroyed, if a 'destroy'
method is defined for the object's class.

   If a 'named_point' object is ever destroyed, then the address of the
object stored in this name 'point/2' fact is no longer valid.  Hence,
there should be a corresponding destroy method that retracts it.

     Self <- destroy :-
             Self >> name(Name),
             retract(name_point(Name, Self)).

   Similar create and destroy methods can be defined for objects that
allocate their own separate memory or that announce their existence to
foreign code.

Instance Methods
----------------

Instance methods allow each object in a class to have its own method for
handling a specified message.  For example, in a push-button class it
would be convenient for each instance (each push-button) to have its own
method for responding to being pressed.

   The declaration

     :- instance_method NAME/ARITY, ....

inside a class definition states that the message NAME/ARITY supports
instance methods.  If the class definition defines a method for this
message, then it will be treated as a default method for the message.

   The 'define_method/3' predicate installs a method for an object of
the class, and the 'undefine_method/3' predicate removes that method.

   Suppose that the 'date_stamp' class, defined earlier, declared an
instance method to print the year of a 'date_stamp' instance.

     :- instance_method print_year/1.

     Self <- print_year(Stream) :-
             Self >> year(Y0),
             Y1 is YO + 1970,
             format(Stream, "~d", [Y1]).

   The arithmetic is necessary because UNIX dates are based on January
1, 1970.

   If a particular 'date_stamp' object's date were to be printed in
Roman numerals, then it could be given a different 'print_year' method,
using the 'define_method/3' predicate.

     | ?- create(date_stamp, DateObj),
          define_method(DateObj,
     		   print_year(Stream),
     		   print_roman_year(Stream, DateObj)).

   If this 'date_stamp' object is created in 1994, then a 'print_year'
message sent to it would print the current year as

     MCMXCIV

   Defining the predicate 'print_roman_year/2' is left as an exercise.
It must be able to access the 'year' slot of a 'date_stamp' object.
Because it is not defined by a method clause within the class
definition, 'print_roman_year/2' cannot use the 'get_slot/2' predicate.

   None of 'instance_method/1', 'define_method/3', 'undefine_method/3'
specify a message operator.  Instance methods can only be defined for
send messages.


File: sicstus.info,  Node: obj-inh,  Next: obj-tcl,  Prev: obj-scl,  Up: lib-objects

10.23.3 Inheritance
-------------------

* Menu:

* obj-inh-sih::                         Single Inheritance
* obj-inh-mih::                         Multiple Inheritance
* obj-inh-ask::                         Asking About Classes and Objects

This section describes the additional features (and the additional
complexity) of defining classes with inheritance in SICStus Objects.
Most of what was said about classes in the previous section remains true
in these examples.


File: sicstus.info,  Node: obj-inh-sih,  Next: obj-inh-mih,  Up: obj-inh

10.23.3.1 Single Inheritance
............................

The simplest case is when a new class inherits some properties (slots
and methods) from a single superclass.  That superclass may, in turn, be
defined in terms of its superclass, etc.  The new class, its superclass,
its superclass's superclass (if any) and so on are all ancestors of the
new class.

Class Definitions
-----------------

The definition of a class with a single superclass begins with a
'class/1' directive of the form

     :- class CLASSNAME = [SLOTDEF, ...] +  SUPERCLASS.

where the list of SLOTDEF descriptions may be empty.  In that case, the
definition can simplified to

     :- class CLASSNAME = SUPERCLASS.

   The class SUPERCLASS must be a defined class when this definition is
given.

   In SICStus Objects, a subclass inherits all the slots of its
superclass.  And, by default, it inherits all the methods of its
superclass.  The remainder of this section describes what the programmer
can do to control this inheritance.

Slots
-----

A class's slots are a combination of those explicitly defined in its
slot description list and the slots it inherits from its superclass.  In
SICStus Objects, a class inherits all the slots of its superclass.  It
follows that a class inherits all the slots of all its ancestors.

   The programmer's control over inheritance of slots is limited.  It is
not possible to rename an inherited slot, nor is it possible to change
its type, unless it is a class slot.  It is possible to change a slot's
initial value.  And, it is possible to effectively change a slot's
visibility.

   To change the initial value or the type (when allowed) of a slot,
include a new SLOTDEF in the list of slot descriptions for the class,
with the same slot name and a new type or initial value.  The type of a
class slot can only be changed to a subclass of the type of the
superclass's slot.  The new initial value must still be a constant of
the appropriate type.

   The 'named_point' class, defined earlier, could have better been
defined from the point class, which began as follows:

     :- class point =
             [public x:float=0,
              public y:float=0].

   The definition of the 'named_point' class would then begin with

     :- class named_point =
             [public name:atom,
              public x:float=1.0] + point.

   This 'named_point' class has public slots named 'name', 'x' and 'y',
with the same types and initial values as the earlier 'named_point'
definition, which did not use inheritance.  This 'named_point' class
also inherits all the methods of the 'point' class, which saves us from
having to write them again (and maintain them).

   A slot that was private or protected in a superclass may be defined
as public.  This will cause get and put methods to be generated in the
subclass.  A slot that was public in a superclass may be defined as
protected or private, but this does not prevent it from inheriting the
get and put methods of the superclass.  For that, the 'uninherit/1'
directive, defined below, is needed.

Methods
-------

In SICStus Objects, by default, a class inherits all the methods of its
superclass.  The programmer has more control over the inheritance of
methods than the inheritance of slots, however.  In particular, methods
can be uninherited and they can be redefined.

   To prevent a method from being inherited, use the 'uninherit/1'
directive.  For example, suppose that the class 'point' is defined as
before.  That is, its definition begins as follows:

     :- class point =
             [public x:float=0,
              public y:float=0].

   Because both slots are public, a put method is automatically
generated for each, which allows their values to be changed.

   The definition of a new class 'fixed_point' might begin as follows:

     :- class fixed_point = point.

     :- uninherit
             point << (x/l),
             point << (y/l).

     Self <- create(X, Y) :-
             store_slot(x, X),
             store_slot(y, Y).

   The parentheses are necessary because of the precedences of the '<<'
and '/' operators.

   Because the put methods from 'point' are not inherited, no instance
of the 'fixed_point' class can change its 'x' and 'y' values once
created--unless the class definition contains another method for doing
so.  The get methods are inherited from 'point', however.

   To redefine a method, simply include method clauses for its message
within a class's definition.  The new method clauses replace, or shadow,
the inherited method clauses for this class.

   Another way to prevent the 'x' and 'y' slots of the 'fixed_point'
class from being modified would be to shadow the put methods.  For
example, they might be redefined as

     Self << x(_) :-
             format(user_error, "cannot modify x slot value.~n.", []),
             fail.

     Self << y(_) :-
             format(user_error, "cannot modify y slot value.~n", []),
             fail.

   Now attempts to modify the 'x' or 'y' values of a fixed point object
generate a specific error message and fail.  A more complicated version
would raise an appropriate exception.

Send Super
----------

Even when a superclass's method is shadowed or uninherited, it is
possible to use the superclass's method inside a method clause for the
new class.  This makes it possible to define a "wrapper" for the
superclass's method, which invokes the superclass's method without
having to duplicate its code.  This technique works with all message
types.

   Sending a message to a superclass is done with a command of the form

     super MESSAGEOP MESSAGE

where MESSAGEOP is one of the message operators ('<<', '>>' or '<-') and
MESSAGE is a message defined for the superclass.  A generalization of
this syntax may be used to specify which superclass to send the message
to.  This is discussed in *note obj-inh-mih::.

   Sending a message to a class's superclass can only be done within a
message clause.


File: sicstus.info,  Node: obj-inh-mih,  Next: obj-inh-ask,  Prev: obj-inh-sih,  Up: obj-inh

10.23.3.2 Multiple Inheritance
..............................

It is possible for a class to be defined with more than one superclass.
Because the class inherits properties from multiple superclasses, this
is referred to as multiple inheritance.

   Multiple inheritance is a complex and controversial topic.  What
should be done about conflicting slot or method definitions?  (This is
sometimes called a "name clash.")  What should be done about slots that
are inherited from two or more superclasses, but that originate with a
common ancestor class?  (This is sometimes called "repeated
inheritance".)  Different systems take different approaches.

   SICStus Objects supports multiple inheritance in a limited but still
useful way.  It does not allow repeated inheritance, and it places all
the responsibility for resolving name clashes on the programmer.  This
section describes the multiple inheritance features of SICStus Objects.

Class Definitions
-----------------

The definition of a class with multiple superclasses begins with a
'class/1' directive of the form

     :- class CLASSNAME = [SLOTDEF, ...] + SUPERCLASS + ....

   The list of slot descriptions and the superclasses to the right of
the '=' can appear in any order, without changing the class being
defined.  In fact, the slot descriptions can be partitioned into more
than one list, without changing the class.  However, it is best to adopt
a fairly simple style of writing class definition and use it
consistently.

   Just as the slot names in a list of slot descriptions must be
distinct, superclass names should not be repeated.

Slots
-----

In SICStus Objects, the programmer has no control over multiple
inheritance of slots.  All slots from all superclasses are inherited.
And, the superclasses should have no slot names in common.

   As a consequence, in SICStus Objects no superclasses of a class
should have a common ancestor.  The only exception would be the unusual
case where that common ancestor has no slots.

Methods
-------

By default, all methods are inherited from all superclasses.  Any of the
superclasses' methods can be uninherited, as described earlier, by using
the 'uninherit/1' directive.

   If the same message is defined for more than one superclass, however,
then you must choose at most one method to inherit for the message.  You
may choose none.  You may do this by defining a new method for the
message (shadowing the superclasses' methods), or by using the
'uninherit/1' directive, or by using the 'inherit/1' directive.

   The following is considered a classic example of multiple
inheritance.

     :- class toy.             % no slots in this class

     Self >> size(small).

     Self >> rolls(false).

     :- end_class toy.

     :- class truck.         % no slots in this class

     Self >> size(large).

     Self >> rolls(true).

     :- end_class truck.

   The idea expressed in these definitions is that most toys are small
and do not roll.  On the other hand, most trucks are large, but they do
roll.  A toy truck shares one feature with each class, but we can hardly
expect a compiler to choose the correct one.

   The definition of a new class, toy_truck, might begin with

     :- class toy_truck = toy + truck.

   Rather than redefine the get methods for 'size' and 'rolls', we can
specify which to inherit in two ways.  One way is positive, stating
which to inherit, and the other way is negative, stating which not to
inherit.

   The positive version would be

     :- inherit
             toy >> (size/1),
             truck >> (rolls/1).

   This is more convenient when a message is defined in several
superclasses, because all but the chosen method are uninherited.  And,
it is probably easier to understand.

   The negative version would be

     :- uninherit
             toy >> (rolls/1),
             truck >> (size/1).

   The 'toy_truck' class would exhibit the same behavior with either
definition.

   It is possible to define methods that access the shadowed or
uninherited methods of the superclasses, by sending the message to the
superclasses.  In the case of multiple inheritance, however, it may be
necessary to specify which superclass to send the message to.

   The 'toy_truck' class, for example, might define these methods:

     Self >> uninherited_size(S) :-
             super(truck) >> size(S).

     Self >> uninherited_rolls(R) :-
             super(toy) >> rolls(R).

   They provide access to the unchosen methods from 'toy_truck''s
superclasses.

   While these examples with the toy_truck class are clearly "toy"
examples, the same techniques can be used in more realistic cases.

Abstract and Mixin Classes
--------------------------

While SICStus Objects only supports a limited form of multiple
inheritance, its facilities are sufficient for working with so-called
"mixin classes".

   The idea is to construct similar classes by first defining a class
that contains the things the desired classes have in common.  Typically,
this will be an "abstract class", which will have no instances itself.
Then, provide the features that differentiate the desired classes with a
set of mixin classes

   Mixin classes that have nothing in common can safely be mixed
together, to build the desired classes.  The mixin classes will usually
be abstract classes, also, because they are too specialized for their
instances to be useful on their own.

   The date_stamp class defined earlier would make a good mixin class.
A similar 'time_stamp' class might be (partially) defined as follows:

     :- class time_stamp =
             [hour:integer,
              minute:integer,
              second:integer].

     Self <- create :-
             time(time(Hour, Minute, Second)),
             store_slot(hour, Hour),
             store_slot(minute, Minute),
             store_slot(second, Second).

   Another mixin class might be used to "register" objects in the Prolog
database.

     :- class registry = [name:atom].

     Self <- create(Name) :-
             Self << name(Name),
             assert(registered(Name, Self)).

     Self <- destroy :-
             Self >> name(Name),
             retract(registered(Name, Self)).

   The 'registry' mixin class could have been used with the 'point'
class to define the 'named_point' class, which was an example from an
earlier section.

   The ability to send a message to an object's superclass is useful
when working with mixin classes.  Suppose the definition of a new class
begins with

     :- NEWCLASS = OLDCLASS + date + time + registry.

where OLDCLASS is some previously defined class that lacks the features
provided by the 'date', 'time' and 'registry' classes.  (In fact, they
should not have any slot names in common.)  Then its create method can
be defined by

     Self <- create(Name) :-
             super(OldClass) <- create,
             super(date) <- create,
             super(time) <- create,
             super(registry) <- create(Name).

   This avoids the need to duplicate the code in the create methods of
OldClass and all three mixin classes.


File: sicstus.info,  Node: obj-inh-ask,  Prev: obj-inh-mih,  Up: obj-inh

10.23.3.3 Asking About Classes and Objects
..........................................

It is possible to determine, at run time, what classes are defined, how
they are related by inheritance, what class an object belongs to, etc.
This section describes the predicates used for those purposes.  Most of
the predicates involve the class hierarchy, so they are properly
described in the section on inheritance.  But, several can be useful
even in programs that use only simple classes.

   Most of these predicates come in pairs, where one predicate involves
one class or its direct superclasses, and the other predicate involves
all ancestors.  For example, the 'class_superclass/2' and
'class_ancestor/2' predicates connect a currently defined class to its
superclass(es) and to all its ancestors, respectively.

   In all of these predicates, the ancestors of a class include not only
superclasses and their ancestors, but also the class itself.  A class
cannot be a superclass of itself, by the rules of defining classes.
However, it is convenient to consider every class an ancestor of itself,
because then we may say that every property of a class is defined in one
of its ancestors, without having to say "the class itself or a
superclass or a superclass of a superclass, etc."

Objects
-------

The 'class_of/2' predicate is used to test whether an object is of a
particular type or to determine the type of an object.  Similarly, the
'descendant_of/2' predicate relates an object to all ancestors of its
class.  (Remember that the object's class is, itself, an ancestor class
of the object.)

   Both require the first argument (the object) to be instantiated.
That is, the predicates cannot be used to find objects of a given class.
If you need to search among all the objects of a class, then you must
provide a way to do it.  One way to do this is to assert a fact
connecting the class name to every object, when it is created.  The
named_point example of the previous section took that idea a step
further by allowing each object to have a different name.

   The 'pointer_object/2' predicate relates an object's address (a
pointer) to the object.  Remember that an instance of CLASS is
represented by a term of the form

     CLASS(ADDRESS)

   The 'pointer_object/2' predicate requires that one of its arguments
be instantiated, but it may be either one.  Hence, just by knowing the
address of an object (which possibly was returned by a foreign function)
it is possible to determine the object's type.

   Most Prolog programmers can safely ignore the 'pointer_object/2'
predicate, unless they are using SICStus Objects with foreign functions
or with the Structs package.

Classes
-------

The 'current_class/1' predicate is used to ask whether a class is
currently defined or to get the names of all currently defined classes.

   The 'class_superclass/2' predicate is used to test whether one class
is a superclass of another, or to find a class's superclasses, or to
find a class's subclasses, or to find all subclass-superclass pairs.
The 'class_ancestor/2' predicate is used in the same ways for the
ancestor relation between currently defined classes.

   As an example, the following goal finds all the ancestors of each
currently defined class.

     | ?- setof(C-As,
     	   (current_class(C),
     	    setof(A, class_ancestor(C,A), As)),
     	   L).

   It binds 'L' to a list of terms of the form CLASS-ANCESTORLIST, with
one term for each currently defined class.

   Arguably, this predicate violates the principle of information
hiding, by letting you ask about how a class is defined.  Therefore, you
should generally avoid it.  It may be useful, however, in debugging and
in building programmer support tools.

Messages
--------

The 'message/4' predicate is used to ask whether a message is defined
for a class or to find what messages are defined for a class, etc.  It
does not distinguish between messages whose methods are defined in the
class itself and those that are inherited from a superclass.

   The 'direct_message/4' predicate is used to ask whether a message is
not only defined for a class, but whether the method for that message is
defined in the class itself.  It can also be used to determine which
methods are defined in a class.  This ability to look inside a class
definition makes 'direct_message/4' an egregious violator of the
principle of information hiding.  Thus it, like 'class_ancestor/2',
should mainly be confined to use in programmer support applications.

   Both 'message/4' and 'direct_message/4' take the message operator as
an argument, along with the class, message name and arity.  Hence it is
possible to use these predicates to ask about get, put or send messages.

   It is not possible to ask about a class's slots, nor should it be.
However, it is possible (and quite reasonable) to ask about the get and
put messages that are defined for a class.  For example, the following
goal finds all the 1-argument messages that are defined for both the get
and put message operators in the class CLASS.

     | ?- setof(Message,
     	   (message(CLASS, <<, Msg, 1),
     	    message(CLASS, >>, Msg, 1)),
     	   L).

   There may or may not be slots corresponding to these messages; that
detail is hidden in the definition of CLASS.  However, it should be
possible to use CLASS as if the slots were there.

   As an example, recall the polar coordinate interface to the point
class, which defined get and put methods for 'r' and 'theta', even
though data was represented inside an object by rectangular coordinates
'x' and 'y'.


File: sicstus.info,  Node: obj-tcl,  Next: obj-tech,  Prev: obj-inh,  Up: lib-objects

10.23.4 Term Classes
--------------------

* Menu:

* obj-tcl-stcl::                        Simple Term Classes
* obj-tcl-rtrm::                        Restricted Term Classes
* obj-tcl-tce::                         Specifying a Term Class Essence

Sometimes it is convenient to be able to send messages to ordinary
Prolog terms as if they were objects.  Prolog terms are easier to create
than objects, and unlike objects, they are automatically garbage
collected (see *note obj-tech-lim::).  Of course, unlike objects, Prolog
terms cannot be modified.  However, when a particular class of objects
never needs to be dynamically modified, and does not need to be
subclassed, it may be appropriate to define it as a "term class".

   A term class is defined much like an ordinary class: it begins with a
':- class' directive defining the class and its slots, follows with
clauses defining the methods for this class, and ends with an ':-
end_class' directive, the end of the file, or another ':- class'
directive.  The only difference is in the form of the ':- class'
directive introducing a term class definition.


File: sicstus.info,  Node: obj-tcl-stcl,  Next: obj-tcl-rtrm,  Up: obj-tcl

10.23.4.1 Simple Term Classes
.............................

The simplest sort of term class declaration has the following form:
     :- class CLASSNAME = term(TERM).

   This declares that any term that unifies with TERM is an instance of
class CLASSNAME.  For example, you might declare:
     :- class rgb_color = term(color(_Red,_Green,_Blue)).

     color(R,_G,_B) >> red(R).
     color(_R,G,_B) >> green(G).
     color(_R,_G,B) >> blue(B).

     :- end_class rgb_color.

   This would declare any term whose principal functor is 'color' and
arity is three to be an object of class 'rgb_color'.  Given this
declaration, entering the goal
     color(0.5, 0.1, 0.6) >> blue(B)

would bind 'B' to 0.6.

   Note that you cannot use 'create/2' to create a term class instance.
Since they are just ordinary terms, you can create them the same way you
would create any ordinary Prolog term.  Similarly, you cannot modify an
existing term class instance.

   You may specify a term class as the type of a slot of an ordinary
class.  This is effectively the same as specifing the type to be 'term'.
In particular, fetching and storing term class slots is not very
efficient.  Also, the default value for slots of term class type is
''''; this is because not enough is known about a simple term class to
determine a better default.  For an explanation of how to avoid these
pitfalls, see *note obj-tcl-tce::.


File: sicstus.info,  Node: obj-tcl-rtrm,  Next: obj-tcl-tce,  Prev: obj-tcl-stcl,  Up: obj-tcl

10.23.4.2 Restricted Term Classes
.................................

The intention of the 'rgb_color' class presented above is to represent a
color as a triple of floating point numbers between 0.0 and 1.0.  But
the above definition does not restrict the arguments of the 'color' term
in any way: _any_ 'color/3' term is considered to be an instance of the
'rgb_color' class.

   The second form of term class declaration allows you to specify
constraints on instances of a term class.  The form of such a
declaration is as follows:
     :- class CLASSNAME = term(TERM, CONSTRAINT).

   This declares that any term that unifies with TERM and satisfies
CONSTRAINT is an instance of class CLASSNAME.  The CONSTRAINT term is an
ordinary Prolog goal, which will usually share variables with TERM.

   To extend our 'rgb_color' class example so that only 'color/3' terms
whose arguments are all floats between 0.0 and 1.0 are instances of
'rgb_color', we would instead begin the definition as follows:
     :- class rgb_color =
              term(color(Red,Green,Blue),
                   (float(Red),   Red >= 0.0,   Red =< 1.0,
                    float(Green), Green >= 0.0, Green =< 1.0,
                    float(Blue),  Blue >= 0.0,  Blue =< 1.0)).

   Note the parentheses around the constraint in this example.  Whenever
the constraint contains multiple goals separated by commas, you will
need to surround the goal with parentheses.

   With this definition of the 'rgb_color' class, only 'color/3' terms
whose arguments are all floating point numbers between 0 and 1 inclusive
will be considered to be instances of 'rgb_color'.


File: sicstus.info,  Node: obj-tcl-tce,  Prev: obj-tcl-rtrm,  Up: obj-tcl

10.23.4.3 Specifying a Term Class Essence
.........................................

As mentioned above, it is possible to specify a term class as the type
of a slot of some other object.  For example, we might declare

     :- class colored_rectangle = [
             public origin:point,
             public size:size,
             public color:rgb_color].

   This will store an 'rgb_color' object (i.e., a 'color/3' term) in the
'color' slot of each 'colored_rectangle' object.  Unfortunately, though,
SICStus Objects cannot tell what is the best way to store a term object,
and therefore it stores it the same way it stores a slot declared to be
of 'term' type: using the Prolog database.  This has all the efficiency
disadvantages of 'term' slots.  In this case, however, we know that all
that really needs to be saved in order to save an 'rgb_color' object is
the three arguments.  We also know that each of these arguments is a
floating point number, and because precision is not terribly critical in
representating colors, each of these numbers can be stored as a 'float',
rather than a 'double'.  In effect, we know that the _essence_ of a
'rgb_color' object is these three numbers; if we have them, then we can
easily construct the 'color/3' term.  If we provide this information in
the declaration of the 'rgb_color' class, then SICStus Objects can store
instances of the 'rgb_color' class as 3 separate floats, rather than as
a term, significantly improving the performance of creating or
destroying a 'colored_rectangle' object, as well as accessing or
modifying its 'color' slot.

   The essence of a term class is specified with the following form of
'class' declaration:
     :- class CLASSNAME = term(TERM, CONSTRAINT, ESSENCE).

where ESSENCE is of the form
     [NAME1:TYPE1=i[Variable1], NAME2:TYPE2=i[Variable2], ...]

and each NAME is a distinct atom naming a slot, each TYPE is a slot type
as specified in *note obj-scl-slt::, and each VARIABLE is an unbound
variable appering in TERM.  Providing a term essence not only makes
storage of terms in ordinary object slots more efficient, it also gives
a name to each "essential" slot of the term class.  This allows you to
use 'fetch_slot' to fetch the slots of this class.

   To extend our 'rgb_color' example, we might introduce the 'rgb_color'
class with this declaration:
     :- class rgb_color =
              term(color(Red,Green,Blue),
                   (float(Red),   Red >= 0.0,   Red =< 1.0,
                    float(Green), Green >= 0.0, Green =< 1.0,
                    float(Blue),  Blue >= 0.0,  Blue =< 1.0),
                   [red:float=Red, green:float=Green, blue:float=Blue]).

   This declaration defines the 'rgb_color' class exactly as the example
declaration of the previous section: every 'color/3' term whose
arguments are all floating point numbers between 0.0 and 1.0 inclusive
are instances of 'rgb_color'.  The difference is that with this
declaration, ordinary classes that have slots of type 'rgb_color', such
as the 'colored_rectangle' example above, will be stored more
efficiently, and their 'rgb_color' slots will be accessed and modified
much more efficiently.  Also, it will be possible to use
'fetch_slot(red, Red)' in the methods of the 'rgb_color' class to fetch
to red component of the message recipient, and similarly for 'green' and
'blue'.


File: sicstus.info,  Node: obj-tech,  Next: obj-exp,  Prev: obj-tcl,  Up: lib-objects

10.23.5 Technical Details
-------------------------

* Menu:

* obj-tech-syn::                        Syntax of Class Definitions
* obj-tech-lim::                        Limitations

This section will be expanded in future versions of SICStus Objects.
For now, it provides a BNF grammar for the syntax of class definitions
and a short list of some limitations of SICStus Objects.


File: sicstus.info,  Node: obj-tech-syn,  Next: obj-tech-lim,  Up: obj-tech

10.23.5.1 Syntax of Class Definitions
.....................................

The following BNF grammar gives a concise description of the syntax of
class definitions.  It assumes an understanding of Prolog syntax for the
following items: "variable", "atom", "compound_term", and "constant".
Slot types, particularly the 'address', 'class' and 'pointer' types,
were discussed in an earlier section.

CLASS_DEF          ::= CLASS_BEGIN { CLAUSE | METHOD } CLASS_END

CLASS_BEGIN        ::= ':- class' CLASS_NAME OPT_CLASS_SPEC '.'

OPT_CLASS_SPEC     ::= EMPTY | '=' CLASS_SPEC

CLASS_SPEC         ::= MULTI_PARENT_OR_SLOTS | TERM_CLASS_SPEC

CLAUSE             ::= HEAD OPT_BODY '.'

HEAD               ::= ATOM | COMPOUND_TERM '.'

METHOD             ::= MESSAGE_HEAD OPT_BODY '.'

MESSAGE_HEAD       ::= MESSAGE_GOAL

CLASS_END          ::= ':- end_class' OPT_CLASS_NAME '.'
                   | EMPTY /* if followed by CLASS_BEGIN or EOF */

MESSAGE            ::= ATOM | COMPOUND_TERM

MULTI_PARENT_OR_SLOTS::= PARENT_OR_SLOTS { '+' PARENT_OR_SLOTS }

PARENT_OR_SLOTS    ::= CLASS_NAME | '[]' | '[' SLOT_DEF {',' SLOT_DEF }
                   ']'

SLOT_DEF           ::= OPT_VISIBILITY SLOT_NAME ':' SLOT_TYPE
                   OPT_INIT_VALUE

OPT_VISIBILITY     ::= EMPTY | 'private' | 'protected' | 'public'

OPT_INIT_VALUE     ::= EMPTY | '=' CONSTANT

TERM_CLASS_SPEC    ::= 'term('TERM OPT_GOAL_ESSENCE')'

OPT_GOAL_ESSENCE   ::= EMPTY | ',' GOAL OPT_ESSENCE

OPT_ESSENCE        ::= EMPTY | ',' ESSENCE

ESSENCE            ::= '[' VARIABLE ':' SLOT_TYPE { ',' VARIABLE ':'
                   SLOT_TYPE } ']'

OPT_BODY           ::= EMPTY | ':-' BODY

BODY               ::= MESSAGE_OR_GOAL { ',' MESSAGE_OR_GOAL }

MESSAGE_OR_GOAL    ::= MESSAGE_GOAL | GOAL

MESSAGE_GOAL       ::= VARIABLE MESSAGE_OPERATOR MESSAGE

MESSAGE_OPERATOR   ::= '<<' | '>>' | '<-'

OPT_CLASS_NAME     ::= EMPTY | CLASS_NAME

CLASS_NAME         ::= ATOM

SLOT_NAME          ::= ATOM

SLOT_TYPE          ::= 'integer'
                   | 'short'
                   | 'char'
                   | 'unsigned_short'
                   | 'unsigned_char'
                   | 'float'
                   | 'double'
                   | 'atom'
                   | 'address'
                   | 'term'
                   | CLASS_NAME
                   | 'pointer(ATOM)'


File: sicstus.info,  Node: obj-tech-lim,  Prev: obj-tech-syn,  Up: obj-tech

10.23.5.2 Limitations
.....................

This section summarizes the current limitations of SICStus Objects.

Debugging
---------

When you debug SICStus Objects programs that were compiled using the
'obj_decl' module, you are tracing the translated version of your code.
This includes all method clauses and (some) message sending commands.

   The source-linked debugger cannot connect compiled SICStus Objects
code with the source code.

Garbage Collection
------------------

There is no garbage collection of objects.  It is the responsibility of
the programmer to keep track of unused objects.  In particular, avoid
doing the following:

     | ?- create(CLASS, OBJECT).

   Unless the create message for CLASS made some provision for finding
the new object again, it is now lost.  It cannot be used, and it cannot
be destroyed.

Multiple Inheritance
--------------------

The provisions for multiple inheritance in this version of SICStus
Objects are limited.  In particular, there is no control over the
inheritance of slots, which makes repeated inheritance impossible.
However, it does support the mixin style of multiple inheritance.

Persistence
-----------

While objects are more persistent than Prolog variables, there is no
automatic way to save objects from one execution of your program to the
next.  Hence they are less persistent than the clauses in the Prolog
database.

   If you need to save a set of objects from one Prolog session to
another, then copy the objects to the Prolog database as terms, and save
them to a QOF file.  Then, after you reload the QOF file, rebuild the
objects.  Keep in mind that addresses are not valid from one session to
another.

   In short, there is no way to avoid initializing objects at run time.


File: sicstus.info,  Node: obj-exp,  Next: obj-glo,  Prev: obj-tech,  Up: lib-objects

10.23.6 Exported Predicates
---------------------------

* Menu:

* obj-exp-send::                        <-/2
* obj-exp-put::                         <</2
* obj-exp-get::                         >>/2
* obj-exp-class::                       class/1
* obj-exp-class_ancestor::              class_ancestor/2
* obj-exp-class_method::                class_method/1
* obj-exp-class_superclass::            class_superclass/2
* obj-exp-class_of::                    class_of/2
* obj-exp-create::                      create/2
* obj-exp-current_class::               current_class/1
* obj-exp-debug_message::               debug_message/0
* obj-exp-define_method::               define_method/3
* obj-exp-descendant_of::               descendant_of/2
* obj-exp-destroy::                     destroy/1
* obj-exp-direct_message::              direct_message/4
* obj-exp-end_class::                   end_class/[0,1]
* obj-exp-fetch_slot::                  fetch_slot/2
* obj-exp-inherit::                     inherit/1
* obj-exp-instance_method::             instance_method/1
* obj-exp-message::                     message/4
* obj-exp-nodebug_message::             nodebug_message/0
* obj-exp-pointer_object::              pointer_object/2
* obj-exp-store_slot::                  store_slot/2
* obj-exp-undefine_method::             undefine_method/3
* obj-exp-uninherit::                   uninherit/1

The following reference pages, alphabetically arranged, describe the
exported SICStus Objects predicates.  They can be imported by an
embedded command:

     :- use_module(library(objects)).


File: sicstus.info,  Node: obj-exp-send,  Next: obj-exp-put,  Up: obj-exp

10.23.6.1 '<-/2'
................

Synopsis
--------

+OBJ '<-' +MESG

Arguments
---------

OBJ
     "object"

MESG
     "term"

Description
-----------

Sends MESG to OBJ.  A send message.  The class of OBJ must have a method
defined for this message.

   A clause with '<-/2' as the principal functor of its head is a method
definition clause.  Such clauses only occur within the scope of a class
definition.  They are expanded at compile time.

Exceptions
----------

'instantiation_error'

     either argument is unbound.

'domain_error'

     MESG is not "callable" or OBJ is not a valid object.

'existence_error'

     MESG is not a defined message for OBJ.

Caveat
------

For reasons of efficiency, an Existence Error will only be raised if the
code that sends the message is compiled with debugging enabled (see
'debug_message'), or if the message is not determined at compile-time.
In other circumstances, the message will simply fail.

   Calls to the '<-/2' predicate will be compiled into more efficient
code if the 'obj_decl' module is loaded at compile time.

See Also
--------

'<</2', '>>/2', 'direct_message/4', 'message/4'


File: sicstus.info,  Node: obj-exp-put,  Next: obj-exp-get,  Prev: obj-exp-send,  Up: obj-exp

10.23.6.2 '<</2'
................

Synopsis
--------

+OBJ '<<' +ATT

Arguments
---------

OBJ
     "object"

ATT
     "term"

Description
-----------

Sends a message to 'Obj' to store the value of 'Att' in the object.  A
put message.  'Att' must be an attribute that can be stored in objects
of 'Obj''s class.

   A clause with '<</2' as the principal functor of its head is a method
definition clause.  Such clauses only occur within the scope of a class
definition.  They are expanded at compile time.

   Put methods are automatically generated for public slots.

Exceptions
----------

'instantiation_error'

     either argument is unbound.

'domain_error'

     MESG is not "callable" or OBJ is not a valid object.

'existence_error'

     MESG is not a defined message for OBJ.

Caveat
------

For reasons of efficiency, an Existence Error exception will only be
raised if the code that sends the message is compiled with debugging
enabled (see 'debug_message'), or if the message is not determined at
compile-time.  In other circumstances, the message will simply fail.

   Calls to the '<</2' predicate will be compiled into more efficient
code if the 'obj_decl' module is loaded at compile time.

See Also
--------

'<-/2', '>>/2', 'direct_message/4', 'message/4', 'store_slot/2'


File: sicstus.info,  Node: obj-exp-get,  Next: obj-exp-class,  Prev: obj-exp-put,  Up: obj-exp

10.23.6.3 '>>/2'
................

Synopsis
--------

+OBJ '>>' +-ATT

Arguments
---------

OBJ
     "object"

ATT
     "term"

Description
-----------

Sends a message to OBJ that fetches the value of ATT from the object.  A
get message.  ATT must be an attribute to fetch from OBJ's class.

   A clause with '>>/2' as the principal functor of its head is a method
definition clause.  Such clauses only occur within the scope of a class
definition.  They are expanded at compile time.

   Get methods are automatically generated for public slots.

Exceptions
----------

'instantiation_error'

     either argument is unbound.

'domain_error'

     MESG is not "callable" or OBJ is not a valid object.

'existence_error'

     MESG is not a defined message for OBJ.

Caveat
------

For reasons of efficiency, an Existence Error exception will only be
raised if the code that sends the message is compiled with debugging
enabled (see 'debug_message'), or if the message is not determined at
compile-time.  In other circumstances, the message will simply fail.

   Calls to the '>>/2' predicate will be compiled into more efficient
code if the 'obj_decl' module is loaded at compile time.

See Also
--------

'<-/2', '<</2', 'direct_message/4', 'message/4', 'fetch_slot/2'


File: sicstus.info,  Node: obj-exp-class,  Next: obj-exp-class_ancestor,  Prev: obj-exp-get,  Up: obj-exp

10.23.6.4 'class/1'  declaration
................................

Synopsis
--------

':- class CLASSNAME.'

   ':- class CLASSNAME = [SLOTDEF, ...].'

   ':- class CLASSNAME = SUPER.'

   ':- class CLASSNAME = [SLOTDEF, ...] + SUPER + ....'

   ':- class CLASSNAME = term(TERM).'

   ':- class CLASSNAME = term(TERM, GOAL).'

   ':- class CLASSNAME = term(TERM, GOAL, ESSENCE).'

Arguments
---------

CLASSNAME
     "atom"

SLOTDEF
     "term"

SUPER
     "atom"

Description
-----------

The definition of class CLASSNAME begins with this 'class/1' directive
and ends with the next 'class/1' directive, the next 'end_class/[0,1]'
directive, or the end of the file, whichever comes first.  All clauses
that look like method definitions within the scope of the class
definition (that is, which have one of '<-/2', '<</2' or '>>/2' as the
principal functors of their heads) are considered method definitions of
the class.

   You may provide as many slot definitions (SLOTDEF) and superclasses
(SUPER) as you like.  All superclasses must be previously defined
classes.

   A slot definition (SlotDef) has the form

     VISIBILITY SLOTNAME:TYPE = INITIALVALUE

where VISIBILITY and '= INITIALVALUE' are optional.

   VISIBILITY is either 'public', 'protected', or 'private'.  If it is
omitted, then the slot is private.

   SLOTNAME must be an atom.

   SLOTTYPE must be one of the following:

'integer'
     signed integer, large enough to hold a pointer

'integer_64   since release 4.3'
     64-bit signed integer

'integer_32'
     32-bit signed integer

'integer_16'
     16-bit signed integer

'integer_8'
     8-bit signed integer

'unsigned'
     unsigned integer, large enough to hold a pointer

'unsigned_64   since release 4.3'
     64-bit unsigned integer

'unsigned_32'
     32-bit unsigned integer

'unsigned_16'
     16-bit unsigned integer

'unsigned_8'
     8-bit unsigned integer

'float'
     64-bit floating point number

'float_32'
     32-bit floating point number

'atom'
     Prolog atom

'address'
     pointer

'term'
     Prolog term

'CLASS'
     pointer to an instance of CLASS, which must be a previously defined
     class

'pointer(TYPE)'
     like 'address', except that access to this slot yields, and update
     of this slot expects, a unary term whose functor is TYPE

   INITIALVALUE may be any constant appropriate for the slot's type.

   TERM, if specified, is any compound Prolog term.  Class declarations
of any of the last three forms introduce a "term class", which defines
any term that unifies with TERM as an instance of the class being
defined.

   GOAL, if specified, is any Prolog goal.  This goal may be used to
restrict which terms that unify with TERM will be considered to be
instance of the class being defined.  The default GOAL is 'true'.  Other
than when it is 'true', GOAL will usually share variables with TERM.

   ESSENCE, if specified, is a list of terms of the form
     VARIABLE:TYPE

where VARIABLE is a variable apprearing somewhere in TERM and TYPE is
one of the possible SLOTTYPE types listed above.  There should be a
VARIABLE':'TYPE pair for every variable in TERM.  By specifying an
essence, you permit much more space- and time-efficient storage of and
access to term slots.

Caveat
------

Note that every class for which you want to be able to create instances
must define at least one create method.

Examples
--------

The following class definition is for a class named 'point', with two
public slots, named 'x' and 'y'.  Both slots are of type 'integer' and
have initial values of 1 and 2, respectively.

     :- class point =
             [public x:integer=1,
              public y:integer=2].

     Self <- create.
     :- end_class point.

   Because the slots are public, they have get and put methods generated
automatically.  Because the class has a create method defined, it is
possible to create an instance with the command

     | ?- create(point, PointObj).

which creates a 'point' object and binds the variable 'PointObj' to it.

   Using the 'point' class, we could create a class, 'named_point',
which has an extra public slot, 'name'.

     :- class named_point =
             [public name:atom] + point.

     Self <- create(Name, X, Y) :-
             Self << name(Name),
             Self << x(X),
             Self << y(Y).

     :- end_class named_point.

   The only way to create a 'named_point' object requires specifying
values for all three slots.

See Also
--------

'end_class/[0,1]'

   *note obj-scl::, *note obj-tcl::.


File: sicstus.info,  Node: obj-exp-class_ancestor,  Next: obj-exp-class_method,  Prev: obj-exp-class,  Up: obj-exp

10.23.6.5 'class_ancestor/2'
............................

Synopsis
--------

'class_ancestor(?CLASS, ?ANC)'

Arguments
---------

CLASS
     "atom"

ANC
     "atom"

Description
-----------

ANC is CLASS or an ancestor class of CLASS.

See Also
--------

'class_superclass/2'


File: sicstus.info,  Node: obj-exp-class_method,  Next: obj-exp-class_superclass,  Prev: obj-exp-class_ancestor,  Up: obj-exp

10.23.6.6 'class_method/1'  declaration
.......................................

Synopsis
--------

':- class_method +NAME/+ARITY, ... .'

Arguments
---------

NAME
     "atom"

ARITY
     "integer"

Description
-----------

Declares that a class's method for send message NAME/ARITY is an
ordinary method, not an instance method.

   Used when the class being defined inherits an instance method from a
superclass, to allow the class to define a non-instance method for the
message.  A descendent class may still declare this to be an instance
method, so the same message may be an instance method for some classes
and an ordinary class method for others.

   Must occur within the scope of the class definition.  Only applies to
send messages.

See Also
--------

'instance_method/1'


File: sicstus.info,  Node: obj-exp-class_superclass,  Next: obj-exp-class_of,  Prev: obj-exp-class_method,  Up: obj-exp

10.23.6.7 'class_superclass/2'
..............................

Synopsis
--------

'class_superclass(?CLASS, ?SUPER)'

Arguments
---------

CLASS
     "atom"

SUPER
     "atom"

Description
-----------

CLASS is an immediate subclass of SUPER.

See Also
--------

'class_ancestor/2'


File: sicstus.info,  Node: obj-exp-class_of,  Next: obj-exp-create,  Prev: obj-exp-class_superclass,  Up: obj-exp

10.23.6.8 'class_of/2'
......................

Synopsis
--------

'class_of(+OBJ, -CLASS)'

Arguments
---------

OBJ
     "object"

CLASS
     "atom"

Description
-----------

CLASS is the class of OBJ.

Exceptions
----------

'instantiation_error'

     OBJ is unbound.

'type_error'

     OBJ is not a valid object.

See Also
--------

'pointer_object/2'


File: sicstus.info,  Node: obj-exp-create,  Next: obj-exp-current_class,  Prev: obj-exp-class_of,  Up: obj-exp

10.23.6.9 'create/2'
....................

Synopsis
--------

'create(+DESCRIPTOR,-OBJ)'

Arguments
---------

DESCRIPTOR
     "term"

OBJ
     "object"

Description
-----------

OBJ is a newly created and initialized object.  Descriptor is a term
describing the object to create.  After memory is allocated and any slot
initializations are performed, a create message is sent to the object.

   The functor of DESCRIPTOR indicates the class to create.  The
arguments of the create message are the arguments of DESCRIPTOR.

Exceptions
----------

'instantiation_error'

     DESCRIPTOR is unbound.

'domain_error'

     DESCRIPTOR is not a valid 'create' descriptor.

'resource_error'

     unable to allocate enough memory for object.

Caveat
------

You must have a 'create/N' method for every arity N you want to be able
to use in creating instances of a class.  This includes arity 0.  If no
such method exists, then a domain error will be raised.

Examples
--------

Given the class definition

     :- class point =
                     [public x:integer=1,
                      public y:integer=2].

     Self <- create.
     Self <- create(X, Y) :-
                     Self << x(X),
                     Self << y(Y).
     :- end_class point.

the command

     | ?- create(point, Point1).

creates a 'point' object, with the default slot values for 'x' and 'y',
and binds variable 'Point1' to the new object.  The command

     | ?- create(point(10,15), Point2).

creates a 'point' object with values 10 and 15 for slots 'x' and 'y',
respectively, and binds variable 'Point2' to the new object.

See Also
--------

'destroy/1'


File: sicstus.info,  Node: obj-exp-current_class,  Next: obj-exp-debug_message,  Prev: obj-exp-create,  Up: obj-exp

10.23.6.10 'current_class/1'
............................

Synopsis
--------

'current_class(*CLASS)'

Arguments
---------

CLASS
     "atom"

Description
-----------

'Class' is the name of a currently defined class.


File: sicstus.info,  Node: obj-exp-debug_message,  Next: obj-exp-define_method,  Prev: obj-exp-current_class,  Up: obj-exp

10.23.6.11 'debug_message/0'  declaration
.........................................

Synopsis
--------

':- debug_message.'

Description
-----------

Prolog clauses following this directive will be compiled to send
messages "carefully."

   That is, a message sent to an object that does not understand the
message will raise an exception, which describes both the message and
the object receiving it.  This also catches attempts to send an unbound
message, to send a message to an unbound object, and similar errors.

See Also
--------

'nodebug_message/0'


File: sicstus.info,  Node: obj-exp-define_method,  Next: obj-exp-descendant_of,  Prev: obj-exp-debug_message,  Up: obj-exp

10.23.6.12 'define_method/3'
............................

Synopsis
--------

'define_method(+OBJ, +MESSAGE, +BODY)'

Arguments
---------

OBJ
     "object"

MESSAGE
     "term"

BODY
     "callable"

Description
-----------

Installs BODY as the method for MESSAGE in the instance OBJ.  Following
the execution of this goal, sending MESSAGE to OBJ will execute BODY,
rather than the default method or a method previously defined with
'define_method/3'.

   MESSAGE must have been declared to be an instance method for the
class of OBJ.

Exceptions
----------

'instantiation_error'

     any argument is unbound.

'type_error'

     OBJ is not a compound term, or MESSAGE or BODY is not "callable".

'domain_error'

     MESSAGE does not specify an instance method for the class of OBJ,
     or BODY include a goal to fetch or store a non-existent slot.

See Also
--------

'instance_method/1', 'undefine_method/3'


File: sicstus.info,  Node: obj-exp-descendant_of,  Next: obj-exp-destroy,  Prev: obj-exp-define_method,  Up: obj-exp

10.23.6.13 'descendant_of/2'
............................

Synopsis
--------

'descendant_of(+OBJ, ?CLASS)'

Arguments
---------

OBJ
     "object"

CLASS
     "atom"

Description
-----------

OBJ is an instance of CLASS or of a descendant of CLASS.

Exceptions
----------

'instantiation_error'

     OBJ is unbound.

'type_error'

     OBJECT is not a valid object.

See Also
--------

'class_ancestor/2', 'class_of/2', 'class_superclass/2'


File: sicstus.info,  Node: obj-exp-destroy,  Next: obj-exp-direct_message,  Prev: obj-exp-descendant_of,  Up: obj-exp

10.23.6.14 'destroy/1'
......................

Synopsis
--------

'destroy(+OBJ)'

Arguments
---------

OBJ
     "object"

Description
-----------

First, sends a 'destroy' message to OBJ, if such a message is defined
for its class.  A 'destroy' message takes no argument.  Unlike
'create/2', it is possible to destroy instances of a class even if it
defines no 'destroy' methods.  Finally, disposes of OBJ.

Exceptions
----------

'instantiation_error'

     OBJ is unbound.

'type_error'

     OBJECT is not a valid object.

See Also
--------

'create/2'


File: sicstus.info,  Node: obj-exp-direct_message,  Next: obj-exp-end_class,  Prev: obj-exp-destroy,  Up: obj-exp

10.23.6.15 'direct_message/4'
.............................

Synopsis
--------

'direct_message(?CLASS, ?OP, ?NAME, ?ARITY)'

Arguments
---------

CLASS
     "atom"

OP
     "message_operator"

NAME
     "atom"

ARITY
     "integer"

Description
-----------

NAME/ARITY is an OP message directly understood (defined rather than
inherited) by instances of CLASS.  This predicate is used to test
whether a message is defined for a class.

   OP is one of '<-', '>>', or '<<', specifying the kind of message.

   This predicate violates the principle of information hiding by
telling whether the method for a message is defined within a class or
inherited.  Hence its use in ordinary programs is discouraged.  It may
be useful, however, during debugging or in developing programming
support tools.

See Also
--------

'<-/2', '<</2', '>>/2', 'message/4'


File: sicstus.info,  Node: obj-exp-end_class,  Next: obj-exp-fetch_slot,  Prev: obj-exp-direct_message,  Up: obj-exp

10.23.6.16 'end_class/[0,1]'  declaration
.........................................

Synopsis
--------

':- end_class.'

   ':- end_class +CLASSNAME.'

Arguments
---------

CLASSNAME
     "atom"

Description
-----------

A class definition continues until the next 'end_class/[0,1]' directive,
the next 'class/1' directive, or the end of the file, whichever comes
first.

   It is not possible to nest one class definition within another.

   All clauses that look like method definitions (that is, which have
one of '<-/2', '<</2' or '>>/2' as the principal functors of their
heads) are considered to be method definitions for the class.

Caveat
------

The argument to 'end_class/1', if specified, must match the class name
of the preceding 'class/1' directive.

See Also
--------

'class/1'


File: sicstus.info,  Node: obj-exp-fetch_slot,  Next: obj-exp-inherit,  Prev: obj-exp-end_class,  Up: obj-exp

10.23.6.17 'fetch_slot/2'
.........................

Synopsis
--------

'fetch_slot(+SLOTNAME, -VALUE)'

Arguments
---------

SLOTNAME
     "atom"

VALUE
     "term"

Description
-----------

Fetches VALUE from the slot specified by SLOTNAME.

   This predicate may only appear in the body of a method clause, and it
always operates on the object to which that message is sent.  It cannot
be used to directly access the slots of another object.

Exceptions
----------

'instantiation_error'

     SLOT is unbound.

'domain_error'

     SLOT is not the name of a slot of the current class.

'permission_error'

     SLOT is a private slot of a superclass.

See Also
--------

'>>/2', 'store_slot/2'

