This is sicstus.info, produced by makeinfo version 5.2 from
sicstus.texi.

INFO-DIR-SECTION SICStus Prolog
START-INFO-DIR-ENTRY
* SICStus Prolog Manual: (sicstus).			SICStus Prolog User's Manual.
END-INFO-DIR-ENTRY

Generated March 15, 2018.


File: sicstus.info,  Node: obj-exp-inherit,  Next: obj-exp-instance_method,  Prev: obj-exp-fetch_slot,  Up: obj-exp

10.23.6.18 'inherit/1'  declaration
...................................

Synopsis
--------

':- inherit +CLASSNAME +OP +NAME/+ARITY, ....'

Arguments
---------

CLASSNAME
     "atom"

OP
     "message_operator"

NAME
     "atom"

ARITY
     "integer"

Description
-----------

CLASSNAME names the class from which the message should be inherited, OP
indicates which kind of message it is, and NAME and ARITY indicate the
name and arity of the message to be inherited.  You may include several
inheritance specifications in one directive.

Caveat
------

Be careful of the precedences of the message operator and the '/'
operator.  You may need to use parentheses.

Examples
--------

Suppose classes 'toy' and 'truck' are defined as follows:

     :-class toy.
     Self <- create.
     Self >> size(small).
     Self >> rolls(false).
     :- end_class toy.

     :- class truck.
     Self <- create.
     Self >> size(small).
     Self >> rolls(true).
     :- end_class truck.

   Then 'toy_truck' inherits its size from 'toy' and the fact that it
rolls from 'truck':

     :- class toy_truck = toy + truck.
     :- inherit
             toy <- (create/O),
             toy <- (size/1),
             truck <- (rolls/1).
     :- end_class toy_truck.

   Note that this is just a toy example.

See Also
--------

'uninherit/1'


File: sicstus.info,  Node: obj-exp-instance_method,  Next: obj-exp-message,  Prev: obj-exp-inherit,  Up: obj-exp

10.23.6.19 'instance_method/1'  declaration
...........................................

Synopsis
--------

':- instance_method +NAME/+ARITY.'

Arguments
---------

NAME
     "atom"

ARITY
     "integer"

Description
-----------

The message NAME/ARITY is declared to support instance methods in a
class.  This means that instances of this class, and its descendants,
may each define their own methods for this message.

   A method defined for this message by the class is considered the
default method for the message.  An instance that does not define its
own method uses the default.  Defining a new method overrides this
default method; there is no need to explicitly remove it.

   An instance method is installed in an instance of the class with the
'define_method/3' predicate.  An instance method is removed from an
instance of the class, reverting to the default method, with the
'undefine_method/3' predicate.

   Must occur within the scope of the class definition.  Only applies to
send messages.

See Also
--------

'class_method/1', 'define_method/3', 'undefine_method/3'


File: sicstus.info,  Node: obj-exp-message,  Next: obj-exp-nodebug_message,  Prev: obj-exp-instance_method,  Up: obj-exp

10.23.6.20 'message/4'
......................

Synopsis
--------

'message(?CLASS, ?OP, ?NAME, ?ARITY)'

Arguments
---------

CLASS
     "atom"

OP
     "message_operator"

NAME
     "atom"

ARITY
     "integer"

Description
-----------

NAME/ARITY is an OP message understood by instances of CLASS.  This
predicate is used to test whether a message is either defined for or
inherited by a class.

   OP is one of '<-', '>>', or '<<', specifying the kind of message.

See Also
--------

'<-/2', '<</2', '>>/2', 'direct_message/4'


File: sicstus.info,  Node: obj-exp-nodebug_message,  Next: obj-exp-pointer_object,  Prev: obj-exp-message,  Up: obj-exp

10.23.6.21 'nodebug_message/0'  declaration
...........................................

Synopsis
--------

':- nodebug_message.'

Description
-----------

Prolog clauses following this directive are no longer compiled to send
messages "carefully."

See Also
--------

'debug_message/0'


File: sicstus.info,  Node: obj-exp-pointer_object,  Next: obj-exp-store_slot,  Prev: obj-exp-nodebug_message,  Up: obj-exp

10.23.6.22 'pointer_object/2'
.............................

Synopsis
--------

'pointer_object(+ADDR,-OBJ)'

   'pointer_object(-ADDR,+OBJ)'

Arguments
---------

ADDR
     "integer"

OBJ
     "object"

Description
-----------

ADDR is the address of object OBJ.  This can be used to get the address
of an object or to get an object given its address.

   *Please note*: This is a low level operation, passing an invalid
address may crash the system.

Exceptions
----------

'instantiation_error'

     both OBJ and ADDR are unbound.

'type_error'

     ADDR is not an integer.


File: sicstus.info,  Node: obj-exp-store_slot,  Next: obj-exp-undefine_method,  Prev: obj-exp-pointer_object,  Up: obj-exp

10.23.6.23 'store_slot/2'
.........................

Synopsis
--------

'store_slot(+SLOTNAME, +NEWVALUE)'

Arguments
---------

SLOTNAME
     "atom"

NEWVALUE
     "term"

Description
-----------

Stores NEWVALUE in the slot specified by SLOTNAME.

   This predicate may only appear in the body of a method clause, and it
always operates on the object to which that message is sent.  It cannot
be used to directly modify the slots of another object.

Exceptions
----------

'instantiation_error'

     either argument is unbound.

'type_error'

     NEWVALUE is not of the appropriate type for SLOTNAME.

'domain_error'

     SLOTNAME is not the name of a slot of the current class.

'permission_error'

     SLOTNAME is a private slot of a superclass.

See Also
--------

'<</2', 'fetch_slot/2'


File: sicstus.info,  Node: obj-exp-undefine_method,  Next: obj-exp-uninherit,  Prev: obj-exp-store_slot,  Up: obj-exp

10.23.6.24 'undefine_method/3'
..............................

Synopsis
--------

'undefine_method(+OBJ, +NAME, +ARITY)'

Arguments
---------

OBJ
     "object"

NAME
     "atom"

ARITY
     "integer"

Description
-----------

Removes OBJ's current instance method for the NAME/ARITY message.  After
executing this goal, sending this message to OBJ executes the class's
default method for the message.

   NAME/ARITY must have been declared to be an instance method for the
class of OBJ.

   If OBJ has no current instance method for the NAME/ARITY message,
then the predicate has no effect.

Exceptions
----------

'instantiation_error'

     any argument is unbound.

'type_error'

     OBJ is not a compound term, NAME is not an atom, or ARITY is not an
     integer.

'domain_error'

     MESSAGE does not specify an instance method for the class of OBJ.

See Also
--------

'define_method/3', 'instance_method/1'


File: sicstus.info,  Node: obj-exp-uninherit,  Prev: obj-exp-undefine_method,  Up: obj-exp

10.23.6.25 'uninherit/1'  declaration
.....................................

Synopsis
--------

':- uninherit +CLASS +OP +NAME/+ARITY, ... .'

Arguments
---------

CLASS
     "atom"

OP
     "message_operator"

NAME
     "atom"

ARITY
     "integer"

Description
-----------

This prevents the class within whose scope this directive appears from
inheriting the NAME/ARITY method of type OP from ancestor CLASS.

   If CLASS is unbound, then the specified message is uninherited from
all ancestors that define it.

Caveat
------

Note that if you define a message for your class, then you do not need
to uninherit that message from its superclasses: it will automatically
be shadowed.

   Be careful of the precedences of the message operator and the '/'
operator.  You may need to use parentheses.

Examples
--------

     :- uninherit someclass << (foo/1),
                  someclass >> (foo/1).

   This prevents the get and put methods for the slot 'foo' from being
inherited from any ancestors of class 'someclass'.  In effect, it makes
the 'foo' slot a protected slot for this class.

See Also
--------

'inherit/1'


File: sicstus.info,  Node: obj-glo,  Next: obj-bas,  Prev: obj-exp,  Up: lib-objects

10.23.7 Glossary
----------------

"abstract class"
     A class that cannot have instances.  Abstract classes are helpful
     in designing a class hierarchy, to contain the common parts of
     several concrete classes.

"ancestor"
     One of a class's superclasses, one of its superclasses's
     superclasses, etc.  Sometimes, for convenience, ancestor includes
     the class itself, along with its proper ancestors.

"child"
     A synonym for subclass.

"class"
     A class is defined by a description of the information its
     instances contain and the messages they respond to.  Every object
     is an instance of one and only one class.

"concrete class"
     A class that can have instances.  Most classes are concrete.

"create method"
     Specifies what actions should be taken when an instance of a class
     is created.  A create method frequently provides initial slot
     values or specifies an action to be performed by the new object.  A
     create message is sent to each new object by the 'create/2'
     predicate.  A create message is a kind of send message.

"descendant"
     One of a class's subclasses, one of its subclasses's subclasses,
     etc.  Sometimes the word descendant includes the class itself,
     along with its proper descendants.

"destroy method"
     Specifies what actions should be taken when an instance of a class
     is destroyed.  A destroy message is sent to an object by the
     'destroy/1' predicate.  A destroy message is a kind of send
     message.

"direct slot access"
     Fetching or storing a slot value without sending a message to the
     object.  This should be used with care!

     SICStus Objects allows direct access to a class's slots only within
     its method definitions, via the 'fetch_slot/2' and 'store_slot/2'
     predicates.

"get message"
     A message that inquires about some aspect of an object.  Typically
     used to fetch slot values.  Get methods are automatically generated
     for public slots.  Get messages are written with the '>>' operator.

"inheritance"
     The process by which a class's slots and methods are determined
     from an ancestor.

"initial value"
     The value a slot is initialized to when an object is created.
     Every slot has a default initial value, which depends upon its
     type.  You may specify different initial values in a class
     definition.

"instance"
     Another word for object.  The word instance draws attention to the
     class of which the object is an instance.

"instance method"
     A method that may be defined differently for each instance of a
     class.  The class may have a default method for this message, which
     is overridden by installing an instance method for a particular
     object.

"message"
     A command to an object to perform an operation or to modify itself,
     or an inquiry into some aspect of the object.  In SICStus Objects,
     a message is either a get message, a put message or a send message.
     The syntax for sending a message to an object is

          OBJECT OPERATOR MESSAGE

     where OPERATOR is one of the following:

     '>>'
          get message

     '<<'
          put message

     '<-'
          send message

"method"
     A class's implementation of a particular message.  You send
     messages to an object, but you define methods for a class.

"method clause"
     A Prolog clause used to define a method for a class.  A method
     clause has one of '<-/2', '<</2' or '>>/2' as the principal functor
     of its head, and it can only appear within the scope of its class's
     definition.  A method's definition may contain more than one
     message clause.

"mixin class"
     A class that is intended to be combined (mixed in) with other
     classes, via multiple inheritance, to define new subclasses.

"multiple inheritance"
     When a class names more than one superclass.  Typically, it
     inherits slots and methods from each.  In SICStus Objects, two
     different superclasses should not use the same slot name.  And, if
     a message is defined by more than one superclass, then the class
     definition must specify which method to inherit.

"object"
     A modifiable data item that holds information and responds to
     messages.  Another word for instance.

"parent class"
     A synonym for superclass.

"private slot"
     A private slot is, by default, only accessible within methods of
     the class itself.  Not even the descendants of the class may access
     its private slots, except through the class's methods.  Get and put
     methods are not automatically generated for a private slot, so it
     is only accessed via the methods you define.  If the visibility of
     a slot is not specified, then it is private, rather than public or
     protected.

"protected slot"
     A protected slot is, by default, only accessible within methods of
     the class itself and its descendants.  Get and put methods are not
     automatically generated for a protected slot, so it is only
     accessed via the methods you define.  If the visibility of a slot
     is not specified, then it is private, rather than public or
     protected.

     SICStus Objects 'protected' is similar to 'protected' in C++.

"public slot"
     A public slot is accessible via its own get and put methods, which
     are generated for it automatically.  If no visibility is specified,
     then a slot is private, rather than public or protected.

"put message"
     A message that modifies some aspect of an object.  Typically used
     to store slot values.  Put methods are automatically generated for
     public slots.  Put messages are written with the '<<' operator.

"send message"
     The most common sort of message.  Used for performing an operation
     on an object or for performing an action that depends upon an
     object.  Send messages are written with the '<-' operator.

"send super"
     When a method for a class executes a shadowed superclass's method.
     This allows a class to put a "wrapper" around its superclass's
     method, making it unnecessary to duplicate the method just to make
     a small extension to it.

"shadow"
     When a class defines its own method for a message defined by one of
     its ancestors, the new method hides or "shadows" the ancestor's
     method.  The new class's descendants will inherit its method for
     that message, rather than its ancestors.  That is, a class always
     inherits the "closer" of two methods for a message.

"slot"
     A part of an instance that holds an individual datum.  Like a
     member of a C struct or a field of a Pascal record.

"subclass"
     A class that is a more specific case of a particular class.  This
     is the opposite of superclass.  A class does not name its
     subclasses; they are inferred.

"superclass"
     A class that is a more general case of a particular class.  Each
     class lists its superclasses.

"term class"
     A class whose instances are represented as ordinary Prolog terms.
     The functor of these objects need not be the name of the class, and
     the arity need not be one.

"term slot"
     A slot that can hold any Prolog term.

"uninherit"
     Specify that a method from a superclass should not be inherited.
     This is similar to shadowing the superclass's method, but does not
     specify a replacement for it.

"visibility"
     A slot may be defined to be either 'public', 'protected', or
     'private'.  By default, if no visibility is specified, then a slot
     is private.


File: sicstus.info,  Node: lib-odbc,  Next: lib-ordsets,  Prev: lib-objects,  Up: The Prolog Library

10.24 The ODBC Interface Library-'library(odbc)'
================================================

This library is an interface to an ODBC database driver.  For an
introduction to ODBC, see
<http://msdn.microsoft.com/en-us/library/ms715408(VS.85).aspx>
("Introduction to ODBC"; Microsoft Web Page).  ODBC 3.x is supported.

* Menu:

* ODBC Overview:: Overview
* ODBC Examples:: Examples
* ODBC Datatypes:: Datatypes
* ODBC Exceptions:: Exceptions
* ODBC Predicates:: Predicates


File: sicstus.info,  Node: ODBC Overview,  Next: ODBC Examples,  Up: lib-odbc

10.24.1 Overview
----------------

ODBC (Open Database Connectivity) is a standard API for using a DBMS
(DataBase Management System).  By using ODBC you can access data from a
multitude of DBMSs without having to know the details of each DBMS.

   'library(odbc)' is a layer on top of ODBC. It has predicates for
opening the database, starting and executing a query, and retrieving the
results of a query.  The ODBC client application, i.e. this library,
accesses all ODBC functionality via a service provided by the operating
system, the ODBC Driver Manager (DM).

   Some operating systems (e.g.  Mac OS X and MS Windows) usually come
with an ODBC Driver Manager preinstalled.  For other, UNIX and
UNIX-like, operating systems, unixODBC (<http://www.unixodbc.org>) is
the most common but Mac OS X use iODBC (<http://www.iodbc.org>).

   The ODBC Driver Manager does not, in itself, provide any database
functionality.  Instead the DM loads a ODBC driver specific to the
particular Database Management System (DBMS) (when
'odbc_db_open/[3,4,5]' is called).

   How to install and configure an ODBC driver is beyond the scope of
this document.  Please consult the documentation for the particular DBMS
you intend to use.  Some popular DBMSs are MySQL and PostgreSQL which
both provide ODBC drivers for many platforms.


File: sicstus.info,  Node: ODBC Examples,  Next: ODBC Datatypes,  Prev: ODBC Overview,  Up: lib-odbc

10.24.2 Examples
----------------

A few examples will best illustrate how to use 'library(odbc)'.

* Menu:

* ODBC Example 1:: Example 1
* ODBC Example 2:: Example 2
* ODBC Example 3:: Example 3
* ODBC Example 4:: Example 4


File: sicstus.info,  Node: ODBC Example 1,  Next: ODBC Example 2,  Up: ODBC Examples

10.24.2.1 Example 1
...................

The first example just verifies that ODBC is working and that some ODBC
drivers have been configured in the ODBC Driver Manager.

     :- use_module(library(odbc)).

     example1 :-
         odbc_env_open(EnvHandle),
         odbc_list_DSN(EnvHandle, DSNs),
         odbc_env_close(EnvHandle),
         format('The known DSNs are: ~q~n', [DSNs]).

   You begin by opening an environment.  This is a handle which can be
used for various calls to the ODBC Driver Manager (DM). You then ask the
DM about the data sources, i.e.  databases, it knows about.  If this
list is empty you need to install and configure the ODBC drivers
appropriate for the database management system that you intend to use.


File: sicstus.info,  Node: ODBC Example 2,  Next: ODBC Example 3,  Prev: ODBC Example 1,  Up: ODBC Examples

10.24.2.2 Example 2
...................

This example is a simple SQL query using a fixed SQL string.

     :- use_module(library(odbc)).

     example_select :-
         odbc_env_open(EnvHandle),
         odbc_db_open('MyDatabase', EnvHandle, ConnectionHandle),
         odbc_query_open(ConnectionHandle, StatementHandle),
         odbc_query_execute_sql(StatementHandle,
                            'SELECT cookie,soft FROM bakery order by soft',
                            ResultSet),
         show_result(ResultSet),
         odbc_query_close(ResultSet),
         odbc_db_close(ConnectionHandle),
         odbc_env_close(EnvHandle).

     show_result(ResultSet) :-
         odbc_sql_fetch(ResultSet, Row),
         show_result1(Row, ResultSet).

     show_result1([], _ResultSet) :- !.
     show_result1(Row, ResultSet) :-
         format('~w~n', [Row]),
         flush_output,
         odbc_sql_fetch(ResultSet, Row1),
         show_result1(Row1, ResultSet).

   As always, you begin by opening an environment.  You then connect to
the database with 'odbc_db_open/3'.  The first argument is the
identifier for the database in the DBMS. In this scenario, connecting to
the database does not require a username and a password.  The output
from 'odbc_db_open/3' is an opaque handle on the database.

   First, 'odbc_query_open/2' is used to create an SQL query, which is
straightforward.  Then, 'odbc_query_execute_sql/3' is used to execute
the SQL query.  By executing an SQL query a _result set_ is created.
Each consecutive call of 'odbc_sql_fetch/2' will retrieve one row from
the result set.


File: sicstus.info,  Node: ODBC Example 3,  Next: ODBC Example 4,  Prev: ODBC Example 2,  Up: ODBC Examples

10.24.2.3 Example 3
...................

This example shows the use of parameter binding.  The positional markers
(?) in the SQL string are bound to the elements in the list in the third
argument of odbc_query_execute_sql/5.  The fourth argument is a list of
datatypes corresponding to the parameters.

     :- use_module(library(odbc)).

     example2 :-
        odbc_env_open('SQL_OV_ODBC3', EnvHandle),
        odbc_db_open('MyDatabase', EnvHandle, ConnectionHandle),
        odbc_query_open(ConnectionHandle, StatementHandle),
        odbc_query_execute_sql(StatementHandle,
                            'INSERT INTO scratch (vehicle, wheels) VALUES (?, ?)',
                            ["railwaycar", 8],
                            ['SQL_VARCHAR', 'SQL_INTEGER'],
                            ResultSet),
        odbc_query_close(ResultSet),
        odbc_db_close(ConnectionHandle),
        odbc_env_close(EnvHandle).


File: sicstus.info,  Node: ODBC Example 4,  Prev: ODBC Example 3,  Up: ODBC Examples

10.24.2.4 Example 4
...................

This example is similar to the second, but this time we ask the database
what the datatypes of the columns of the table are with
odbc_list_data_types/3.

     :- use_module(library(odbc)).

     example3 :-
        odbc_env_open(EnvHandle),
        odbc_db_open('MyDatabase', EnvHandle, ConnectionHandle),
        odbc_query_open(ConnectionHandle, StatementHandle),
        odbc_list_data_types(StatementHandle,
                             scratch(vehicle, wheels),
                             DataTypes),
        odbc_query_execute_sql(StatementHandle,
                            'INSERT INTO scratch (vehicle, wheels) VALUES (?, ?)',
                            ["railwaycar", 8],
                            DataTypes,
                            ResultSet),
        odbc_query_close(ResultSet),
        odbc_db_close(ConnectionHandle),
        odbc_env_close(EnvHandle).



File: sicstus.info,  Node: ODBC Datatypes,  Next: ODBC Exceptions,  Prev: ODBC Examples,  Up: lib-odbc

10.24.3 Datatypes
-----------------

* Menu:

* ODBC Reading:: Reading from the database
* ODBC Writing:: Writing to the database


File: sicstus.info,  Node: ODBC Reading,  Next: ODBC Writing,  Up: ODBC Datatypes

10.24.3.1 Reading from the database
...................................

When reading data from the database the following datatypes are
supported, with conversion to the corresponding prolog datatypes.
'SQL_CHAR', 'SQL_VARCHAR' etc.
     A list of character codes.
'SQL_BIT'
     The integer '0' for false, or '1' for true.
'SQL_INTEGER', 'SQL_TINYINT', 'SQL_SMALLINT', etc.
     An integer.
'SQL_REAL', 'SQL_DOUBLE', 'SQL_FLOAT'
     A floating point number.
'SQL_DATE'
     A term 'date(Year, Month, DayOfMonth)', with one-based integer
     arguments.  E.g. 'date(2012,10,22)' means October 22, 2012.
'SQL_TIME'
     A term 'time(Hour, Minute, Second)' with one-based integer
     arguments.  E.g. 'time(22,11,5)' means eleven minutes and five
     seconds past ten pm.
'SQL_TIMESTAMP'
     A term 'timestamp(Year, Month, Day, Hour, Minute, Second,
     Fraction)' where the arguments have the same meaning as for
     'SQL_TIME' and 'SQL_TIMESTAMP' and FRACTION means fractional
     nanoseconds past, as an integer.
the SQL null value
     The atom 'null'.
'SQL_BINARY' and other binary types
'SQL_INTERVAL_HOUR' and other interval types
'SQL_UTCTIME' and 'SQL_UTCDATETIME'
     Currently not supported.
Note that atoms with names that start with an upper case letter, like
'SQL_CHAR' must be quoted in Prolog, e.g. ''SQL_CHAR''.


File: sicstus.info,  Node: ODBC Writing,  Prev: ODBC Reading,  Up: ODBC Datatypes

10.24.3.2 Writing to the database
.................................

When writing data to the database the following SQL datatypes are
supported.

'SQL_CHAR', 'SQL_VARCHAR' etc.
     A list of character codes, or a list of atoms.

     For backwards compatibility only, an atom is also accepted, but
     note that the atoms 'null' and '[]' have special meaning (as SQL
     null value and empty code list, respectively) and more atoms with
     special meaning may be introduced in the future.  For compatibility
     with some ODBC drivers, the integer 0 and 1 are allowed, meaning
     "0" and "1".
'SQL_BIT'
     The integer '0' for false, or '1' for true.
'SQL_INTEGER', 'SQL_TINYINT', 'SQL_SMALLINT', etc.
     An integer.
'SQL_REAL', 'SQL_DOUBLE', 'SQL_FLOAT'
     A floating point number or a small integer.
'SQL_DATE'
     A term 'date(Year, Month, DayOfMonth)', as above.
'SQL_TIME'
     A term 'time(Hour, Minute, Second)', as above.
'SQL_TIMESTAMP'
     A term 'timestamp(Year, Month, Day, Hour, Minute, Second,
     Fraction)', as above.
the SQL null value
     The atom 'null'.
'SQL_BINARY' and other binary types
'SQL_INTERVAL_HOUR' and other interval types
'SQL_UTCTIME' and 'SQL_UTCDATETIME'
     Currently not supported.
if a value is out of range for the corresponding SQL type, e.g. a too
large integer for 'SQL_SMALLINT', the result is undefined.  Note that
atoms with names that start with an upper case letter, like 'SQL_CHAR'
must be quoted in Prolog, e.g. ''SQL_CHAR''.


File: sicstus.info,  Node: ODBC Exceptions,  Next: ODBC Predicates,  Prev: ODBC Datatypes,  Up: lib-odbc

10.24.4 Exceptions
------------------

When an error in the ODBC layer occurs, predicates in 'library(odbc)'
throw 'error/2' exceptions.  Both arguments of the 'error/2' exception
are the same and has the following form 'odbc_error(DETAIL, GOAL)',
where 'Goal' is some goal where the error occurred, and DETAIL gives
more information about the error.  The DETAIL term can have the
following form:

'data_conversion'
     Thrown in case of a error when converting to or from a SICStus data
     type from or to an ODBC data type.

'unsupported_datatype'
     Thrown when an SQL data type is unsupported when converting to or
     from a SICStus data type from or to an ODBC data type.

'unknown_datatype'
     Thrown when an unknown SQL data type is found when converting to or
     from a SICStus data type from or to an ODBC data type.

'type_error'
     Thrown when the Prolog data is of a type incompatible with the SQL
     data type when converting from a SICStus data type to an ODBC data
     type.

'native_code'
     Thrown in case of a error in the native code of 'library(odbc)'.

'invalid_handle(handle_type, INVALIDHANDLE, RETURNCODE)'
     Thrown when an invalid handle type is specified.

'invalid_handle('HandleType'-HANDLETYPE, 'Handle'-HANDLE)'
     Thrown when an invalid handle is specified.

'invalid_handle(result_set, RESULTSET)'

     Thrown when a Result Set handle is invalid.

'unknown_connection_option(OPTIONS)'

     Thrown when an unknown option was given when calling
     'odbc_db_open/[3,4,5]'.

'internal_error'
     Thrown when an internal error occurs in 'library(odbc)'.  Please
     report this to SICStus Support.

'diag(RETURNCODE, RECS)'
     Thrown when an error occurs in the ODBC layer, e.g.  a SQL syntax
     error.  RECS is bound to the diagnostic records reported from ODBC.

'out_of_memory'
     Thrown when some operation runs out of memory.
there may be other DETAILS and new DETAILS may be added in the future.


File: sicstus.info,  Node: ODBC Predicates,  Prev: ODBC Exceptions,  Up: lib-odbc

10.24.5 Predicates
------------------

'odbc_env_open(-ENVHANDLE)'

     Opens an ODBC environment.  Throws an exception if the environment
     could not be opened.
'odbc_db_open(+DBNAME,+ENVHANDLE,-CONNECTIONHANDLE)'

     Opens a database with the name DBNAME.  The database cannot require
     a username and a password.  CONNECTIONHANDLE is an opaque handle
     for accessing the database.
'odbc_db_open(+DBNAME,+ENVHANDLE,+OPTIONS,-CONNECTIONHANDLE)'

     Opens a database with the name DBNAME.  OPTIONS should be a list of
     zero or more of:
     'username(+USERNAME)'
          The username for connecting to the database.  The default is
          ''''.

     'password(+PASSWORD)'
          The password for connection to the database.  The default is
          ''''.

     'login_timeout(+TIMEOUT)'
          The number of seconds to wait for a login request to complete.
          If 0 is used, the login attempt will wait indefinitely.  The
          default is driver-dependent.

     'connection_timeout(+TIMEOUT)'
          The number of seconds to wait for any request on the
          connection to complete.  If the Timeout value is 0 (the
          default), there is no timeout.

     'raw(+CONNECTIONOPTIONS)'
          CONNECTIONOPTIONS should be a list of atoms.  They are passed,
          terminated by ';', as extra options when opening the database.
     CONNECTIONHANDLE is an opaque handle for accessing the database.
'odbc_db_open(+DBNAME,+ENVHANDLE,+OPTIONS,-CONNECTIONHANDLE,-CONNECTIONSTRING)'

     Like 'odbc_db_open/4' but also returns the completed connection
     string returned by the ODBC driver.
'odbc_query_open(+CONNECTIONHANDLE, -STATEMENTHANDLE)'
     Creates a new database query.  CONNECTIONHANDLE is a handle
     previously allocated with 'odbc_db_open/[3,4,5]'.
'odbc_list_DSN(+ENVHANDLE,-DSNS)'

     ENVHANDLE is an opaque database handle.  DSNS is unified with a
     list of all DSNs (Data Source Names).  The list elements are X-Y
     where X is the DSN and Y its description.
'odbc_list_data_types(+STATEMENTHANDLE, +TABLEDESC, -DATATYPES)'
     Makes a list of the datatypes in a table.  STATEMENTHANDLE is a
     handle previously allocated with 'odbc_query_open/2'.  TABLEDESC is
     a description of the table and its columns of the form
     'tablename(columnname1, columnname2, ..., columnnameN)', or of the
     form '[tablename, columnname1, columnname2, ..., columnnameN]' (the
     latter form is useful if the table has more than 255 columns).
     DATATYPES is unified with a list of the corresponding datatypes,
     i.e.  on the form '[datatype1, datatype2, ... datatypeN]'.
'odbc_current_table(+ConnectionHandle, ?TableName)   since release 4.2'
     Enumerate the _proper_ tables in the database, i.e. tables with
     attribute ''TABLE_TYPE'("TABLE")'.

     CONNECTIONHANDLE is a handle previously allocated with
     'odbc_db_open/[3,4,5]'.  TABLENAME is the name, as an atom, of the
     table.

     Note that 'odbc_current_table/2' may exit nondeterminately even if
     all arguments are instantiated when it is called.
'odbc_current_table(+ConnectionHandle, ?TableName, ?Attribute)   since release 4.2'
     Enumerate database tables and their attributes.

     CONNECTIONHANDLE is a handle previously allocated with
     'odbc_db_open/[3,4,5]'.  TABLENAME is the name, as an atom, of the
     table.  ATTRIBUTE is an attribute of the table.

     There are two kinds of attributes, _derived_ attributes and _raw_
     attributes.

     The _derived_ attributes are translations of raw attributes and
     other information and are in a format that is directly useful.
     There is currently only one derived attribute,

     'arity(VALUE)'
          The number of columns in the table, as an integer.

          This attribute is always present.
     the set of derived attributes may be extended in the future.

     The raw attributes correspond direcly to the (non-null) values
     returned from the ODBC function 'SQLTables()' and are returned as
     is, wrapped in a functor with the same name as the attribute, e.g.
     ''TABLE_CAT'("foo")' would be returned for a table in the catalog
     "foo".  Note that the names of the raw attributes are in all
     uppercase so you need to surround them with single quotes to
     prevent their name from being parsed as a variable.  Some of the
     raw attributes are,

     ''TABLE_CAT'(VALUE)'
          Catalog name, as a code list.  This attribute corresponds to
          the 'TABLE_CAT' column, called 'TABLE_QUALIFIER' in ODBC 2.0,
          as returned from the ODBC function 'SQLTables()'.
     ''TABLE_TYPE'(VALUE)'
          Table type, as a code list.  This attribute corresponds to the
          'TABLE_TYPE' column, as returned from the ODBC function
          'SQLTables()'.  The standard table types are '"TABLE"',
          '"VIEW"', '"SYSTEM TABLE"', '"GLOBAL TEMPORARY"', '"LOCAL
          TEMPORARY"', '"ALIAS"', and '"SYNONYM"', but there can be
          data-source-specific types as well.

          This attribute is always present.
     ''REMARKS'(VALUE)'
          Table descriptive text, as a code list.  This attribute
          corresponds to the 'REMARKS' column, as returned from the ODBC
          function 'SQLTables()'.

     see the ODBC documentation for 'SQLTables()' for the full list of
     raw attributes and their meaning.

     Note that 'odbc_current_table/3' may exit nondeterminately even if
     one of more arguments are instantiated when it is called.
'odbc_table_column(+ConnectionHandle, ?TableName, ?ColumnName)   since release 4.2'
     Enumerate database table columns.

     CONNECTIONHANDLE is a handle previously allocated with
     'odbc_db_open/[3,4,5]'.  TABLENAME is the name, as an atom, of the
     table.  COLUMNNAME is the name, as an atom, of the table.

'odbc_table_column(+ConnectionHandle, ?TableName, ?ColumnName, ?Attribute)   since release 4.2'
     Enumerate database table columns and their attributes.

     CONNECTIONHANDLE is a handle previously allocated with
     'odbc_db_open/[3,4,5]'.  TABLENAME is the name, as an atom, of the
     table.  COLUMNNAME is the name, as an atom, of the table.
     ATTRIBUTE is an attribute of the table.

     There are two kinds of attributes, _derived_ attributes and _raw_
     attributes.

     The _derived_ attributes are translations of raw attributes and
     other information and are in a format that is directly useful.
     There is currently only one derived attribute,

     'nullable(VALUE)'
          'true' if the column is definitely nullable, or 'false' if the
          column is definitely not nullable.  The value is derived from
          the raw attributes 'NULLABLE' and 'IS_NULLABLE', see the
          documentation for 'SQLColumns()' for details.

          This attribute is not present if it can not be determined
          whether the column is nullable.
     the set of derived attributes may be extended in the future.

     The raw attributes correspond direcly to the (non-null) values
     returned from the ODBC function 'SQLColumns()' and are returned as
     is, wrapped in a functor with the same name as the attribute, e.g.
     ''TABLE_CAT'("foo")' would be returned for a column in a table in
     the catalog "foo".  Note that the names of the raw attributes are
     in all uppercase so you need to surround them with single quotes to
     prevent their name from being parsed as a variable.  Some of the
     raw attributes are,

     ''REMARKS'(VALUE)'
          Column descriptive text, as a code list.  This attribute
          corresponds to the 'REMARKS' column, as returned from the ODBC
          function 'SQLColumns()'.

     ''ORDINAL_POSITION'(VALUE)'
          The ordinal position of the column in the table, starting at
          1.  This attribute corresponds to the 'ORDINAL_POSITION'
          column, as returned from the ODBC function 'SQLColumns()'.

          This attribute is always present.

     See the ODBC documentation for 'SQLColumns()' for the full list of
     raw attributes and their meaning.

     Note that 'odbc_table_column/4' may exit nondeterminately even if
     one of more arguments are instantiated when it is called.
'odbc_query_execute_sql(+STATEMENTHANDLE, +SQLSTRING, +PARAMDATA, +PARAMDATATYPES, -RESULTSET)'
     Executes an SQL query.  STATEMENTHANDLE is a handle previously
     allocated with 'odbc_query_open/2'.  SQLSTRING is the SQL statement
     to be executed.  The statement string may contain parameter
     markers.  PARAMDATA is a list of data to be bound to the parameter
     markers.  PARAMDATATYPES is a list of data types corresponding to
     the PARAMDATA list.  RESULTSET is bound to an opaque data structure
     describing the result of the query.
'odbc_query_execute_sql(+STATEMENTHANDLE, +SQLSTRING, -RESULTSET)'
     STATEMENTHANDLE is a handle previously allocated with
     'odbc_query_open/2'.  SQLSTRING is the SQL statement to be
     executed.  RESULTSET is bound to an opaque data structure
     describing the result of the query.
'odbc_sql_fetch(+RESULTSET, -ROW)'
     Fetch the next row from the result set.  RESULTSET is the result
     set from 'odbc_query_execute_sql/[3,5]'.  ROW is unified with a
     non-empty list of data constituting a row in the result set, or
     with '[]' when there are no more rows.  The elements in the ROW are
     in the same order as in the corresponding query.
'odbc_query_close(+QUERY)'
     Closes the query represented by QUERY, which can be either a result
     set, e.g.  as returned from 'odbc_query_execute_sql/[3,5]', or it
     can be a statement handle, as returned from 'odbc_query_open/2'.

'odbc_db_close(+CONNECTIONHANDLE)'
     Closes the connection to the database.
'odbc_env_close(+ENVHANDLE)'
     Frees the environment handle.


File: sicstus.info,  Node: lib-ordsets,  Next: lib-pillow,  Prev: lib-odbc,  Up: The Prolog Library

10.25 Ordered Set Operations--'library(ordsets)'
================================================

This library module provides operations on sets represented as ordered
lists with no duplicates.  Thus '{c,r,a,f,t}' would be '[a,c,f,r,t]'.
The ordering is defined by the '@<' family of term comparison
predicates, which is the ordering used by 'sort/2' and 'setof/3'.

   The benefit of the ordered representation is that the elementary set
operations can be done in time proportional to the sum of the argument
sizes rather than their product.  You should use the operations defined
here in preference to those in 'library(sets)' unless there is a
compelling reason why you can't.  Some of the unordered set routines,
such as 'member/2', 'length/2' and 'select/3' can be used unchanged on
ordered sets; feel free so to use them.

   There is no 'ordset_to_list/2', as an ordered set is a list already.
Exported predicates:

'is_ordset(+LIST)'

     is true when LIST is a list of terms [T1,T2,...,TN] and the terms
     are strictly increasing: T1 @< T2 @< ... @< TN.  The output of
     'sort/2' always satisfies this test.  Anything which satisfies this
     test can be given to the predicates in this file, regardless of
     where you got it.
'list_to_ord_set(+LIST, -SET)'

     is true when SET is the ordered representation of the set
     represented by the unordered representation List.  The only reason
     for giving it a name at all is that you may not have realised that
     'sort/2' could be used this way.
'ord_add_element(+SET1, +ELEMENT, -SET2)'

     Equivalent to 'ord_union(SET1, [ELEMENT], SET2)', but a bit faster.
'ord_del_element(+SET1, +ELEMENT, -SET2)'

     Equivalent to 'ord_subtract(SET1, [ELEMENT], SET2)', but a bit
     faster.
'ord_disjoint(+SET1, +SET2)'

     is true when the two ordered sets have no element in common.
'ord_intersect(+SET1, +SET2)'

     is true when the two ordered sets have at least one element in
     common.
'ord_intersection(+SET1, +SET2, -INTERSECTION)'

     is true when INTERSECTION is the ordered representation of SET1 and
     SET2, provided that SET1 and SET2 are ordered sets.
'ord_intersection(+SET1, +SET2, ?INTERSECTION, ?DIFFERENCE)'
     is true when INTERSECTION is the intersection of SET1 and SET2, and
     DIFFERENCE is SET2 \ SET1 (like in ord_union/4), provided that SET1
     and SET2 are ordered sets.
'ord_intersection(+LISTOFSETS, -INTERSECTION)'
     is true when LISTOFSETS is a nonempty proper list of ordered sets
     and INTERSECTION is their intersection.
'ord_member(+ELT, +SET)'

     is true when ELT is a member of SET.  Suggested by Mark Johnson.
'ord_nonmember(+ITEM, +SET)'

     is true when the given ITEM is _not_ an element of the given SET.
'ord_seteq(+SET1, +SET2)'

     is true when the two arguments represent the same set.  Since they
     are assumed to be ordered representations, they must be identical.
'ord_setproduct(+SET1, +SET2, -PRODUCT)'

     If SET1 and SET2 are ordered sets, PRODUCT will be an ordered set
     of X1-X2 pairs.  Note that we cannot solve for SET1 and SET2,
     because there are infinitely many solutions when PRODUCT is empty,
     and may be a large number in other cases.  Could be defined as:

          ord_setproduct(Set1, Set2, Product) :-
          	(   foreach(H1,Set1),
          	    param(Set2),
          	    fromto(Product,P1,P3,[])
          	do  (   foreach(H2,Set2),
          		param(H1),
          		fromto(P1,[H1-H2|P2],P2,P3)
          	    do  true
          	    )
          	).
'ord_subset(+SET1, +SET2)'

     is true when every element of the ordered set SET1 appears in the
     ordered set SET2.
'ord_subtract(+SET1, +SET2, -DIFFERENCE)'

     is true when DIFFERENCE contains all and only the elements of SET1
     which are not also in SET2.
'ord_symdiff(+SET1, +SET2, -DIFFERENCE)'

     is true when DIFFERENCE is the symmetric difference of SET1 and
     SET2.
'ord_disjoint_union(+SET1, +SET2, -UNION)'

     is true when SET1 and SET2 (given to be ordered sets) have no
     element in common, and UNION is their union.  The meaning is the
     same as
              ord_disjoint(Set1, Set2),
              ord_union(Set1, Set2, Union)
     but it is more efficient.
'ord_union(+SET1, +SET2, -UNION)'

     is true when UNION is the union of SET1 and SET2.  Note that when
     something occurs in both sets, we want to retain only one copy.
'ord_union(+OLDSET, +NEWSET, -UNION, -REALLYNEW)'
     is true when UNION is NEWSET U OLDSET and REALLYNEW is NEWSET \
     OLDSET.  This is useful when you have an iterative problem, and
     you're adding some possibly new elements (NEWSET) to a set
     (OLDSET), and as well as getting the updated set (UNION) you would
     like to know which if any of the "new" elements didn't already
     occur in the set (REALLYNEW).
'ord_union(+LISTOFSETS, -UNION)'
     is true when LISTOFSETS is given as a proper list of ordered sets
     and UNION is their union.  Letting K be the length of LISTOFSETS,
     and N the sum of the sizes of its elements, the cost is O(N LG K).
'ordset_order(+XS, +YS, -R)'

     is true when R is '<', '=', or '>' according as XS is a subset of
     YS, equal to YS, or a superset of YS.  XS and YS are ordered sets.


File: sicstus.info,  Node: lib-pillow,  Next: lib-plunit,  Prev: lib-ordsets,  Up: The Prolog Library

10.26 The PiLLoW Web Programming Library--'library(pillow)'
===========================================================

The PiLLoW library ("Programming in Logic Languages on the Web") is a
free Internet/WWW programming library for Logic Programming Systems that
simplifies the process of writing applications for such environment.
The library provides facilities for generating HTML or XML structured
documents by handling them as Prolog terms, producing HTML forms,
writing form handlers, processing HTML templates, accessing and parsing
WWW documents (either HTML or XML), accessing code posted at HTTP
addresses, etc.

   PiLLoW is documented in its own reference manual, located in
<http://www.clip.dia.fi.upm.es/Software/pillow/pillow_doc_html/pillow_doc_toc.html>
(HTML) or <http://www.clip.dia.fi.upm.es/Software/pillow/pillow_doc.ps>
(Postscript).  The following points are worth noting wrt. the PiLLoW
reference manual:

   * PiLLoW is automatically installed with the SICStus Prolog
     distribution.  No extra action needs to be taken.

   * PilloW comes as a single library module, 'library(pillow)'.

     This subsumes the various 'load_package/1' and 'use_module/1'
     queries mentioned in the PiLLoW reference manual.

   Further information can be found at the PiLLoW home page,
<http://clip.dia.fi.upm.es/Software/pillow/pillow.html>.


File: sicstus.info,  Node: lib-plunit,  Next: lib-process,  Prev: lib-pillow,  Up: The Prolog Library

10.27 Plunit Interface--'library(plunit)'
=========================================

* Menu:

* PlUnit Introduction:: Introduction
* PlUnit A Unit Test Box:: A Unit Test Box
* PlUnit Running the Test-Suite:: Running the Test-Suite
* PlUnit Tests and Production Systems:: Tests and Production Systems


File: sicstus.info,  Node: PlUnit Introduction,  Next: PlUnit A Unit Test Box,  Up: lib-plunit

10.27.1 Introduction
--------------------

This library module provides a Prolog unit-test framework, initially
developed by Jan Wielemaker for SWI-Prolog.  The code and documentation
was subsequently adapted for SICStus Prolog by SICS. The module is a
third-party product, and not part of SICStus Prolog proper.

   Automatic testing of software during development is probably the most
important Quality Assurance measure.  Tests can validate the final
system, which is nice for your users.  However, most (Prolog) developers
forget that it is not just a burden during development.

   * Tests document how the code is supposed to be used.
   * Tests can validate claims you make on the Prolog implementation.
     Writing a test makes the claim explicit.
   * Tests avoid big applications saying "no" after modifications.  This
     saves time during development, and it saves _a lot_ of time if you
     must return to the application a few years later or you must modify
     and debug someone else's application.


File: sicstus.info,  Node: PlUnit A Unit Test Box,  Next: PlUnit Running the Test-Suite,  Prev: PlUnit Introduction,  Up: lib-plunit

10.27.2 A Unit Test Box
-----------------------

Tests are written in normal Prolog.  A unit test is a named collection
of individual tests, enclosed within the directives:
     ':- begin_tests(UNIT[,OPTIONS]).'

and:
     ':- end_tests(UNIT).'

   They can be embedded inside a normal source module, or be placed in a
separate test-file that loads the files to be tested.  The individual
tests are defined by rules of the form:
     'test(NAME[,OPTIONS]) :- TEST-BODY.'

where NAME is a ground term and OPTIONS is a list describing additional
properties of the test.  Here is a very simple example:

     :- begin_tests(lists).
     :- use_module(library(lists)).

     test(reverse) :-
             reverse([a,b], [b,a]).

     :- end_tests(lists).

   The optional second argument of the unit test declaration as well as
of the individual test-heads defines additional processing options.  The
following options are available:

'blocked(REASON)'

     The test is currently disabled.  Tests are flagged as blocked if
     they cannot be run for some reason.  E.g. they crash Prolog, they
     rely on some service that is not available, they take too much
     resources, etc.  Tests that fail but do not crash, etc.  should be
     flagged using 'fixme(FIXME)'.  REASON should be an atom.

'fixme(REASON)'

     Similar to 'blocked(FIXME)', but the test is executed anyway.  A
     summary is printed at the end of the test run.  REASON should be an
     atom.

'condition(GOAL)'

     Precondition for running the test.  If the condition fails, then
     the test is skipped.  The condition can be used as an alternative
     to the 'setup' option.  The only difference is that failure of a
     condition skips the test and is considered an error when using the
     'setup' option.  GOAL should be a callable.

'nondet'

     Available for individual test rules only.  Unless this keyword
     appears in the option list, nondeterminate success of the test-body
     is considered an error.

'forall(GENERATOR)'

     Available for individual test rules only.  Runs the same test for
     each solution of GENERATOR.  Each run invokes the 'setup' and
     'cleanup' handlers.  This can be used to run the same test with
     different inputs.  If an error occurs, then the test is reported as
     'name (forall bindings = VARS)', where VARS indicates the bindings
     of variables in GENERATOR, which should be a callable.

'setup(GOAL)'

     GOAL is run before the test-body.  Typically used together with the
     'cleanup' option to create and destroy the required execution
     environment.  GOAL should be a callable.

'cleanup(GOAL)'

     GOAL is always called after completion of the test-body, regardless
     of whether it fails, succeeds or raises an exception.  This option
     or 'call_cleanup/2' must be used by tests that require side-effects
     that must be reverted after the test completes.  GOAL may share
     variables with a setup option and should be a callable:

     :- use_module(library(file_systems)).

     create_file(Tmp) :-
             open(temp(plunit), write, Out, [if_exists(generate_unique_name)]),
             current_stream(Tmp, write, Out),
             portray_clause(Out, hello(_World)),
             close(Out).

     test(read, [setup(create_file(Tmp)), cleanup(delete_file(Tmp))]) :-
             see(Tmp),
             read(Term),
             seen,
             Term = hello(_).

     *Please note*: Do not place directives that load source code
     between ':- begin_tests(UNIT[,OPTIONS])' and ':- end_tests(UNIT)'.
     Loading source files in this context can cause spurious error
     messages.

   The following options specify how to verify the result of the
test-body, and are only available for individual test rules.  It is not
meaningful to specify more than one of them:

'true'
'true(TEST)'

     The test-body as well as the goal TEST must succeed.  TEST defaults
     to 'true' and should be a callable that typically shares variables
     with the test-body.  This is the same as inserting the test at the
     end of the conjunction, but makes the test harness print a "wrong
     answer" message as opposed to a general failure message:

          test(badadd, [true(A =:= 4)]) :-
                  A is 1 + 2.

     will yield the error message:

          ! /home/matsc/sicstus4/doc/foo.pl:11:
          !       test badadd: wrong answer (compared using =:=)
          !     Expected: 4
          !     Got:      3

'all(ANSWERTERM CMP INSTANCES)'

     Similar to 'true(ANSWERTERM CMP INSTANCES)', but used if you want
     to collect all solutions to a nondeterminate test.  ANSWERTERM
     should share variables with the test-body.  Let ALL be the list of
     instances of ANSWERTERM for each solution.  Then the goal
     'CMP(ALL,INSTANCES)' must succeed.  The tests in the example below
     are equivalent:

          test(all1, all(X == [1,2])) :-
                  (X = 1 ; X = 2).

          test(all2, true(Xs == [1,2])) :-
                  findall(X, (X = 1 ; X = 2), Xs).

'set(ANSWERTERM CMP INSTANCES)'

     Similar to 'all(ANSWERTERM CMP INSTANCES)', but sorts the
     ANSWERTERM instances before the comparison.  The tests in the
     example below are equivalent:

          test(set1, set(X == [1,2])) :-
                  (X = 2 ; X = 1 ; X = 1).

          test(set2, true(Ys == [1,2])) :-
                  findall(X, (X = 2 ; X = 1 ; X = 1), Xs),
                  sort(Xs, Ys).

'fail'

     The test-body must fail.

'exception(EXPECTED)'
'throws(EXPECTED)'

     The test-body must raise an exception RAISED that is checked wrt.
     EXPECTED using 'terms:subsumeschk(EXPECTED, RAISED)'.  I.e. the
     raised exception must be more specific than the specified EXPECTED.

'error(ISO)'
'error(ISO,INFO)'

     A shorthand for 'exception(error(ISO,INFO))'.  INFO defaults to an
     anonymous variable.

10.27.3 Writing the Test-Body
-----------------------------

* Menu:

* PlUnit Determinate Tests:: Determinate Tests
* PlUnit Nondeterminate Tests:: Nondeterminate Tests
* PlUnit Tests Expected to Fail:: Tests Expected to Fail
* PlUnit Tests Expected to Raise Exceptions:: Tests Expected to Raise Exceptions

The test-body is ordinary Prolog code.  Without any options, the
test-body must be designed to succeed _determinately_.  Any other result
is considered a failure.  One of the options 'fail', 'true', 'exception'
or 'error' can be used to specify a different expected result.  In this
subsection we illustrate typical test-scenarios by testing built-in and
library predicates.


File: sicstus.info,  Node: PlUnit Determinate Tests,  Next: PlUnit Nondeterminate Tests,  Up: PlUnit A Unit Test Box

10.27.3.1 Determinate Tests
...........................

Determinate tests are tests that must succeed exactly once, leaving no
choicepoints behind.  The test-body supplies proper values for the input
arguments and verifies the output arguments.  Verification can use
test-options or be explicit in the test-body.  The tests in the example
below are equivalent.

     test(add1) :-
             A is 1 + 2,
             A =:= 3.

     test(add2, [true(A =:= 3)]) :-
             A is 1 + 2.

   The test engine verifies that the test-body does not leave a
choicepoint.  We illustrate this using the test below:

     test(member1) :-
             member(b, [a,b,c]).

   Although this test succeeds, 'member/2' leaves a choicepoint behind,
which is reported by the test harness.  To make the test silent, use one
of the alternatives below.

     test(member2) :-
             memberchk(b, [a,b,c]).

     test(member3) :-
             member(b, [a,b,c]), !.

     test(member4, [nondet]) :-
             member(b, [a,b,c]).


File: sicstus.info,  Node: PlUnit Nondeterminate Tests,  Next: PlUnit Tests Expected to Fail,  Prev: PlUnit Determinate Tests,  Up: PlUnit A Unit Test Box

10.27.3.2 Nondeterminate Tests
..............................

Nondeterminate tests succeed zero or more times.  Their results can be
tested using 'findall/3' followed by a value-check.  The following are
equivalent tests:

     test(member5) :-
             findall(X, member(X, [a,b,c]), Xs),
             Xs == [a,b,c].

     test(member6, true(Xs == [a,b,c])) :-
             findall(X, member(X, [a,b,c]), Xs).


File: sicstus.info,  Node: PlUnit Tests Expected to Fail,  Next: PlUnit Tests Expected to Raise Exceptions,  Prev: PlUnit Nondeterminate Tests,  Up: PlUnit A Unit Test Box

10.27.3.3 Tests Expected to Fail
................................

Tests that are expected to fail may be specified using the option 'fail'
or by negating the test-body using '\+'.

     test(is_set) :-
             \+ is_set([a,a]).

     test(is_set, [fail]) :-
             is_set([a,a]).


File: sicstus.info,  Node: PlUnit Tests Expected to Raise Exceptions,  Prev: PlUnit Tests Expected to Fail,  Up: PlUnit A Unit Test Box

10.27.3.4 Tests Expected to Raise Exceptions
............................................

Tests that are expected to raise exceptions may be specified using the
option 'exception(EXPECTED)' or one of its equivalents, or by wrapping
the test in 'on_exception/3' or 'catch/3'.  The following tests are
equivalent:

     :- use_module(library(terms)).
     test(div01) :-
          on_exception(Excp, A is 1/0, true),
          subsumeschk(error(evaluation_error(zero_divisor),_), Excp).

     test(div02, [error(evaluation_error(zero_divisor))]) :-
          A is 1/0.

     test(div03, [error(evaluation_error(zero_divisor),_)]) :-
          A is 1/0.

     test(div04, [exception(error(evaluation_error(zero_divisor),_))]) :-
          A is 1/0.

     test(div05, [throws(error(evaluation_error(zero_divisor),_))]) :-
          A is 1/0.


File: sicstus.info,  Node: PlUnit Running the Test-Suite,  Next: PlUnit Tests and Production Systems,  Prev: PlUnit A Unit Test Box,  Up: lib-plunit

10.27.4 Running the Test-Suite
------------------------------

At any time, the tests can be executed by loading the program and
running 'run_tests/[0,1,2]':

'run_tests'

     Run all individual tests of all test-units.

'run_tests(SPEC)'
'run_tests(SPEC,OPTIONS)'
     Run only the specified tests.  The options 'quiet' and 'verbose'
     (the default) are available; see below.  SPEC should be one of:

        * a term UNIT where UNIT is the name of a test-unit, denotes all
          individual tests of the test-unit UNIT, or
        * a term UNIT:TEST where UNIT is the name of a test-unit and
          TEST is one of its individual tests, denotes the given test
          only, or
        * a term UNIT:LIST where UNIT is the name of a test-unit and
          LIST is a list of its individual tests, denotes the given list
          of tests, or
        * finally, a list of terms of one of the above forms.

   Running single tests is particularly useful for tracing a test, e.g.:

     | ?- trace, run_tests(lists:member).

   'run_tests/[0,1,2]' prints a report during execution.  The 'quiet'
options suppresses informational messages; in its absence, messages are
printed in full as follows.

   First, each test-unit report begins with a header:

     '% PL-Unit: UNIT'

   Then comes a message (success or failure) for all specified tests not
marked as 'blocked' or 'fixme'.  Success messages are informational;
others are error or warning messages.  Any errors encountered while
executing options are also reported.  To close the test-unit, a footer
is printed:

     '% done'

   After all test-units, a summary report is printed, stating:

   * how many tests passed resp.  failed
   * which tests were blocked
   * details for each test marked as 'fixme'


File: sicstus.info,  Node: PlUnit Tests and Production Systems,  Prev: PlUnit Running the Test-Suite,  Up: lib-plunit

10.27.5 Tests and Production Systems
------------------------------------

Most applications do not want the test-suite to end up in the final
application.  There are several ways to achieve this.  One way is to
place all tests in separate files and not to load the tests when
creating the production environment.  Another way is to wrap each unit
test box in a pair of ':- if(...)', ':- endif' directives.  For example,
the test could be whether the 'plunit' module has been loaded:

     :- if(current_module(plunit)).
     :- begin_tests(UNIT[,OPTIONS]).
     ...
     :- end_tests(UNIT).
     :- endif.

   Alternatively, you can reserve a system property e.g.
'enable_unit_tests' to control whether unit tests should be enabled.
The property is enabled if you run SICStus Prolog as:

     % sicstus -Denable_unit_tests=true

   Then your Prolog source file could have the structure:

     :- use_module(library(system), [environ/2]).

     ...

     :- if(environ(enable_unit_tests, true)).
     :- use_module(library(plunit)).
     :- begin_tests(UNIT[,OPTIONS])
     ...
     :- end_tests(UNIT)
     :- endif.


File: sicstus.info,  Node: lib-process,  Next: lib-prologbeans,  Prev: lib-plunit,  Up: The Prolog Library

10.28 Process Utilities--'library(process)'
===========================================

This package contains utilities for process creation.

   A process is represented by a "process reference", a ground compound
term.  Both SICStus and the operating system maintain a state for each
such process reference and they must therefore be released, either
explicitly with 'process_release/1' or implicitly by
'process_wait/[2,3]'.  Process references are created with
'process_create/[2,3]' if explicitly requested with the 'process/1'
option.  Process references are required in order to obtain the exit
status of a process after 'process_create/[2,3]' has returned.

   Many of the predicates can accept a numeric operating system process
id ("PID") but since process ids are subject to re-use by the OS this is
less reliable and does not work if the process has already exited.

10.28.1 Examples
----------------

The following illustrates some common tasks.  The process library is
portable and works on all supported platforms, including UNIX, Linux and
Windows.  However, the examples are by necessity platform dependent.
Unless otherwise noted, the examples will work on UNIX and similar
systems only.

   (If you are looking for something like the old SICStus 3
'system:system/1' and 'system:popen/3', *Note unsafe_system::.)

  1. Run the 'date' command in the standard shell 'sh'.  The output of
     the command is sent to the terminal:
          | ?- process_create(path(sh),
               ['-c', date]).

  2. Run the 'date' command in the standard shell 'sh'.  Wait for the
     command to terminate before returning to Prolog.  Fail if the
     process gets an error.  The output of the command is sent to the
     terminal:
          | ?- process_create(path(sh),
               ['-c', date], [wait(exit(0))]).
     Using 'wait/1' option in this way is a convenient way to ensure
     that the command has finished before Prolog continues.

  3. Run the 'date' command in the standard shell 'sh'.  The output of
     the command is received by Prolog:
          | ?- process_create(path(sh),
               ['-c', date], [stdout(pipe(S))]),
               read_line(S,L), close(S), atom_codes(Date,L).
          ...,
          Date = 'Fri Jan 24 12:59:26 CET 2014' ?

  4. Pipe the output of the 'date' command to a file:
          | ?- process_create(path(sh),
               ['-c', [date, '>', file('/tmp/foo.txt')]]).

  5. Count the number of words in an atom, using the 'wc' command:
          | ?- process_create(path(wc), ['-w'],
               [stdin(pipe(In)), stdout(pipe(Out))]),
               write(In, 'a b c\n'), close(In),
               read_line(Out, L), close(Out), number_codes(N, L).
          ...
          N = 3
     It may be preferable to let the input or output go via a file.
     This avoids deadlock in case the stream buffers fill up.

  6. Count the number of unique words in a file, piping the output of
     the 'uniq' command to the 'wc' command:
          | ?- process_create(path(sh),
               ['-c', ['uniq ', file('/tmp/foo.txt'), ' | wc -w']],
               [stdout(pipe(Out))]),
               read_line(Out, L), close(Out), number_codes(N, L).
          ...
          N = 6
     Note that quoting is a problem (and potential security issue), so
     *never* pass untrusted data, like file names, to the shell using
     '-c' (*note Quoting and Security::).

  7. Run the 'make' command with the '-n' (dry run) option, discarding
     output, fail if it does not succeed:
          | ?- process_create(path(make), ['-n'],
               [stdout(null), wait(Exit)]),
               Exit = exit(0).
     By using the 'wait/1' option, 'process_create/3' will not return
     until the subprocess has exited and its exit status is available.

  8. Run 'ls' on a home directory in a subshell using the user's
     preferred shell:
          | ?- process_create('$SHELL', ['-c', [ls, ' ', file('~/') ]]).

  9. Run a command with output piped from a file and input provided by
     Prolog.  This is similar to 'popen('cat > ./myscript.sh',write,S)'
     in SICStus 3.  This example also shows one way to create a shell
     script which is useful when more advanced shell interaction is
     needed.  (The created script outputs the most common line in its
     input.  It is used in the next example.)
          | ?- process_create(path(sh),
               ['-c',
               'cat > ./myscript.sh && chmod a+x ./myscript.sh'],
               [stdin(pipe(S))]),
               write(S, '#! /bin/sh\n'),
               write(S, 'sort | uniq -c | sort -nr | head -n 1\n'),
               close(S).
     Please read *note Quoting and Security:: for problems with this
     approach.

  10. Run a shell script with input piped from a file and output read by
     Prolog.  This is similar to 'popen('./myscript.sh <
     ./somefile.txt',read,S)' in SICStus 3.
          | ?- open('somefile.txt',write,OF),
               write(OF,'hello\nworld\nhello\nhello\n'),close(OF),
               process_create(path(sh),
               ['-c', './myscript.sh < ./somefile.txt'],
               read_line(S, L), atom_codes(Line, L), close(S).
          ...,
          Line = '   3 hello' ?
     Please read *note Quoting and Security:: for problems with this
     approach.

  11. Run a goal in a SICStus subprocess (UNIX and Windows):
          | ?- process_create(application(sicstus),
               ['-f', '--noinfo', '--nologo',
               '--goal', 'read(X), call(X), halt.'],
               [stdin(pipe(In)), stdout(pipe(Out))]),
               format(In,'~q .~n', [(length([h,e,l,l,o], Len),
                                     format('~q .~n', [Len]))]),
               close(In), read(Out,Answer), close(Out).
          ...,
          Answer = 5

  12. Run 'notepad.exe' on a file 'C:/foo.txt' under Windows:
          | ?- process_create('$SYSTEMROOT/notepad.exe',
               [file('C:/foo.txt')]).
  13. Open a command shell in a separate window under Windows:
          | ?- process_create('$COMSPEC',[],[window(true)]).

10.28.1.1 Microsoft Windows Shell
.................................

On Windows, it is not possible to pass multiple parameters to a
subprocess.  When a subprocess is started, it receives exactly one
argument and a quoting convention must be used to encode the parameters
as the single argument actually passed to the process.

   Unfortunately, there is no such universal quoting convention, every
program can interpret its (single) argument in any way it sees fit.

   Most programs use a convention established by the Microsoft C
library.  This is the convention used by 'process_create/[2,3]' and it
usually works well.

   However, the command processor on Windows ('cmd.exe') does not use
the common convention and, except for very simple cases, passing
arguments to 'cmd.exe' will not work reliably.

   *Please note*: Passing arguments to 'cmd.exe' suffers from the same
security vulnerabilities as those described in *note Quoting and
Security::, below.

   If you want to run commands using 'cmd.exe', it is best to create a
batch ('.bat') file with your commands and then tell 'cmd.exe' to run
the batch file.

   The following example illustrates how to create a Windows batch file
that pipes some output to a file ('COMSPEC' is an environment variable
containing the path to 'cmd.exe'):
     | ?- BatFileName='test.bat',
          open(BatFileName, write, S),
          write(S, 'date /T > "result.txt"\n'), close(S),
          process_create('$COMSPEC', ['/Q', '/C', file(BatFileName)],
          [wait(exit(0))]),
          open('result.txt', read, R),
          read_line(R,L),close(R),atom_codes(Date,L).
     ...,
     Date = '2014-01-27 ',
     ... ?

   More recent versions of Windows come with a redesigned command line
processor, 'PowerShell', which solves the problems associated with the
traditional 'cmd.exe' command line processor.  In particular, it has a
very general way to encode command line arguments, using 'base-64'
encoding.  Currently, there is no direct support for PowerShell in this
library, but the following example shows how to get the current week day
both using a plain text command and with a base-64-encoded command

     | ?- Command = '(get-date).DayOfWeek',
          process_create(path(powershell),
          ['-Command', Command],
          [stdout(pipe(S))]),
          read_line(S,L),atom_codes(Day,L).
     ...,
     Day = 'Monday',
     ... ?

     | ?- EncodedCommand =
            'KABnAGUAdAAtAGQAYQB0AGUAKQAuAEQAYQB5AE8AZgBXAGUAZQBrAA==',
          process_create(path(powershell),
          ['-encodedCommand', EncodedCommand],
          [stdout(pipe(S))]),
          read_line(S,L),atom_codes(Day,L).
     ...,
     Day = 'Monday',
     ... ?
where the ENCODEDCOMMAND value was created by encoding the string
''(get-date).DayOfWeek'' using Base 64.  See the PowerShell
documentation for details.

10.28.2 Quoting and Security
----------------------------

It easy to get undesired, and possibly harmful, effects if arbitrary
data is passed without proper quoting to a shell.  For instance,
accepting arbitrary file names and passing them as part of a command
line to a subshell can cause the shell to execute arbitrary, possibly
malicious, code.

   The following, vulnerable, predicates suffer from this problem.  They
are similar to predicates that existed in SICStus 3, and their fragility
is one of the reasons process interaction was redesigned in SICStus 4.
     % DO NOT USE. This code is vulnerable.
     % Similar to system:system/1 in SICStus 3.
     unsafe_system(Cmd) :-
        % pass Cmd to shell, wait for exit, fail on error.
        process_create(path(sh), ['-c', Cmd], [wait(exit(0))]).

     % DO NOT USE. This code is vulnerable.
     % Similar to system:popen/3 in SICStus 3.
     unsafe_popen(Cmd, Direction, Pipe) :-
        % pass Cmd to shell, do not wait for exit,
        % connect to stdin or stdout of subprocess.
        ( Direction == read ->
          process_create(path(sh), ['-c', Cmd], [stdout(pipe(Pipe))])
        ; Direction == write ->
          process_create(path(sh), ['-c', Cmd], [stdin(pipe(Pipe))])
        ).

   Now consider the task of passing the contents of some file FILE to a
command 'mycommand'.  You may think the following is a good idea (it is
not!):

     % DO NOT USE. This code is vulnerable.
     unsafe_command(File, S) :-
        atom_concat('./mycommand < ', File, Cmd),
        unsafe_popen(Cmd, read, S).

   That works as expected if the the 'File' argument is a plain file
with no characters that has special meaning to the shell, e.g.
     File = './somefile.txt',
     unsafe_command(File, S), read_line(S,L),close(S).

   However, assume that the file name was obtained from some untrusted
source and consider the following example:
     File = '$(say bohoo)',
     unsafe_command(File, S), read_line(S,L),close(S).
depending on the system this can have a quite scary effect, and
illustrates how shell meta characters in the constructed command line
can lead to potentially dangerous results.

   The safest way to interact with the shell is to create shell scripts
and pass arguments to the scripts as separate arguments to the shell.
E.g.
     % A safer version
     safer_command(File, S) :-
        % pass the file as the first argument to mycommand.
        process_create(path(sh),
                       ['-c', file('./mycommand'), file(File)],
                       [stdout(pipe(S))]).
   Exported predicates:

'process_create(+FILE, +ARGS)'
'process_create(+FILE, +ARGS, :OPTIONS)'

     Start a new process running the program identified by FILE and the
     arguments specified in ARGS.  The standard streams of the new
     process can be redirected to prolog streams.  The exit status of
     the process can be obtained with 'process_wait/[2,3]'.

     FILE, is expanded as if by 'absolute_file_name/2' (with arguments
     'access(execute)' and 'file_type(executable)') and is used to
     locate the file to execute.

     The predefined file search path 'path/1' (*note ref-fdi::) is
     especially useful here since it makes it easy to look up the names
     of an executable in the directories mentioned by the 'PATH'
     environment variable.  To run the Windows command shell 'cmd' you
     would simply specify 'path('cmd.exe')' (or 'path(cmd)'), to start
     the UNIX Bash shell you would specify 'path(bash)'.

     ARGS is a list of argument specifications.  Each argument
     specification is either a simple argument specification, see below,
     or a non-empty list of simple argument specifications.  The
     expanded value of each element of ARGS is concatenated to produce a
     single argument to the new process.  A "simple argument
     specification" can be one of:

     an atom
          The atom name is used as the expanded value.  Some operating
          systems only support 7-bit ASCII characters here.  Even when
          some larger subset of Unicode is used it may not work
          correctly with all programs.

     'file(FILE)'
          FILE, an atom, is treated as a file name and subject to an
          operating system specific transformation to ensure file name
          syntax and character set is appropriate for the new process.
          This is especially important under Windows where it ensures
          that the full Windows Unicode character set can be used.

          *Please note*: The FILE part of 'file(FILE)' is not subject to
          syntactic rewriting, the argument specification 'file/1' only
          adjusts for differences in file name syntax and character
          encoding between SICStus and the operating system.  You must
          explicitly call 'absolute_file_name/[2,3]' if you want to
          expand file search paths etc.

     OPTIONS is a list of options:

     'stdin(SPEC)'
     'stdout(SPEC)'
     'stderr(SPEC)'
          Each SPEC specifies how the corresponding standard stream of
          the new process should be created.  SPEC can be one of:
          'std'
               The new process shares the (OS level) standard stream
               with the Prolog process.  This is the default.  Note
               that, especially under Windows, the Prolog process may
               not have any OS level standard streams, or the OS streams
               may not be connected to a console or terminal.  In such a
               case you need to use 'pipe/[1,2]' spec, see below, and
               explicitly read (write) data from (to) the process.
          'null'
               The stream is redirected to a null stream, i.e. a stream
               that discards written data and that is always at end of
               file when read.
          'pipe(STREAM)   since release 4.0'
          'pipe(STREAM, STREAMOPTIONS)   since release 4.3.2'

               A new Prolog stream is created and connected to the
               corresponding stream of the new process.  STREAMOPTIONS
               is a list of options affecting the created stream.  The
               supported stream options are: 'type/1', 'eol/1', and
               'encoding/1', with the same meaning as for 'open/4'
               (*note mpg-ref-open::).

               The default, if no stream options are specified, is to
               use a text stream with the OS default character encoding.

               This stream must be closed using 'close/[1,2]', it is not
               closed automatically when the new process exits.

     'wait(-EXITSTATUS)   since release 4.3'
          The call will not return until the sub-process has terminated.
          EXITSTATUS will be bound to the exit status of the process, as
          described for 'process_wait/2'.
     'process(PROC)'
          PROC will be bound to a process reference that can be used in
          calls to 'process_wait/[2,3]' etc..  This process reference
          must be released, either explicitly with 'process_release/1'
          or implicitly by 'process_wait/[2,3]'.  It is often easier to
          use the 'wait/1' option if you just want to wait for the
          process to terminate.

     'detached(BOOL)'
          BOOL is either 'true' or 'false'.  Specifies whether the new
          process should be "detached", i.e. whether it should be
          notified of terminal events such as '^C' interrupts.  By
          default a new process is created detached if none of the
          standard streams are specified, explicitly or implicitly, as
          'std'.

     'cwd(CWD)'

          CWD is expanded as if by 'absolute_file_name/2' and is used as
          the working directory for the new process.

          By default, the working directory is the same as the Prolog
          working directory.

     'window(BOOL)'
          BOOL is either 'true' or 'false' (the default).  Specifies
          whether the process should open in its own window.

          Specifying 'window(true)' may give unexpected results if the
          standard stream options 'stdin/1', 'stdout/1' and 'stderr/1'
          are specified with anything but their default value 'std'.

          Currently only implemented on Windows.

     'environment(ENV)   since release 4.1'

          ENV is a list of 'VAR=VALUE' for extra environment variables
          to pass to the sub-process in addition to the default process
          environment.  VAR should be an atom.  VALUE should be an
          argument specification, as described above.  The VALUE is
          typically an atom but, especially on the Windows platform, it
          may be necessary to wrap file names in 'file/1' to ensure file
          paths are converted to the native format.  *Note System
          Properties and Environment Variables: (sicstus)System
          Properties and Environment Variables, for more information.

'process_wait(+PROCESS, -EXITSTATUS)'
'process_wait(+PROCESS, -EXITSTATUS, +OPTIONS)'

     Wait for a process to exit and obtain the exit status.

     PROCESS is either a process reference obtained from
     'process_create/3' or an OS process identifier.  Specifying a
     process identifier is not reliable.  The process identifier may
     have been re-used by the operating system.  Under Windows, it is
     not possible to obtain the exit status using a process identifier
     if the process has already exited.

     EXITSTATUS is one of:
     'exit(EXITCODE)'
          The process has exited with exit code EXITCODE.  By convention
          processes use exit code zero to signify success and a
          (positive) non-zero value to specify failure.
     'killed(SIGNALNUMBER)'
          UNIX only, the process was killed by signal 'SignalNumber' (a
          positive integer).

     'timeout'
          The 'timeout/1' option was specified and the process did not
          exit within the specified interval.  In this case the process
          reference is not released, even if the 'release/1' option is
          specified.
     OPTIONS is a list of options:
     'timeout(SECONDS)'
          Specify a maximum time, in seconds, to wait for the process to
          terminate.  SECONDS should be an integer or floating point
          number or the atom 'infinite' (the default) to specify
          infinite wait.  If the specified timeout interval passes
          before the process exits, 'process_wait/3' exits with
          EXITSTATUS set to 'timeout' and the process reference is not
          released.

          Currently the UNIX implementation supports only timeout values
          0 (zero) and 'infinite'.

     'release(BOOL)'
          BOOL is either 'true' (the default) or 'false'.  Specifies
          whether the process reference should be released when
          'process_wait/3' exits successfully.
'process_id(-PID)'

     Obtain the process identifier of the current (i.e. Prolog) process.
'process_id(+PROCESS, -PID)'

     Obtain the process identifier of the process reference PROCESS.
'is_process(+THING)'

     Returns true if THING is a process reference that has not been
     released.
'process_release(+PROCESS)'

     Release a process reference PROCESS that has previously been
     obtained from 'process_create/3'.  This ensures that Prolog and the
     operating system can reclaim any resources associated with the
     process reference.

     Usually you would not call this.  Either do not request the process
     reference when calling 'process_create/3' or let
     'process_wait/[2,3]' reclaim the process reference when the process
     terminates.
'process_kill(+PROCESS)'
'process_kill(+PROCESS, +SIGNALSPEC)'

     Send a signal to the process designated by PROCESS.  The signal can
     either be a non-negative integer or a signal name as an (all
     uppercase) atom.

     The following signal names are accepted under UNIX if the platform
     defines them: 'SIGABRT', 'SIGALRM', 'SIGBUS', 'SIGCHLD', 'SIGCONT',
     'SIGFPE', 'SIGHUP', 'SIGILL', 'SIGINT', 'SIGKILL' (the default),
     'SIGPIPE', 'SIGPOLL', 'SIGPROF', 'SIGQUIT', 'SIGSEGV', 'SIGSTOP',
     'SIGSYS', 'SIGTERM', 'SIGTRAP', 'SIGTSTP', 'SIGTTIN', 'SIGTTOU',
     'SIGURG', 'SIGUSR1', 'SIGUSR2', 'SIGVTALRM', 'SIGXCPU' and
     'SIGXFSZ'.  However, many of these do not make sense to send as
     signals.

     Under Windows, which does not have the signal concept, the signal
     name 'SIGKILL' (the default) is treated specially and terminates
     the process with 'TerminateProcess(Process, -1)'.  *Please note*:
     Using 'process_kill/[2,3]' on Windows is not recommended.  Also, on
     Windows, the call may throw an error if the process has already
     exited.


File: sicstus.info,  Node: lib-prologbeans,  Next: lib-queues,  Prev: lib-process,  Up: The Prolog Library

10.29 PrologBeans Interface--'library(prologbeans)'
===================================================

* Menu:

* PB Intro:: Introduction
* PB Features:: Features
* PB First Example:: A First Example
* PB Prolog Server Interface:: Prolog Server Interface
* PB Java Client Interface:: Java Client Interface
* PB Java Examples:: Java Examples
* PB .NET Client Interface:: .NET Client Interface
* PB .NET Examples:: .NET Examples


File: sicstus.info,  Node: PB Intro,  Next: PB Features,  Up: lib-prologbeans

10.29.1 Introduction
--------------------

PrologBeans is a package for integrating Prolog with applications
written in other languages.  Currently Java and .NET are supported.
PrologBeans is based on running Prolog as a separate server process, and
the other part of the application as a client process.  This makes
PrologBeans automatically distributable since the server and the client
can run on different computers anywhere on the Internet.

   PrologBeans is designed to be used when client applications need to
send queries to a Prolog server (and less intended for showing a GUI
from a Prolog program).  One typical application would be to connect a
Java or .NET based web application to a Prolog server (see examples
later).

 [image src="images/prologbeansarch.png" text="" ]
   _PrologBeans setup where the Prolog application serves several users
accessing both via a web application server and a .NET GUI._

   The PrologBeans package consists of two parts.  The Prolog server is
a library module, 'library(prologbeans)'.  The client is a class
library, 'prologbeans.jar' for Java (installed on all platforms), and
'prologbeans.dll' for .NET (only installed on Microsoft Windows
platforms).


File: sicstus.info,  Node: PB Features,  Next: PB First Example,  Prev: PB Intro,  Up: lib-prologbeans

10.29.2 Features
----------------

The current version of PrologBeans is designed to be used mainly as a
connection from the client (Java or .NET) to Prolog.  Current features
are:

   * Socket based communication [Java and .NET]
   * Allows the client application and Prolog server to run on different
     machines [Java and .NET]
   * Multiple client applications can connect to same Prolog server
     [Java and .NET]
   * Client applications can make use of several Prolog servers [Java
     and .NET]
   * Allows Java Applets to access Prolog server [Java]
   * Platform independent (e.g. any platform where Prolog and Java or
     .NET exist) [Java and .NET]
   * Simplifies the use of Prolog in Java application servers (Tomcat,
     etc) [Java]
   * Prohibits unwanted use of Prolog server by host control (only
     specified hosts can access the Prolog server) [Java and .NET]
   * Supports Java servlet sessions [Java]
   * Supports JNDI lookup (Java Naming and Directory Interface) [Java]
   * Supports .NET server pages (ASPX). [.NET]


File: sicstus.info,  Node: PB First Example,  Next: PB Prolog Server Interface,  Prev: PB Features,  Up: lib-prologbeans

10.29.3 A First Example
-----------------------

This section provides an example to illustrate how PrologBeans can be
used.  This application has a simple Java GUI where the user can enter
expressions that will be evaluated by an expression evaluation server.

     import java.awt.*;
     import java.awt.event.*;
     import javax.swing.*;
     import se.sics.prologbeans.*;

     public class EvaluateGUI implements ActionListener {

       private JTextArea text = new JTextArea(20, 40);
       private JTextField input = new JTextField(36);
       private JButton evaluate = new JButton("Evaluate");
       private PrologSession session = new PrologSession();

       public EvaluateGUI() throws java.io.IOException
         {
         if ((Integer.getInteger("se.sics.prologbeans.debug", 0)).intValue() != 0) {
     	  session.setTimeout(0);
           }
         JFrame frame = new JFrame("Prolog Evaluator");
         Container panel = frame.getContentPane();
         panel.add(new JScrollPane(text), BorderLayout.CENTER);
         JPanel inputPanel = new JPanel(new BorderLayout());
         inputPanel.add(input, BorderLayout.CENTER);
         inputPanel.add(evaluate, BorderLayout.EAST);
         panel.add(inputPanel, BorderLayout. SOUTH);
         text.setEditable(false);
         evaluate.addActionListener(this);
         input.addActionListener(this);

         frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
         frame.pack();
         frame.setVisible(true);

         session.connect();
       }

       public void actionPerformed(ActionEvent event) {
         try {
           Bindings bindings = new Bindings().bind("E",
                               input.getText() + '.');
           QueryAnswer answer =
             session.executeQuery("evaluate(E,R)", bindings);
           PBTerm result = answer.getValue("R");
           if (result != null) {
             text.append(input.getText() + " = " + result + '\n');
             input.setText("");
           } else {
             text.append("Error: " + answer.getError() + '\n');
           }
         } catch (Exception e) {
           text.append("Error when querying Prolog Server: " +
                       e.getMessage() + '\n');
           e.printStackTrace();
         }
       }

       public static void main(String[] args) throws java.io.IOException
       {
         new EvaluateGUI();
       }
     }

   The Java code above first sets up the GUI with a text area for
showing results, a text field for entering expressions, and a button for
requesting an evaluation (the constructor 'EvaluateGUI()').  It will
also add itself as 'ActionListener' on both the text field and the
button.  The method 'actionPerformed(ActionEvent event)' will be called
whenever the user has pressed <RET> or clicked on the button.
'actionPerformed' first binds the variable E to the value of the text
field, and then sends the query to the Prolog server with
'session.executeQuery("evaluate(E,R)", bindings);'.  If everything goes
well, then the Prolog server will return an answer (bound to R), which
will be appended to the text area.

     :- module(evaluate,[main/0,my_predicate/2]).
     :- use_module(library(prologbeans)).
     :- use_module(library(codesio), [read_from_codes/2]).

     %% Register acceptable queries and start the server (using default port)
     main:-
         register_query(evaluate(C,P), my_predicate(C,P)),
         start.

     %% We have received a code-list
     %% which needs to be converted into an expression
     my_predicate(Chars, P) :-
         read_from_codes(Chars, X),
         P is X.

   The Prolog code above first defines the module and imports the needed
modules.  Then, in the 'main/0' predicate, it configures the server to
answer queries on the form 'evaluate(C,P)' and starts the server.  The
last few lines defines the predicate 'my_predicate(Chars, P)', which is
the predicate that performs the evaluation.  Note that, here, the
expression to evaluate is represented as a code-list and must be
converted into a term before evaluation.

   In general, arbitrary Prolog terms can be passed to the client via
this mechanism, including terms containing unbound variables.  However,
any unbound variables with attributes or blocked goals attached to them
will be replaced by plain, brand new variables.  This is analogous to
the way attributed variables are handled in terms that are written,
copied, asserted, gathered as solutions to 'findall/3' and friends, or
raised as exceptions.  If the attributes must be passed to the client,
then the Prolog code can obtain them by using 'copy_term/3' (*note
ref-lte-cpt::).

   *Please note*: the environment variable 'SP_PATH' as used here is
meant to be a shorthand (*note CPL Notes::), and does not need to be set
explicitly.

   To start the example, first start the Prolog server by going to the
'%SP_PATH%\library\prologbeans\examples\evaluate' (Windows), or
'$SP_PATH/library/prologbeans/examples/evaluate' (UNIX/Linux) directory
and type:

     % sicstus -l EVALUATE.PL --goal "main."

   To start the GUI type (from the same directory as above):

     > java -classpath "%SP_PATH%\bin\prologbeans.jar;." EvaluateGUI (Windows), or
     % java -classpath "$SP_PATH/bin/prologbeans.jar:." EvaluateGUI (UNIX)


File: sicstus.info,  Node: PB Prolog Server Interface,  Next: PB Java Client Interface,  Prev: PB First Example,  Up: lib-prologbeans

10.29.4 Prolog Server Interface
-------------------------------

The Prolog interface is based on the idea of a Prolog server that
provides its service by answering queries from external applications
(typically Java applications).  The Prolog interface in PrologBeans is
defined in 'library(prologbeans)', which implements the Prolog server
and exports the following predicates:

'start'
'start(+OPTIONS)'

     starts the Prolog server using the options specified.  *Please
     note*: 'start/[0,1]' will not return until a server shutdown
     occurs.  OPTIONS should be a list of zero or more of:

     'port(?VAL)'
          an integer denoting the port number of the Prolog server.  The
          default port, if no port option is present, is 8066.  In the
          case of the default port being used, the Socket Reuse Adress
          bit will be set in the underlying sockets layer.  If 'VAL' is
          a variable, then some unused port will be selected by the OS,
          the actual port number can be obtained with
          'get_server_property/1', typically from a 'server_started'
          event listener.

     'accepted_hosts(+VAL)'
          a list of atoms denoting the hosts (in form of IP-addresses)
          that are accepted by the Prolog server (default:
          '['127.0.0.1']').

     'session_timeout(+VAL)'
          an integer denoting the duration of a session in seconds.  The
          session will be removed if it has been inactive more than this
          timeout when the session garbage collect starts.  If the
          session timeout is set to zero, then there will be no garbage
          collection of sessions (default: '0').

     'session_gc_timeout(+VAL)'
          an integer denoting the minimum time in seconds between two
          consecutive session garbage collections.  If the timeout is
          set to zero, then there will be no garbage collection of
          sessions (default: '0').

     For example:

          :- start([port(7500),
                    accepted_hosts(['127.0.0.1','99.8.7.6'])]).

'shutdown'
'shutdown(+Mode)'

     shuts down the server and closes the sockets and the streams after
     processing all available input.  There are three modes:
     'now'
          as soon as possible (default).
     'no_sessions'
          after all sessions have ended (all sessions have either been
          explicitly removed by request of the client application, or
          they have been garbage collected).  *Please note*: there can
          still be connections to the Prolog server even when all
          sessions have ended.
     'no_connections'
          after all connections to the Prolog server are closed.
          *Please note*: there can still be user sessions left when all
          connections have been closed.

'register_query(+QUERY, :PREDICATETOCALL)'
'register_query(+QUERY, :PREDICATETOCALL, +SESSIONVAR)'

     registers a query and the corresponding goal.  Before the
     registration, any previously registered query matching QUERY will
     be removed (as if by 'unregister_query(QUERY)').  The goal
     PREDICATETOCALL will be called when a query matching QUERY is
     received.

     Typically, QUERY and PREDICATETOCALL share variables that are
     instantiated by the call, and the instantiated QUERY is passed back
     to the client.  In general, variable bindings can be arbitrary
     Prolog terms, including terms containing unbound variables.
     However, any unbound variables with attributes or blocked goals
     attached to them will be replaced by plain, brand new variables.
     This is analogous to the way attributed variables are handled in
     terms that are written, copied, asserted, gathered as solutions to
     'findall/3' and friends, or raised as exceptions.  If the
     attributes must be passed to the client, then the Prolog code can
     obtain them by using 'copy_term/3' (*note ref-lte-cpt::).

     The goal is called determinately, i.e. it is never backtracked
     into.  If it fails, then the term 'no' is passed to the client
     instead of the instantiated QUERY.  If it raises an exception E,
     then the term 'error(E)' is passed to the client instead of the
     instantiated QUERY.

     Before calling the query, the variable SESSIONVAR, if given, is
     bound to the id of the current session.  Session ids are typically
     generated in web applications that track users and mark all
     consecutive web-accesses with the same session id.

'unregister_query(+QUERY)'
     unregisters all queries matching QUERY.

'session_get(+SESSIONID, +PARAMETERNAME, +DEFAULTVALUE, -VALUE)'

     returns the value of a given parameter in a given session.  If no
     value exists, then it will return the default value.  Arguments:
     SESSIONID
          is the id of the session for which values have been stored
     PARAMETERNAME
          an atom, is the name of the parameter to retrieve
     DEFAULTVALUE
          is the value that will be used if no value is stored
     VALUE
          is the stored value or the default value if nothing was stored

'session_put(+SESSIONID, +PARAMETERNAME, +VALUE)'

     stores the value of the given parameter.  *Please note*: any
     pre-existing value for this parameter will be overwritten.  Note
     that 'session_put/3' will not be undone when backtracking (the
     current implementation is based on 'assert').  Arguments:

     SESSIONID
          is the id of the session for the values to store
     PARAMETERNAME
          an atom, is the name of the parameter to store
     VALUE
          the value to be stored

'register_event_listener(+EVENT, :PREDICATETOCALL)'
'register_event_listener(+EVENT, :PREDICATETOCALL, -ID)'

     Registers 'PREDICATETOCALL' to be called (as if by
     'once(PREDICATETOCALL)') when the event matching 'EVENT' occurs
     (event matching is on principal functor only).  If the goal fails
     or raises an exception, then a warning is written to 'user_error'
     but the failure or exception is otherwise ignored.  Arguments:

     EVENT
          is the event template; see below.
     PREDICATETOCALL
          an arbitrary goal.
     ID
          becomes bound to a (ground) term that can be used with
          'unregister_event_listener/1' to remove this event listener.

     The predefined events are as follows:

     'session_started(+SESSIONID)'
          called before the first call to a query for this session
     'session_ended(+SESSIONID)'
          called before the session is about to be garbage collected
          (removed)
     'server_started'
          called when the server is about to start (enter its main loop)
     'server_shutdown'
          called when the server is about to shut down

     Attempt to register an event listener for other events than the
     predefined events will throw an exception.

     More than one listeners can be defined for the same event.  They
     will be called in some unspecified order when the event occurs.

'unregister_event_listener(+ID)'

     Unregister a previously registered event listener.  The ID is the
     value returned by the corresponding call to
     'register_event_listener/3'.  It is an error to attempt to
     unregister an event listener more than once.


File: sicstus.info,  Node: PB Java Client Interface,  Next: PB Java Examples,  Prev: PB Prolog Server Interface,  Up: lib-prologbeans

10.29.5 Java Client Interface
-----------------------------

The Java interface is centered around the class 'PrologSession', which
represents a connection (or session) to a Prolog server.
'PrologSession' contains static methods for looking up named
'PrologSession' instances using JNDI (Java Naming and Directory
Interface) as well as methods for querying the Prolog server.  Other
important classes are: 'QueryAnswer', which contains the answer for a
query sent to the Prolog server; 'PBTerm', which represents a Prolog
term; and 'Bindings', which supports stuffing of variable values used in
queries.

   General information about Java, Servlets and JNDI is available at the
Java Technology site: <http://java.sun.com/>

   A brief description of the provided Java classes are presented below.
More information about the Java APIs is available in the JavaDoc files
on the page <http://sicstus.sics.se/documentation.html>.

'PrologSession'
     The 'PrologSession' object is the connection to the Prolog server.
     The constructor 'PrologSession()' creates a 'PrologSession' with
     the default settings ('host = localhost, port = 8066'.

'QueryAnswer'
     The 'QueryAnswer' contains the answer (new bindings) for a query
     (or the error that occurred during the query process).

'PBTerm'
     The 'PBTerm' object is for representing parsed Prolog terms.

'Bindings'
     'Bindings' is used for binding variables to values in a query sent
     to the Prolog.  The values will be automatically stuffed before
     they are sent to the Prolog server.


File: sicstus.info,  Node: PB Java Examples,  Next: PB .NET Client Interface,  Prev: PB Java Client Interface,  Up: lib-prologbeans

10.29.6 Java Examples
---------------------

* Menu:

* PB Ex Embedding:: Embedding Prolog in Java Applications
* PB Ex Servers:: Application Servers
* PB Ex Tomcat:: Configuring Tomcat for PrologBeans

The PrologBeans examples for Java can be found in the directory
corresponding to the file search path 'pbexamples', defined as if by a
clause:

     user:file_search_path(pbexamples, library('prologbeans/examples')).


File: sicstus.info,  Node: PB Ex Embedding,  Next: PB Ex Servers,  Up: PB Java Examples

10.29.6.1 Embedding Prolog in Java Applications
...............................................

If you have an advanced Prolog application that needs a GUI, then you
can write a stand-alone Java application that handles the GUI and set up
the Prolog server to call the right predicates in the Prolog
application.

   An example of how to do this can be found under the
'pbexamples(evaluate)' directory (see the example code in *note PB First
Example::).

   Another example of this is 'pbexamples(pbtest)', which illustrates
several advanced features like:
   * registering several queries
   * listening to server events ('server_started')
   * shutting down the Prolog server from Java
   * starting up the Prolog server from Java
   * using dynamic (OS assigned) ports for the Java/Prolog communication

   The example is run by executing the Java program 'PBTest':
     > java -classpath "%SP_PATH%\bin\prologbeans.jar;." PBTest (Windows), or
     % java -classpath "$SP_PATH/bin/prologbeans.jar:." PBTest (UNIX)


File: sicstus.info,  Node: PB Ex Servers,  Next: PB Ex Tomcat,  Prev: PB Ex Embedding,  Up: PB Java Examples

10.29.6.2 Application Servers
.............................

If you want to get your Prolog application to be accessible from an
intranet or the Internet, then you can use this package to embed the
Prolog programs into a Java application server such as Tomcat,
WebSphere, etc.

   An example of how to do this is provided in 'pbexamples(sessionsum)'.
This example uses sessions to keep track of users so that the
application can hold a state for a user session (as in the example
below, remember the sum of all expressions evaluated in the session).

     <%@ page import = "se.sics.prologbeans.*" %>
     <html>
     <head><title>Sum Calculator</title></head>
     <body bgcolor="white">
     <font size=4>Prolog Sum Calculator, enter expression to evaluate:
     <form><input type=text name=query></form>
     <%
        PrologSession pSession =
        PrologSession.getPrologSession("prolog/PrologSession", session);
        pSession.connect();

        String evQuery = request.getParameter("query");
        String output = "";
        if (evQuery != null) {
          Bindings bindings = new Bindings().bind("E",evQuery + '.');
          QueryAnswer answer =
             pSession.executeQuery("sum(E,Sum,Average,Count)", bindings);
          PBTerm average = answer.getValue("Average");
          if (average != null) {
             PBTerm sum = answer.getValue("Sum");
             PBTerm count = answer.getValue("Count");

             output = "<h4>Average =" + average + ", Sum = "
             + sum + " Count = " + count + "</h4>";
          } else {
             output = "<h4>Error: " + answer.getError() + "</h4>";
          }
       }
     %>
     <%= output  %><br></font>
     <p><hr>Powered by SICStus Prolog
     </body></html>

   The example shows the code of a JSP (Java Server Page).  It makes use
of the method 'PrologSession.getPrologSession(String jndiName,
HTTPSession session)', which uses JNDI to look up a registered
'PrologSession', which is connected to the Prolog server.  The variable
SESSION is in a JSP bound to the current 'HTTPSession', and the variable
REQUEST is bound to the current 'HTTPRequest'.  Since the 'HTTPSession'
object 'session' is specified all queries to the Prolog server will
contain a session id.  The rest of the example shows how to send a query
and output the answer.

   Example usage of sessions (from the 'sessionsum' example) is shown
below, and is from 'pbexamples('sessionsum/sessionsum.pl')':

     :- module(sessionsum,[main/0,sum/5]).
     :- use_module(library(prologbeans)).
     :- use_module(library(codesio), [read_from_codes/2]).

     %% Register the acceptable queries (session based)
     main:-
         register_query(sum(C,Sum,Average,Count),
                        sum(C,Session,Sum,Average,Count),
                        Session),
         start.

     %% The sum predicate which gets the information from a session database,
     %% makes some updates and then stores it back in to the session store
     %% (and returns the information back to the application server)
     sum(ExprChars, Session, Sum, Average, Count) :-
         session_get(Session, sum, 0, OldSum),
         session_get(Session, count, 0, OldCount),
         read_from_codes(ExprChars, Expr),
         Val is Expr,
         Sum is OldSum + Val,
         Count is OldCount + 1,
         Average is Sum / Count,
         session_put(Session, sum, Sum),
         session_put(Session, count, Count).

   In this example a query 'sum/4' is registered to call 'sum/5' where
one of the variables, SESSION will be bound to the session id associated
to the query.  The 'sum/5' predicate uses the 'session_get/4' predicate
to access stored information about the particular session, and then it
performs the evaluation of the expression.  Finally, it updates and
stores the values for this session.


File: sicstus.info,  Node: PB Ex Tomcat,  Prev: PB Ex Servers,  Up: PB Java Examples

10.29.6.3 Configuring Tomcat for PrologBeans
............................................

This section will briefly describe how to set up a Tomcat server so that
is it possible to test the example JSPs.  Some knowledge about how to
run Tomcat and how to set up your own web application is required.
Detailed information about Tomcat is available at
<http://jakarta.apache.org/tomcat/>.

   Assuming that the environment variable CATALINA_HOME is set to the
installation directory of Tomcat, do the following:

  1. Create the directory '$CATALINA_HOME/webapps/PB_example'

  2. Copy the file 'pbexamples('sessionsum/sessionsum.jsp')' to
     '$CATALINA_HOME/webapps/PB_example/sessionsum.jsp'
  3. Create the directory
     '$CATALINA_HOME/webapps/PB_example/WEB-INF/lib'

  4. Copy the file '$SP_PATH/bin/prologbeans.jar' to
     '$CATALINA_HOME/webapps/PB_example/WEB-INF/lib/prologbeans.jar'

  5. Create the directory '$CATALINA_HOME/webapps/PB_example/META-INF'

  6. Create the file
     '$CATALINA_HOME/webapps/PB_example/META-INF/context.xml' with the
     following content:
          <Context docBase="PB_example">
             <Resource name="prolog/PrologSession" auth="Container"
                       type="se.sics.prologbeans.PrologSession"
          	     factory="org.apache.naming.factory.BeanFactory" />

          </Context>

  7. Create the file '$CATALINA_HOME/webapps/PB_example/WEB-INF/web.xml'
     with the following content:
          <?xml version="1.0" encoding="ISO-8859-1"?>
          <!DOCTYPE web-app
               PUBLIC "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN"
              "http://java.sun.com/dtd/web-app_2_3.dtd">
          <web-app>

              <resource-env-ref>
                <description>
                  Object factory for PrologSession instances.
                </description>
                <resource-env-ref-name>
                  prolog/PrologSession
                </resource-env-ref-name>
                <resource-env-ref-type>
                  se.sics.prologbeans.PrologSession
                </resource-env-ref-type>
              </resource-env-ref>

          </web-app>

  8. Start SICStus, load 'sessionsum.pl' and run main.

  9. Start the Tomcat server.

  10. In a web browser, enter
     <http://localhost:8080/PB_example/sessionsum.jsp>


File: sicstus.info,  Node: PB .NET Client Interface,  Next: PB .NET Examples,  Prev: PB Java Examples,  Up: lib-prologbeans

10.29.7 .NET Client Interface
-----------------------------

The class 'PrologSession' in the .NET interface represents a connection
to a Prolog server.  'PrologSession' contains methods for establishing a
connection and querying the Prolog server.  Other important classes are:
'QueryAnswer', which contains the answer for a query sent to the Prolog
server; 'PBTerm', which represents a Prolog term; and 'Bindings', which
supports stuffing of variable values used in queries.

   The 'PrologSession' object is the connection to the Prolog server.
The constructor 'PrologSession()' creates a 'PrologSession' with the
default settings ('host = localhost, port = 8066'.

   The interface is almost exactly as the Java version.  See the C#
source code ('library/prologbeans.NET/*.cs') or the JavaDoc, for
details.


File: sicstus.info,  Node: PB .NET Examples,  Prev: PB .NET Client Interface,  Up: lib-prologbeans

10.29.8 .NET Examples
---------------------

* Menu:

* PB C# Examples:: C# Examples
* PB VB Example:: Visual Basic Example

The PrologBeans examples for .NET can be found in the directory
corresponding to the file search path 'pbnetexamples', defined as if by
a clause:

     user:file_search_path(pbnetexamples, library('prologbeans.NET/examples')).


File: sicstus.info,  Node: PB C# Examples,  Next: PB VB Example,  Up: PB .NET Examples

10.29.8.1 C# Examples
.....................

_.NET Embedding._  If you have an advanced Prolog application that needs
a GUI, then you can write a stand-alone .NET application that handles
the GUI and set up the Prolog server to call the right predicates in the
Prolog application.

   An example of how to do this can be found under the
'pbnetexamples('evaluate.NET')' directory.  This example is the C#
version of the example shown in *note PB First Example::).

   To start the example, first start the Prolog server by going to the
'pbnetexamples('evaluate.NET')' directory and type:

     > sicstus -l EVALUATE.PL --goal "main."

   To start the GUI type (from the same directory as above):

     > run.bat

   Another example of this is 'pbnetexamples('pbtest.NET')', which
illustrates several advanced features like:

   * registering several queries
   * listening to server events ('server_started')
   * shutting down the Prolog server from .NET
   * starting up the Prolog server from .NET
   * using dynamic (OS assigned) ports for the .NET/Prolog communication

   The example is run by executing the C# program 'PBTest':

     > PBTest

   _ASPX Servers Pages._  If you want to get your Prolog application to
be accessible from an intranet or the Internet, then you can use this
package to embed the Prolog programs into a .NET ASP page which can be
served by e.g. Internet Information Services.

   An example of how to do this is provided in
'pbnetexamples('prologasp.NET/eval.aspx')'.  Consult your IIS
documentation for how to configure it for an ASPX page.  *The ASPX
example has a number of security vulnerabilites and is for illustrative
purposes only.  Consult with an expert.  *


File: sicstus.info,  Node: PB VB Example,  Prev: PB C# Examples,  Up: PB .NET Examples

10.29.8.2 Visual Basic Example
..............................

A Visual Basic .NET example can be found in
'pbnetexamples('vb_examples.NET/calculator')'.  It is a simple
calculator similar to the first C# 'EvaluateGUI' example in *note PB
First Example::.  This example is in the form of a Visual Studio
project.

   To run the example:

  1. Open the project files in Visual Studio .NET
  2. Add a reference in Visual Studio .NET to the installed
     'prologbeans.dll'
  3. Start sicstus with the following command:
          sicstus -l %SP_PATH%/library/prologbeans/examples/evaluate/evaluate --goal "main."
  4. Build and run the example in Visual Studio .NET


File: sicstus.info,  Node: lib-queues,  Next: lib-random,  Prev: lib-prologbeans,  Up: The Prolog Library

10.30 Queue Operations --'library(queues)'
==========================================

This module provides an implementation of queues, where you can
   * create an empty queue
   * add an element at either end of a queue
   * add a list of elements at either end of a queue
   * remove an element from the front of a queue
   * remove a list of elements from the front of a queue
   * determine the length of a queue
   * enumerate the elements of a queue
   * recognise a queue
   * print a queue nicely
   The representation was invented by Mark Johnson of the Center for the
Study of Language and Information.  All operations are fast.

   Exported predicates:

'empty_queue(?QUEUE)'

     is true when QUEUE represents an empty queue.  It can be used to
     test whether an existing queue is empty or to make a new empty
     queue.
'singleton_queue(?X, ?QUEUE)'

     is true when QUEUE is a queue with just one element X.
'portray_queue(+QUEUE)'

     writes a queue out in a pretty form, as QUEUE[ELEMENTS].  This form
     cannot be read back in, it is just supposed to be readable.  While
     it is meant to be called only when 'is_queue(QUEUE)' has been
     established, as by 'user:portray(Q) :- is_queue(Q), !,
     portray_queue(Q)'.  it is also meant to work however it is called.
'is_queue(+QUEUE)'

     is true when QUEUE is a queue.  The elements of QUEUE do not have
     to be instantiated, and the BACK of the QUEUE may or may not be.
     It can only be used to recognise queues, not to generate them.  To
     generate queues, use 'queue_length(QUEUE, _)'.
'queue_head(+QUEUE, -HEAD)'

     is true when HEAD is the first element of the given QUEUE.  It does
     not remove HEAD from QUEUE; HEAD is still there afterwards.  It can
     only be used to find HEAD, it cannot be used to make a QUEUE.
'queue_tail(?QUEUE, ?TAIL)'

     is true when QUEUE and TAIL are both queues and TAIL contains all
     the elements of QUEUE except the first.  Note that QUEUE and TAIL
     share structure, so that you can add elements at the back of only
     one of them.  It can solve for either argument given the other.
'queue_cons(?HEAD, ?TAIL, ?QUEUE)'

     is true when HEAD is the head of QUEUE and TAIL is the tail of
     QUEUE, that is, when TAIL and QUEUE are both queues, and the
     elements of the QUEUE are HEAD followed by the elements of TAIL in
     order.  It can be used in either direction, so
              queue_cons(+Head, +Q0, -Q)      adds Head to Q0 giving Q
              queue_cons(-Head, -Q, +Q0)      removes Head from Q0 giving Q
'queue_last(?LAST, ?QUEUE)'

     is true when LAST is the last element currently in QUEUE.  It does
     not remove LAST from QUEUE; it is still there.  This can be used to
     generate a non-empty QUEUE.  The cost is O(|QUEUE|).
'queue_last(+FORE, +LAST, -QUEUE)'
     is true when FORE and QUEUE are both lists and the elements of
     QUEUE are the elements of FORE in order followed by LAST.  This is
     the operation which adds an element at the end of FORE giving
     QUEUE; it is not reversible, unlike 'queue_cons/3', and it
     side-effects FORE, again unlike 'queue_cons/3'.
'append_queue(?LIST, ?QUEUE0, ?QUEUE)'

     is true when QUEUE is obtained by appending the elements of LIST in
     order at the front of QUEUE0, e.g.  'append_queue([a,b,c],
     Queue[d,e], Queue[a,b,c,d,e])'.  Use
              append_queue([+X1,...,+Xn], +Q0, -Q) to add X1,...,Xn to Q0 giving Q
              append_queue([-X1,...,-Xn], -Q, +Q0) to take X1...Xn from Q0 giving Q
     The cost is O(N) and the operation is pure.
'queue_append(+QUEUE0, +LIST, -QUEUE)'

     is true when QUEUE is obtained by appending the elements of LIST in
     order at the rear end of QUEUE0, e.g.  'append_queue(Queue[a,b,c],
     [d,e], Queue[a,b,c,d,e])'.  This is like 'queue_last/3'; it
     side-effects QUEUE0.
'list_queue(?LIST, ?QUEUE)'

     is true when QUEUE is a queue and LIST is a list and both have the
     same elements in the same order.  'list_queue/2' and 'queue_list/2'
     are the same except for argument order.
'queue_list(?QUEUE, ?LIST)'

     is true when QUEUE is a queue and LIST is a list and both have the
     same elements in the same order.  'queue_list/2' and 'list_queue/2'
     are the same except for argument order.
'queue_length(?QUEUE, ?LENGTH)'

     is true when QUEUE is a queue having LENGTH elements.  It may be
     used to determine the LENGTH of a QUEUE or to make a QUEUE of given
     LENGTH.
'queue_member(?ELEMENT, +QUEUE)'

     is true when ELEMENT is an element of QUEUE.  It could be made to
     generate queues, but that would be rather inefficient.  It bears
     the name 'queue_member/2' because it is prepared to enumerate
     ELEMENTS.
'queue_memberchk(+ELEMENT, +QUEUE)'

     is true when the given ELEMENT is an element of QUEUE.  Once it
     finds a member of QUEUE which unifies with ELEMENT, it commits to
     it.  Use it to check a ground ELEMENT.
'map_queue(:PRED, +QUEUE[X1,...,XN])'

     succeeds when PRED(XI) succeeds for each element XI of the QUEUE.
'map_queue(:PRED, +QUEUE[X1,...,XN], ?QUEUE[Y1,...,YN])'
     succeeds when PRED(XI,YI) succeeds for each corresponding pair of
     elements XI, YI of the two queues.
'map_queue_list(:PRED, ?QUEUE[X1,...,XN], ?[Y1,...,YN])'

     succeeds when PRED(XI, YI) is true for each corresponding pair
     XI,YI of elements of the QUEUE and the LIST.  It may be used to
     generate either of the sequences from the other.
'map_list_queue(:PRED, ?[X1,...,XN], ?QUEUE[Y1,...,YN])'

     succeeds when PRED(XI, YI) is true for each corresponding pair
     XI,YI of elements of the LIST and the QUEUE.  It may be used to
     generate either of the sequences from the other.
'some_queue(:PRED, +QUEUE[X1,...,XN])'

     succeeds when PRED(XI) succeeds for some XI in the QUEUE.  It will
     try all ways of proving PRED(XI) for each XI, and will try each XI
     in the QUEUE.  'somechk_queue/2' is to 'some_queue/2' as
     'memberchk/2' is to 'member/2'; you are more likely to want
     'somechk_queue/2'.  This acts on backtracking like 'member/2';
     QUEUE should be proper.
'some_queue(:PRED, +QUEUE[X1,...,XN], ?QUEUE[Y1,...,YN])'
     is true when PRED(XI, YI) is true for some I.
'somechk_queue(:PRED, +QUEUE[X1,...,XN])'

     is true when PRED(XI) is true for some I, and it commits to the
     first solution it finds (like 'memberchk/2').
'somechk_queue(:PRED, +QUEUE[X1,...,XN], ?QUEUE[Y1,...,YN])'
     is true when PRED(XI, YI) is true for some I, and it commits to the
     first solution it finds (like 'memberchk/2').


File: sicstus.info,  Node: lib-random,  Next: lib-rem,  Prev: lib-queues,  Up: The Prolog Library

10.31 Random Number Generator--'library(random)'
================================================

This library module provides a random number generator using algorithm
AS 183 from the Journal of Applied Statistics as the basic algorithm.

   The state of the random number generator corresponds to a term
'random(X,Y,Z,B)' where X is an integer in the range [1,30268], Y is an
integer in the range [1,30306], Z is an integer in the range [1,30322],
and B is a nonzero integer.

   Exported predicates:

'getrand(-RANDOMSTATE)'

     returns the random number generator's current state
'setrand(+RANDOMSTATE)'

     sets the random number generator's state to RANDOMSTATE.
     RANDOMSTATE can either be a random state previously obtained with
     'getrand/1', or an arbitrary integer.  The latter is useful when
     you want to initialize the random state to a fresh value.  If
     RANDOMSTATE is not an integer or a valid random state, it raises an
     error.
'maybe'

     succeeds determinately with probability 1/2, fails with probability
     1/2.  We use a separate "random bit" generator for this test to
     avoid doing much arithmetic.
'maybe(+PROBABILITY)'
     succeeds determinately with probability Probability, fails with
     probability 1-PROBABILITY.  Arguments =< 0 always fail, >= 1 always
     succeed.
'maybe(+P, +N)'
     succeeds determinately with probability P/N, where 0 =< P =< N and
     P and N are integers.  If this condition is not met, it fails.  It
     is equivalent to 'random(0, N, X), X < P', but is somewhat faster.
'random(-UNIFORM)'

     unifies UNIFORM with a new random number in [0.0,1.0)
'random(+L, +U, -R)'
     unifies R with a random integer in [L,U) when L and U are integers
     (note that U will _never_ be generated), or to a random floating
     number in [L,U) otherwise.
'random_member(-ELEM, +LIST)'

     unifies ELEM with a random element of LIST, which must be proper.
     Takes O(N) time (average and best case).
'random_select(?ELEM, ?LIST, ?REST)'

     unifies ELEM with a random element of LIST and REST with all the
     other elements of LIST (in order).  Either LIST or REST should be
     proper, and LIST should/will have one more element than REST.
     Takes O(N) time (average and best case).
'random_subseq(+LIST, -SBSQ, -CMPL)'

     unifies SBSQ with a random sub-sequence of LIST, and CMPL with its
     complement.  After this, 'subseq(List, Sbsq, Cmpl)' will be true.
     Each of the 2**|LIST| solutions is equally likely.  Like its
     name-sake 'subseq/3', if you supply SBSQ and CMPL it will
     interleave them to find LIST.  Takes O(N) time.  LIST should be
     proper.
'random_permutation(?LIST, ?PERM)'

     unifies PERM with a random permutation of LIST.  Either LIST or
     PERM should be proper, and they should/will have the same length.
     Each of the N! permutations is equally likely, where 'length(List,
     N)'.  This takes O(N LG N) time and is bidirectional.
'random_perm2(A,B, X,Y)'

     unifies X,Y = A,B or X,Y = B,A, making the choice at random, each
     choice being equally likely.  It is equivalent to
     'random_permutation([A,B], [X,Y])'.
'random_numlist(+P, +L, +U, -LIST)'

     where P is a probability (0..1) and L=<U are integers unifies LIST
     with a random subsequence of the integers L..U, each integer being
     included with probability P.


File: sicstus.info,  Node: lib-rem,  Next: lib-samsort,  Prev: lib-random,  Up: The Prolog Library

10.32 Rem's Algorithm--'library(rem)'
=====================================

This library module maintains equivalence classes using Rem's algorithm.
Exported predicates:

'rem_create(+SIZE, -REM)'

     creates an equivalence representation function REM which maps each
     of the nodes 1..SIZE to itself.
'rem_head(?NODE, +REM, -HEAD)'

     is true when HEAD is the representative of the equivalence class
     that NODE belongs to in the given REM.
'rem_equivalent(?NODE1, ?NODE2, +REM)'

     is true when NODE1 and NODE2 belong to the same equivalence class
     in the given REM.
'rem_add_link(?NODE1, ?NODE2, +OLDREM, -NEWREM)'

     is true when adding the equivalence NODE1===NODE2 to the partition
     represented by OLDREM yields a partition which is represented by
     NEWREM.  If NODE1 or NODE2 is uninstantiated, it will backtrack
     over all the nodes.  It's not clear how useful this is.


File: sicstus.info,  Node: lib-samsort,  Next: lib-sets,  Prev: lib-rem,  Up: The Prolog Library

10.33 Generic Sorting--'library(samsort)'
=========================================

This library module provides generic sorting.  Exported predicates:

'samsort(+RAWLIST, -SORTED)'

     takes a proper list RAWLIST and unifies SORTED with a list having
     exactly the same elements as RAWLIST but in ascending order
     according to the standard order on terms.
'merge(+LIST1, +LIST2, -MERGED)'

     is true when MERGED is the stable merge of the two given lists.  If
     the two lists are not ordered, the merge doesn't mean a great deal.
     Merging is perfectly well defined when the inputs contain
     duplicates, and all copies of an element are preserved in the
     output, e.g.  merge("122357", "34568", "12233455678").
'samsort(:ORDER, +RAWLIST, -SORTEDLIST)'
     takes a proper list RAWLIST and a binary predicate ORDER and
     unifies SORTEDLIST with a list having exactly the same elements as
     RAWLIST but in ascending order according to ORDER.  This is only
     supposed to work when Order is transitive.
'merge(:ORDER, +LIST1, +LIST2, -MERGED)'
     is like 'merge/3' except that it takes an ORDER predicate as its
     first arguments, like all the generalised ordering routines.
'samkeysort(+RAWLIST, -SORTED)'

     takes a proper list RAWLIST of KEY-VALUE pairs, and unifies SORTED
     with a list having exactly the same elements as RAWLIST but in
     ascending order according to the standard order on the keys.
     'samkeysort/2' is stable in the sense that the relative position of
     elements with the same key is maintained.
'keymerge(+LIST1, +LIST2, -MERGED)'

     is like 'merge/3' except that it compares only the keys of its
     input lists.  Note that it will not work properly when MERGED is
     already instantiated.


File: sicstus.info,  Node: lib-sets,  Next: lib-sockets,  Prev: lib-samsort,  Up: The Prolog Library

10.34 Unordered Set Operations--'library(sets)'
===============================================

This library module provides operations on sets represented as unordered
lists with no repeated elements.  The ordered representation used in
'library(ordsets)' is much more efficient, but these routines were
designed before sort/2 entered the language.  Exported predicates:

'add_element(+ELEMENT, +SET1, -SET2)'

     is true when SET1 and SET2 are sets represented as unordered lists,
     and SET2 = SET1 U {ELEMENT}.  It may only be used to calculate SET2
     given ELEMENT and SET1.
'del_element(+ELEMENT, +SET1, -SET2)'

     is true when SET1 and SET2 are sets represented as unordered lists,
     and SET2 = SET1 \ {ELEMENT}.  It may only be used to calculate SET2
     given ELEMENT and SET1.  If SET1 does not contain ELEMENT, SET2
     will be identical to SET1 (the old version made a new copy of
     SET1).  If SET1 is not an unordered set, but contains more than one
     copy of ELEMENT, only the first will be removed.  If you want to
     delete all copies of a given element, use 'lists:delete/3'.  For a
     version which fails if ELEMENT is not in SET1, use 'selectchk/3'.
'disjoint(+SET1, +SET2)'

     is true when the two given sets have no elements in common.  It is
     the opposite of 'intersect/2'.  If either of the arguments is
     improper, 'disjoint/2' will fail.
'is_set(+LIST)'

     is true when LIST is a proper list that contains no repeated
     elements.
'pairfrom(?SET, ?ELEMENT1, ?ELEMENT2, ?RESIDUE)'

     is true when SET is a list, ELEMENT1 occurs in list, ELEMENT2
     occurs in list after ELEMENT1, and RESIDUE is everything in SET bar
     the two ELEMENTS.  The point of this thing is to select pairs of
     elements from a set without selecting the same pair twice in
     different orders.
'intersect(+SET1, +SET2)'

     is true when the two sets have a member in common.  It assumes that
     both sets are known, and that you don't care which element it is
     that they share.
'subset(+SET1, +SET2)'

     is true when each member of SET1 occurs in SET2.  It can only be
     used to test two given sets; it cannot be used to generate subsets.
     There is no predicate for generating subsets as such, but the
     predicates 'subseq/3', 'subseq0/2', 'subseq1/2' in 'library(lists)'
     may do what you want (they preserve the order of elements within a
     list).  Could be defined as:

          subset(Set1, Set2) :-
          	(   foreach(X,Set1),
          	    param(Set2)
          	do  memberchk(X,Set2)
          	).
'set_order(+XS, +YS, -R)'

     is true when R is '<', '=', or '>' according as XS is a subset of
     YS, equivalent to YS, or a superset of YS.
'seteq(+SET1, +SET2)'

     is true when each Set is a subset of the other.
'list_to_set(+LIST, -SET)'

     is true when LIST and SET are lists, and SET has the same elements
     as LIST in the same order, except that it contains no duplicates.
     The two are thus equal considered as sets.
'power_set(+SET, -POWERSET)'

     is true when SET is a list and POWERSET is a list of lists which
     represents the power set of the set that Set represents.
'intersection(+SET1, +SET2, -INTERSECTION)'

     is true when all three arguments are lists representing sets, and
     INTERSECTION contains every element of SET1 which is also an
     element of SET2, the order of elements in INTERSECTION being the
     same as in SET1.  That is, INTERSECTION represents the intersection
     of the sets represented by SET1 and SET2.  Could be defined as:

          intersection(Set1, Set2, Intersection) :-
          	(   foreach(X,Set1),
          	    fromto(Intersection,S0,S,[]),
          	    param(Set2)
          	do  (member(X, Set2) -> S0 = [X|S] ; S0 = S)
          	).
'intersection(+LISTOFSETS, -INTERSECTION)'
     is true when INTERSECTION is the intersection of all the sets in
     LISTOFSETS.  The order of elements in INTERSECTION is taken from
     the first set in LISTOFSETS.  This has been turned inside out to
     minimise the storage turnover.  Could be defined as:

          intersection([Set1|Sets], Intersection) :-
          	(   foreach(X,Set1),
          	    fromto(Intersection,S0,S,[]),
          	    param(Sets)
          	do  (   (   foreach(Set,Sets),
          		    param(X)
          		do  memberchk(X, Set)
          		) -> S0 = [X|S]
          	    ;   S0 = S
          	    )
          	).
'subtract(+SET1, +SET2, -DIFFERENCE)'

     is like 'intersect/3', but this time it is the elements of SET1
     which _are_ in SET2 that are deleted.  Note that duplicated
     ELEMENTS of SET1 which are not in SET2 are retained in DIFFERENCE.
     Could be defined as:

          subtract(Set1, Set2, Difference) :-
          	(   foreach(X,Set1),
          	    fromto(Difference,S0,S,[]),
          	    param(Set2)
          	do  (member(X, Set2) -> S0 = S ; S0 = [X|S])
          	).
'symdiff(+SET1, +SET2, -DIFFERENCE)'

     is true when DIFFERENCE is the symmetric difference of SET1 and
     SET2, that is, if each element of DIFFERENCE occurs in one of SET1
     and SET2 but not both.  The construction method is such that the
     answer will have no duplicates even if the SETS do.
'setproduct(+SET1, +SET2, -CARTESIANPRODUCT)'

     is true when SET1 is a set (list) and SET2 is a set (list) and
     CARTESIANPRODUCT is a set of ELT1-ELT2 pairs, with a pair for for
     each element ELT1 of SET1 and ELT2 of SET2.  Could be defined as:

          setproduct(Set1, Set2, Product) :-
          	(   foreach(H1,Set1),
          	    param(Set2),
          	    fromto(Product,P1,P3,[])
          	do  (   foreach(H2,Set2),
          		param(H1),
          		fromto(P1,[H1-H2|P2],P2,P3)
          	    do  true
          	    )
          	).
'disjoint_union(+SET1, +SET2, -UNION)'

     is true when 'disjoint(Set1, Set2)' and 'union(Set1, Set2, Union)',
     that is, SET1 and SET2 have no element in command and UNION is
     their union.  Could be defined as:

          disjoint_union(Set1, Set2, Union) :-
          	(   foreach(X,Set1),
          	    fromto(Union,[X|S],S,Set2),
          	    param(Set2)
          	do  nonmember(X, Set2)
          	).
'union(+SET1, +SET2, -UNION)'

     is true when 'subtract(Set1,Set2,Diff)' and
     'append(Diff,Set2,Union)', that is, when UNION is the elements of
     SET1 that do not occur in SET2, followed by all the elements of
     SET2.  Could be defined as:

          union(Set1, Set2, Union) :-
          	(   foreach(X,Set1),
          	    fromto(Union,S0,S,Set2),
          	    param(Set2)
          	do  (member(X, Set2) -> S0 = S ; S0 = [X|S])
          	).
'union(+SET1, +SET2, -UNION, -DIFFERENCE)'
     is true when 'union(Set1, Set2, Union)' and 'subtract(Set1, Set2,
     Difference)'.  Could be defined as:

          union(Set1, Set2, Union, Difference) :-
          	(   foreach(X,Set1),
          	    fromto(Union,S0,S,Set2),
          	    fromto(Difference,T0,T,[]),
          	    param(Set2)
          	do  (   member(X, Set2) -> S0 = S, T0 = T
          	    ;   S0 = [X|S], T0 = [X|T]
          	    )
          	).
'union(+LISTOFSETS, -UNION)'
     is true when UNION is the union of all the sets in LISTOFSETS.  It
     has been arranged with storage turnover in mind.  Could be defined
     as:

          union(Sets, Union) :-
          	(   foreach(Set,Sets),
          	    param(Answer)
          	do  (   foreach(X,Set),
          		param(Answer)
          	    do  memberchk(X, Answer)
          	    )
          	),
          	append(Answer, [], Answer),	% cauterise it
          	!,
          	Union = Answer.


File: sicstus.info,  Node: lib-sockets,  Next: lib-statistics,  Prev: lib-sets,  Up: The Prolog Library

10.35 Socket I/O--'library(sockets)'
====================================

This library package defines a number of predicates for communicating
over sockets.

   To create a (bi-directional) stream connected to a remote server, use
'socket_client_open/3'.

   To open a port for remote clients to connect to, use
'socket_server_open/[2,3]' and to open a stream to a connecting client,
use 'socket_server_accept/4'.

   To be able to multiplex input and output from several streams (not
necesessarily socket streams) and incoming connections, use
'socket_select/7'.

   When opening a client or server socket a "socket address" needs to be
specified.  The address specifies the address family and family-specific
information.  The following formats are supported for socket addresses:
'inet(NODENAME,SERVNAME)'
'NODENAME:SERVNAME'
'SERVNAME'
     This specifies the address for and ordinary internet socket
     ('AF_INET' or 'AF_INET6').  NODENAME is the internet address of the
     remote host, as an atom, something like ''www.sics.se'' or
     ''193.10.64.51''.  The empty nodename '''' (the default), has
     special meaning, see the documentation for 'socket_client_open/3'
     and 'socket_server_open/[2,3]'.  SERVNAME is either a port number
     as an atom of decimal digits or as an integer, e.g. ''80'', or
     '80'; alternatively some "well known port names" can be used, e.g.
     ''http''.  The set of well known port names is OS specific,
     portable code should use integer port numbers.  SERVNAME can also
     be a variable when opening a server socket with
     'socket_server_open/[2,3]'.  In this case a available port is
     assigned automatically and Servname is bound to it.

'unix(PATH)   since release 4.0.3'
     A Unix domain ('AF_UNIX') socket is opened at the specified file
     system location.  This is only supported on Unix-like platforms.
     PATH is a file-name and is passed to 'absolute_file_name/2'.  There
     may be platform-specific restrictions on the length of the
     resulting pathname and the file system containing it.

   All streams below can be read from as well as written to.  All I/O
predicates operating on streams can be used, for example 'get_code/2',
'get_byte/2', 'read/2', 'write/2', 'format/3', 'current_stream/3', etc.
The predicates that create streams take options similar to 'open/4',
e.g. to specify whether the stream is binary (the default) or text.

'socket_client_open(+ADDR, -STREAM, +OPTIONS)'

     Creates a stream STREAM connected to address ADDR.  See above for
     the allowed address formats.  If the nodename is empty ('''') then
     a connection is made to the local machine.

     The stream is created using options from OPTIONS.  Supported
     options include:
     'type(binary)'
          Create a binary stream (the default).
     'type(text)'
          Create a text stream.  The default encoding is Latin 1.
     'eof_action(ACTION)'
          end of file action, as for 'open/4'.
     'encoding(ENCODING)   since release 4.1'
          As for open/4.  Implies 'type(text)'.
     'eol(EOL)   since release 4.1'
          As for open/4.  Implies 'type(text)'.

     To create a binary stream to some web server 'www.sics.se', you
     would do e.g.
          | ?- socket_client_open('www.sics.se':80, Stream, [type(binary)]).

     or, to make a text (Latin 1) stream to a 'daytime' service in Hong
     Kong you could do:

          | ?- socket_client_open('stdtime.gov.hk':daytime, S, [type(text)]),
               read_line(S, L),
               format('~s', [L]).

     See the source code for 'library('linda/client')' for a simple
     client.

'socket_server_open(?ADDR, -SERVERSOCKET, +OPTIONS)   since release 4.0.3'

     Create a server socket SERVERSOCKET that listens on address ADDR.
     See above for the allowed address formats.  If the nodename is
     empty ('''') then any remote client machine is allowed to connect
     unless the option 'loopback(true)' is also specified.  ADDR can
     specify an internet address where the port is a variable in which
     case a free port number is used and PORT is bound to it.  The
     common case is that Addr is a numeric port number or a variable
     that becomes bound to a free port number.

     The created server socket should be closed with
     'socket_server_close/1' eventually.  Incoming connection can be
     accepted with 'socket_server_accept/4' and waited for with
     'socket_select/7'.  See the source code for
     'library('linda/server')' for a simple server that uses this
     predicate.

     OPTIONS is a list of options, currently
     'reuseaddr(Bool)   since release 4.0.3'
          BOOL is either 'true' or 'false' (the default).  If 'true'
          then allow reuse of local addresses.  For internet sockets
          this corresponds to the 'SO_REUSEADDR' socket option.  For
          unix domain sockets this means that the file will be deleted,
          if present, before opening.
     'numeric_nodename(Bool)   since release 4.0.3'
          BOOL is either 'true' or 'false' (the default).  If 'true'
          then the nodename of an internet address will be treated as a
          numerical address and no name lookup will be performed.
     'numeric_servname(Bool)   since release 4.0.3'
          BOOL is either 'true' or 'false' (the default).  If 'true'
          then the servname of an internet address will be treated as a
          numerical port number and no lookup of well known port names
          will be performed.
     'loopback(Bool)   since release 4.0.3'
          BOOL is either 'true' or 'false' (the default).  If 'true'
          then the nodename will be ignored and the socket will only
          listen to connection from the loopback device, i.e. the local
          machine.
'socket_server_open(?PORT, -SERVERSOCKET)'
     The same as 'socket_server_open(PORT, SERVERSOCKET, [])'.
'socket_server_accept(+SERVERSOCKET, -CLIENT, -STREAM, +STREAMOPTIONS)'

     The first connection to socket SERVERSOCKET is extracted, blocking
     if necessary.  The stream STREAM is created on this connection
     using STREAMOPTIONS as for 'socket_client_open/3'.  CLIENT will be
     unified with an atom containing the numerical Internet host address
     of the connecting client.  Note that the stream will be
     'type(binary)' unless 'type(text)' is specified either explicitly
     or implicitly with 'encoding/1' or other text-only options.
'socket_server_close(+SERVERSOCKET)'

     Close the server socket SERVERSOCKET and stop listening on its
     port.
'socket_select(+SERVERSOCKETS,-SREADY, +READSTREAMS,-RREADY, +WRITESTREAMS,-WREADY, +TIMEOUT)'

     Check for server sockets with incoming connections (i.e. ready for
     'socket_server_accept/4'), streams on READSTREAMS ready for input,
     and streams on WRITESTREAMS ready for output.  The streams can be
     any kind of streams, they need not be socket streams.  The ready
     server sockets are returned (in the same order) in SREADY, the
     ready input streams in RREADY, and the ready output streams in
     WREADY.

     An input (output) stream is ready for input (output) when an "item"
     can be read (written) without blocking.  An item is a character for
     text streams and a byte for binary streams.  Note that a stream is
     considered ready for I/O if the corresponding I/O operation will
     raise an error (such as if the stream is past end of stream).

     Each entry in the input lists SERVERSOCKETS, READSTREAMS, and
     WRITESTREAMS can be either a server socket or stream respectively
     or a term 'TERM-ENTRY' where ENTRY is the server socket or stream
     and TERM is some arbitrary term used for book-keeping.  If an entry
     is associated with a term in this way then so will the
     corresponding ready entry.

     If TIMEOUT is instantiated to 'off', the predicate waits until
     something is available.  If TIMEOUT is a nonzero number (integer or
     floating point), then the predicate waits at most that number of
     seconds before returning.  For backward compatibility, if TIMEOUT
     is S:U the predicate waits at most S seconds and U microseconds.
     If there is a timeout, all ready lists are unified with '[]'.

     See the source code for 'library('linda/server')' for a simple
     server that uses this predicate.
'current_host(?HOSTNAME)'

     HOSTNAME is unified with the fully qualified name of the machine
     that the process is executing on.  The call will also succeed if
     HOSTNAME is instantiated to the unqualified name of the machine in
     lower case.  *Please note:* this predicate will fail if there are
     errors, e.g. if no domain has been configured.


File: sicstus.info,  Node: lib-statistics,  Next: lib-structs,  Prev: lib-sockets,  Up: The Prolog Library

10.36 Statistics Functions--'library(statistics)'
=================================================

This library module provides commonly used sample and population
statistics functions.  In this module, a SAMPLE is simply a proper list
of numbers, normally floating-point; WEIGHT is a proper list of numbers
and should be of the same length as SAMPLE.

   *Please note:* These functions are plain textbook algorithms and we
make no claims about numerical stability, avoiding loss of precision,
etc.

   Exported predicates:
'min(+SAMPLE, -VALUE)'

     is true when VALUE is the smallest element of SAMPLE.
'max(+SAMPLE, -VALUE)'

     is true when VALUE is the largest element of SAMPLE.
'min_max(+SAMPLE, -MIN, -MAX)'

     is true when MIN (MAX) is the smallest (largest) element of SAMPLE.
'range(+SAMPLE, -VALUE)'

     is true when VALUE is the difference between the largest and
     smallest elements of SAMPLE.
'mode(+SAMPLE, -VALUES)'

     is true when VALUES is the most frequently occurring value(s) in
     SAMPLE.  If there is a unique value with maximum frequency, this
     value is returned as the only element of VALUES.  Otherwise, VALUES
     contains the maximum frequency elements in increasing order.  This
     predicate does not make much sense if the sample is continuous.
'mean(+SAMPLE, -VALUE)'
'arithmetic_mean(+SAMPLE, -VALUE)'

     is true when VALUE is the arithmetic mean of SAMPLE.
'weighted_mean(+WEIGHT, +SAMPLE, -VALUE)'

     is true when VALUE is the arithmetic mean of SAMPLE weighted by
     WEIGHT.
'geometric_mean(+SAMPLE, -VALUE)'

     is true when VALUE is the geometric mean of SAMPLE.
'harmonic_mean(+SAMPLE, -VALUE)'

     is true when VALUE is the harmonic mean of SAMPLE.
'central_moment(K, +SAMPLE, -VALUE)'

     is true when VALUE is the K-th central moment of SAMPLE.  Also
     known as the K-th central moment about the mean.  K should be
     positive integer.
'skewness(+SAMPLE, -VALUE)'

     is true when VALUE is the skewness of SAMPLE.  This is a measure of
     the asymmetry of its distribution.  A sample with negative skew is
     said to be _left-skewed_.  Most of its mass is on the right of the
     distribution, with the tail on the left.  Vice versa for positive
     skew.  A sample's skewness is undefined if its variance is zero.
'kurtosis(+SAMPLE, -VALUE)'

     is true when VALUE is the excess kurtosis of SAMPLE.  This is a
     measure of the peakedness of its distribution.  A high kurtosis
     indicates that most of the sample's variance is due to infrequent
     severe deviations, rather than frequent modest deviations.  A
     sample's excess kurtosis is undefined if its variance is zero.  In
     this implementation, the kurtosis of the normal distribution is 0.
'ml_variance(+SAMPLE, -VALUE)'
'population_variance(+SAMPLE, -VALUE)'

     is true when VALUE is the maximum likelihood estimate of the
     variance of SAMPLE.  Also known as the population variance, where
     the denominator is the length of SAMPLE.
'sample_variance(+SAMPLE, -VALUE)'
'unbiased_variance(+SAMPLE, -VALUE)'

     is true when VALUE is the unbiased estimate of the variance of
     SAMPLE.  Also known as the sample variance, where the denominator
     is the length of SAMPLE minus one.
'weighted_variance(+WEIGHT, +SAMPLE, -VALUE)'

     is true when VALUE is the weighted (biased) estimate of the
     variance of SAMPLE.
'ml_standard_deviation(+SAMPLE, -VALUE)'
'population_standard_deviation(+SAMPLE, -VALUE)'

     is true when VALUE is the maximum likelihood estimate of the
     standard deviation of SAMPLE.  Also known as the population
     standard deviation, where the denominator is the length of SAMPLE.
     Equals the square root of the population variance.
'sample_standard_deviation(+SAMPLE, -VALUE)'
'unbiased_standard_deviation(+SAMPLE, -VALUE)'

     is true when VALUE is the unbiased estimate of the standard
     deviation of SAMPLE.  Also known as the sample standard deviation,
     where the denominator is the length of SAMPLE minus one.  Equals
     the square root of the sample variance.
'weighted_standard_deviation(+WEIGHT, +SAMPLE, -VALUE)'

     is true when VALUE is the weighted (biased) estimate of the
     standard deviation of SAMPLE.  Equals the square root of the
     weighted (biased) variance.
'covariance(+SAMPLE1, +SAMPLE2, -VALUE)'

     is true when VALUE is the covariance of SAMPLE1 and SAMPLE2.
'correlation(+SAMPLE1, +SAMPLE2, -VALUE)'

     is true when VALUE is the correlation of SAMPLE1 and SAMPLE2.
'median(+SAMPLE, -VALUE)'

     is true when VALUE is the median of SAMPLE, that is, the value
     separating the higher half of the sample from the lower half.  If
     there are an even number of observations, then the median is
     defined to be the smaller middle value.  Same as the 0.5-fractile
     of SAMPLE.
'fractile(P, +SAMPLE, -VALUE)'

     is true when VALUE is the P-fractile of SAMPLE, that is, the
     smallest value in the sample such that the fraction P of the sample
     is less than or equal to that value.  P should be a number in
     (0.0,1.0].
'normalize(+SAMPLE, -NORMALIZED)'

     is true when NORMALIZED is the normalized SAMPLE, so that
     NORMALIZED has a mean of 0 and a population standard deviation of
     1.


File: sicstus.info,  Node: lib-structs,  Next: lib-system,  Prev: lib-statistics,  Up: The Prolog Library

10.37 The Structs Package--'library(structs)'
=============================================

* Menu:

* str-fty::                             Foreign Types
* str-cft::                             Checking Foreign Term Types
* str-cdf::                             Creating and Destroying Foreign Terms
* str-afd::                             Accessing and Modifying Foreign Term Contents
* str-cas::                             Casting
* str-nul::                             Null Foreign Terms
* str-ifc::                             Interfacing with Foreign Code
* str-etr::                             Examining Type Definitions at Runtime
* str-tip::                             Tips
* str-exa::                             Example

The 'structs' package allows Prolog to hold pointers to C data
structures, and to access and store into fields in those data
structures.  Currently, the only representation for a pointer supported
by SICStus Prolog is an integer, so it is not possible to guarantee that
Prolog cannot confuse a pointer with an ordinary Prolog term.  What this
package does is to represent such a pointer as a term with the type of
the structure or array as its functor and the integer that is the
address of the actual data as its only argument.  We will refer such
terms as "foreign terms".

   The package consists of two modules, 'str_decl' and 'structs'.  The
'str_decl' module is used at compile time to translate the
structs-related constructs.  Any file that defines or accesses structs
should include the command:

     :- load_files(library(str_decl),
                   [when(compile_time), if(changed)]).

   The 'structs' module provides runtime support for structs.  A file
that accesses structs should include the command:

     :- use_module(library(structs)).

   You will probably include both in most files that define and access
structs.

   *Please note:* A file that loads 'library(str_decl)' currently cannot
recursively load another file that loads 'library(str_decl)', because
that would confuse the internal database being used by the package.

     *Important caveats:*

     You should not count on future versions of the structs package to
     continue to represent foreign terms as compound Prolog terms.  In
     particular, you should never explicitly take apart a foreign term
     using unification or 'functor/3' and 'arg/3'.  You may use the
     predicate 'foreign_type/2' to find the type of a foreign term, and
     'cast/3' (casting a foreign term to address) to get the address
     part of a foreign term.  You may also use 'cast/3' to cast an
     address back to a foreign term.  You should use
     'null_foreign_term/2' to check if a foreign term is null, or to
     create a null foreign term of some type.

     It should never be necessary to explicitly take apart foreign
     terms.


File: sicstus.info,  Node: str-fty,  Next: str-cft,  Up: lib-structs

10.37.1 Foreign Types
---------------------

* Menu:

* str-fty-dty::                         Declaring Types

There are two sorts of objects that Prolog may want to handle: "atomic"
and "compound".  "Atomic" objects include numbers and atoms, and
"compound" objects include data structures and arrays.  To be more
precise about it, an atomic type is defined by one of the following:

'integer'
     signed integer, large enough to hold a pointer.

'integer_64   since release 4.3'
     64 bit signed integer.

'integer_32'
     32 bit signed integer.

'integer_16'
     16 bit signed integer.

'integer_8'
     8 bit signed integer.

'unsigned'
     unsigned integer, large enough to hold a pointer.

'unsigned_64   since release 4.3'
     64 bit unsigned integer.

'unsigned_32'
     32 bit unsigned integer.

'unsigned_16'
     16 bit unsigned integer.

'unsigned_8'
     8 bit unsigned integer.

'float'
     64 bit floating-point number.

'float_32'
     32 bit floating-point number.

'atom'
     32 bit Prolog atom number.  Unique for different atoms, but not
     consistent across Prolog sessions.  The atom is made non garbage
     collectable.  *Note Atoms in C::.

'string'
     A pointer to an encoded string.  Represented as an atom in Prolog.
     *Please note*: This string must not be overwritten, as it
     constitutes the print name of an atom.  Also, the atom and string
     are made non garbage collectable.  *Note Atoms in C::.

'address'
     An untyped pointer.  Like 'pointer(_)', but 'library(structs)' does
     no type checking for you.  Represented as a Prolog integer.

'opaque'
     Unknown type.  Cannot be represented in Prolog.  A pointer to an
     opaque object may be manipulated.

   Compound types are defined by one of the following:

'pointer(TYPE)'
     a pointer to a thing of type TYPE.

'array(NUM,TYPE)'
     A chunk of memory holding NUM (an integer) things of type TYPE.

'array(TYPE)'
     A chunk of memory holding some number of things of type TYPE.  This
     type does not allow bounds checking, so it should be used with
     great care.  It is also not possible to use this sort of array as
     an element in an array, or in a struct or union.

'struct(FIELDS)'
     A compound structure.  FIELDS is a list of FIELD_name:TYPE pairs.
     Each FIELD_name is an atom, and each TYPE is any valid type.

'union(MEMBERS)'
     A union as in C. MEMBERS is a list of MEMBER_name:TYPE pairs.  Each
     MEMBER_name is an atom, and each TYPE is any valid type.  The space
     allocated for one of these is the maximum of the spaces needed for
     each member.  It is not permitted to store into a union (you must
     get a member of the union to store into, as in C).

   C programmers will recognize that the kinds of data supported by this
package were designed for the C language.  They should also work for
other languages, but programmers must determine the proper type
declarations in those languages.  The table above makes clear the
storage requirements and interpretation of each type.

   Note that there is one important difference between the 'structs'
package and C: the 'structs' package permits declarations of pointers to
arrays.  A pointer to an array is distinguished from a pointer to a
single element.  For example
     pointer(array(integer_8))

is probably a more appropriate declaration of a C string type than
     pointer(integer_8)

which is the orthodox way to declare a string in C.


File: sicstus.info,  Node: str-fty-dty,  Up: str-fty

10.37.1.1 Declaring Types
.........................

Programmers may declare new named data structures with the following
procedure:
     :- foreign_type
         Type_name = Type,
         ...,
         Type_name = Type.

where TYPE_NAME is an atom, and TYPE defines either an atomic or
compound type, or is a previously-defined type name.

   In Prolog, atomic types are represented by the natural atomic term
(integer, float, or atom).  Compound structures are represented by terms
whose functor is the name of the type, and whose only argument is the
address of the data.  So a term 'foo(123456)' represents the thing of
type 'foo' that exists at machine address 123456.  And a term
'integer(123456)' represents the integer that lives in memeory at
address 123456, _not_ the number 123456.

   For types that are not named, a type name is generated using the
names of associated types and the dollar sign character ('$'), and
possibly a number.  Therefore, users should not use '$' in their type
names.


File: sicstus.info,  Node: str-cft,  Next: str-cdf,  Prev: str-fty,  Up: lib-structs

10.37.2 Checking Foreign Term Types
-----------------------------------

The type of a foreign term may determined by the goal
     foreign_type(+FOREIGN_TERM, -TYPE_NAME)

   Note that 'foreign_type/2' will fail if FOREIGN_TERM is not a foreign
term.


File: sicstus.info,  Node: str-cdf,  Next: str-afd,  Prev: str-cft,  Up: lib-structs

10.37.3 Creating and Destroying Foreign Terms
---------------------------------------------

Prolog can create or destroy foreign terms using
     new(+TYPE, -DATUM),
     new(+TYPE, +SIZE, -DATUM) and
     dispose(+DATUM)

where TYPE is an atom specifying what type of foreign term is to be
allocated, and DATUM is the foreign term.  TYPE should be an atomic type
or a previously-defined type name.  The DATUM returned by 'new/[2,3]' is
initialized to all zeroes.  'dispose/1' is a dangerous operation, since
once the memory is disposed, it may be used for something else later.
If DATUM is later accessed, then the results will be unpredictable.
'new/3' is only used to allocate arrays whose size is not known
beforehand, as defined by 'array(TYPE)', rather than 'array(NUM,TYPE)'.


File: sicstus.info,  Node: str-afd,  Next: str-cas,  Prev: str-cdf,  Up: lib-structs

10.37.4 Accessing and Modifying Foreign Term Contents
-----------------------------------------------------

Prolog can get or modify the contents of a foreign term with the
procedures
     get_contents(+DATUM, ?PART, ?VALUE)
     put_contents(+DATUM, +PART, +VALUE).

   It can also get a pointer to a field or element of a foreign term
with the procedure
     get_address(+DATUM, ?PART, ?VALUE).

   For all three of these, DATUM must be a foreign term, and PART
specifies what part of DATUM VALUE is.  If DATUM is an array, then PART
should be an integer index into the array, where 0 is the first element.
For a pointer, PART should be the atom 'contents' and VALUE will be what
the pointer points to.  For a struct, PART should be a field name, and
VALUE will be the contents of that field.  In the case of
'get_contents/3' and 'get_address/3', if PART is unbound, then
'get_contents/3' will backtrack through all the valid parts of DATUM,
binding both PART and VALUE.  A C programmer might think of the
following pairs as corresponding to each other:
     Prolog: get_contents(Foo, Bar, Baz)
          C: Baz = Foo->Bar

     Prolog: put_contents(Foo, Bar, Baz)
          C: Foo->Bar = Baz

     Prolog: get_address(Foo, Bar, Baz)
          C: Baz = &Foo->Bar.

   The hitch is that only atomic and pointer types can be got and put by
'get_contents/3' and 'put_contents/3'.  This is because Prolog can only
hold pointers to C structures, not the structures themselves.  This is
not quite as bad as it might seem, though, since usually structures
contain pointers to other structures, anyway.  When a structure directly
contains another structure, Prolog can get a pointer to it with
'get_address/3'.


File: sicstus.info,  Node: str-cas,  Next: str-nul,  Prev: str-afd,  Up: lib-structs

10.37.5 Casting
---------------

Prolog can "cast" one type of foreign term to another.  This means that
the foreign term is treated just as if it where the other type.  This is
done with the following procedure:
     cast(+FOREIGN0, +NEW_TYPE, -FOREIGN)

where FOREIGN is the foreign term that is the same data as FOREIGN0,
only is of foreign type NEW_TYPE.  FOREIGN0 is not affected.  This is
much like casting in C.

   Casting a foreign term to 'address' will get you the raw address of a
foreign term.  This is not often necessary, but it is occasionally
useful in order to obtain an indexable value to use in the first
argument of a dynamic predicate you are maintaining.  An 'address' may
also be casted to a proper foreign type.

   This predicate should be used with great care, as it is quite easy to
get into trouble with this.


File: sicstus.info,  Node: str-nul,  Next: str-ifc,  Prev: str-cas,  Up: lib-structs

10.37.6 Null Foreign Terms
--------------------------

"NULL" foreign terms may be handled.  The predicate
     null_foreign_term(+TERM, -TYPE)
     null_foreign_term(-TERM, +TYPE)

holds when TERM is a foreign term of TYPE, but is NULL (the address is
0).  At least one of TERM and TYPE must be bound.  This can be used to
generate NULL foreign terms, or to check a foreign term to determine
whether or not it is NULL.


File: sicstus.info,  Node: str-ifc,  Next: str-etr,  Prev: str-nul,  Up: lib-structs

10.37.7 Interfacing with Foreign Code
-------------------------------------

Foreign terms may be passed between Prolog and other languages through
the foreign interface.

   To use this, all foreign types to be passed between Prolog and
another language must be declared with 'foreign_type/2' before the
'foreign/[2,3]' clauses specifying the foreign functions.

   The 'structs' package extends the foreign type specifications
recognized by the foreign interface.  In addition to the types already
recognized by the foreign interface, any atomic type recognized by the
'structs' package is understood, as well as a pointer to any named
'structs' type.

   For example, if you have a function

     char nth_char(string, n)
         char *string;
         int n;
         {
             return string[n];
         }

   then you might use it from Prolog as follows:
     :- foreign_type cstring = array(integer_8).

     foreign(nth_char, c, nth_char(+pointer(cstring), +integer, [-integer_8])).

   This allows the predicate 'nth_char/3' to be called from Prolog to
determine the nth character of a C string.

   Note that all existing foreign interface type specifications are
unaffected, in particular 'address/[0,1]' continue to pass addresses to
and from Prolog as plain integers.

   If you use the foreign resource linker, 'splfr', on a Prolog file
that uses the 'structs' package, then you must pass it the '--structs'
option.  This will make 'splfr' understand foreign type specifications
and translate them into C declarations in the generated header file
(*note The Foreign Resource Linker::).


File: sicstus.info,  Node: str-etr,  Next: str-tip,  Prev: str-ifc,  Up: lib-structs

10.37.8 Examining Type Definitions at Runtime
---------------------------------------------

The above described procedures should be sufficient for most needs.
This module does, however, provide a few procedures to allow programmers
to access type definitions.  These may be a convenience for debugging,
or in writing tools to manipulate type definitions.

   The following procedures allow programmers to find the definition of
a given type:
     type_definition(?TYPE, ?DEFINITION)
     type_definition(?TYPE, ?DEFINITION, ?SIZE)

where TYPE is an atom naming a type, DEFINITION is the definition of
that type, and SIZE is the number of bytes occupied by a foreign term of
this type.  SIZE will be the atom 'unknown' if the size of an object of
that type is not known.  Such types may not be used as fields in structs
or unions, or in arrays.  However, pointers to them may be created.  If
TYPE is not bound at call time, then these procedures will backtrack
through all current type definitions.

   A definition looks much like the definition given when the type was
defined with 'type/1', except that it has been simplified.  Firstly,
intermediate type names have been elided.  For example, if 'foo' is
defined as 'foo=integer', and 'bar' as 'bar=foo', then
'type_definition(bar, integer)' would hold.  Also, in the definition of
a compound type, types of parts are always defined by type names, rather
than complex specifications.  So if the type of a field in a struct was
defined as 'pointer(fred)', then it will show up in the definition as
''$fred''.  Of course, 'type_definition('$fred', pointer(fred))' would
hold, also.

   The following predicates allow the programmer to determine whether or
not a given type is atomic:
     atomic_type(?TYPE)

     atomic_type(?TYPE, ?PRIMITIVE_TYPE)

     atomic_type(?TYPE, ?PRIMITIVE_TYPE, ?SIZE)

where TYPE is an atomic type.  See *note str-fty:: for the definition of
an atomic type.  PRIMITIVE_TYPE is the primitive type that TYPE is
defined in terms of.  SIZE is the number of bytes occupied by an object
of type TYPE, or the atom 'unknown', as above.  If TYPE is unbound at
call time, then these predicates will backtrack through all the
currently defined atomic types.


File: sicstus.info,  Node: str-tip,  Next: str-exa,  Prev: str-etr,  Up: lib-structs

10.37.9 Tips
------------

  1. Most important tip: do not subvert the 'structs' type system by
     looking inside foreign terms to get the address, or use 'functor/3'
     to get the type.  This has two negative effects: firstly, if the
     'structs' package should change its representation of foreign
     terms, then your code will not work.  But more importantly, you are
     more likely to get type mismatches, and likely to get unwrapped
     terms or even doubly wrapped terms where you expect wrapped ones.
  2. Remember that a foreign term 'fred(123456)' is not of type 'fred',
     but a pointer to 'fred'.  Looked at another way, what resides in
     memory at address 123456 is of type 'fred'.
  3. The wrapper put on a foreign term signifies the type of that
     foreign term.  If you declare a type to be 'pointer(opaque)'
     because you want to view that pointer to be opaque, when you get
     something of this type, then it will be printed as
     'opaque(456123)'.  This is not very informative.  It is better to
     declare
          fred = opaque,
          thing = struct([...,
                      part:pointer(fred),
                      ...
                  ]).

     so that when you get the contents of the 'part' member of a
     'thing', it is wrapped as 'fred(456123)'.


File: sicstus.info,  Node: str-exa,  Prev: str-tip,  Up: lib-structs

10.37.10 Example
----------------

The following example shows how to use 'library(structs)' in a simple
package for handling integer arrays.  We define a module 'minivec' with
exported predicates for creating and disposing arrays, accessing its
elements, and computing their sum.  The summing operation is implemented
in C and the rest in Prolog.  Arrays are created using the 'array(TYPE)'
foreign type.

   Note that the type declaration 'int32' does not have to be given in
the C source code, as it appears in the automatically generated header
file 'minivec_glue.h'.  Note also how the foreign type specification
'+pointer(int_array)' corresponds to the C type declaration 'int32 *'.

                                                         _% minivec.pl_
     :- module(minivec, [
             new_array/2,
             get_array/3,
             put_array/3,
             dispose_array/1,
             sum_array/2
             ]).

     :- load_files(library(str_decl), [when(compile_time)]).
     :- use_module(library(structs)).

     :- foreign_type
             int32           = integer_32,
             int_array       = array(int32).

     foreign(c_sum_array, c_sum_array(+integer,
                                      +pointer(int_array),
                                      [-integer])).

     foreign_resource(minivec, [c_sum_array]).

     :- load_foreign_resource(minivec).

     new_array(Size, array(Size,Mem)) :-
             new(int_array, Size, Mem).

     get_array(Index, array(_,Mem), Value) :-
             get_contents(Mem, Index, Value).

     put_array(Index, array(_,Mem), Value) :-
             put_contents(Mem, Index, Value).

     dispose_array(array(_,Mem)) :-
             dispose(Mem).

     sum_array(array(Size,Mem), Sum) :-
             c_sum_array(Size, Mem, Sum).

                                                      _/* minivec.c */_
     #include "minivec_glue.h"

     SP_integer c_sum_array(SP_integer cnt, int32 *mem)
     {
       int i;
       SP_integer sum = 0;

       for (i=0; i<cnt; i++)
         sum += mem[i];
       return sum;
     }

                                                            _# session_
     % splfr --struct minivec.pl minivec.c
     % sicstus -l minivec
     % compiling /home/matsc/sicstus4/Suite/minivec.pl...
     % [...]
     % compiled /home/matsc/sicstus4/Suite/minivec.pl in module minivec, 30 msec 68388 bytes
     SICStus 4.4.1 ...
     Licensed to SICS
     | ?- new_array(4, A),
          put_array(0,A,1),
          put_array(1,A,10),
          put_array(2,A,100),
          put_array(3,A,1000),
          sum_array(A,S),
          dispose_array(A).
     A = array(4,int_array(1264224)),
     S = 1111

   A fragment from the generated header file:

                                                 _/* minivec_glue.h */_
     #include <sicstus/sicstus.h>
     #include <stdlib.h>
     typedef int int32;
     typedef int32 *(int_array)/* really an unknown-size array */;
     extern SP_integer c_sum_array( SP_integer, int32 *);


File: sicstus.info,  Node: lib-system,  Next: lib-tcltk,  Prev: lib-structs,  Up: The Prolog Library

10.38 Operating System Utilities--'library(system)'
===================================================

This package contains utilities for invoking services from the operating
system that does not fit elsewhere.

   Exported predicates:

'now(-WHEN)'

     Unifies the current date and time as a UNIX timestamp with WHEN.
'datime(-DATIME)'

     Unifies DATIME with the current date and time as a 'datime/6'
     record of the form 'datime(YEAR,MONTH,DAY,HOUR,MIN,SEC)'.  All
     fields are integers.
'datime(+WHEN,-DATIME)'
'datime(-WHEN,+DATIME)'
     Convert a time stamp, as obtained by 'now/1', to a 'datime/6'
     record.  Can be used in both directions.
'sleep(+SECONDS)'

     Puts the SICStus Prolog process asleep for SECOND seconds, where
     SECONDS should be a non-negative number.
'environ(?VAR, ?VALUE)'

     VAR is the name of a system property or an environment variable,
     and VALUE is its value.  Both are atoms.  Can be used to enumerate
     all current system properties and environment variables.

     The same as 'environ(VAR, VALUE, merged)'.
'environ(?VAR, ?VALUE, +SOURCE)   since release 4.1'
     VAR is the name of an environment variable or system property, and
     VALUE is its value.  Both are atoms.  Can be used to enumerate all
     current environment variables and system properties.

     SOURCE is one of 'properties', in which case only system properties
     are enumerated; 'environment', in which case only environment
     variables are enumerated; and 'merged', in which case both
     environment variables and system properties are enumerated.  When
     SOURCE is 'merged' and an environment variable and a system
     property have equivalent names, the value of the system property is
     returned.

     On UNIX-like platforms, two names are equivalent if and only if
     they are identical.  On Windows-like platforms, a case insensitive
     comparison is used.

     *Note System Properties and Environment Variables::, for more
     information.


File: sicstus.info,  Node: lib-tcltk,  Next: lib-terms,  Prev: lib-system,  Up: The Prolog Library

10.39 Tcl/Tk Interface--'library(tcltk)'
========================================

* Menu:

* Introduction (Tcl):: Introduction
* Tcl:: Tcl
* Tk:: Tk
* The Tcl/Tk Prolog Library:: The Tcl/Tk Prolog Library
* Putting It All Together:: Putting It All Together
* Quick Reference:: Quick Reference
* Resources:: Resources


File: sicstus.info,  Node: Introduction (Tcl),  Next: Tcl,  Up: lib-tcltk

10.39.1 Introduction
--------------------

This is a basic tutorial for those SICStus Prolog users who would like
to add Tcl/Tk user interfaces to their Prolog applications.  The
tutorial assumes no prior knowledge of Tcl/Tk but, of course, does
assume the reader is proficient in Prolog.

   Aware that the reader may not have heard of Tcl/Tk, we will start by
answering three questions: what is Tcl/Tk?  what is it good for?  what
relationship does it have to Prolog?

* Menu:

* What Is Tcl/Tk?:: What Is Tcl/Tk?
* What Is Tcl/Tk Good For?:: What Is Tcl/Tk Good For?
* What Is Tcl/Tks Relationship to SICStus Prolog?:: What Is Tcl/Tks Relationship to SICStus Prolog?
* A Quick Example of Tcl/Tk in Action:: A Quick Example of Tcl/Tk in Action
* Outline of This Tutorial:: Outline of This Tutorial


File: sicstus.info,  Node: What Is Tcl/Tk?,  Next: What Is Tcl/Tk Good For?,  Up: Introduction (Tcl)

10.39.1.1 What Is Tcl/Tk?
.........................

Tcl/Tk, as its title suggests, is actually two software packages: Tcl
and Tk.  Tcl, pronounced _tickle_, stands for _tool command language_
and is a scripting language that provides a programming environment and
programming facilities such as variables, loops, and procedures.  It is
designed to be easily extensible.

   Tk, pronounced _tee-kay_, is just such an extension to Tcl, which is
a "toolkit" for windowing systems.  In other words, Tk adds facilities
to Tcl for creating and manipulating user interfaces based on windows
and widgets within those windows.


File: sicstus.info,  Node: What Is Tcl/Tk Good For?,  Next: What Is Tcl/Tks Relationship to SICStus Prolog?,  Prev: What Is Tcl/Tk?,  Up: Introduction (Tcl)

10.39.1.2 What Is Tcl/Tk Good For?
..................................

In combination the Tcl and Tk packages (we will call the combination
simply Tcl/Tk) are useful for creating graphical user interfaces (GUIs)
to applications.  The GUI is described in terms of instances of Tk
widgets, created through calls in Tcl, and Tcl scripts that form the
glue that binds together the GUI and the application.  (If you are a
little lost at this point, then all will be clear in a moment with a
simple example.)

   There are lots of systems out there for adding GUIs to applications
so why choose Tcl/Tk?  Tcl/Tk has several advantages that make it
attractive for this kind of work.  Firstly, it is good for rapid
prototyping of GUIs.  Tcl is an interpreted scripting language.  The
scripts can be modified and executed quickly, with no compilation phase,
so speeding up the development loop.

   Secondly, it is easier to use a system based on a scripting language,
such as Tcl/Tk, than many of the conventional packages available.  For
example, getting to grips with the X windows suite of C libraries is not
an easy task.  Tcl/Tk can produce the same thing using simple scripting
with much less to learn.  The penalty for this is that programs written
in an interpreted scripting language will execute more slowly than those
written using compiled C library calls, but for many interfaces that do
not need great speed Tcl/Tk is fast enough and its ease of use more than
outweighs the loss of speed.  In any case, Tcl/Tk can easily handle
hundreds of events per mouse movement without the user noticing.

   Thirdly, Tcl/Tk is good for making cross-platform GUIs.  The Tk
toolkit has been ported to native look-and-feel widgets on Mac, PC
(Windows), and UNIX (X windows) platforms.  You can write your scripts
once and they will execute on any of these platforms.

   Lastly, the software is distributed under a free software license and
so is available in both binary and source formats free of charge.


File: sicstus.info,  Node: What Is Tcl/Tks Relationship to SICStus Prolog?,  Next: A Quick Example of Tcl/Tk in Action,  Prev: What Is Tcl/Tk Good For?,  Up: Introduction (Tcl)

10.39.1.3 What Is Tcl/Tks Relationship to SICStus Prolog?
.........................................................

SICStus Prolog comes with a Prolog library for interfacing to Tcl/Tk.
The purpose of the library is to enable Prolog application developers to
add GUIs to their applications rapidly and easily.


File: sicstus.info,  Node: A Quick Example of Tcl/Tk in Action,  Next: Outline of This Tutorial,  Prev: What Is Tcl/Tks Relationship to SICStus Prolog?,  Up: Introduction (Tcl)

10.39.1.4 A Quick Example of Tcl/Tk in Action
.............................................

As a taster, we will show you two simple examples programs that use
SICStus Prolog with the Tcl/Tk extensions: the ubiquitous "hello world"
example; and a very simple telephone book look up example.

   You are not expected to understand how these examples work at this
stage.  They are something for you to quickly type in to see how easy it
is to add GUIs to Prolog programs through Tcl/Tk.  After reading through
the rest of this tutorial you will fully understand these examples and
be able to write your own GUIs.

   Here is the "Hello World" program; also in
'library('tcltk/examples/ex1.pl')':

     :- use_module(library(tcltk)).

     go :-
         tk_new([name('Example 1')], Interp),
         tcl_eval(Interp, 'button .fred -text "hello world"
                           -command { puts "hello world"}', _),
         tcl_eval(Interp, 'pack .fred', _),
         tk_main_loop.


 [image src="images/tcltkex1.png" text="" ]
                  SICStus+Tcl/Tk hello world program.

   To run it just start up SICStus (under Windows use 'sicstus', not
'spwin'), load the program, and evaluate the Prolog goal 'go'.  The
first line of the 'go' clause calls 'tk_new/2', which creates a Tcl/Tk
interpreter and returns a handle 'Interp' through which Prolog will
interact with the interpreter.  Next a call to 'tcl_eval/3' is made,
which creates a button displaying the 'hello world' text.  Next a call
is made to 'tcl_eval/3' that causes the button to be displayed in the
main application window.  Finally, a call is make to 'tk_main_loop/0'
that passes control to Tcl/Tk, making sure that window events are
serviced.

   See how simple it is with just a three line Prolog program to create
an application window and display a button in it.  Click on the button
and see what it does.

   The reason you should use 'sicstus' under Windows instead of 'spwin'
is that the latter does not have the C standard streams
('stdin','stdout','stderr') and the Tcl command 'puts' will give an
error if there is no 'stdout'.

   The previous example showed us how to create a button and display
some text in it.  It was basically pure Tcl/Tk generated from within
Prolog but did not have any interaction with Prolog.  The following
example demonstrates a simple callback mechanism.  A name is typed into
a text entry box, a button is pressed, which looks up the telephone
number corresponding to the name in a Prolog database, and the telephone
number is then displayed.

   Here is the code; also in 'library('tcltk/examples/ex2.pl')':

     :- use_module(library(tcltk)).

     telephone(fred, '123-456').
     telephone(wilbert, '222-2222').
     telephone(taxi, '200-0000').
     telephone(mary, '00-36-1-666-6666').

     go :-
          tk_new([name('Example 2')], T),
          tcl_eval(T, 'entry .name -textvariable name',_),
          tcl_eval(T, 'button .search -text search -command {
                           prolog telephone($name,X);
                           set result $prolog_variables(X) }', _),
          tcl_eval(T, 'label .result -relief raised -textvariable result', _),
          tcl_eval(T, 'pack .name .search .result -side top -fill x', _),
          tk_main_loop.


 [image src="images/tcltkex2.png" text="" ]
                SICStus+Tcl/Tk telephone number lookup

   Again, to run the example, start up SICStus Prolog, load the code,
and run the goal 'go'.

   You will notice that three widgets will appear in a window: one is
for entering the name of the person or thing that you want to find the
telephone number for, the button is for initiating the search, and the
text box at the bottom is for displaying the result.

   Type 'fred' into the entry box, hit the search button and you should
see the phone number displayed.  You can then try the same thing but
with 'wilbert', 'taxi' or 'mary' typed into the text entry box.

   What is happening is that when the button is pressed, the value in
the entry box is retrieved, then the 'telephone/2' predicate is called
in Prolog with the entry box value as first argument, then the second
argument of telephone is retrieved (by this time bound to the number)
and is displayed below the button.

   This is a very crude example of what can be done with the Tcl/Tk
module in Prolog.  For example, this program does not handle cases where
there is no corresponding phone number or where there is more than one
corresponding phone number.  The example is just supposed to wet your
appetite, but all these problems can be handled by Prolog + Tcl/Tk,
although with a more sophisticated program.  You will learn how to do
this in the subsequent chapters.


File: sicstus.info,  Node: Outline of This Tutorial,  Prev: A Quick Example of Tcl/Tk in Action,  Up: Introduction (Tcl)

10.39.1.5 Outline of This Tutorial
..................................

Now we have motivated using Tcl/Tk as a means of creating GUIs for
Prolog programs, this document goes into the details of using Tcl/Tk as
a means of building GUIs for SICStus Prolog applications.

   Firstly, Tcl is introduced and its syntax and core commands
described.  Then the Tk extensions to Tcl are introduced.  We show how
with Tcl and Tk together the user can build sophisticated GUIs easily
and quickly.  At the end of this Tcl/Tk part of the tutorial an example
of a pure Tcl/Tk program will be presented together with some tips on
how to design and code Tcl/Tk GUIs.

   The second phase of this document describes the SICStus Prolog
'tcltk' library.  It provides extensions to Prolog that allow Prolog
applications to interact with Tcl/Tk: Prolog can make calls to Tcl/Tk
code and vice versa.

   Having reached this point in the tutorial the user will know how to
write a Tcl/Tk GUI interface and how to get a Prolog program to interact
with it, but arranging which process (the Prolog process or the Tcl/Tk
process) is the dominant partner is non-trivial and so is described in a
separate chapter on event handling.  This will help the user choose the
most appropriate method of cooperation between Tcl/Tk and Prolog to suit
their particular application.

   This section, the Tcl/Tk+Prolog section, will be rounded off with the
presentation of some example applications that make use of Tcl/Tk and
Prolog.

   Then there is a short discussion section on how to use other Tcl
extension packages with Tcl/Tk and Prolog.  Many such extension packages
have been written and when added to Prolog enhanced with Tcl/Tk can
offer further functionality to a Prolog application.

   The appendices provide a full listing with description of the
predicates available in the 'tcltk' SICStus Prolog library, and the
extensions made to Tcl/Tk for interacting with Prolog.

   Lastly, a section on resources gives pointers to where the reader can
find more information on Tcl/Tk.


File: sicstus.info,  Node: Tcl,  Next: Tk,  Prev: Introduction (Tcl),  Up: lib-tcltk

10.39.2 Tcl
-----------

Tcl is an interpreted scripting language.  In this chapter, first the
syntax of Tcl is described and then the core commands are described.  It
is not intended to give a comprehensive description of the Tcl language
here but an overview of the core commands, enough to get the user
motivated to start writing their own scripts.

   For pointers to more information on Tcl; *note Resources::.

* Menu:

* Syntax (Tcl):: Syntax
* Variables (Tcl):: Variables
* Commands:: Commands
* What We Have Left Out (Tcl):: What We Have Left Out


File: sicstus.info,  Node: Syntax (Tcl),  Next: Variables (Tcl),  Up: Tcl

10.39.2.1 Syntax
................

A Tcl script consists of a series of strings separated from each other
by a newline character.  Each string contains a command or series of
semi-colon separated commands.  A command is a series of words separated
by spaces.  The first word in a command is the name of the command and
subsequent words are its arguments.

   An example is:

     set a 1
     set b 2

which is a Tcl script of two commands: the first command sets the value
of variable 'a' to '1', and the second command sets the value of
variable 'b' to '2'.

   An example of two commands on the same line separated by a semi-colon
is:

     set a 1; set b 2

which is equivalent to the previous example but written entirely on one
line.

   A command is executed in two phases.  In the first phase, the command
is broken down into its constituent words and various textual
substitutions are performed on those words.  In the second phase, the
procedure to call is identified from the first word in the command, and
the procedure is called with the remaining words as arguments.

   There are special syntactic characters that control how the first
phase, the substitution phase, is carried out.  The three major
substitution types are variable substitution, command substitution, and
backslash substitution.

   _Variable substitution_ happens when a '$' prefixed word is found in
a command.  There are three types of variable substitution:

   - '$NAME'
        - where NAME is a scalar variable.  NAME is simply substituted
          in the word for its value.  NAME can contain only letters,
          digits, or underscores.

   - '$NAME(INDEX)'
        - where NAME is the name of an array variable and INDEX is the
          index into it.  This is substituted by the value of the array
          element.  NAME must contain only letters, digits, or
          underscores.  INDEX has variable, command, and backslash
          substitution performed on it too.

   - '${NAME}'
        - where NAME can have any characters in it except closing curly
          bracket.  This is more or less the same as '$NAME'
          substitution except it is used to get around the restrictions
          in the characters that can form NAME.

   An example of variable substitution is:

     set a 1
     set b $a

which sets the value of variable 'a' to '1', and then sets the value of
variable 'b' to the value of variable 'a'.

   _Command substitution_ happens when a word contains an open square
bracket, '['.  The string between the open bracket and matching closing
bracket are treated as a Tcl script.  The script is evaluated and its
result is substituted in place of the original command substitution
word.

   A simple example of command substitution is:

     set a 1
     set b [set a]

which does the same as the previous example but using command
substitution.  The result of a 'set a' command is to return the value of
'a', which is then passed as an argument to 'set b' and so variable 'b'
acquires the value of variable 'a'.

   _Backslash substitution_ is performed whenever the interpreter comes
across a backslash.  The backslash is an escape character and when it is
encountered is causes the interpreter to handle the next characters
specially.  Commonly escaped characters are '\a' for audible bell, '\b'
for backspace, '\f' for form feed, '\n' for newline, '\r' for carriage
return, '\t' for horizontal tab, and '\v' for vertical tab.
Double-backslash, '\\', is substituted with a single backslash.  Other
special backslash substitutions have the following forms:

   * '\ooo'
        - the digits 'ooo' give the octal value of the escaped character

   * '\xHH'
        - the 'x' denotes that the following hexadecimal digits are the
          value of the escaped character

   Any other character that is backslash escaped is simply substituted
by the character itself.  For example, '\W' is replaced by 'W'.

   A further syntactic construction is used to _delay substitution_.
When the beginning of a word starts with a curly bracket, '{', it does
not do any of the above substitutions between the opening curly bracket
and its matching closing curly bracket.  The word ends with the matching
closing curly bracket.  This construct is used to make the bodies of
procedures in which substitutions happen when the procedure is called,
not when it is constructed.  Or it is used anywhere when the programmer
does not want the normal substitutions to happen.  For example:

     puts {I have $20}

will print the string 'I have $20' and will not try variable
substitution on the '$20' part.

   A word delineated by curly brackets is replaced with the characters
within the brackets without performing the usual substitutions.

   A word can begin with a _double-quote_ and end with the matching
closing double-quote.  Substitutions as detailed above are done on the
characters between the quotes, and the result is then substituted for
the original word.  Typically double-quotes are used to group sequences
of characters that contain spaces into a single command word.

   For example:

     set name "Fred the Great"
     puts "Hello my name is $name"

outputs 'Hello my name is Fred the Great'.  The first command sets the
value of variable 'name' to the following double-quoted string '"Fred
the Great"'.  The the next command prints its argument, a single
argument because it is a word delineated by double-quotes, that has had
variable substitution performed on it.

   Here is the same example but using curly brackets instead of
double-quotes:

     set name {Fred the Great}
     puts {Hello my name is $name}

gives the output 'Hello my name is $name' because substitutions are
suppressed by the curly bracket notation.

   And again the same example but without either curly brackets or
double-quotes:

     set name Fred the Great
     puts Hello my name is $name

simply fails because both 'set' and 'puts' expect a single argument but
without the word grouping effects of double-quotes or curly brackets
they find that they have more than one argument and throw an exception.

   Being a simple scripting language, Tcl does not have any real idea of
data types.  The interpreter simply manipulates strings.  The Tcl
interpreter is not concerned with whether those strings contain
representations of numbers or names or lists.  It is up to the commands
themselves to interpret the strings that are passed to them as arguments
in any manner those choose.


File: sicstus.info,  Node: Variables (Tcl),  Next: Commands,  Prev: Syntax (Tcl),  Up: Tcl

10.39.2.2 Variables
...................

This has been dealt with implicitly above.  A variable has a name and a
value.  A name can be any string whatsoever, as can its value.

   For example,

     set "Old King Cole" "merry soul"

sets the value of the variable named 'Old King Cole' to the value 'merry
soul'.  Variable names can also be numbers:

     set 123 "one two three"

sets the variable with name '123' to the value 'one two three'.  In
general, it is better to use the usual conventions -- start with a
letter then follow with a combination of letters, digits, and
underscores -- when giving variables names to avoid confusion.

   Array variables are also available in Tcl.  These are denoted by an
array name followed by an array index enclosed in round brackets.  As an
example:

     set fred(one) 1
     set fred(two) 2

will set the variable 'fred(one)' to the value '1' and 'fred(two)' to
the value '2'.

   Tcl arrays are associative arrays in that both the array name and the
array index can be arbitrary strings.  This also makes multidimensional
arrays possible if the index contains a comma:

     set fred(one,two) 12

   It is cheating in that the array is not stored as a multidimensional
array with a pair of indices, but as a linear array with a single index
that happens to contain a comma.


File: sicstus.info,  Node: Commands,  Next: What We Have Left Out (Tcl),  Prev: Variables (Tcl),  Up: Tcl

10.39.2.3 Commands
..................

Now that the Tcl syntax and variables have been been dealt with, we will
now look at some of the commands that are available.

   Each command when executed returns a value.  The return value will be
described along with the command.

   A quick word about the _notation_ used to describe Tcl commands.  In
general, a description of a command is the name of the command followed
by its arguments separated by spaces.  An example is:

     set VARNAME ?VALUE?

which is a description of the Tcl set command, which takes a variable
name VARNAME and an optional argument, a VALUE.

   Optional arguments are enclosed in question mark, ?, pairs, as in the
example.

   A series of three dots ... represents repeated arguments.  An example
is a description of the 'unset' command:

     unset VARNAME ?VARNAME VARNAME ...?

which shows that the 'unset' command has at least one compulsory
argument VARNAME but has any number of subsequent optional arguments.

   The most used _command over variables_ is the 'set' command.  It has
the form

     set VARNAME ?VALUE?

   The value of VALUE is determined, the variable VARNAME is set to it,
and the value is returned.  If there is no VALUE argument, then the
value of the variable is simply returned.  It is thus used to set and/or
get the value of a variable.

   The 'unset' command is used to remove variables completely from the
system:

     unset VARNAME ?VARNAME VARNAME ...?

which given a series of variable names deletes them.  The empty string
is always returned.

   There is a special command for incrementing the value of a variable:

     incr VARNAME ?INCREMENT?

which, given the name of a variable thats value is an integer string,
increments it by the amount INCREMENT.  If the INCREMENT part is left
out, then it defaults to '1'.  The return value is the new value of the
variable.

   _Expressions_ are constructed from operands and operators and can
then be evaluated.  The most general expression evaluator in Tcl is the
'expr' command:

     expr ARG ?ARG ARG ... ARG?

which evaluates its arguments as an expression and returns the value of
the evaluation.

   A simple example expression is

     expr 2 * 2

which when executed returns the value '4'.

   There are different classes of operators: arithmetic, relational,
logical, bitwise, and choice.  Here are some example expressions
involving various operators:

arithmetic    '$x * 2'
relational    '$x > 2'
logical       '($x == $y) || ($x == $z)'
bitwise       '8 & 2'
choice        '($a == 1) ? $x : $y'

   Basically the operators follow the syntax and meaning of their ANSI C
counterparts.

   Expressions to the 'expr' command can be contained in curly brackets
in which case the usual substitutions are not done before the 'expr'
command is evaluated, but the command does its own round of
substitutions.  So evaluating a script such as:

     set a 1
     expr { ($a==1) : "yes" ? "no" }

will evaluate to 'yes'.

   Tcl also has a whole host of math functions that can be used in
expressions.  Their evaluation is again the same as that for their ANSI
C counterparts.  For example:

     expr { 2*log($x) }

will return 2 times the natural log of the value of variable 'x'.

   Tcl has a notion of _lists_, but as with everything it is implemented
through strings.  A list is a string that contains words.

   A simple list is just a space separated series of strings:

     set a {one two three four five}

will set the variable 'a' to the list containing the five strings shown.
The empty list is denoted by an open and close curly bracket pair with
nothing in between: '{}'.

   For the Prolog programmer, there is much confusion between a Prolog
implementation of lists and the Tcl implementation of lists.  In Prolog
we have a definite notion of the printed representation of a list: a
list is a sequence of terms enclosed in square brackets (we ignore dot
notation for now); a nested list is just another term.

   In Tcl, however, a list is really just a string that conforms to a
certain syntax: a string of space separated words.  But in Tcl there is
more than one way of generating such a string.  For example,

     set fred {a b c d}

sets 'fred' to

     "a b c d"

as does

     set fred "a b c d"

because '{a b c d}' evaluates to the string 'a b c d', which has the
correct syntax for a list.  But what about nested lists?  Those are
represented in the final list-string as being contained in curly
brackets.  For example:

     set fred {a b c {1 2 3} e f}

results in 'fred' having the value

     "a b c {1 2 3} e f"

   The outer curly brackets from the 'set' command have disappeared,
which causes confusion.  The curly brackets within a list denote a
nested list, but there are no curly brackets at the top-level of the
list.  (We cannot help thinking that life would have been easier if the
creators of Tcl would have chosen a consistent representation for lists,
as Prolog and LISP do.)

   So remember: a list is really a string with a certain syntax, space
separated items or words; a nested list is surrounded by curly brackets.

   There are a dozen commands that operate on lists.

     concat ?LIST LIST ...?

   This makes a list out of a series of lists by concatenating its
argument lists together.  The return result is the list resulting from
the concatenation.

     lindex LIST INDEX

returns the INDEX-th element of the LIST.  The first element of a list
has an index of 0.

     linsert LIST INDEX VALUE ?VALUE ...?

returns a new list in which the VALUE arguments have been inserted in
turn before the INDEX-th element of LIST.

     list ?VALUE VALUE ...?

returns a list where each element is one of the VALUE arguments.

     llength LIST

returns the number of elements in list LIST.

     lrange LIST FIRST LAST

returns a slice of a list consisting of the elements of the list LIST
from index FIRST until index LAST.

     lreplace LIST FIRST LAST ?VALUE ... VALUE?

returns a copy of list LIST but with the elements between indices FIRST
and LAST replaced with a list formed from the VALUE arguments.

     lsearch ?-exact? ?-glob? ?-regexp? LIST PATTERN

returns the index of the first element in the list that matches the
given pattern.  The type of matching done depends on which of the switch
is present '-exact', '-glob', '-regexp', is present.  Default is
'-glob'.

     lsort ?-ascii? ?-integer? ?-real? ?-command COMMAND? ?-increasing? ?-decreasing{? LIST

returns a list, which is the original list LIST sorted by the chosen
technique.  If none of the switches supplies the intended sorting
technique, then the user can provide one through the '-command COMMAND'
switch.

   There are also two useful commands for converting between lists and
strings:

     join LIST ?JOINSTRING?

which concatenates the elements of the list together, with the separator
JOINSTRING between them, and returns the resulting string.  This can be
used to construct filenames; for example:

     set a {{} usr local bin}
     set filename [join $a /]

results in the variable 'filename' having the value '/usr/local/bin'.

   The reverse of the 'join' command is the 'split' command:

     split STRING ?SPLITCHARS?

which takes the string STRING and splits it into string on SPLITCHARS
boundaries and returns a list with the strings as elements.  An example
is splitting a filename into its constituent parts:

     set a [split /usr/local/src /]

gives 'a' the value '{{} usr local src}', a list.

   Tcl has the four usual classes of _control flow_ found in most other
programming languages:

     if...elseif...else, while, for, foreach, switch, and eval.

   We go through each in turn.

   The general form of an 'if' command is the following:

     if TEST1 BODY1 ?ELSEIF TEST2 BODY2 ELSEIF ...? ?ELSE BODYN?

which when evaluated, evaluates expression TEST1, which if true causes
BODY1 to be evaluated, but if false, causes TEST2 to be evaluated, and
so on.  If there is a final 'else' clause, then its BODYN part is
evaluated if all of the preceding tests failed.  The return result of an
'if' statement is the result of the last BODY command evaluated, or the
empty list if none of the bodies are evaluated.

   Conditional looping is done through the 'while' command:

     while TEST BODY

which evaluates expression TEST, which if true then evaluates BODY.  It
continues to do that until TEST evaluates to 0, and returns the empty
string.

   A simple example is:

     set a 10
     while {$a > 0} { puts $a; incr a -1 }

which initializes variable 'a' with value ten and then loops printing
out the value of 'a' and decrementing it until its value is 0, when the
loop terminates.

   The 'for' loop has the following form:

     for INIT TEST REINIT BODY

which initializes the loop by executing INIT, then each time around the
loop the expression TEST is evaluated, which if true causes BODY to be
executed and then executes REINIT.  The loop spins around until TEST
evaluates to 0.  The return result of a 'for' loop is the empty string.

   An example of a 'for' loop:

     for {set a 10} ($a>0) {incr a -1} {puts $a}

which initializes the variable 'a' with value '10', then goes around the
loop printing the value of 'a' and decrementing it as long as its value
is greater than '0'.  Once it reaches '0' the loop terminates.

   The 'foreach' command has the following form:

     foreach VARNAME LIST BODY

where VARNAME is the name of a variable, LIST is an instance of a list,
and BODY is a series of commands to evaluate.  A 'foreach' then iterates
over the elements of a list, setting the variable VARNAME to the current
element, and executes BODY.  The result of a 'foreach' loop is always
the empty string.

   An example of a 'foreach' loop:

     foreach friend {joe mary john wilbert} {puts "I like $friend"}

will produce the output:

     I like joe
     I like mary
     I like john
     I like wilbert

   There are also a couple of commands for controlling the flow of
loops: 'continue' and 'break'.

   'continue' stops the current evaluation of the body of a loop and
goes on to the next one.

   'break' terminates the loop altogether.

   Tcl has a general switch statement, which has two forms:

     switch ?OPTIONS? STRING PATTERN BODY ?PATTERN BODY ... ?
     switch ?OPTIONS? STRING { PATTERN BODY ?PATTERN BODY ...? }

   When executed, the switch command matches its STRING argument against
each of the PATTERN arguments, and the BODY of the first matching
pattern is evaluated.  The matching algorithm depends on the options
chosen, which can be one of

'-exact'     use exact matching
'-glob'      use glob-style matching
'-regexp'    use regular expression matchinig

   An example is:

     set a rob
     switch -glob $a {
         a*z { puts "A to Z"}
         r*b { puts "rob or rab"}
     }

which will produce the output:

     rob or rab

   There are two forms of the 'switch' command.  The second form has the
command arguments surrounded in curly brackets.  This is primarily so
that multi-line switch commands can be formed, but it also means that
the arguments in brackets are not evaluated (curly brackets suppress
evaluation), whereas in the first type of switch statement the arguments
are first evaluated before the switch is evaluated.  These effects
should be borne in mind when choosing which kind of switch statement to
use.

   The final form of control statement is 'eval':

     eval ARG ?ARG ...?

which takes one or more arguments, concatenates them into a string, and
executes the string as a command.  The return result is the normal
return result of the execution of the string as a command.

   An example is

     set a b
     set b 0
     eval set $a 10

which results in the variable 'b' being set to '10'.  In this case, the
return result of the 'eval' is '10', the result of executing the string
'"set b 10"' as a command.

   Tcl has several _commands over strings_.  There are commands for
searching for patterns in strings, formatting and parsing strings (much
the same as 'printf' and 'scanf' in the C language), and general string
manipulation commands.

   Firstly we will deal with formatting and parsing of strings.  The
commands for this are 'format' and 'scan' respectively.

     format FORMATSTRING ?VALUE VALUE ...?

which works in a similar to C's 'printf'; given a format string with
placeholders for values and a series of values, return the appropriate
string.

   Here is an example of printing out a table for base 10 logarithms for
the numbers 1 to 10:

     for {set n 1} {$n <= 10} {incr n} {
         puts [format "log10(%d) = %.4f" $n [expr log10($n)]]
     }

which produces the output

     ln(1) = 0.0000
     ln(2) = 0.3010
     ln(3) = 0.4771
     ln(4) = 0.6021
     ln(5) = 0.6990
     ln(6) = 0.7782
     ln(7) = 0.8451
     ln(8) = 0.9031
     ln(9) = 0.9542
     ln(10) = 1.0000

   The reverse function of 'format' is 'scan':

     scan STRING FORMATSTRING VARNAME ?VARNAME ...?

which parses the string according to the format string and assigns the
appropriate values to the variables.  it returns the number of fields
successfully parsed.

   An example,

     scan "qty 10, unit cost 1.5, total 15.0" \
          "qty %d, unit cost %f, total %f"    \
          quantity cost_per_unit total

would assign the value 10 to the variable 'quantity', 1.5 to the
variable 'cost_per_unit' and the value 15.0 to the variable 'total'.

   There are commands for performing two kinds of pattern matching on
strings: one for matching using regular expressions, and one for
matching using UNIX-style wildcard pattern matching (globbing).

   The command for regular expressions matching is as follows:

     regexp ?-indices? ?-nocase? EXP STRING ?MATCHVAR? ?SUBVAR SUBVAR ...?

where EXP is the regular expression and STRING is the string on which
the matching is performed.  The regexp command returns 1 if the
expression matches the string, 0 otherwise.  The optional '-nocase'
switch does matching without regard to the case of letters in the
string.  The optional MATCHVAR and SUBVAR variables, if present, are set
to the values of string matches.  In the regular expression, a match
that is to be saved into a variable is enclosed in round braces.  An
example is

     regexp {([0-9]+)} "I have 3 oranges" a

will assign the value 3 to the variable 'a'.

   If the optional switch '-indices' is present, then instead of storing
the matching substrings in the variables, the indices of the substrings
are stored; that is a list with a pair of numbers denoting the start and
end position of the substring in the string.  Using the same example:

     regexp -indices {([0-9]+)} "I have 3 oranges" a

will assign the value '"7 7"', because the matched numeral '3' is in the
eighth position in the string, and indices count from 0.

   String matching using the UNIX-style wildcard pattern matching
technique is done through the 'string match' command:

     string match PATTERN STRING

where PATTERN is a wildcard pattern and STRING is the string to match.
If the match succeeds, then the command returns 1; otherwise, it returns
0.  An example is

     string match {[a-z]*[0-9]} {a_$%^_3}

which matches because the command says match any string that starts with
a lower case letter and ends with a number, regardless of anything in
between.

   There is a command for performing string substitutions using regular
expressions:

     regsub ?-all? ?-nocase? EXP STRING SUBSPEC VARNAME

where EXP is the regular expression and STRING is the input string on
which the substitution is made, SUBSPEC is the string that is
substituted for the part of the string matched by the regular
expression, and VARNAME is the variable on which the resulting string is
copied into.  With the '-nocase' switch, the matching is done without
regard to the case of letters in the input string.  The '-all' switch
causes repeated matching and substitution to happen on the input string.
The result of a 'regsub' command is the number of substitutions made.

   An example of string substitution is:

     regsub {#name#} {My name is #name#} Rob result

which sets the variable 'result' to the value "My name is Rob".  An
example of using the '-all' switch:

     regsub -all {#name#} {#name#'s name is #name#} Rob result

sets the variable 'result' to the value "Rob's name is Rob" and it
returns the value 2 because two substitutions were made.

   The are a host of other ways to manipulate strings through variants
of the 'string' command.  Here we will go through them.

   To select a character from a string given the character position, use
the 'string index' command.  An example is:

     string index "Hello world" 6

which returns 'w', the 7th character of the string.  (Strings are
indexed from 0).

   To select a substring of a string, given a range of indices use the
'string range' command.  An example is:

     string range "Hello world" 3 7

which returns the string "lo wo".  There is a special index marker named
'end', which is used to denote the the end of a string, so the code

     string range "Hello world" 6 end

will return the string "world".

   There are two ways to do simple search for a substring on a string,
using the 'string first' and 'string last' commands.  An example of
'string first' is:

     string first "dog" "My dog is a big dog"

find the first position in string "My dog is a big dog" that matches
"dog".  It will return the position in the string in which the substring
was found, in this case 3.  If the substring cannot be found, then the
value -1 is returned.

   Similarly,

     string last "dog" "My dog is a big dog"

will return the value 16 because it returns the index of the last place
in the string that the substring matches.  Again, if there is no match,
then -1 is returned.

   To find the length of a string use 'string length', which given a
string simply returns its length.

     string length "123456"

returns the value 6.

   To convert a string completely to upper case use 'string toupper':

     string toupper "this is in upper case"

returns the string "THIS IS IN UPPER CASE".

   Similarly,

     string tolower "THIS IS IN LOWER CASE"

returns the string "this is in lower case".

   There are commands for removing characters from strings: 'string
trim', 'string trimright', and 'string trimleft'.

     string trim STRING ?CHARS?

which removes the characters in the string CHARS from the string STRING
and returns the trimmed string.  If CHARS is not present, then
whitespace characters are removed.  An example is:

     string string "The dog ate the exercise book" "doe"

which would return the string "Th g at th xrcis bk".

   'string trimleft' is the same as 'string trim' except only leading
characters are removed.  Similarly 'string trimright' removes only
trailing characters.  For example:

     string trimright $my_input

would return a copy of the string contained in '$my_input' but with all
the trailing whitespace characters removed.

   There is a comprehensive set of commands for _file manipulation_.  We
will cover only the some of the more important ones here.

   To open a file the 'open' command is used:

     open NAME ?ACCESS?

where NAME is a string containing the filename, and the option ACCESS
parameter contains a string of access flags, in the UNIX style.  The
return result is a handle to the open file.

   If ACCESS is not present, then the access permissions default to
'"r"', which means open for reading only.  The command returns a file
handle that can be used with other commands.  An example of the use of
the 'open' command is

     set fid [open "myfile" "r+"]

which means open the file 'myfile' for both reading and writing and set
the variable 'fid' to the file handle returned.

   To close a file simply use

     close FILEID

   For example,

     close $fid

will close the file that has the file handle stored in the variable
'fid'.

   To read from a file, the 'read' command is used:

     read FILEID NUMBYTES

which reads NUMBYTES bytes from the file attached to file handle FILEID,
and returns the bytes actually read.

   To read a single line from a file use 'gets':

     gets FILEID ?VARNAME?

which reads a line from the file attached to file handle FILEID but
chops off the trailing newline.  If variable VARNAME is specified, then
the string read in is stored there and the number of bytes is returned
by the command.  If the variable is not specified, then the command
returns the string only.

   To write to a file, use 'puts':

     puts ?-nonewline? ?FILEID? STRING

which outputs the string STRING.  If the file handle FILEID is present,
then the string is output to that file; otherwise, it is printed on
'stdout'.  If the switch '-nonewline' is present, then a trailing
newline is not output.

   To check if the end of a file has been reached, use 'eof':

     eof FILEID

which, given a file handle FILEID returns 1 if the end has been reached,
and 0 otherwise.

   The are a host of other commands over files and processes, which we
will not go into here.

   (For extra information on file I/O commands, refer to the Tcl manual
pages.)

   Tcl provides a way of _creating new commands_, called procedures,
that can be executed in scripts.  The arguments of a procedure can be
call-by-value or call-by-reference, and there is also a facility for
creating new user defined control structures using procedures.

   A procedure is declared using the 'proc' command:

     proc NAME ARGLIST BODY

where the name of the procedure is NAME, the arguments are contained in
ARGLIST and the body of the procedure is the script BODY.  An example of
a procedure is:

     proc namePrint { first family } {
         puts "My first name is $first"
         puts "My family name is $family"
     }

which can be called with

     namePrint Tony Blair

to produce the output:

     My first name is Tony
     My family name is Blair

   A procedure with no arguments is specified with an empty argument
list.  An example is a procedure that just prints out a string:

     proc stringThing {} {
         puts "I just print this string"
     }

   Arguments can be given defaults by pairing them with a value in a
list.  An example here is a counter procedure:

     proc counter { value { inc 1 } } {
         eval $value + $inc
     }

which can be called with two arguments like this

     set v 10
     set v [counter $v 5]

which will set variable 'v' to the value 15; or it can be called with
one argument:

     set v 10
     set v [counter $v]

in which case 'v' will have the value 11, because the default of the
argument 'inc' inside the procedure is the value 1.

   There is a special argument for handling procedures with variable
number of arguments, the 'args' argument.  An example is a procedure
that sums a list of numbers:

     proc sum { args } {
         set result 0;

         foreach n $args {
          set result [expr $result + $n ]
         }

         return $result;
     }

which can be called like this:

     sum 1 2 3 4 5

which returns the value 15.

   The restriction on using defaulted arguments is that all the
arguments that come after the defaulted ones must also be defaulted.  If
'args' are used, then it must be the last argument in the argument list.

   A procedure can return a value through the 'return' command:

     return ?OPTIONS? ?VALUE?

which terminates the procedure returning value VALUE, if specified, or
just causes the procedure to return, if no value specified.  (The
?OPTIONS? part has to do with raising exceptions, which we will will not
cover here.)

   The return result of a user defined procedure is the return result of
the last command executed by it.

   So far we have seen the arguments of a procedure are passed using the
call-by-value mechanism.  They can be passed call by reference using the
'upvar' command:

     upvar ?LEVEL? OTHERVAR1 MYVAR1 ?OTHERVAR2 MYVAR2 ...?

which makes accessible variables somewhere in a calling context with the
current context.  The optional argument LEVEL describes how many calling
levels up to look for the variable.  This is best shown with an example:

     set a 10
     set b 20

     proc add { first second } {
         upvar $first f $second s
         expr $f+$s
     }

which when called with

     add a b

will produce the result 30.  If you use call-by-value instead:

     add $a $b

then the program will fail because when executing the procedure 'add' it
will take the first argument 10 as the level argument, a bad level.
(Also variable '20' does not exist at any level.)

   New control structures can be generated using the 'uplevel' command:

     uplevel ?LEVEL? ARG ?ARG ARG ...?

which is like 'eval', but it evaluates its arguments in a context higher
up the calling stack.  How far up the stack to go is given by the
optional LEVEL argument.

     proc do { loop condition } {
         set nostop 1

         while { $nostop } {
             uplevel $loop
             if {[uplevel "expr $condition"] == 0} {
                 set nostop 0
              }
         }
     }

which when called with this

     set x 5
     do { puts $x; incr x -1 } { $x > 0 }

will print

     5
     4
     3
     2
     1

   (*Please note*: this does not quite work for all kinds of calls
because of 'break', 'continue', and 'return'.  It is possible to get
around these problem, but that is outside the scope of this tutorial.)

   A word about the _scope of variables_.  Variables used within
procedures are normally created only for the duration of that procedure
and have local scope.

   It is possible to declare a variable as having global scope, through
the 'global' command:

     global NAME1 ? NAME2 ...?

where NAME1, NAME2, ..., are the names of global variables.  Any
references to those names will be taken to denote global variables for
the duration of the procedure call.

   Global variables are those variables declared at the topmost calling
context.  It is possible to run a 'global' command at anytime in a
procedure call.  After such a command, the variable name will refer to a
global variable until the procedure exits.

   An example:

     set x 10

     proc fred { } {
         set y 20
         global x
         puts [expr $x + $y]
     }

     fred

will print the result '30' where 20 comes from the local variable 'y'
and 10 comes from the global variable 'x'.

   Without the 'global x' line, the call to 'fred' will fail with an
error because there is no variable 'x' defined locally in the procedure
for the 'expr' to evaluate over.

   In common with other scripting languages, there is a command for
_evaluating the contents of a file_ in the Tcl interpreter:

     source FILENAME

where FILENAME is the filename of the file containing the Tcl source to
be evaluated.  Control returns to the Tcl interpreter once the file has
been evaluated.


File: sicstus.info,  Node: What We Have Left Out (Tcl),  Prev: Commands,  Up: Tcl

10.39.2.4 What We Have Left Out
...............................

We have left out a number of Tcl commands as they are outside of the
scope of this tutorial.  We list some of them here to show some of what
Tcl can do.  Please refer to the Tcl manual for more information.

"http"
     implements the HTTP protocol for retrieving web pages

"namespaces"
     a modules systems for Tcl

"trace"
     commands can be attached to variables that are triggered when the
     variable changes value (amongst other things)

"processes"
     start, stop, and manage processes

"sockets"
     UNIX and Internet style socket management

"exception handling"

"3rd party extension packages"
     load extension packages into Tcl and use their facilities as native
     Tcl commands


File: sicstus.info,  Node: Tk,  Next: The Tcl/Tk Prolog Library,  Prev: Tcl,  Up: lib-tcltk

10.39.3 Tk
----------

Tk is an extension to Tcl.  It provides Tcl with commands for easily
creating and managing graphical objects, or widgets, so providing a way
to add graphical user interfaces (GUIs) to Tcl applications.

   In this section we will describe the main Tk widgets, the Tcl
commands used to manipulate them, how to give them behaviors, and
generally how to arrange them into groups to create a GUI.

* Menu:

* Widgets:: Widgets
* Types of Widget:: Types of Widget
* Widgets Hierarchies:: Widgets Hierarchies
* Widget Creation:: Widget Creation
* Geometry Managers:: Geometry Managers
* Event Handling:: Event Handling
* Miscellaneous:: Miscellaneous
* What We Have Left Out (Tk):: What We Have Left Out
* Queens Display:: Example pure Tcl/Tk program


File: sicstus.info,  Node: Widgets,  Next: Types of Widget,  Up: Tk

10.39.3.1 Widgets
.................

A widget is a "window object".  It is something that is displayed that
has at least two parts: a state and a behavior.  An example of a widget
is a button.  Its state is things like what color is it, what text is
written it in, and how big it is.  Its behavior is things like what it
does when you click on it, or what happens when the cursor is moved over
or away from it.

   In Tcl/Tk there are three parts to creating a useful widget.  The
first is creating an instance of the widget with its initial state.  The
second is giving it a behavior by defining how the widget behaves when
certain events happen -- event handling.  The third is actually
displaying the widget possibly in a group of widgets or inside another
widget -- geometry management.  In fact, after creating all the widgets
for a GUI, they are not displayed until handled by a geometry manager,
which has rules about how to calculate the size of the widgets and how
they will appear in relation to each other.


File: sicstus.info,  Node: Types of Widget,  Next: Widgets Hierarchies,  Prev: Widgets,  Up: Tk

10.39.3.2 Types of Widget
.........................

In Tcl/Tk there are currently 15 types of widget.  In alphabetical order
they are (see also 'library('tcltk/examples/widgets.tcl')'):

'button'
     a simple press button

'canvas'
     is a container for displaying "drawn" objects such as lines,
     circles, and polygons.

'checkbutton'
     a button that hold a state of either on or off

'entry'
     a text entry field

'frame'
     a widget that is a container for other widgets

'label'
     a simple label

'listbox'
     a box containing a list of options

'menu'
     a widget for creating menu bars

'menubutton'
     a button, which when pressed offers a selection of choices

'message'
     a multi-line text display widget

'radiobutton'
     a button used to form groups of mutually interacting buttons (When
     one button is pressed down, the others pop up.)

'scale'
     is like a slider on a music console.  It consists of a trough scale
     and a slider.  Moving the slider to a position on the scale sets
     the overall value of the widget to that value.

'scollbar'
     used to add scrollbars to windows or canvases.  The scrollbar has a
     slider, which when moved changes the value of the slider widget.

'text'
     a sophisticated multi-line text widget that can also display other
     widgets such as buttons

'toplevel'
     for creating new standalone toplevel windows.  (These windows are
     containers for other widgets.  They are not terminal windows.)


 [image src="images/tcltkwidgets.png" text="" ]
                       Meet The Main Tk Widgets


File: sicstus.info,  Node: Widgets Hierarchies,  Next: Widget Creation,  Prev: Types of Widget,  Up: Tk

10.39.3.3 Widgets Hierarchies
.............................

Before going further it is necessary to understand how instances of
widgets are named.  Widgets are arranged in a hierarchy.  The names of
widget instances are formed from dot separated words.  The root window
is simply '.' on its own.  So for, example, a button widget that is
displayed in the root window might have the name '.b1'.  A button that
is displayed inside a frame that is displayed inside the root window may
have the name '.frame1.b1'.  The frame would have the name '.frame1'.

   Following this notation, it is clear that widgets are both formed in
hierarchies, with the dot notation giving the path to a widget, and in
groups, all widgets with the same leading path are notionaly in the same
group.

   (It is a similar to the way file systems are organized.  A file has a
path that shows where to find it in the hierarchical file system.  But
also files with the same leading path are in the same directory/folder
and so are notionaly grouped together.)

   An instance of a widget is created through the a Tcl command for that
widget.  The widget command my have optional arguments set for
specifying various attributes of the widget that it will have when it is
created.  The result of a successful widget command is the name of the
new widget.

   For example, a command to create a button widget named '.mybutton'
that displays the text "I am a button" would look like this:

     button .mybutton -text "I am a button"

and this will return the name '.mybutton'.

   A widget will only be created if all the windows/widgets in the
leading path of the new widget also exist, and also that the name of the
new widget does not already exist.

   For example, the following

     button .mybutton -text "I am a button"
     button .mybutton -text "and so am I"

will fail at the second command because there is also a widget named
'.mybutton' from the first command.

   The following will also fail

     button .frame.mybutton -text "I am a button"

if there is no existing widget with the name '.frame' to be the parent
of '.mybutton'.

   All this begs the question: why are widgets named and arranged in a
hierarchy?  Is not a GUI just a bunch of widgets displayed in a window?

   This is not generally how GUIs are arranged.  For example, they often
have a menubar over the top of each window.  The menubar contains
pulldown menus.  The pulldown menus may have cascading menu items that
may cascade down several levels.  Under the menu bar is the main part of
the window that may also be split into several "frames".  A left hand
frame my have a set of buttons in it, for example.  And so on.  From
this you can see that the widgets in GUIs are naturally arranged in a
hierarchy.  To achieve this in Tcl/Tk instances of widgets are placed in
a hierarchy, which is reflected in their names.

   Now we will go through each of the widget commands in turn.  Each
widget command has many options most of which will not be described
here.  Just enough will be touched on for the reader to understand the
basic operation of each widget.  For a complete description of each
widget and its many options refer to the Tk manual.


File: sicstus.info,  Node: Widget Creation,  Next: Geometry Managers,  Prev: Widgets Hierarchies,  Up: Tk

10.39.3.4 Widget Creation
.........................

As has already been said, a widget is a window object that has state and
behavior.  In terms of Tcl/Tk a widget is created by calling a widget
creation command.  There is a specific widget creation for each type of
widget.

   The widget creation command is supplied with arguments.  The first
argument is always the name you want to give to the resulting widget;
the other arguments set the initial state of the widget.

   The immediate result of calling a widget creation command is that it
returns the name of the new widget.  A side-effect is that the instance
of the widget is created and its name is defined as in the Tcl
interpreter as a procedure through which the widget state can be
accessed and manipulated.

   This needs an example.  We will use the widget creator command
'button' to make a button widget:

     button .fred -text 'Fred' -background red

which creates an instance of a button widget named '.fred' that will
display the text 'Fred' on the button and will have a red background
color.  Evaluating this command returns the string '.fred', the name of
the newly created widget.

   As a side-effect, a Tcl procedure named '.fred' is created.  A call
to a widget instance has the following form:

     WIDGETNAME METHOD METHODARGS

where WIDGETNAME is the name of the widget to be manipulated, METHOD is
the action to be performed on the widget, and METHODARGS are the
arguments passed to the method that is performed on the widget.

   The two standard methods for widgets are 'configure' and 'cget'.
'configure' - is used to change the state of a widget; for example:

     .fred configure -background green -text 'Sid'

will change the background color of the widget '.fred' to green and the
text displayed to 'Sid'.

   'cget' is used to get part of the state of a widget; for example:

     .fred cget -text

will return 'Sid' if the text on the button '.fred' is 'Sid'.

   In addition to these general methods, there are special methods for
each widget type.  For example, with button widgets you have the 'flash'
and 'invoke' methods.

   For example,

     .fred invoke

can be called somewhere in the Tcl code to invoke button '.fred' as
though it had been clicked on.

     .fred flash

can be called somewhere in the Tcl code to cause the button to flash.

   We will come across some of these special method when we discuss the
widgets in detail.  For a comprehensive list of widget methods, refer to
entry for the appropriate widget creation command in the Tcl/Tk manual.

   We now discuss the widget creation command for each widget type.

   A _label_ is a simple widget for displaying a single line of text.
An example of creating an instance of a label is

     label .l -text "Hello world!"

which simply creates the label named '.l' with the text 'Hello world!'
displayed in it.  Most widgets that display text can have a variable
associated with them through the option '-textvariable'.  When the value
of the variable is changed the text changes in the associated label.
For example,

     label .l -text "Hello world!" -textvariable mytext

creates a text label called '.l' displaying the initial text 'Hello
world!' and associated text variable 'mytext'; 'mytext' will start with
the value 'Hello world!'.  However, if the following script is executed:

     set mytext "Goodbye moon!"

then the text in the label will magically change to 'Goodbye moon!'.

   A _message widget_ is similar to a label widget but for multi-line
text.  As its name suggests it is mostly used for creating popup message
information boxes.

   An example of a message widget is

     message .msg -text "Your data is incorrect.\n\n \
                   Please correct it and try again." \
         -justify center

which will create a message widget displaying the text shown, center
justified.  The width of the message box can be given through the
'-width' switch.  Any lines that exceed the width of the box are wrapped
at word boundaries.

   Calling the 'button' command creates an instance of a _button
widget_.  An example is:

     button .mybutton -text "hello" -command {puts "howdie!"}

which creates a button with name '.mybutton' that will display the text
"hello" and will execute the Tcl script 'puts "howdie!"' (that is print
'howdie!' to the terminal) when clicked on.

   _Checkbuttons_ are buttons that have a fixed state that is either on
or off.  Clicking on the button toggles the state.  To store the state,
a checkbutton is associated with a variable.  When the state of the
checkbutton changes, so does that of the variable.  An example is:

     checkbutton .on_or_off -text "I like ice cream" -variable ice

which will create a checkbutton with name '.on_or_off' displaying the
text 'I like ice cream' and associated with the variable 'ice'.  If the
checkbutton is checked, then 'ice' will have the value 1; if not
checked, then it will have the value 0.  The state of the checkbutton
can also be changed by changing the state of the variable.  For example,
executing

     set ice 0

will set the state of '.on_or_off' to not checked.

   _Radiobuttons_ are buttons that are grouped together to select one
value among many.  Each button has a value, but only one in the button
group is active at any one time.  In Tcl/Tk this is achieved by creating
a series of radiobutton that share an associated variable.  Each button
has a value.  When a radiobutton is clicked on, the variable has that
value and all the other buttons in the group are put into the off state.
Similarly, setting the value of the variable is reflected in the state
of the button group.  An example is:

     radiobutton .first -value one -text one -variable count
     radiobutton .second -value two -text two -variable count
     radiobutton .third -value three -text three -variable count

which creates three radiobuttons that are linked through the variable
'count'.  If button '.second' is active, for example, then the other two
buttons are in the inactive state and 'count' has the value 'two'.  The
following code sets the button group to make the button '.third' active
and the rest inactive regardless of the current state:

     set count three

   If the value of 'count' does not match any of the values of the
radiobuttons, then they will all be off.  For example executing the
script

     set count four

will turn all the radiobuttons off.

   An _entry widget_ allows input of a one line string.  An example of
an entry widget:

     label .l -text "Enter your name"
     entry .e -width 40 -textvariable your_name

would display a label widget named '.l' showing the string 'Enter your
name' and an entry widget named '.e' of width 40 characters.  The value
of variable 'your_name' will reflect the string in the entry widget: as
the entry widget string is updated, so is the value of the variable.
Similarly, changing the value of 'your_name' in a Tcl script will change
the string displayed in the entry field.

   A _scale widget_ is for displaying an adjustable slider.  As the
slider is moved its value, which is displayed next to the slider,
changes.  To specify a scale, it must have '-from' and '-to' attributes,
which is the range of the scale.  It can have a '-command' option, which
is set to a script to evaluate when the value of the slider changes.

   An example of a scale widget is:

     scale .s -from 0 -to 100

which creates a scale widget with name '.s' that will slide over a range
of integers from 0 to 100.

   There are several other options that scales can have.  For example it
is possible to display tick marks along the length of the scale through
the '-tickinterval' attribute, and it is possible to specify both
vertically and horizontally displayed scales through the '-orient'
attribute.

   A _listbox_ is a widget that displays a list of single line strings.
One or more of the strings may be selected through using the mouse.
Initializing and manipulating the contents of a listbox is done through
invoking methods on the instance of the listbox.  As examples, the
'insert' method is used to insert a string into a listbox, 'delete' to
delete one, and 'get' to retrieve a particular entry.  Also the
currently selected list items can be retrieved through the 'selection'
command.

   Here is an example of a listbox that is filled with entries of the
form 'entry N':

     listbox .l
     for { set i 0 } { $i<10 } { incr i } {
         .l insert end "entry $i"
     }

   A listbox may be given a height and/or width attribute, in which case
it is likely that not all of the strings in the list are visible at the
same time.  There are a number of methods for affecting the display of
such a listbox.

   The 'see' method causes the listbox display to change so that a
particular list element is in view.  For example,

     .l see 5

will make sure that the sixth list item is visible.  (List elements are
counted from element 0.)

   A _scrollbar_ widget is intended to be used with any widget that is
likely to be able to display only part of its contents at one time.
Examples are listboxes, canvases, text widgets, and frames, amongst
others.

   A scrollbar widget is displayed as a movable slider between two
arrows.  Clicking on either arrow moves the slider in the direction of
the arrow.  The slider can be moved by dragging it with the cursor.

   The scollbar and the widget it scrolls are connected through Tcl
script calls.  A scrollable widgets will have a 'scrollcommand'
attribute that is set to a Tcl script to call when the widget changes
its view.  When the view changes the command is called, and the command
is usually set to change the state of its associated scrollbar.

   Similarly, the scrollbar will have a 'command' attribute that is
another script that is called when an action is performed on the
scrollbar, like moving the slider or clicking on one of its arrows.
That action will be to update the display of the associated scrollable
widget (which redraws itself and then invokes its 'scrollcommand', which
causes the scrollbar to be redrawn).

   How this is all done is best shown through an example:

     listbox .l -yscrollcommand ".s set" -height 10
     scrollbar .s -command ".l yview"
     for { set i 0 } { $i < 50 } { incr i } {
         .l insert end "entry $i"
     }

creates a listbox named '.l' and a scrollbar named '.s'.  Fifty strings
of the form 'entry N' are inserted into the listbox.  The clever part is
the way the scrollbar and listbox are linked.  The listbox has its
'-yscrollcommand' attribute set to the script '".s set"'.  What happens
is that if the view of '.l' is changed, this script is called with 4
arguments attached: the number of entries in the listbox, the size of
the listbox window, the index of the first entry currently visible, and
the index of the last entry currently visible.  This is exactly enough
information for the scrollbar to work out how to redisplay itself.  For
example, changing the display of the above listbox could result in the
following '-yscrollcommand' script being called:

     .s set 50 10 5 15

which says that the listbox contains 50 elements, it can display 10 at
one time, the first element displayed has index 5 and the last one on
display has index 15.  This call invokes the 'set' method of the
scrollbar widget '.s', which causes it to redraw itself appropriately.

   If, instead, the user interacts with the scrollbar, then the
scrollbar will invoke its '-command' script, which in this example is
'".l yview"'.  Before invoking the script, the scrollbar widget
calculates which element should the first displayed in its associated
widget and appends its index to the call.  For example, if element with
index 20 should be the first to be displayed, then the following call
will be made:

     .l yview 20

which invokes the 'yview' method of the listbox '.l'.  This causes '.l'
to be updated (which then causes its '-yscrollcommand' to be called,
which updates the scrollbar).

   A _frame_ widget does not do anything by itself except reserve an
area of the display.  Although this does not seem to have much purpose,
it is a very important widget.  It is a container widget; that is, it is
used to group together collections of other widgets into logical groups.
For example, a row of buttons may be grouped into a frame, then as the
frame is manipulated so will the widgets displayed inside it.  A frame
widget can also be used to create large areas of color inside another
container widget (such as another frame widget or a toplevel widget).

   An example of the use of a frame widget as a container:

     canvas .c -background red
     frame .f
     button .b1 -text button1
     button .b2 -text button2
     button .b3 -text button3
     button .b4 -text button4
     button .b5 -text button5
     pack .b1 .b2 .b3 .b4 .b5 -in .f -side left
     pack .c -side top -fill both -expand 1
     pack .f -side bottom

which specifies that there are two main widgets a canvas named '.c' and
a frame named '.f'.  There are also 5 buttons, '.b1' through '.b5'.  The
buttons are displayed inside the frame.  Then the canvas is displayed at
the top of the main window and the frame is displayed at the bottom.  As
the frame is displayed at the bottom, then so will the buttons because
they are displayed inside the frame.

   (The 'pack' command causes the widgets to be handled for display by
the packer geometry manager.  The '-fill' and '-expand 1' options to
pack for '.c' tell the display manager that if the window is resized,
then the canvas is to expand to fill most of the window.  You will learn
about geometry managers later in the Geometry Managers section.)

   A _toplevel_ widget is a new toplevel window.  It is a container
widget inside which other widgets are displayed.  The root toplevel
widget has path '.' -- i.e. dot on its own.  Subsequent toplevel widgets
must have a name that is lower down the path tree just like any other
widget.

   An example of creating a toplevel widget is:

     toplevel .t

   All the widgets displayed inside '.t' must also have '.t' as the root
of their path.  For example, to create a button widget for display
inside the '.t' toplevel the following would work:

     button .t.b -text "Inside 't'"

   (Attributes, such as size and title, of toplevel widgets can be
changed through the 'wm' command, which we will not cover in this
tutorial.  The reader is referred to the Tk manual.)

   Yet another kind of container is a _menu widget_.  It contains a list
of widgets to display inside itself, as a pulldown menu.  A simple entry
in a menu widget is a 'command' widget, displayed as an option in the
menu widget, which if chosen executes a Tcl command.  Other types of
widgets allowed inside a menu widget are radiobuttons and checkboxes.  A
special kind of menu item is a 'separator' that is used to group
together menu items within a menu.  (It should be noted that the widgets
inside a menu widget are special to that menu widget and do not have an
independent existence, and so do not have their own Tk name.)

   A menu widget is built by first creating an instance of a menu widget
(the container) and then invoking the 'add' method to make entries into
the menu.  An example of a menu widget is as follows:

     menu .m
     .m add command -label "Open file" -command "open_file"
     .m add command -label "Open directory" -command "open_directory"
     .m add command -label "Save buffer" -command "save_buffer"
     .m add command -label "Save buffer as..." -command "save_buffer_as"
     .m add separator
     .m add command -label "Make new frame" -command "new_frame"
     .m add command -label "Open new display" -command "new_display"
     .m add command -label "Delete frame" -command "delete_frame"

which creates a menu widget called '.m', which contains eight menu
items, the first four of which are commands, then comes a separator
widget, then the final three command entries.  (Some of you will notice
that this menu is a small part of the 'Files' menu from the menubar of
the Emacs text editor.)

   An example of a checkbox and some radiobutton widget entries:

     .m add checkbox -label "Inverse video" -variable inv_vid
     .m add radiobutton -label "black" -variable color
     .m add radiobutton -label "blue" -variable color
     .m add radiobutton -label "red" -variable color

which gives a checkbox displaying 'Inverse video', keeping its state in
the variable 'inv_vid', and three radiobuttons linked through the
variable 'color'.

   Another menu item variant is the 'cascade' variant, which is used to
make cascadable menus, i.e. menus that have submenus.  An example of a
cascade entry is the following:

     .m add cascade -label "I cascade" -menu .m.c

which adds a cascade entry to the menu '.m' that displays the text 'I
cascade'.  If the 'I cascade' option is chosen from the '.m' menu, then
the menu '.m.c' will be displayed.

   The cascade option is also used to make menubars at the top of an
application window.  A menu bar is simply a menu each element of which
is a cascade entry, (for example).  The menubar menu is attached to the
application window through a special configuration option for toplevel
widgets, the '-menu' option.  Then a menu is defined for each of the
cascade entry in the menubar menu.

   There are a large number of other variants to menu widgets: menu
items can display bitmaps instead of text; menus can be specified as
tear-off menus; accelerator keys can be defined for menu items; and so
on.

   A _menubutton widget_ displays like a button, but when activated a
menu pops up.  The menu of the menubutton is defined through the 'menu'
command and is attached to the menubutton.  An example of a menu button:

     menubutton .mb -menu .mb.m -text "mymenu"
     menu .mb.m
     .mb.m add command -label hello
     .mb.m add command -label goodbye

which crates a menubutton widget named '.mb' with attached menu '.mb.m'
and displays the text 'mymenu'.  Menu '.mb.m' is defined as two command
options, one labelled 'hello' and the other labelled 'goodbye'.  When
the menubutton '.mb' is clicked on, the menu '.mb.m' will popup and its
options can be chosen.

   A _canvas widget_ is a container widget that is used to manage the
drawing of complex shapes; for example, squares, circles, ovals, and
polygons.  (It can also handle bitmaps, text and most of the Tk widgets
too.)  The shapes may have borders, filled in, be clicked on, moved
around, and manipulated.

   We will not cover the working of the canvas widget here.  It is
enough to know that there is a powerful widget in the Tk toolkit that
can handle all manner of graphical objects.  The interested reader is
referred to the Tk manual.

   A _text widget_ is another powerful container widget that handles
multi-line texts.  The textwidget can display texts with varying font
styles, sizes, and colors in the same text, and can also handle other Tk
widgets embedded in the text.

   The text widget is a rich and complicated widget and will not be
covered here.  The interested reader is referred to the Tk manual.


File: sicstus.info,  Node: Geometry Managers,  Next: Event Handling,  Prev: Widget Creation,  Up: Tk

10.39.3.5 Geometry Managers
...........................

So far we have described each of the Tk widgets but have not mentioned
how they are arranged to be displayed.  Tk separates the creating of
widgets from the way they are arranged for display.  The "geometry" of
the display is handled by a "geometry manager".  A geometry manager is
handed the set of widgets to display with instructions on their layout.
The layout instructions are particular to each geometry manager.

   Tk comes with three distinct geometry managers: 'grid', 'place', and
'pack'.  As might be expected the 'grid' geometry manager is useful for
creating tables of widgets, for example, a table of buttons.

   The 'place' geometry manager simply gives each widget an X and Y
coordinate and places them at that coordinate in their particular parent
window.

   The 'pack' geometry manager places widgets according to constraints,
like "these three button widgets should be packed together from the left
in their parent widget, and should resize with the parent".

   (In practice the 'grid' and 'pack' geometry managers are the most
useful because they can easily handle events such as resizing of the
toplevel window, automatically adjusting the display in a sensible
manner.  'place' is not so useful for this.)

   Each container widget (the master) has a geometry manager associated
with it, which tells the container how to display its sub-widgets
(slaves) inside it.  A single master has one and only one kind of
geometry manager associated with it, but each master can have a
different kind.  For example, a frame widget can use the packer to pack
other frames inside it.  One of the slave frames could use the grid
manager to display buttons inside it itself, while another slave frame
could use the packer to pack labels inside it itself.

   The problem is how to display widgets.  For example, there is an
empty frame widget inside which a bunch of other widgets will be
displayed.  The 'pack' geometry manager's solution to this problem is to
successively pack widgets into the empty space left in the container
widget.  The container widget is the master widget, and the widgets
packed into it are its slaves.  The slaves are packed in a sequence: the
packing order.

   What the packer does is to take the next slave to be packed.  It
allocates an area for the slave to be packed into from the remaining
space in the master.  Which part of the space is allocated depends on
instructions to the packer.  When the size of the space has been
determined, this is sliced off the free space, and allocated to the
widget that is displayed in it.  Then the remaining space is available
to subsequent slaves.

   At any one time the space left for packing is a rectangle.  If the
widget is too small to use up a whole slice from the length or breadth
of the free rectangle, then still a whole slice is allocated so that the
free space is always rectangular.

   It can be tricky to get the packing instructions right to get the
desired finished effect, but a large number of arrangements of widgets
is possible using the packer.

   Let us take a simple example: three buttons packed into the root
window.  First we create the buttons; see also
'library('tcltk/examples/ex3.tcl')':

     button .b1 -text b1
     button .b2 -text b2
     button .b3 -text b3

then we can pack them thus:

     pack .b1 .b2 .b3

which produces a display of the three buttons, one on top of the other,
button '.b1' on the top, and button '.b3' on the bottom.


 [image src="images/tcltkex3.png" text="" ]
                          Three Plain Buttons

   If we change the size of the text in button '.b2' through the
command:

     .b2 config -text "hello world"

then we see that the window grows to fit the middle button, but the
other two buttons stay their original size.


 [image src="images/tcltkex4.png" text="" ]
                         Middle Button Widens

   The packer defaults to packing widgets in from the top of the master.
Other directions can be specified.  For example, the command:

     pack .b1 .b2 .b3 -side left

will pack starting at the left hand side of the window.  The result of
this is that the buttons are formed in a horizontal row with the wider
button, '.b2', in the middle.


 [image src="images/tcltkex5.png" text="" ]
                         Packing From The Left

   It is possible to leave space between widgets through the _padding_
options to the packer: '-padx' and '-pady'.  What these do is to
allocate space to the slave that is padded with the padding distances.
An example would be:

     pack .b1 .b2 .b3 -side left -padx 10


 [image src="images/tcltkex6.png" text="" ]
                           External Padding

which adds 10 pixels of space to either side of the button widgets.
This has the effect of leaving 10 pixels at the left side of button
'.b1', 20 pixels between buttons '.b1' and '.b2', 20 pixels between
buttons '.b2' and '.b3', and finally 10 pixels on the right side of
button '.b3'.

   That was external padding for spacing widgets.  There is also
internal padding for increasing the size of widgets in the X and Y
directions by a certain amount, through '-ipadx' and '-ipady' options;
i.e. internal padding.  For example:

     pack .b1 .b2 .b3 -side left -ipadx 10 -ipady 10


 [image src="images/tcltkex7.png" text="" ]
                           Internal Padding

instead of spacing out the widgets, will increase their dimensions by 10
pixels in each direction.

   Remember that space is allocated to a widget from the currently
available space left in the master widget by cutting off a complete
slice from that space.  It is often the case that the slice is bigger
that the widget to be displayed in it.

   There are further options for allowing a widget to fill the whole
slice allocated to it.  This is done through the '-fill' option, which
can have one of four values: 'none' for no filling (default), 'x' to
fill horizontally only, 'y' to fill vertically only, and 'both' to fill
both horizontally and vertically at the same time.

   Filling is useful, for example, for creating buttons that are the
same size even though they display texts of differing lengths.  To take
our button example again, the following code produces three buttons, one
on top of each other, but of the same size:

     button .b1 -text b1
     button .b2 -text "hello world"
     button .b3 -text b3
     pack .b1 .b2 .b3 -fill x


 [image src="images/tcltkex8.png" text="" ]
                 Using 'fill' For Evenly Sized Widgets

   How does this work?  The width of the toplevel windows is dictated by
button '.b2' because it has the widest text.  Because the three buttons
are packed from top to bottom, the slices of space allocated to them are
cut progressively straight along the top of the remaining space.  i.e.
each widget gets a horizontal slice of space the same width cut from the
top-level widget.  Only the wide button '.b2' would normally fit the
whole width of its slice.  But by allowing the other two widgets to fill
horizontally, they will also take up the whole width of their slices.
The result: 3 buttons stacked on top of each other, each with the same
width, although the texts they display are not the same length.

   A further common example is adding a scrollbar to a listbox.  The
trick is to get the scrollbar to size itself to the listbox; see also
'library('tcltk/examples/ex9a.tcl')':

     listbox .l
     scrollbar .s
     pack .l .s -side left


 [image src="images/tcltkex9a.png" text="" ]
                   Scrollbar With Listbox, First Try

   So far we have a listbox on the left and a tiny scrollbar on the
right.  To get the scrollbar to fill up the vertical space around it add
the following command:

     pack .s -fill y

   Now the display looks like a normal listbox with a scrollbar.


 [image src="images/tcltkex9b.png" text="" ]
                  Scrollbar With Listbox, Second Try

   Why does this work?  They are packed from the left, so first a large
vertical slice of the master is given to the listbox, then a thin
vertical slice is given to the scrollbar.  The scrollbar has a small
default width and height and so it does not fill the vertical space of
its slice.  But filling in the vertical direction (through the 'pack .s
-fill y' command) allows it to fill its space, and so it adjusts to the
height of the listbox.

   The 'fill' packing option specifies whether the widget should fill
space left over in its slice of space.  A further option to take into
account is what happens when the space allocated to the master widget is
much greater than the that used by its slaves.  This is not usually a
problem initially because the master container widget is sized to
shrink-wrap around the space used by its slaves.  If the container is
subsequently resized, however, to a much larger size, then there is a
question as to what should happen to the slave widgets.  A common
example of resizing a container widget is the resizing of a top-level
window widget.

   The default behavior of the packer is not to change the size or
arrangement of the slave widgets.  There is an option though through the
'expand' option to cause the slices of space allocated to slaves to
expand to fill the newly available space in the master.  'expand' can
have one of two values: '0' for no expansion, and '1' for expansion.

   Take the listbox-scrollbar example; see also
'library('tcltk/examples/ex10.tcl')':

     listbox .l
     scrollbar .s
     pack .l -side left
     pack .s -side left -fill y

   Initially this looks good, but now resize the window to a much bigger
size.  You will find that the listbox stays the same size and that empty
space appears at the top and bottom of it, and that the scrollbar
resizes in the vertical.  It is now not so nice.


 [image src="images/tcltkex10.png" text="" ]
             Scrollbar And Listbox, Problems With Resizing

   We can fix part of the problem by having the listbox expand to fill
the extra space generated by resizing the window.

     pack .l -side left -expand 1


 [image src="images/tcltkex10a.png" text="" ]
                  Scrollbar And Listbox, Almost There

   The problem now is that 'expand' just expands the space allocated to
the listbox, it does not stretch the listbox itself.  To achieve that we
need to apply the 'fill' option to the listbox too.

     pack .l -side left -expand 1 -fill both


 [image src="images/tcltkex10b.png" text="" ]
          Scrollbar And Listbox, Problem Solved Using 'fill'

   Now whichever way the top-level window is resized, the
listbox-scrollbar combination should look good.

   If more than one widget has the expansion bit set, then the space is
allocated equally to those widgets.  This can be used, for example, to
make a row of buttons of equal size that resize to fill the widget of
their container.  Try the following code; see also
'library('tcltk/examples/ex11.tcl')':

     button .b1 -text "one"
     button .b2 -text "two"
     button .b3 -text "three"
     pack .b1 .b2 .b3 -side left -fill x -expand 1


 [image src="images/tcltkex11.png" text="" ]
                     Resizing Evenly Sized Widgets

   Now resize the window.  You will see that the buttons resize to fill
the width of the window, each taking an equal third of the width.

     *Please note*: the best way to get the hang of the packer is to
     play with it.  Often the results are not what you expect,
     especially when it comes to fill and expand options.  When you have
     created a display that looks pleasing, always try resizing the
     window to see if it still looks pleasing, or whether some of your
     fill and expand options need revising.

   There is an option to change how a slave is displayed if its
allocated space is larger than itself.  Normally it will be displayed
centered.  That can be changed by anchoring it with the '-anchor'
option.  The option takes a compass direction as its argument: 'n', 's',
'e', 'w', 'nw', 'ne', 'sw', 'se', or 'c' (for center).

   For example, the previous example with the resizing buttons displays
the buttons in the center of the window, the default anchoring point.
If we wanted the buttons to be displayed at the top of the window, then
we would anchor them there thus; see also
'library('tcltk/examples/ex12.tcl')':

     button .b1 -text "one"
     button .b2 -text "two"
     button .b3 -text "three"
     pack .b1 .b2 .b3 -side left -fill x -expand 1 -anchor n


 [image src="images/tcltkex12.png" text="" ]
                           Anchoring Widgets

   Each button is anchored at the top of its slice and so in this case
is displayed at the top of the window.

   The packing order of widget can also be changed.  For example,

     pack .b3 -before .b2

will change the positions of '.b2' and '.b3' in our examples.


 [image src="images/tcltkex13.png" text="" ]
                 Changing The Packing Order Of Widgets

   The _grid geometry manager_ is useful for arranging widgets in grids
or tables.  A grid has a number of rows and columns and a widget can
occupy one of more adjacent rows and columns.

   A simple example of arranging three buttons; see also
'library('tcltk/examples/ex14.tcl')':

     button .b1 -text b1
     button .b2 -text b2
     button .b3 -text b3
     grid .b1 -row 0 -column 0
     grid .b2 -row 1 -column 0
     grid .b3 -row 0 -column 1 -rowspan 2

this will display button '.b1' above button '.b2'.  Button '.b3' will be
displayed in the next column and it will take up two rows.


 [image src="images/tcltkex14.png" text="" ]
                   Using the 'grid' Geometry Manager

   However, '.b3' will be displayed in the center of the space allocated
to it.  It is possible to get it to expand to fill the two rows it has
using the '-sticky' option.  The '-sticky' option says to which edges of
its cells a widget "sticks" to, i.e. expands to reach.  (This is like
the fill and expand options in the pack manager.)  So to get '.b3' to
expand to fill its space we could use the following:

     grid .b3 -sticky ns

which says stick in the north and south directions (top and bottom).
This results in '.b3' taking up two rows and filling them.


 [image src="images/tcltkex15.png" text="" ]
           'grid' Geometry Manager, Cells With Sticky Edges

   There are plenty of other options to the grid geometry manager.  For
example, it is possible to give some rows/columns more "weight" than
others, which gives them more space in the master.  For example, if in
the above example you wanted to allocate 1/3 of the width of the master
to column 0 and 2/3 of the width to column 1, then the following
commands would achieve that:

     grid columnconfigure . 0 -weight 1
     grid columnconfigure . 1 -weight 2

which says that the weight of column 0 for master '.' (the root window)
is 1 and the weight of column 1 is 2.  Since column 1 has more weight
than column 0 it gets proportionately more space in the master.

   It may not be apparent that this works until you resize the window.
You can see even more easily how much space is allocated to each button
by making expanding them to fill their space through the sticky option.
The whole example looks like this; see also
'library('tcltk/examples/ex16.tcl')':

     button .b1 -text b1
     button .b2 -text b2
     button .b3 -text b3
     grid .b1 -row 0 -column 0 -sticky nsew
     grid .b2 -row 1 -column 0 -sticky nsew
     grid .b3 -row 0 -column 1 -rowspan 2 -sticky nsew
     grid columnconfigure . 0 -weight 1
     grid columnconfigure . 1 -weight 2

   Now resize the window to various sizes and we will see that button
'.b3' has twice the width of buttons '.b1' and '.b2'.


 [image src="images/tcltkex16.png" text="" ]
                      Changing Row/Column Ratios

   The same kind of thing can be specified for each row too via the
'grid rowconfigure' command.

   For other options and a full explanation of the grid manager see the
manual.

   'place' simply places the slave widgets in the master at the given x
and y coordinates.  It displays the widgets with the given width and
height.  For example (see also 'library('tcltk/examples/ex17.tcl')'):

     button .b1 -text b1
     button .b2 -text b2
     button .b3 -text b3
     place .b1 -x 0 -y 0
     place .b2 -x 100 -y 100
     place .b3 -x 200 -y 200


 [image src="images/tcltkex17.png" text="" ]
                  Using The 'place' Geometry Manager

will place the buttons '.b1', '.b2', and '.b3' along a diagonal 100
pixels apart in both the x and y directions.  Heights and widths can be
given in absolute sizes, or relative to the size of the master in which
case they are specified as a floating point proportion of the master;
0.0 being no size and 1.0 being the size of the master.  x and y
coordinates can also be specified in a relative way, also as a floating
point number.  For example, a relative y coordinate of 0.0 refers to the
top edge of the master, while 1.0 refers to the bottom edge.  If both
relative and absolute x and y values are specified, then they are
summed.

   Through this system the placer allows widgets to be placed on a kind
of rubber sheet.  If all the coordinates are specified in relative
terms, as the master is resized, then so will the slaves move to their
new relative positions.


File: sicstus.info,  Node: Event Handling,  Next: Miscellaneous,  Prev: Geometry Managers,  Up: Tk

10.39.3.6 Event Handling
........................

So far we have covered the widgets types, how instances of them are
created, how their attributes can be set and queried, and how they can
be managed for display using geometry managers.  What we have not
touched on is how to give each widget a behavior.

   This is done through event handlers.  Each widget instance can be
given a window event handler for each kind of window event.  A window
event is something like the cursor moving into or out of the widget, a
key press happening while the widget is active (in focus), or the widget
being destroyed.

   Event handlers are specified through the 'bind' command:

     bind WIDGETNAME EVENTSEQUENCE COMMAND

where WIDGETNAME is the name or class of the widget to which the event
handler should be attached, EVENTSQUEUENCE is a description of the event
that this event handler will handle, and COMMAND is a script that is
invoked when the event happens (i.e. it is the event handler).

   Common event types are

'Key'
'KeyPress'
     when a key was pressed

'KeyRelease'
     when a key was released

'Button'
'ButtonPress'
     when a mouse button was pressed

'ButtonRelease'
     when a mouse button was released

'Enter'
     when the cursor moves into a widget

'Leave'
     when the cursor moved our of a widget

'Motion'
     when the cursor moves within a widget

   There are other event types.  Please refer to the Tk documentation
for a complete list.

   The EVENTSEQUENCE part of a 'bind' command is a list of one or more
of these events, each event surrounded by angled brackets.  (Mostly, an
event sequence consists of handling a single event.  Later we will show
more complicated event sequences.)

   An example is the following:

     button .b -text "click me"
     pack .b
     bind .b <Enter> { puts "entering .b" }

makes a button '.b' displaying text 'click me' and displays it in the
root window using the packing geometry manager.  The 'bind' command
specifies that when the cursor enters (i.e. goes onto) the widget, then
the text 'entering .b' is printed at the terminal.

   We can make the button change color as the cursor enters or leaves it
like this:

     button .b -text "click me" -background red
     pack .b
     bind .b <Enter> { .b config -background blue }
     bind .b <Leave> { .b config -background red }

which causes the background color of the button to change to blue when
the cursor enters it and to change back to red when the cursor leaves.

   An action can be appended to an event handler by prefixing the action
with a '+' sign.  An example is:

     bind .b <Enter> {+puts "entering .b"}

which, when added to the example above, would not only change the color
of the button to red when the cursor enters it, but would also print
'entering .b' to the terminal.

   A binding can be revoked simply by binding the empty command to it:

     bind .b <Enter> {}

   A list of events that are bound can be found by querying the widget
thus:

     bind .b

which will return a list of bound events.

   To get the current command(s) bound to an event on a widget, invoke
'bind' with the widget name and the event.  An example is:

     bind .b <Enter>

which will return a list of the commands bound to the event <Enter> on
widget '.b'.

   Binding can be generalized to sequences of events.  For example, we
can create an entry widget that prints 'spells rob' each time the key
sequence 'ESC r o b' happens:

     entry .e
     pack .e
     bind .e <Escape>rob {puts "spells rob"}

   (A letter on its own in an event sequence stands for that key being
pressed when the corresponding widget is in focus.)

   Events can also be bound for entire classes of widgets.  For example,
if we wanted to perform the same trick for ALL entry widgets, then we
could use the following command:

     bind entry <Escape>rob {puts "spells rob"}

   In fact, we can bind events over all widgets using 'all' as the
widget class specifier.

   The event script can have substitutions specified in it.  Certain
textual substitutions are then made at the time the event is processed.
For example, '%x' in a script gets the x coordinate of the mouse
substituted for it.  Similarly, '%y' becomes the y coordinate, '%W' the
dot path of the window on which the event happened, '%K' the keysym of
the button that was pressed, and so on.  For a complete list, see the
manual.

   In this way it is possible to execute the event script in the context
of the event.

   A clever example of using the 'all' widget specifier and text
substitutions is given in John Ousterhout's book on Tcl/Tk (*note
Resources::):

     bind all <Enter> {puts "Entering %W at (%x, %y)"}
     bind all <Leave> {puts "Leaving %W at (%x, %y)"}
     bind all <Motion> {puts "Pointer at (%x, %y)"}

which implements a mouse tracker for all the widgets in a Tcl/Tk
application.  The widget's name and x and y coordinates are printed at
the terminal when the mouse enters or leaves any widget, and also the x
and y coordinates are printed when the mouse moves within a widget.


File: sicstus.info,  Node: Miscellaneous,  Next: What We Have Left Out (Tk),  Prev: Event Handling,  Up: Tk

10.39.3.7 Miscellaneous
.......................

There are a couple of other Tk commands that we ought to mention:
'destroy' and 'update'.

   The 'destroy' command is used to destroy a widget, i.e. remove it
from the Tk interpreter entirely and so from the display.  Any children
that the widget may have are also 'destroy'-ed.  Anything connected to
the destroyed widget, such as bindings, are also cleaned up
automatically.

   For example, to create a window containing a button that is destroyed
when the button is pressed:

     button .b -text "Die!" -command { destroy . }
     pack .b

creates a button '.b' displaying the text 'Die!', which runs the command
'destroy .' when it is pressed.  Because the widget '.' is the main
toplevel widget or window, running that command will kill the entire
application associated with that button.

   The command 'update' is used to process any pending Tk events.  An
event is not just such things as moving the mouse but also updating the
display for newly created and displayed widgets.  This may be necessary
in that usually Tk draws widgets only when it is idle.  Using the
'update' command forces Tk to stop and handle any outstanding events
including updating the display to its actually current state, i.e.
flushing out the pending display of any widgets.  (This is analogous to
the 'fflush' command in C that flushes writes on a stream to disk.  In
Tk displaying of widgets is "buffered"; calling the 'update' command
flushes the buffer.)


File: sicstus.info,  Node: What We Have Left Out (Tk),  Next: Queens Display,  Prev: Miscellaneous,  Up: Tk

10.39.3.8 What We Have Left Out
...............................

There are a number of Tk features that we have not described but we list
some of them here in case the reader is interested.  Refer to the Tk
manual for more explanation.

'photo'
     creating full color images through the command

'wm'
     setting and getting window attributes

selection and focus commands

modal interaction
     (not recommended)

'send'
     sending messages between Tk applications


File: sicstus.info,  Node: Queens Display,  Prev: What We Have Left Out (Tk),  Up: Tk

10.39.3.9 Example pure Tcl/Tk program
.....................................

To show some of what can be done with Tcl/Tk, we will show an example of
part of a GUI for an 8-queens program.  Most people will be familiar
with the 8-queens problem: how to place 8 queens on a chess board such
that they do not attack each other according to the normal rules of
chess.

   Our example will not be a program to solve the 8-queens problem (that
will come later in the tutorial) but just the Tcl/Tk part for displaying
a solution.  The code can be found in
'library('tcltk/examples/ex18.tcl')'.

   The way an 8-queens solution is normally presented is as a list of
numbers.  The position of a number in the list indicates the column the
queens is placed at and the number itself indicates the row.  For
example, the Prolog list '[8, 7, 6, 5, 4, 3, 2, 1]' would indicate 8
queens along the diagonal starting a column 1, row 8 and finishing at
column 8 row 1.

   The problem then becomes, given this list of numbers as a solution,
how to display the solution using Tcl/Tk.  This can be divided into two
parts: how to display the initial empty chess board, and how to display
a queen in one of the squares.

   Here is our code for setting up the chess board:

                                                            _% ex18.pl_
     #! /usr/bin/wish

     proc setup_board { } {
         # create container for the board
         frame .queens

         # loop of rows and columns
         for {set row 1} {$row <= 8} {incr row} {
             for {set column 1} {$column <= 8} {incr column} {

                 # create label with a queen displayed in it
                 label .queens.$column-$row -bitmap @bitmaps/q64s.bm -relief flat

                 # choose a background color depending on the position of the
                 # square; make the queen invisible by setting the foreground
                 # to the same color as the background
                 if { [expr ($column + $row) % 2] } {
                     .queens.$column-$row config -background #ffff99
                     .queens.$column-$row config -foreground #ffff99
                 } else {
                     .queens.$column-$row config -background #66ff99
                     .queens.$column-$row config -foreground #66ff99
                 }

                 # place the square in a chess board grid
                 grid .queens.$column-$row -row $row -column $column -padx 1 -pady 1
             }
         }
         pack .queens
     }

     setup_board

   The first thing that happens is that a frame widget is created to
contain the board.  Then there are two nested loops that loop over the
rows and columns of the chess board.  Inside the loop, the first thing
that happens is that a label widget is created.  It is named using the
row and column variables so that it can be easily referenced later.  The
label will not be used to display text but to display an image, a bitmap
of a queen.  The label creation command therefore has the special
argument '-bitmap @q64s.bm', which says that the label will display the
bitmap loaded from the file 'q64s.bm'.

   The label with the queen displayed in it has now been created.  The
next thing that happens is that the background color of the label
(square) is chosen.  Depending on the position of the square it becomes
either a "black" or a "white" square.  At the same time, the foreground
color is set to the background color.  This is so that the queen
(displayed in the foreground color) will be invisible, at least when the
board is first displayed.

   The final action in the loop is to place the label (square) in
relation to all the other squares for display.  A chess board is a
simple grid of squares, and so this is most easily done through the
'grid' geometry manager.

   After the board has been set up square-by-square it still needs to be
displayed, which is done by 'pack'-ing the outermost frame widget.

   To create and display a chess board widget, all that is needed is to
call the procedure

     setup_board

which creates the chess board widget.

   Once the chess board has been displayed, we need to be able to take a
solution, a list of rows ordered by column, and place queens in the
positions indicated.

   Taking a topdown approach, our procedure for taking a solution and
displaying is as follows:

     proc show_solution { solution } {
         clear_board
         set column 1
         foreach row $solution {
             place_queen $column $row
             incr column
         }
     }

   This takes a solution in 'solution', clears the board of all queens,
and then places each queen from the solution on the board.

   Next we will handle clearing the board:

     proc clear_board { } {
         for { set column 1 } {$column <= 8} {incr column} {
             reset_column $column
         }
     }

     proc reset_column { column } {
         for {set row 1 } { $row <= 8 } {incr row} {
             set_queens $column $row off
         }
     }

     proc set_queens { column row state } {
         if { $state == "on" } {
             .queens.$column-$row config -foreground black
         } else {
             .queens.$column-$row config
             -foreground [.queens.$column-$row cget -background]
         }
     }

   The procedure 'clear_board' clears the board of queens by calling the
procedure 'reset_column' for each of the 8 columns on a board.
'reset_column' goes through each square of a column and sets the square
to 'off' through 'set_queens'.  In turn, 'set_queens' sets the
foreground color of a square to black if the square is turned 'on', thus
revealing the queen bitmap, or sets the foreground color of a square to
its background color, thus making the queens invisible, if it is called
with something other than 'on'.

   That handles clearing the board, clearing a column or turning a queen
on or off on a particular square.

   The final part is 'place_queen':

     proc place_queen { column row } {
         reset_column $column
         set_queens $column $row on
     }

   This resets a column so that all queens on it are invisible and then
sets the square with coordinates given in 'row' and 'column' to on.

   A typical call would be:

     show_solution "1 2 3 4 5 6 7 6 8"


 [image src="images/tcltkex18.png" text="" ]
                      8-Queens Display In Tcl/Tk

which would display queens along a diagonal.  (This is of course not a
solution to the 8-queens problem.  This Tcl/Tk code only displays
possible queens solutions; it does not check if the solution is valid.
Later we will combine this Tcl/Tk display code with Prolog code for
generating solutions to the 8-queens problem.)


File: sicstus.info,  Node: The Tcl/Tk Prolog Library,  Next: Putting It All Together,  Prev: Tk,  Up: lib-tcltk

10.39.4 The Tcl/Tk Prolog Library
---------------------------------

Now we have covered the wonders of Tcl/Tk, we come to the real meat of
the tutorial: how to couple the power of Tcl/Tk with the power of
SICStus Prolog.

   Tcl/Tk is included in SICStus Prolog by loading a special library.
The library provides a bidirectional interface between Tcl/Tk and
Prolog.

* Menu:

* How it Works - An Overview:: How it Works - An Overview
* Basic Functions:: Basic Functions
* Evaluation Functions:: Evaluation Functions
* Event Functions:: Event Functions
* Servicing Tk Events:: Servicing Tcl and Tk events
* Passing Control to Tk:: Passing Control to Tk
* Housekeeping:: Housekeeping functions
* Summary:: Summary


File: sicstus.info,  Node: How it Works - An Overview,  Next: Basic Functions,  Up: The Tcl/Tk Prolog Library

10.39.4.1 How it Works - An Overview
....................................

Before describing the details of the Tcl/Tk library we will give an
overview of how it works with the Prolog system.

   The Tcl/Tk library provides a loosely coupled integration of Prolog
and Tcl/Tk.  By this we mean that the two systems, Prolog and Tcl/Tk,
although joined through the library, are mostly separate; Prolog
variables have nothing to do with Tcl variables, Prolog and Tcl program
states are separate, and so on.

   The Tcl/Tk library extends Prolog so that Prolog can create a number
of independent Tcl interpreters with which it can interact.  Basically,
there is a predicate, which when executed creates a Tcl interpreter and
returns a handle with which Prolog can interact with the interpreter.

   Prolog and a Tcl interpreter interact, and so communicate and
cooperate, through two ways:

  1. One system evaluates a code fragment in the other system and
     retrieves the result.  For example, Prolog evaluates a Tcl code
     fragment in an attached Tcl interpreter and gets the result of the
     evaluation in a Prolog variable.  Similarly, a Tcl interpreter can
     evaluate a Prolog goal and get the result back through a Tcl
     variable.

     This is synchronous communication in that the caller waits until
     the callee has finished their evaluation and reads the result.

  2. One system passing a "message" to the other on an "event" queue.

     This is asynchronous communication in that the receiver of the
     message can read the message whenever it likes, and the sender can
     send the message without having to wait for a reply.

   The Tk part of Tcl/Tk comes in because an attached Tcl interpreter
may be extended with the Tk widget set and so be a Tcl/Tk interpreter.
This makes it possible to add GUIs to a Prolog application: the
application loads the Tcl/Tk Prolog library, creates a Tcl/Tk
interpreter, and sends commands to the interpreter to create a Tk GUI.
The user interacts with the GUI and therefore with the underlying Prolog
system.

   There are two main ways to partition the Tcl/Tk library functions: by
function, i.e. the task they perform; or by package, i.e. whether they
are Tcl, Tk, or Prolog functions.  We will describe the library in terms
of the former because it fits in with the tutorial style better, but at
the end is a summary section that summarizes the library functions both
ways.

   Taking the functional approach, the library can be split into six
function groups:

   * basic functions
        - loading the library
        - creating and destroying Tcl and Tcl/Tk interpreters
   * evaluation functions
        - evaluating Tcl expressions from Prolog
        - evaluating Prolog expressions from Tcl
   * Prolog event functions
        - handling the Prolog/Tcl event queue
   * Tk event handling
   * passing control to Tk
   * housekeeping functions

   We go through each group in turn.


File: sicstus.info,  Node: Basic Functions,  Next: Evaluation Functions,  Prev: How it Works - An Overview,  Up: The Tcl/Tk Prolog Library

10.39.4.2 Basic Functions
.........................

The heart of the system is the ability to create an embedded Tcl
interpreter with which the Prolog system can interact.  A Tcl
interpreter is created within Prolog through a call to 'tcl_new/1':

     tcl_new(-TCLINTERPRETER)

which creates a new interpreter, initializes it, and returns a reference
to it in the variable TCLINTERPRETER.  The reference can then be used in
subsequent calls to manipulate the interpreter.  More than one Tcl
interpreter object can be active in the Prolog system at any one time.

   To start a Tcl interpreter extended with Tk, the 'tk_new/2' predicate
is called from Prolog.  It has the following form:

     tk_new(+OPTIONS, -TCLINTERPRETER)

which returns through the variable TCLINTERPRETER a handle to the
underlying Tcl interpreter.  The usual Tcl/Tk window pops up after this
call is made and it is with reference to that window that subsequent
widgets are created.  As with the 'tcl_new/1' predicate, many Tcl/Tk
interpreters may be created from Prolog at the same time through calls
to 'tk_new/2'.

   The OPTIONS part of the call is a list of some (or none) of the
following elements:

'top_level_events'
     This allows Tk events to be handled while Prolog is waiting for
     terminal input; for example, while the Prolog system is waiting for
     input at the top-level prompt.  Without this option, Tk events are
     not serviced while the Prolog system is waiting for terminal input.
     (For information on Tk events; *note Event Handling::).

'name(+APPLICATIONNAME)'
     This gives the main window a title APPLICATIONNAME.  This name is
     also used for communicating between Tcl/Tk applications via the Tcl
     'send' command.  ('send' is not covered in this document.  Please
     refer to the Tcl/Tk documentation.)

'display(+DISPLAY)'
     (This is X windows specific.)  Gives the name of the screen on
     which to create the main window.  If this is not given, then the
     default display is determined by the 'DISPLAY' environment
     variable.

   An example of using 'tk_new/2':

     | ?- tk_new([top_level_events, name('My SICStus/Tk App')], Tcl).

which creates a Tcl/Tk interpreter, returns a handle to it in the
variable 'Tcl' and Tk events are serviced while Prolog is waiting at the
top-level prompt.  The window that pops up will have the title 'My
SICStus/Tk App'.

   The reference to a Tcl interpreter returned by a call to 'tk_new/2'
is used in the same way and in the same places as a reference returned
by a call to 'tcl_new/1'.  They are both references to Tcl interpreters.

   To remove a Tcl interpreter from the system, use the 'tcl_delete/1'
predicate:

     tcl_delete(+TCLINTERPRETER)

which given a reference to a Tcl interpreter, closes down the
interpreter and removes it.  The reference can be for a plain Tcl
interpreter or for a Tk enhanced one; 'tcl_delete/1' removes both kinds.


File: sicstus.info,  Node: Evaluation Functions,  Next: Event Functions,  Prev: Basic Functions,  Up: The Tcl/Tk Prolog Library

10.39.4.3 Evaluation Functions
..............................

There are two functions in this category: Prolog extended to be able to
evaluate Tcl expressions in a Tcl interpreter; Tcl extended to be able
to evaluate a Prolog expression in the Prolog system.

   There is a mechanism for describing Tcl commands in Prolog as Prolog
terms.  This is used in two ways: firstly, to be able to represent Tcl
commands in Prolog so that they can be subsequently passed to Tcl for
evaluation; and secondly for passing terms back from Tcl to Prolog by
doing the reverse transformation.

   Why not represent a Tcl command as a simple atom or string?  This can
indeed be done, but commands are often not static and each time they are
called require slightly different parameters.  This means constructing
different atoms or strings for each command in Prolog, which are
expensive operations.  A better solution is to represent a Tcl command
as a Prolog term, something that can be quickly and efficiently
constructed and stored by a Prolog system.  Variable parts to a Tcl
command (for example command arguments) can be passed in through Prolog
variables.

   In the special command format, a Tcl command is specified as follows.

COMMAND        ::= NAME
               | 'codes("code-list")'
               | 'write("term")'
               | 'writeq("term")'
               | 'write_canonical("term")'
               | 'format(FMT,ARGS)'
               | 'dq(COMMAND)'
               | 'br(COMMAND)'
               | 'sqb(COMMAND)'
               | 'min(COMMAND)'
               | 'dot(LISTOFNAMES)'
               | 'list(LISTOFCOMMANDS)'
               | LISTOFCOMMANDS
FMT            ::= "atom"
NAME           ::= "atom"                    { other than '[]' }
               | "number"
LISTOFCOMMANDS ::= '[]'
               | '[ COMMAND |
               LISTOFCOMMANDS ]'
LISTOFNAMES    ::= '[]'
               | '[ NAME | LISTOFNAMES ]'
ARGS           ::= '[]'
               | '[ "term" | ARGS ]'

where

ATOM
NUMBER
     denote their printed representations
'codes(PROLOGSTRING)'
     denotes the string represented by PROLOGSTRING (a code-list)
'write(TERM)'
'writeq(TERM)'
'write_canonical(TERM)'
     denotes the string that is printed by the corresponding built-in
     predicate.

          *Please note*: In general it is not possible to reconstruct
          TERM from the string printed by 'write/1'.  If TERM will be
          passed back into Prolog, then it therefore safest to use
          'write_canonical(TERM)'.

'format(FMT, ARGS)'
     denotes the string that is printed by the corresponding built-in
     predicate
'dq(COMMAND)'
     denotes the string specified by COMMAND, enclosed in double quotes
'br(COMMAND)'
     denotes the string specified by COMMAND, enclosed in curly brackets
'sqb(COMMAND)'
     denotes the string specified by COMMAND, enclosed in square
     brackets
'min(COMMAND)'
     denotes the string specified by COMMAND, immediately preceded by a
     hyphen
'dot(LISTOFNAME)'
     denotes the widget path specified by LISTOFNAME, preceded by and
     separated by dots
'list(LISTOFCOMMANDS)'
     denotes the TCL list with one element for each element in
     LISTOFCOMMANDS.  This differs from just using LISTOFCOMMANDS or
     'br(LISTOFCOMMANDS)' when any of the elements contains spaces,
     braces or other characters treated specially by TCL.
LISTOFCOMMANDS
     denotes the string denoted by each element, separated by spaces.
     In many cases 'list(LISTOFCOMMANDS)' is a better choice.

   Examples of command specifications and the resulting Tcl code:

     [set, x, 32]
         => set x 32

     [set, x, br([a, b, c])]
         => set x {a b c}

     [dot([panel,value_info,name]), configure, min(text), br(write('$display'/1))]
          => .panel.value_info.name configure -text {$display/1 

     ['foo bar',baz]
          =>foo bar baz

     list(['foo bar',bar])
          => {foo bar} baz

     list(['foo { bar'',bar])
          => foo\ \{ \bar baz

   Prolog calls Tcl through the predicate 'tcl_eval/3', which has the
following form:

     tcl_eval(+TCLINTERPRETER, +COMMAND, -RESULT)

which causes the interpreter TCLINTERPRETER to evaluate the Tcl command
COMMAND and return the result RESULT.  The result is a string (a
code-list) that is the usual return string from evaluating a Tcl
command.  COMMAND is not just a simple Tcl command string (although that
is a possibility) but a Tcl command represented as a Prolog term in the
special Command Format (*note Evaluation Functions::).

   Through 'tcl_eval/3', Prolog has a method of synchronous
communication with an embedded Tcl interpreter and a way of manipulating
the state of the interpreter.

   An example:

     | ?- tcl_new(Interp), 
          tcl_eval(Interp, 'set x 1', _),
          tcl_eval(Interp, 'incr x', R).

which creates a Tcl interpreter the handle of which is stored in the
variable 'Interp'.  Then variable 'x' is set to the value '"1"' and then
variable 'x' is incremented and the result returned in 'R' as a string.
The result will be "2".  By evaluating the Tcl commands in separate
'tcl_eval/3' calls, we show that we are manipulating the state of the
Tcl interpreter and that it remembers its state between manipulations.

   It is worth mentioning here also that because of the possibility of
the Tcl command causing an error to occur in the Tcl interpreter, two
new exceptions are added by the 'tcltk' library:

     tcl_error(GOAL, MESSAGE)
     tk_error(GOAL, MESSAGE)

where MESSAGE is a code-list detailing the reason for the exception.
Also two new 'user:portray_message/2' rules are provided so that any
such uncaught exceptions are displayed at the Prolog top-level as

     [TCL ERROR: GOAL - MESSAGE]
     [TK ERROR: GOAL - MESSAGE]

respectively.

   These exception conditions can be raised/caught/displayed in the
usual way through the built-in predicates 'raise_exception/3',
'on_exception/1', and 'portray_message/2'.

   As an example, the following Prolog code will raise such an
exception:

     | ?- tcl_new(X), tcl_eval(X, 'wilbert', R).

which causes a 'tcl_error/2' exception and prints the following:

     {TCL ERROR: tcl_eval/3 - invalid command name "wilbert"}

assuming that there is no command or procedure defined in Tcl called
'wilbert'.

   The Tcl interpreters created through the SICStus Prolog Tcl/Tk
library have been extended to allow calls to the underlying Prolog
system.

   To evaluate a Prolog expression in the Prolog system from a Tcl
interpreter, the new 'prolog' Tcl command is invoked.  It has the
following form:

     prolog PROLOGGOAL

where PROLOGGOAL is the printed form of a Prolog goal.  This causes the
goal to be executed in Prolog.  It will be executed in the 'user' module
unless it is prefixed by a module name.  Execution is always
determinate.

   The return value of the command either of the following:

'"1"'
     if execution succeeded,
'"0"'
     if execution failed.

   If succeeded (and "1" was returned), then any variable in PROLOGGOAL
that has become bound to a Prolog term will be returned to Tcl in the
Tcl array named 'prolog_variables' with the variable name as index.  The
term is converted to Tcl using the same conversion as used for Tcl
commands (*note Evaluation Functions::).  As a special case the values
of unbound variables and variables with names starting with '_', are not
recorded and need not conform to the special command format, this is
similar to the threatment of such variables by the Prolog top-level.

   An example:

     test_callback(Result) :-
         tcl_new(Interp),
         tcl_eval(Interp,
             'if {[prolog "foo(X,Y,Z)"] == 1} \\
                 {list $prolog_variables(X) \\
                       $prolog_variables(Y) \\
                       $prolog_variables(Z)}',
                 Result),
         tcl_delete(Interp).

     foo(1, bar, [a, b, c]).

   When called with the query:

     | ?- test_callback(Result).

will succeed, binding the variable 'Result' to:

     "1 bar {a b c}"

   This is because execution of the 'tcl_eval/3' predicate causes the
execution of the 'prolog' command in Tcl, which executes 'foo(X, Y, Z)'
in Prolog making the following bindings: 'X = 1', 'Y = bar', 'Z = [a, b,
c]'.  The bindings are returned to Tcl in the associative array
'prolog_variables' where 'prolog_variables(X)' is "1",
'prolog_variables(Y)' is "bar", and 'prolog_variables(Z)' is "a b c".
Then Tcl goes on to execute the 'list' command as

     list "1" "bar" "a b c"

which returns the result

     "1 bar {a b c}"

(remember: nested lists magically get represented with curly brackets)
which is the string returned in the RESULT part of the Tcl call, and is
ultimately returned in the 'Result' variable of the top-level call to
'test_callback(Result)'.

   If an error occurs during execution of the 'prolog' Tcl command, then
a 'tcl_error/2' exception will be raised.  The message part of the
exception will be formed from the string 'Exception during Prolog
execution: ' appended to the Prolog exception message.  An example is
the following:

     | ?- tcl_new(T), tcl_eval(T, 'prolog wilbert', R).

which will print

     {TCL ERROR: tcl_eval/3 - Exception during Prolog execution:
       wilbert  existence_error(wilbert,0,procedure,user:wilbert/0,0)}

at the Prolog top-level, assuming that the predicate 'wilbert/0' is not
defined on the Prolog side of the system.  (This is a 'tcl_error'
exception containing information about the underlying exception, an
'existence_error' exception, which was caused by trying to execute the
non-existent predicate 'wilbert'.)


File: sicstus.info,  Node: Event Functions,  Next: Servicing Tk Events,  Prev: Evaluation Functions,  Up: The Tcl/Tk Prolog Library

10.39.4.4 Event Functions
.........................

Another way for Prolog to communicate with Tcl is through the predicate
'tcl_event/3':

     tcl_event(+TCLINTERPRETER, +COMMAND, -EVENTS)

   This is similar to 'tcl_eval/3' in that the command COMMAND is
evaluated in the Tcl interpreter TCLINTERPRETER, but the call returns a
list of events in EVENTS rather than the result of the Tcl evaluation.
COMMAND is again a Tcl command represented as a Prolog term in the
special Command Format described previously (*note Evaluation
Functions::).

   This begs the questions what are these events and where does the
event list come from?  The Tcl interpreters in the SICStus Prolog Tcl/Tk
library have been extended with the notion of a Prolog event queue.
(This is not available in plain standalone Tcl interpreters.)  The Tcl
interpreter can put events on the event queue by executing a
'prolog_event' command.  Each event is a Prolog term.  So a Tcl
interpreter has a method of putting Prolog terms onto a queue, which can
later be picked up by Prolog as a list as the result of a call to
'tcl_event/3'.  (It may be helpful to think of this as a way of passing
messages as Prolog terms from Tcl to Prolog.)

   A call to 'tcl_event/3' blocks until there is something on the event
queue.

   A second way of getting Prolog events from a Prolog event queue is
through the 'tk_next_event/[2,3]' predicates.  These have the form:

     tk_next_event(+TCLINTERPRETER, -EVENT)
     tk_next_event(+OPTIONS, +TCLINTERPRETER, -EVENT)

where TCLINTERPRETER reference to a Tcl interpreter and EVENT is the
Prolog term at the head of the associated Prolog event queue.  (The
OPTIONS feature will be described below in the Housekeeping section when
we talk about Tcl and Tk events; *note Housekeeping::.).

   (We will meet 'tk_next_event/[2,3]' again later when we discuss how
it can be used to service Tk events; *note Servicing Tk Events::).

   If the interpreter has been deleted, then the empty list '[]' is
returned.

   The Tcl interpreters under the SICStus Prolog library are extended
with a command, 'prolog_event', for adding events to a Prolog event
queue.

   The 'prolog_event' command has the following form:

        prolog_event TERMS ...

where TERMS are strings that contain the printed representation of
Prolog terms.  These are stored in a queue and retrieved as Prolog terms
by 'tcl_event/3' or 'tk_next_event/[2,3]' (described above).

   An example of using the 'prolog_event' command:

     test_event(Event) :-
         tcl_new(Interp),
         tcl_event(Interp, [prolog_event, dq(write(zap(42)))], Event),
         tcl_delete(Interp).

with the query:

     | ?- test_event(Event).

will succeed, binding 'Event' to the list '[zap(42)]'.

   This is because 'tcl_event' converts its argument using the special
Command Format conversion (*note Evaluation Functions::), which yields
the Tcl command 'prolog_event "zap(42)"'.  This command is evaluated in
the Tcl interpreter referenced by the variable 'Interp'.  The effect of
the command is to take the string given as argument to 'prolog_event'
(in this case '"zap(42)"') and to place it on the Tcl to Prolog event
queue.  The final action of a 'tcl_event/3' call is to pick up any
strings on the Prolog queue from Tcl, add a trailing full stop and space
to each string, and parse them as Prolog terms, binding 'Event' to the
list of values, which in this case is the singleton list '[zap(42)]'.
(The queue is a list the elements of which are terms put there through
calls to 'prolog_event').

   If any of the TERM-s in the list of arguments to 'prolog_event' is
not a valid representation of a Prolog term, then an exception is raised
in Prolog when it is converted from the Tcl string to the Prolog term
using 'read'.  To ensure that Prolog will be able to read the term
correctly it is better to always use 'write_canonical' and to ensure
that Tcl is not confused by special characters in the printed
representation of the Prolog term it is best to wrap the list with
'list'.

   A safer variant that safely passes any term from Prolog via Tcl and
back to Prolog is thus:

     test_event(Term, Event) :-
         tcl_new(Interp),
         tcl_event(Interp, list([prolog_event, write_canonical(Term)]), Event),
         tcl_delete(Interp).

   As an example of using the Prolog event system supplied by the
'tcltk' library, we will return to our 8-queens example but now
approaching from the Prolog side rather than the Tcl/Tk side:

     :- use_module(library(tcltk)).

     setup :-
         tk_new([name('SICStus+Tcl/Tk - Queens')], Tcl),
         tcl_eval(Tcl, 'source queens.tcl', _),
         tk_next_event(Tcl, Event),
         (   Event = next -> go(Tcl),
         ;   closedown(Tcl)
         ).

     closedown(Tcl) :-
         tcl_delete(Tcl).

     go(Tcl) :-
         tcl_eval(Tcl, 'clear_board', _),
         queens(8, Qs),
         show_solution(Qs, Tcl),
         tk_next_event(Tcl, Event),
         (   Event = next -> fail
         ;   closedown(Tcl)
         ).
     go(Tcl) :-
         tcl_eval(Tcl, 'disable_next', _),
         tcl_eval(Tcl, 'clear_board', _),
         tk_next_event(Tcl, _Event),
         closedown(Tcl).

   This is the top-level fragment of the Prolog side of the 8-queens
example.  It has three predicates: 'setup/0', 'closedown/1', and 'go/1'.
'setup/0' simply creates the Tcl interpreter, loads the Tcl code into
the interpreter using a call to 'tcl_eval/3' (which also initializes the
display) but then calls 'tk_next_event/2' to wait for a message from the
Tk side.

   The Tk part that sends 'prolog_event'-s to Prolog looks like this:

     button .next -text next -command {prolog_event  next}
     pack .next

     button .stop -text stop -command {prolog_event stop}
     pack .stop

that is two buttons, one that sends the atom 'next', the other that
sends the atom 'stop'.  They are used to get the next solution and to
stop the program respectively.

   So if the user presses the 'next' button in the Tk window, then the
Prolog program will receive a 'next' atom via a
'prolog_event'/'tk_next_event' pair, and the program can proceed to
execute 'go/1'.

   'go/1' is a failure driven loop that generates 8-queens solutions and
displays them.  First it generates a solution in Prolog and displays it
through a 'tcl_eval/3' call.  Then it waits again for a Prolog events
via 'tk_next_event/2'.  If the term received on the Prolog event queue
is 'next', then corresponding to the user pressing the "next solution"
button, then fail is executed and the next solution found, thus driving
the loop.

   If the 'stop' button is pressed, then the program does some tidying
up (clearing the display and so on) and then executes 'closedown/1',
which deletes the Tcl interpreter and the corresponding Tk windows
altoegther, and the program terminates.

   This example fragment show how it is possible for a Prolog program
and a Tcl/Tk program to communicate via the Prolog event queue.


File: sicstus.info,  Node: Servicing Tk Events,  Next: Passing Control to Tk,  Prev: Event Functions,  Up: The Tcl/Tk Prolog Library

10.39.4.5 Servicing Tcl and Tk events
.....................................

The notion of an event in the Prolog+Tcl/Tk system is overloaded.  We
have already come across the following kinds of events:

   * Tk widget events captured in Tcl/Tk through the 'bind' command
   * Prolog queue events controlled through the 'tcl_event/3',
     'tk_next_event(2,3)', and 'prolog_event' functions

   It is further about to be overloaded with the notion of Tcl/Tk
events.  It is possible to create event handlers in Tcl/Tk for reacting
to other kinds of events.  We will not cover them here but describe them
so that the library functions are understandable and in case the user
needs these features in an advanced application.

   There are the following kinds of Tcl/Tk events:

idle events
     happen when the Tcl/Tk system is idle

file events
     happen when input arrives on a file handle that has a file event
     handler attached to it

timer events
     happen when a Tcl/Tk timer times out

window events
     when something happens to a Tk window, such as being resized or
     destroyed

   The problem is that in advanced Tcl/Tk applications it is possible to
create event handlers for each of these kinds of event, but they are not
normally serviced while in Prolog code.  This can result in unresponsive
behavior in the application; for example, if window events are not
serviced regularly, then if the user tries to resize a Tk window, then
it will not resize in a timely fashion.

   The solution to this is to introduce a Prolog predicate that passes
control to Tk for a while so that it can process its events,
'tk_do_one_event/[0,1]'.  If an application is unresponsive because it
is spending a lot of time in Prolog and is not servicing Tk events often
enough, then critical sections of the Prolog code can be sprinkled with
calls to 'tk_do_one_event/[0,1]' to alleviate the problem.

   'tk_do_one_event/[0,1]' has the following forms:

     tk_do_one_event
     tk_do_one_event(+OPTIONS)

which passes control to Tk to handle a single event before passing
control back to Prolog.  The type of events handled is passed through
the OPTIONS variable, a list of atoms that are event types.

   The OPTIONS list can contain the following atoms:

'tk_dont_wait'
     do not wait for new events, process only those that are ready

'tk_window_events'
     process window events

'tk_file_events'
     process file events

'tk_timer_events'
     process timer events

'tk_idle_events'
     process 'Tcl_DoWhenIdle' events

'tk_all_events'
     process any event

   Calling 'tk_do_one_event/0' is equivalent to a call to
'tk_do_one_event/1' with the 'tk_all_events' and 'tk_dont_wait' flags.

   A call to either of these predicates succeeds only if an event of the
appropriate type happens in the Tcl/Tk interpreter.  If there are no
such events, then 'tk_do_one_event/1' will fail if the 'tk_dont_wait'
wait flag is present, as will 'tk_do_one_event/0', which has that flag
set implicitly.

   If the 'tk_dont_wait' flag is not set, then a call to
'tk_do_one_event/1' will block until an appropriate Tk event happens (in
which case it will succeed).

   It is straight forward to define a predicate that handles all Tk
events and then returns:

     tk_do_all_events :-
         tk_do_one_event, !,
         tk_do_all_events.
     tk_do_all_events.

   The predicate 'tk_next_event/[2,3]' is similar to
'tk_do_one_event/[0,1]' except that it processes Tk events until at
least one Prolog event happens.  (We came across this predicate before
when discussing Prolog event queue predicates.  This shows the
overloading of the notion event where we have a predicate that handles
both Tcl/Tk events and Prolog queue events.)

   It has the following forms:

     tk_next_event(+TCLINTERPRETER, -EVENT)
     tk_next_event(+OPTIONS, +TCLINTERPRETER, -EVENT)

   The Prolog event is returned in the variable EVENT and is the first
term on the Prolog event queue associated with the interpreter
TCLINTERPRETER.  (Prolog events are initiated on the Tcl side through
the new Tcl command 'prolog_event', covered earlier; *note Event
Functions::).

