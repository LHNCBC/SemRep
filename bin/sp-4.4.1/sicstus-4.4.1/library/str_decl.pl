%   Package: structs_decl
%   Author : Peter Schachte
%   Updated: 12/10/98
%   Purpose: handle structure declarations for structs package

%   Copyright (C) 1990, Quintus Computer Systems, Inc.  All rights reserved.

:- if(current_prolog_flag(dialect, spider)).

%% [PM] 4.1.3 foreign_type/1 is not exported, instead it is special-cased by a term expansion.
%%      For SPIDER we instead fake an exported definition.
:- module(structs_decl, [(foreign_type)/1]).

:- else.
%% [PM] 4.1.3 The real module directive
:- module(structs_decl, []).

:- endif.

:- use_module(library(alignments), [
        primitive_type_size/3,
        pointer_alignment/2
        ]).

:- %% [PM] 4.1.0 was (which confused to SPIDER): initialization
	op(1150, fx, [(foreign_type)]).

:- multifile
	'SU_messages':typename/3,
	'SU_messages':operation/3,
	'SU_messages':commandtype/3,
	'SU_messages':contexttype/3,
	'SU_messages':message/3.


'SU_messages':typename(foreign_type_name) --> !,
	['name for user-defined type'-[]].
'SU_messages':typename(foreign_type) --> !,
	['name of foreign type'-[]].
'SU_messages':typename(fixed_size_type) --> !,
	['fixed size type'-[]].
'SU_messages':typename(type_definition) --> !,
	['type definition'-[]].
'SU_messages':typename(foreign_arg_decl) --> !,
	['foreign argument declaration'-[]].

'SU_messages':operation(define) --> !,
	['define'-[]].

'SU_messages':commandtype(opaque_type_definition) --> !,
	['definition of opaque type'-[]].

'SU_messages':contexttype(before_use) --> !,
	['before use'-[]].

'SU_messages':message(already_defined) --> !,
	['that type is already defined'-[]].

%  Multifile procedures generated by this module:
%
%	structs1:type_defn(Type_name, Simple_type_expr)
%		Type_name is the name of a user-defined type,
%		Simple_type_expr is a type expression defining
%		the type (see doc for new_atomic_type/8 for a
%		description of what a "simple" type expr is).
%
%	structs1:type_size(Type_name, Size, Alignment)
%		Size is the size of a Type_name, in bytes.
%		Alignment is the byte alignment required for this
%		type; that is, the address of the beginning of an
%		instance of Type_name must be divisible by Alignment.
%		Sadly, alignment is completely machine and compiler
%		specific.
%
%	structs1:type_file(Type_name, File)
%		File is the file that defined Type_name.  This hack
%		is to get around the fact that when the development
%		system compiles a file, the predicates previously
%		defined in this file are callable until the first
%		clause for each is found.  This means that when
%		compiling the first type definition, types defined
%		in that file when last loaded are still around.
%		So when we get a redefinition, we want to be able
%		to ask if the old definition came from the same file.
%
%	structs1:get_contents(Datum, Part, Value)
%		This procedure is actually code used to get Part
%		of Datum, which is a compound datum.  Value is
%		bound to the contents of Part of Datum.
%
%	structs1:put_contents(Datum, Part, Value)
%		This procedure is actually code used to put Part
%		of Datum, which is a compound datum.  Part of Datum
%		is set to Value.
%
%	structs1:get_address(Datum, Part, Value)
%		This procedure is actually code used to get the
%		address of Part	of Datum, which is a compound datum.
%		Value is bound to the address of Part of Datum.
%
%  There are also three separate procedures for each struct defined,
%  using the names get_X_field, put_X_field, and get_X_address,
%  where X is the name of the structure.  Similarly, there are two
%  procedures for each union defined, named get_X_field and
%  get_X_address.  All of these procedures are 3-ary.
%

% [MC] these declarations are needed by splfr:
:- multifile
	structs1:type_defn/2,
	structs1:type_size/3,
	structs1:type_file/2.

% [PM] 4.2.1 SPIDER warns about these not being volatile. I think SPIDER is right. I think they are only used during compilation.
:- dynamic
	current_type_defn/2,
	current_type_size/3,
	current_type_file/2,
	current_get_pred/1,
	declared_discontiguous_foreign/0,
	declared_multifile_discontiguous/0.

/****************************************************************
		    Installation of type definitions
 ****************************************************************/


%  compile_foreign_type_decl(+Decls, +Goal, +D0, -D)
%  D is D0 followed by the list of processed type declarations generated
%  by compiling the foreign type declaration(s) Decls.  D0 is a list of
%  processed declarations seen but not interned.  Goal is the goal
%  declaring all these types, for error-reporting purposes

compile_foreign_type_decl(Var, Goal) -->
	{var(Var)}, !,
	{print_message(error, instantiation_error(Goal,1))}.
compile_foreign_type_decl((Type_decl1,Type_decl2), Goal) -->
	compile_foreign_type_decl(Type_decl1, Goal),
	compile_foreign_type_decl(Type_decl2, Goal).
compile_foreign_type_decl((Type_name=Type_expr), Goal) -->
	(   new_type(Type_name, Type_expr, Goal) -> []
	;   % new_type will print an error message and fail if Type_expr
	    % is invalid for some reason.
	    []
	).


%  new_type(+Type_name, +Type_expr, +Goal, +D0, -D)
%  define Type_name to be a name for type Type_expr.  Goal is the original
%  goal, for error-reporting purposes.  D0 is a list of terms describing
%  type definitions seen but not interned, and D is this list plus the
%  processed version of this type declaration.

new_type(Type_name, Type_expr, Goal) -->
	{   (   var(Type_name) ; var(Type_expr)) ->
		print_message(error, instantiation_error(Goal,1)),
		fail
	;   ( \+ atom(Type_name) ; primitive_type_size(Type_name, _, _)) ->
		print_message(error,
			domain_error(Goal,1,foreign_type_name,Type_name)),
		fail
	;   user_type_file(Type_name, Oldfile),
	    prolog_load_context(file, Newfile),
	    (Newfile \== Oldfile ; Newfile == user) ->
		print_message(error,
			permission_error(Goal,define,foreign_type,
				Type_name,already_defined)),
		fail
	;   true
	},
	{   known_type_defn(Type_expr, Type_defn, _, _) -> true
	;   Type_defn = Type_expr
	},
	declare_multifile_discontiguous,
	(   {primitive_type_size(Type_defn, Size, Alignment)} ->
		{Simple = Type_defn},
		new_simple_type(Type_defn, Type_name)
	;   new_compound_type(Type_defn, Type_name, Type_name, 0, _,
			Simple, Size, Alignment, Goal)
	),
	type_clauses(Simple, Type_name, Size, Alignment).


%  known_type_defn(+Type_name, -Type_defn, -Size, -Alignment)

known_type_defn(Type_name, Type_defn, Size, Alignment) :-
	atom(Type_name),
	(   user_type_size(Type_name, Size, Alignment),
	    user_type_defn(Type_name, Type_defn0) ->
		cleanup_definition(Type_defn0, Type_defn)
	;   primitive_type_size(Type_name, Size, Alignment) ->
		Type_defn = Type_name
	).


%  type_clauses(+Type_expr, +Type_name, +Size, +Alignment, +D0, -D)
%  D is D0 followed by the basic clauses to define Type_name as a name
%  for type Type_expr, with Size and Alignment.  Type_expr is a simple
%  type expression.  This does NOT include accessor clauses.

type_clauses(Type_expr, Type_name, Size, Alignment) -->
	{   prolog_load_context(file, File) -> true
	;   File = none				% for debugging
	},
	{   assertz(current_type_size(Type_name,Size,Alignment)),
	    assertz(current_type_defn(Type_name, Type_expr)),
	    assertz(current_type_file(Type_name, File))
	},
	[structs1:type_size(Type_name,Size,Alignment),
	 structs1:type_defn(Type_name, Type_expr),
	 structs1:type_file(Type_name, File)].

new_simple_type(Type_defn, Type_name) -->
    	{Ptr_term_1 =.. [Type_name,Ptr]},
    	{Ptr_term_2 =.. [Type_defn,Ptr]},
	[structs1:get_address(Ptr_term_1, contents, Ptr_term_1),
	 (structs1:get_contents(Ptr_term_1,contents,Target_term) :-
	         structs1:get_contents(Ptr_term_2,contents,Target_term)),
	 (structs1:put_contents(Ptr_term_1,contents,Target_term) :-
	         structs1:put_contents(Ptr_term_2,contents,Target_term))].

%  new_compound_type(+Type_expr, +Type_name, +Parent, +N0, -N,
%	-Simple, -Size, -Alignment, +Goal, +D0, -D)
%  declare Type_name to be the name of type Type_expr, which is believed
%  to be a compound type (we fail if it's not).  Size is the number of
%  bytes one of these beasts occupy, and Alignment is the byte alignment
%  needed for one.  Simple is a simplified version of Type_expr, which
%  has only type names, not type expressions, for constituent types.
%  Parent is the user-supplied name for the type that defines this one,
%  N0 is the number of auxilliary types defined so far, and N is the
%  number after this type is defined.
%  Goal is the goal defining this type, for error-reporting
%  purposes.  D0 is a list of terms describing
%  type definitions seen but not interned, and D is this list plus the
%  processed version of this type declaration.

new_compound_type(pointer(Type_expr), Type_name, Parent, N0, N,
		pointer(Target_type), Size, Alignment, Goal) --> !,
	( {atom(Type_expr)} ->
	      {N = N0, Target_type = Type_expr}
	; get_type_name(Type_expr, Parent, N0, N, Target_type, _, _, Goal)
	),
	{pointer_alignment(Size, Alignment)},
	build_pointer_accessors(Type_name, Target_type).
% For enums
new_compound_type(enum(Enums), Type_name, _Parent, N0, N,
		enum(Enums), Size, Alignment, _Goal) --> !,
        { N = N0 },
	{primitive_type_size(integer_32, Size, Alignment)},
	build_enums(Enums, Type_name).
new_compound_type(array(Num_elts,Type_expr), Type_name, Parent, N0, N,
		array(Num_elts,Elt_type), Size, Alignment, Goal) --> !,
	get_type_name(Type_expr, Parent, N0, N, Elt_type, Elt_size0,
		Alignment, Goal),
	(   {integer(Elt_size0)} ->
		% we assume that an array should be aligned as it's elements
		{Elt_size is ((Elt_size0+Alignment-1)//Alignment)*Alignment},
		{Size is Elt_size*Num_elts},
		build_array_accessors(Type_name, Num_elts, Elt_type, Elt_size)
	;   % otherwise it must be a type of unknown size
	    {print_message(error,
		    domain_error(Goal,1,fixed_size_type,Type_expr))},
	    {fail}
	).
new_compound_type(array(Type_expr), Type_name, Parent, N0, N,
		array(Elt_type), Size, Alignment, Goal) --> !,
        { Size = unknown },
	get_type_name(Type_expr, Parent, N0, N, Elt_type, Elt_size0,
		Alignment, Goal),
	(   {integer(Elt_size0)} ->
		% we assume that an array should be aligned as it's elements
		{Elt_size is ((Elt_size0+Alignment-1)//Alignment)*Alignment},
		build_array_accessors(Type_name, unknown, Elt_type, Elt_size)
	;   % otherwise it must be a type of unknown size
	    {print_message(error,
		    domain_error(Goal,1,fixed_size_type,Type_expr))},
	    {fail}
	).
new_compound_type(struct(Fields), Type_name, Parent, N0, N,
		struct(Simple_fields), Size, Alignment, Goal) --> !,
	% we assume that a struct should be aligned as its first field
	    new_struct(Fields, Type_name, Parent, N0, N, Simple_fields,
		Size, Alignment, Goal).
new_compound_type(union(Members), Type_name, Parent, N0, N,
		union(Simple_members), Size, Alignment, Goal) --> !,
	new_union(Members, Type_name, Parent, N0, N, Simple_members,
		Size, Alignment, Goal).
new_compound_type(Type_expr, _, _, _, _, _, _, _, Goal) -->
	{print_message(error,
		domain_error(Goal,1,type_definition,Type_expr))},
	{fail}.


%  get_type_name(+Type_expr, +Parent_type, +N0, -N, -Type_name, -Size,
%	-Alignment, +D0, -D, +Goal)
%  Type_name is an atom describing type Type_expr.  Instances of this type
%  are Size bytes long, and must be aligned on an Alignment-byte
%  boundry.  If Type_expr is a valid type name or primitive
%  type, it is returned as Type_name, otherwise, a new type name is created
%  and defined, as described above.  Parent_type is the name of the
%  outermost type being defined, N0 is the number of subtypes defined so
%  far, and N is the number after this defn, to be used as a base for names
%  of subtypes.  D0 is a list of known uninterned types, and D is D0 extended
%  with any definitions necessary to define Type_name.  Goal is the
%  declaration, for error-reporting purposes.


get_type_name(Name, _, N0, N, Type_name, Size, Alignment, _) -->
	{atom(Name)},
	{known_type_defn(Name, _, Size, Alignment)},
	!,
        { N = N0, Type_name = Name }.
get_type_name(pointer(Type_expr), Parent, N0, N, Type_name, Size, Alignment, Goal) --> !,
	(   {atom(Type_expr)} ->
		% we allow target type of pointer to be undefined, to
		% allow recursive structs
		{Contents_type = Type_expr, N = N0}
	;   get_type_name(Type_expr, Parent, N0, N, Contents_type, _, _, Goal)
	),
	{atom_concat(Contents_type, $, Type_name)},
	{pointer_alignment(Size, Alignment)},
	(   {known_type_defn(Type_name, _, _, _)} -> []
		% don't install this type as we already know about it
	;   type_clauses(pointer(Contents_type), Type_name , Size, Alignment),
	    build_pointer_accessors(Type_name, Contents_type)
	).
get_type_name(array(Num,Type_expr), Parent, N0, N, Type_name, Size, Alignment, Goal) --> !,
	{subtype_name(Parent, Type_name, N0, N1)},
	new_compound_type(array(Num,Type_expr), Type_name, Parent, N1, N,
		Simple, Size, Alignment, Goal),
	type_clauses(Simple, Type_name, Size, Alignment).
get_type_name(array(Type_expr), Parent, N0, N, Type_name, unknown, Alignment, Goal) --> !,
	{subtype_name(Parent, Type_name, N0, N1)},
	new_compound_type(array(Type_expr), Type_name, Parent, N1, N,
		Simple, unknown, Alignment, Goal),
	type_clauses(Simple, Type_name, unknown, Alignment).
get_type_name(struct(Fields), Parent, N0, N, Type_name, Size, Alignment, Goal) --> !,
	{subtype_name(Parent, Type_name, N0, N1)},
	new_compound_type(struct(Fields), Type_name, Parent, N1, N,
		Simple, Size, Alignment, Goal),
	type_clauses(Simple, Type_name, Size, Alignment).
get_type_name(union(Fields), Parent, N0, N, Type_name, Size, Alignment, Goal) --> !,
	{subtype_name(Parent, Type_name, N0, N1)},
	new_compound_type(union(Fields), Type_name, Parent, N1, N,
		Simple, Size, Alignment, Goal),
	type_clauses(Simple, Type_name, Size, Alignment).
get_type_name(enum(Enums), Parent, N0, N, Type_name, Size, Alignment, Goal) --> !,
	{subtype_name(Parent, Type_name, N0, N1)},
	new_compound_type(enum(Enums), Type_name, Parent, N1, N,
		Simple, Size, Alignment, Goal),
	type_clauses(Simple, Type_name, Size, Alignment).
get_type_name(Expr, _, _, _, _, _, _, Goal) -->
	{print_message(error, domain_error(Goal,1,type_definition,Expr))},
	{fail}.

subtype_name(Parent, Subtype, N0, N) :-
	N is N0+1,
	number_codes(N0, List2),
	atom_codes(N0atm, [0'$|List2]),
	atom_concat(Parent, N0atm, Subtype).


/****************************************************************
			Pointer declarations
 ****************************************************************/

%  build_pointer_accessors(+Type_name, +Target_type, +D0, -D)
%  Type_name is the name of a pointer type pointing to a Target_type thing.
%  D contains whatever linkage clauses are necessary to access the target of
%  one of these pointers, followed by D0.

build_pointer_accessors(Type_name, Target_type) -->
	{Ptr_term =.. [Type_name,Ptr]},
	{Target_term =.. [Target_type,Ptr2]},
	{primitive_type_accessors(integer, Ptr, Ptr2, Get_goal, Put_goal)},
	[structs1:get_address(Ptr_term, contents, Ptr_term),
	 (structs1:get_contents(Ptr_term,contents,Target_term) :- Get_goal),
	 (structs1:put_contents(Ptr_term,contents,Target_term) :- Put_goal)].


/****************************************************************
			Enum declarations
 ****************************************************************/

enum_goal(+, TypeName, IntV, EnumAtom, ToGoal) :-
    	from_enum_goal(TypeName, IntV, EnumAtom, ToGoal).
enum_goal(-, TypeName, IntV, EnumAtom, ToGoal) :-
    	to_enum_goal(TypeName, IntV, EnumAtom, ToGoal).

to_enum_goal(TypeName, IntV, EnumAtom, ToGoal) :-
	atom_concat('int_to_', TypeName, ToName),
	ToGoal =.. [ToName, IntV, EnumAtom].

from_enum_goal(TypeName, IntV, EnumAtom, FromGoal) :-
	atom_concat(TypeName, '_to_int', FromName),
	FromGoal =.. [FromName, EnumAtom, IntV].

%  build_enums(+Enums, +Type_name, +D0, -D)

build_enums(Enums, Type_name) -->
	{Ptr_term =.. [Type_name,Ptr]},
	{to_enum_goal(Type_name, IntV, EnumAtom, ToGoal)},
	{from_enum_goal(Type_name, IntV, EnumAtom, FromGoal)},
	{functor(ToGoal, ToName, _)},
	{functor(FromGoal, FromName, _)},
	{primitive_type_accessors(integer_32, Ptr, IntV, Get_goal, Put_goal)},
	[structs1:get_address(Ptr_term, contents, Ptr_term),
	 (structs1:get_contents(Ptr_term,contents,EnumAtom) :- Get_goal, structs1:ToGoal),
	 (structs1:put_contents(Ptr_term,contents,EnumAtom) :- structs1:FromGoal, Put_goal),
	 :-(discontiguous(structs1:ToName/2)),
	 :-(discontiguous(structs1:FromName/2))],
	build_enum_tables(Enums, Type_name, 0).

build_enum_tables([], _, _) --> [].
build_enum_tables([Enum|Enums], Type_name, CurrEnumVal) -->
    	{enum_value(Enum, CurrEnumVal, ThisName, ThisVal)},
	{NextVal is ThisVal + 1},
	{to_enum_goal(Type_name, ThisVal, ThisName, ToFact)},
	{from_enum_goal(Type_name, ThisVal, ThisName, FromFact)},
	[structs1:ToFact, structs1:FromFact],
	build_enum_tables(Enums, Type_name, NextVal).

enum_value(Enum=Val, _, Enum, Val) :- !.
enum_value(Enum,   Val, Enum, Val).

/****************************************************************
			Array declarations
 ****************************************************************/

%  build_array_accessors(+Type_name, +Num_elts, +Elt_type, +Elt_size, +D0, -D)
%  Type_name is the name of an array type holding Num_elts elements of
%  type Elt_type.  We know that Elt_type things occupy Elt_size bytes
%  each.  Build whatever linkage clauses are necessary to access the
%  elements of the array.  If Num_elts is the atom unknown, then this
%  is an array of unknown size, so we can't do bounds checking.
%  D contains whatever linkage clauses are necessary to access the target of
%  one of these pointers, followed by D0.

build_array_accessors(Type_name, Num_elts, Elt_type, Elt_size) -->
	{Term =.. [Type_name, Ptr]},
	{simplify_is(Elt_num*Elt_size, Offset, Offset_goal0)},
	{simplify_is(Ptr+Elt_num*Elt_size, Address, Addr_goal0)},
	{   integer(Num_elts) ->
		High_elt is Num_elts-1,
		conjoin(structs:between(0,High_elt,Elt_num), Offset_goal0,
			Offset_goal),
		conjoin(structs:between(0,High_elt,Elt_num), Addr_goal0,
			Addr_goal)
	;   Offset_goal = Offset_goal0,
	    Addr_goal = Addr_goal0
	},
	% Now Offset_goal is bound to the goal to bind Offset to the
	% appropriate offset for element Elt_num, doing bounds testing
	% if possible; and Addr_goal is bound to the goal to bind
	% Address to the address of the Elt_num element.
	(   {accessor_goals(Elt_type, Ptr, Offset, Value, Get_goal0, Put_goal0)} ->
		% now Get_goal is bound to the goal to bind Value to the
		% contents of memory at Ptr+Offset, which is of type Elt_type.
		% Put_goal is the goal to put Value into memory there.
		{conjoin(Offset_goal, Get_goal0, Get_goal)},
		{conjoin(Offset_goal, Put_goal0, Put_goal)},
		[(structs1:get_contents(Term,Elt_num,Value):-structs1:Get_goal),
		 (structs1:put_contents(Term,Elt_num,Value):-structs1:Put_goal)]
	;   []			% can't access elements
	),
	% we evaluate any aliases of Elt_type to primitive types
	{ known_type_defn(Elt_type, Simple_type, _, _),
	  atom(Simple_type)		% maybe a hack
	-> Addr_value =.. [Simple_type, Address]
	;  Addr_value =.. [Elt_type, Address]
	},
	[(structs1:get_address(Term,Elt_num,Addr_value):-structs1:Addr_goal)].



/****************************************************************
			Struct declarations
 ****************************************************************/

%  new_struct(+Fields, +Struct_name, +Parent, +N0, -N, -Simplified_fields,
%	-Size, -Alignment, +Goal, +D0, -D)
%  Fields is the list of fields of a structure named Struct_name.
%  Simplified_fields is the same as Fields, except that all field types
%  are given as type names, rather than expressions.  Size is the number
%  of bytes an instance of this structure occupies, and Alignment is
%  the byte alignment required for this struct.  This procedure
%  generates the necessary linkage clauses to access fields of this
%  structure.  Goal is the goal declaring this type, for error reporting.
%  D contains whatever linkage clauses are necessary to access the target of
%  one of these pointers, followed by D0.

new_struct(Fields, Struct_name, Parent, N0, N, Simplified_fields, Size,
		Alignment, Goal) -->
	{accessor_names(Struct_name, Get_pred, Put_pred, Addr_pred)},
	[:-(discontiguous(structs1:Get_pred/3)),
	 :-(discontiguous(structs1:Put_pred/3)),
	 :-(discontiguous(structs1:Addr_pred/3))],
	new_struct(Fields, 0, Get_pred, Put_pred, Addr_pred, Struct_name,
		Parent, N0, N, Simplified_fields, Size, Goal),
	build_struct_accessors(Struct_name, Get_pred, Put_pred,	Addr_pred),
	{struct_or_union_alignment(Simplified_fields, 0, Alignment)}.


%  new_struct(+Fields, +Offset, +Get_pred, +Put_pred, +Addr_pred, +Struct_name,
%	+Parent, +N0, -N, -Simplified_fields, -Size, +Goal, +D0, -D)
%  Build the accessor procedures necessary to access fields of a struct.
%  Fields is a list of the fields of the struct starting at byte offset
%  Offset.   Get_pred, Put_pred, and Addr_pred are the names of the
%  accessor procedures that must be generated.  Struct_name is the name
%  of the structure being defined, used in error messages.  Parent, N0,
%  N, Size, Simplified_fields, Goal, D0, and D are as described above.  

new_struct([], Size, _, _, _, _, _, N, N, [], Size, _, D, D).
new_struct([Field_name:Type_expr|Fields], Offset0, Get_pred, Put_pred,
		Addr_pred, Struct_name, Parent, N0, N,
	    [field(Field_name,Type_name,Offset0)|Simplified_fields],
	    Size, Goal) -->
	(   get_type_name(Type_expr, Parent, N0, N1, Type_name, Field_size,
		    Field_align, Goal),
	    {integer(Field_size)} ->
		{Offset1 is ((Offset0+Field_align-1)//Field_align)*Field_align},
		build_field_accessors(Field_name, Offset1, Type_name, 
			Get_pred, Put_pred, Addr_pred),
		{Offset2 is Offset1+Field_size},
		new_struct(Fields, Offset2, Get_pred, Put_pred, Addr_pred,
			Struct_name, Parent, N1, N, Simplified_fields, Size,
			Goal)
	;   {print_message(error,
		    domain_error(Goal,1,fixed_size_type,Type_expr))},
	    {fail}
	).

%  build_field_accessors(+Field_name, +Offset, +Type_name, +Get_pred,
%		+Put_pred, +Addr_pred, +Clauses0, -Clauses)
%  Clauses is the list of clauses necessary to access field Field_name,
%  of type Type_name, which is found at byte offset Offset of a structure,
%  followed by Clauses0.  Other args are as above.

build_field_accessors(Field_name, Offset, Type_name, Get_pred, Put_pred,
		Addr_pred) -->
	[structs1:(Addr_head:-Addr_goal)],
	{Addr_head =.. [Addr_pred,Field_name,Ptr,Value]},
	{Value =.. [Type_name,Addr]},
	{simplify_is(Ptr+Offset, Addr, Addr_goal)},
	(   {accessor_goals(Type_name, Ptr, Offset, Value1, Get_goal, Put_goal)} ->
	        {assertz(current_get_pred(Get_pred))},
		{Get_head =.. [Get_pred,Field_name,Ptr,Value1]},
		{Put_head =.. [Put_pred,Field_name,Ptr,Value1]},
		[structs1:(Get_head :- Get_goal),
		 structs1:(Put_head :- Put_goal)]
	;   []			% can't access contents of this slot
	).


%  build_struct_accessors(+Struct_name, +Get_pred, +Put_pred, +Addr_pred,
%	D0, D)
%  Build and assert the clauses that link the user-visable accessor
%  procedures to the accessor procedures for struct Struct_name, named
%  Get_pred, Put_pred, and Addr_pred.  Clauses is the list of clauses
%  defining the accessor procedures.  It is possible for a struct to
%  have no fields the contents of which can be accessed, in which case,
%  don't generate those linkage clauses.

build_struct_accessors(Struct_name, Get_pred, Put_pred, Addr_pred) -->
	{Addr_goal =.. [Addr_pred,Fieldname,Ptr,Value]},
	{Term =.. [Struct_name,Ptr]},
	[(structs1:get_address(Term,Fieldname,Value):-structs1:Addr_goal)],
	(    {current_get_pred(Get_pred)} ->
		{Get_goal =.. [Get_pred,Fieldname,Ptr,Value]},
		{Put_goal =.. [Put_pred,Fieldname,Ptr,Value]},
	        [(structs1:get_contents(Term,Fieldname,Value):-
			 structs1:Get_goal),
		 (structs1:put_contents(Term,Fieldname,Value):-
			 structs1:Put_goal)]
	;   []			% don't need these linkage clauses,
				% because there's nothing to link to
	).


/****************************************************************
			Union declarations
 ****************************************************************/

%  new_union(+Members, +Union_name, +Parent, +N0, -N, -Simplified_members,
%	-Size, -Alignment, +Goal, +D0, -D)
%  Members is the list of members of a union named Union_name.
%  Simplified_members is the same as Members, except that all member types
%  are given as type names, rather than expressions.  Size is the number
%  of bytes an instance of this union occupies, and Alignment is its
%  alignment constraint.  Parent is the user-supplied name for the type
%  that defines this one, N0 is the number of auxilliary types defined so
%  far, and N is the number after this type is defined.
%  Goal is the goal defining this type, for error-reporting
%  purposes.  D0 is a list of terms describing
%  type definitions seen but not interned, and D is this list plus the
%  processed version of this type declaration.

new_union(Members, Union_name, Parent, N0, N, Simplified_members, Size,
		Alignment, Goal) -->
	{accessor_names(Union_name, Get_pred, Put_pred, Addr_pred)},
	[:-(discontiguous(structs1:Get_pred/3)),
	 :-(discontiguous(structs1:Put_pred/3)),
	 :-(discontiguous(structs1:Addr_pred/3))],
	new_union(Members, 0, Get_pred, Put_pred, Addr_pred, Union_name,
		Parent, N0, N, Simplified_members, Size, Goal),
	build_union_accessors(Union_name, Get_pred, Put_pred, Addr_pred),
	{struct_or_union_alignment(Simplified_members, 0, Alignment)}.

%  new_union(+Members, +Size0, +Get_pred, +Put_pred, Addr_pred, +Union_name, 
%	+Parent, +N0, -N, -Simplified_members, -Size, +Goal, +D0, -D)
%  Build the accessor procedures necessary to access members of a union.
%  Members is a list of members of the union.  Get_pred and Addr_pred
%  are the names of the accessor procedures that must be generated. 
%  Union_name is the name of the union being defined, used in error
%  messages.  Size is the greater of Size0 and the number of bytes that
%  must be allocated for any of the members listed on MEMBERS. 
%  Simplified_members is as described above.  Parent is the user-supplied
%  name for the type that defines this one, N0 is the number of auxilliary
%  types defined so far, and N is the number after this type is defined. 
%  Goal is the goal defining this type, for error-reporting
%  purposes.  D0 is a list of terms describing
%  type definitions seen but not interned, and D is this list plus the
%  processed version of this type declaration.

new_union([], Size, _, _, _, _, _, N, N, [], Size, _, D, D).
new_union([Member_name:Type_expr|Members], Size0, Get_pred, Put_pred,
	  	Addr_pred, Union_name, Parent, N0, N,
		[Member_name:Type_name|Simplified_members], Size, Goal) -->
	(   get_type_name(Type_expr, Parent, N0, N1, Type_name, Size1, _, Goal),
	    {integer(Size1)} ->
		build_member_accessors(Member_name, Type_name,
			Get_pred, Put_pred, Addr_pred),
		{Size2 is max(Size0, Size1)},
		new_union(Members, Size2, Get_pred, Put_pred, Addr_pred,
			Union_name, Parent, N1, N, Simplified_members, Size,
			Goal)
	;   {print_message(error,
		    domain_error(Goal,1,fixed_size_type,Type_expr))},
	    {fail}
	).

%  build_member_accessors(+Member_name, +Type_name, +Get_pred, +Addr_pred,
%		+Clauses0, -Clauses)
%  Clauses is the list of clauses necessary to access member Member_name,
%  of type Type_name, followed by Clauses0.  Other args are as above.

build_member_accessors(Member_name, Type_name, Get_pred, Put_pred,
		Addr_pred) -->
	[structs1:Addr_head],
	{Addr_head =.. [Addr_pred,Member_name,Ptr,Value]},
	{Value =.. [Type_name,Ptr]},
	(   {accessor_goals(Type_name, Ptr, 0, Value1, Get_goal, Put_goal)} ->
	        {assertz(current_get_pred(Get_pred))},
		{Get_head =.. [Get_pred,Member_name,Ptr,Value1]},
		{Put_head =.. [Put_pred,Member_name,Ptr,Value1]},
	    [structs1:(Get_head:-Get_goal),
	     structs1:(Put_head:-Put_goal)]
	;   []			% can't access contents of this slot
	).


%  build_union_accessors(+Union_name, +Get_pred, +Put_pred, +Addr_pred,
%	+D0, -D)
%  Build and assert the clauses that link the user-visable accessor
%  procedures to the accessor procedures for union Union_name, named
%  Get_pred and Addr_pred.  D0 is the list of clauses defining the
%  accessor procedures, and D is this list plus the new union accessors.
%  It is possible for a union to have no members the contents of which
%  can be accessed, in which case, don't generate the linkage clause
%  for Get_pred.

build_union_accessors(Type_name, Get_pred, Put_pred, Addr_pred) -->
	{Addr_goal =.. [Addr_pred,Membername,Ptr,Value]},
	{Term =.. [Type_name,Ptr]},
	[(structs1:get_address(Term,Membername,Value) :-
		 structs1:Addr_goal)],
	(   {current_get_pred(Get_pred)} ->
		{Get_goal =.. [Get_pred,Membername,Ptr,Value]},
		{Put_goal =.. [Put_pred,Membername,Ptr,Value]},
	        [(structs1:get_contents(Term,Membername,Value):-
			 structs1:Get_goal),
		 (structs1:put_contents(Term,Membername,Value):-
			 structs1:Put_goal)]
	;   []			% don't need this linkage clause,
				% because there's nothing to link to
	).


/****************************************************************
			Procedures for all types
 ****************************************************************/

%  cleanup_definition(+Definition0, -Definition)
%  Definition is the definition we want to show users corresponding to
%  Definition0, a definition as we store them internally.
%  NB:  this is also defined in structs.pl.

cleanup_definition(Definition0, Definition) :-
	(   Definition0 = struct(Fields0) ->
		Definition = struct(Fields),
	    (   foreach(field(N,T,_),Fields0),
		foreach(N:T,Fields)
	    do  true
	    )
	;   Definition = Definition0
	).

%  accessor_names(+Name, -Get_pred, -Put_pred, -Addr_pred)
%  Get_pred, Put_pred, and Addr_pred are the appropriate names for
%  the accessor procedures for struct or union Name.

accessor_names(Name, Get_pred, Put_pred, Addr_pred) :-
	atom_concat(Name, '_field', Suffix),
	atom_concat('get_', Suffix, Get_pred),
	atom_concat('put_', Suffix, Put_pred),
	atom_concat(Name, '_address', Suffix2),
	atom_concat('get_', Suffix2, Addr_pred).

%  accessor_goals(+Type_name, +Ptr, +Offset, +Value, -Get_goal,	-Put_goal)
%  Get_goal and Put_goal are the appropriate goals for getting and putting
%  Value, a pointer to a C-type data structure of type Type_name, out of
%  and into memory starting at location Prt + Offset.

accessor_goals(Type_name, Ptr, Offset, Value, Get_goal, Put_goal) :-
	simplify_expr(Ptr+Offset, Addrexpr),
	known_type_defn(Type_name, Defn, _, _),
	(   primitive_type_size(Defn, _, _) ->
		primitive_type_accessors(Defn, Addrexpr, Value,
			Get_goal, Put_goal)
	;   Defn = pointer(Dest_type) ->
		Value =.. [Dest_type,Actual_value],
	        primitive_type_accessors(integer, Addrexpr, Actual_value, Get_goal, Put_goal)
	;   Defn = enum(_Enums) ->
		to_enum_goal(Type_name, Code_value, Value, ToGoal),
		from_enum_goal(Type_name, Code_value, Value, FromGoal),
	        primitive_type_accessors(integer_32, Addrexpr, Code_value, Get_goal0, Put_goal0),
		Get_goal = (Get_goal0, structs1:FromGoal),
		Put_goal = (structs1:ToGoal, Put_goal0)
	).

%  primitive_type_accessors(+Type_name, +Addrexpr, +Value, -Get_goal,
%		-Put_goal)
%  same as accessor_goals/6 above, except that it is known that Type_name
%  is a primitive type.

primitive_type_accessors(Type_name, Addrexpr, Value, structs:Get_goal, structs:Put_goal) :-
	simple(Addrexpr), !,
	primitive_type_accessor_names(Type_name, GetF, PutF),
	Get_goal =.. [GetF,Addrexpr,0,Value],
	Put_goal =.. [PutF,Addrexpr,0,Value].
primitive_type_accessors(Type_name, Ptr+Offset, Value, structs:Get_goal, structs:Put_goal) :-
	primitive_type_accessor_names(Type_name, GetF, PutF),
	Get_goal =.. [GetF,Ptr,Offset,Value],
	Put_goal =.. [PutF,Ptr,Offset,Value].

primitive_type_accessor_names(integer,          get_integer,     put_integer    ).
primitive_type_accessor_names(integer_64,       get_integer_64,  put_integer_64 ).
primitive_type_accessor_names(integer_32,       get_integer_32,  put_integer_32 ).
primitive_type_accessor_names(integer_16,       get_integer_16,  put_integer_16 ).
primitive_type_accessor_names(integer_8,        get_integer_8,   put_integer_8  ).
primitive_type_accessor_names(unsigned,         get_unsigned,    put_unsigned   ).
primitive_type_accessor_names(unsigned_64,      get_unsigned_64, put_unsigned_64).
primitive_type_accessor_names(unsigned_32,      get_unsigned_32, put_unsigned_32).
primitive_type_accessor_names(unsigned_16,      get_unsigned_16, put_unsigned_16).
primitive_type_accessor_names(unsigned_8,       get_unsigned_8,  put_unsigned_8 ).
primitive_type_accessor_names(float,            get_float,       put_float      ).
primitive_type_accessor_names(float_32,         get_float_32,    put_float_32   ).
primitive_type_accessor_names(address,          get_integer,     put_integer    ).
primitive_type_accessor_names(atom,             get_atom,        put_atom       ).
primitive_type_accessor_names(string,           get_string,      put_string     ).


%  struct_or_union_alignment(+Fields_or_members, +Alignment0, -Alignment)
%  Alignment is the byte alignment necessary for a struct or union with
%  Fields_or_members, or Alignment0, whichever is greater.
%  Fields_or_members is in simplified form.  This code assumes that
%  the alignment necessary for a struct or union is the greatest
%  alignment necessary for any of its fields or members.


struct_or_union_alignment(Fields_or_members, Alignment00, Alignment) :-
	(   foreach(Member,Fields_or_members),
	    fromto(Alignment00,Alignment0,Alignment2,Alignment)
	do  (   Member = _:Type_name -> true
	    ;   Member = field(_,Type_name,_)
	    ),
	    known_type_defn(Type_name, _, _, Alignment1),
	    Alignment2 is max(Alignment0, Alignment1)
	).

%  simplify_is(+Expr, +Var, -Goal)
%  A very simple simplifier.  Goal is the goal necessary to bind Var to
%  the value of Expr.  Var may be bound, and Goal bound to true, if the
%  expression can be simplified to a single variable or constant.

simplify_is(Expr0, Var, Goal) :-
	simplify_expr(Expr0, Expr),
	(   simple(Expr) ->
		Var = Expr,
		Goal = true
	;   Goal = is(Var,Expr)
	).

%  simplify(+Expr0, -Expr)
%  the actual simplifier.  Expr is arithmetically equivalent to Expr0.

simplify_expr(Var, Var) :-
	simple(Var), !.
simplify_expr(*(Expr1,Expr2), Expr) :-
	simplify_expr(Expr1, Expr1a),
	simplify_expr(Expr2, Expr2a),
	(   Expr1a == 1 -> Expr = Expr2a
	;   Expr2a == 1 -> Expr = Expr1a
	;   Expr1a == 0 -> Expr = 0
	;   Expr2a == 0 -> Expr = 0
	;   Expr = *(Expr1a,Expr2a)
	).
simplify_expr(+(Expr1,Expr2), Expr) :-
	simplify_expr(Expr1, Expr1a),
	simplify_expr(Expr2, Expr2a),
	(   Expr1a == 0 -> Expr = Expr2a
	;   Expr2a == 0 -> Expr = Expr1a
	;   Expr = +(Expr1a,Expr2a)
	).

%  conjoin(+Goal1, +Goal2, -Conj)
%  Conj is the conjunction of Goal1 and Goal2.  Drops redundant 'true's.

conjoin(Goal1, Goal2, Conj) :-
	(   Goal1 == true -> Conj = Goal2
	;   Goal2 == true -> Conj = Goal1
	;   Conj = (Goal1,Goal2)
	).




/****************************************************************
			foreign file handling
 ****************************************************************/

%  process_pred_spec(+Spec0, +Module, +Clause, -Spec, -WrapperClause)
%  Spec0 is a foreign predicate specification as described in the QP
%  manuals.  Spec is a different predicate specification to be used
%  instead.  WrapperClause is the extra clause needed to define the foreign
%  pred.  As usual, Module is the module this foreign predicate is to
%  be defined in.  Fails if this is not a typed foreign predicate.
%  Clause is the original foreign/2 or /3 clause for error reporting.

process_pred_spec(Spec0, Clause, Spec, Extras) :-
	functor(Spec0, Pred0, Arity),
	functor(Head, Pred0, Arity),
	atom_codes(Pred0, Chars),
	atom_codes(Pred, [0'$|Chars]),
	functor(Spec1, Pred, Arity),
	functor(Body, Pred, Arity),
	process_pred_args(Arity, Spec0, Clause, Spec1, Head, Body,
			  true, Pre, true, Post, false, Needed),
	(   Needed == false ->
		% We don't need the wrapper clause, but we may have used
		% some type name aliases, so we don't want to just fail.
		Extras = [],
		Spec1 =.. [_|Args],		% not fast, but good
		Spec =.. [Pred0|Args]		% enough here
	;   Extras = [:-(Head,(Pre,Body,Post))],
	    Spec = Spec1
	).


%  process_pred_args(+N, +Spec0, +Clause, +Spec, +Head, +Body,
%	+PreGoals0, -PreGoals, +PostGoals0, -PostGoals,
%	+NeedWrapperClause0, -NeedWrapperClause)
%  Process arguments up to N of Spec0, a foreign predicate spec.
%  Spec will be the new foreign predicate spec, and Head:-Body
%  will define the wrapper clause to strip off/add on foreign
%  wrappers.  NeedWrapperClause is either true
%  or false, depending on whether or not there is spec of a user-defined
%  type in some argument position <= N.  If no user-defined types are
%  specified in any argument positions, process_pred_args/7 fails.

process_pred_args(N, Spec0, Clause, Spec, Head, Body, Pre0, Pre, Post0, Post,
	    NeedWrapperClause0, NeedWrapperClause) :-
	(   N =:= 0 ->
		NeedWrapperClause = NeedWrapperClause0,
		Pre0 = Pre, Post0 = Post
	;   arg(N, Spec0, Arg_spec),
	    arg(N, Spec, New_spec),
	    arg(N, Head, Head_arg),
	    arg(N, Body, Body_arg),
	    N1 is N-1,
	    handle_arg_spec(Arg_spec, Clause, New_spec, Head_arg, Body_arg,
			    Pre0, Pre1, Post0, Post1,
			    NeedWrapperClause0, NeedWrapperClause1),
	    process_pred_args(N1, Spec0, Clause, Spec, Head, Body,
		    Pre1, Pre, Post1, Post,
		    NeedWrapperClause1, NeedWrapperClause)
	).

%  handle_arg_spec(+Arg_spec, +Clause, -New_spec, -Head_arg, -Body_arg,
%	  +Pre0, -Pre, +Post0, -Post,
%	  +NeedWrapperClause0, -NeedWrapperClause)
%  Arg_spec is an argument specification in a foreign predicate
%  specification, and Head_arg and Body_arg are the appropriate
%  arguments for that argument position in a linkage procedure.  They
%  will be bound together if Arg_spec does not specify a user-defined
%  type; if not, Head_arg will be the foreign term corresponding to
%  the address Body_arg.  New_spec is the real foreign arg spec to
%  be given to Prolog.  Head_arg \== Body_arg, then NeedWrapperClause
%  is true, else it is NeedWrapperClause0.  Clause is the original
%  foreign/2 or /3 clause for error reporting.

handle_arg_spec(+Type, Clause, +New_type, Head_arg, Body_arg,
		Pre0, Pre, Post, Post, 
		NeedWrapperClause0, NeedWrapperClause) :-
	handle_arg_type(Type, +Type, Clause, New_type, Head_arg, Body_arg,
		Pre0, Pre,
		NeedWrapperClause0, NeedWrapperClause, +).
handle_arg_spec(-Type, Clause, -New_type, Head_arg, Body_arg,
		Pre, Pre, Post0, Post,
		NeedWrapperClause0, NeedWrapperClause) :-
	handle_arg_type(Type, -Type, Clause, New_type, Head_arg, Body_arg,
		Post0, Post,
		NeedWrapperClause0, NeedWrapperClause, -).
handle_arg_spec([-Type], Clause, [-New_type], Head_arg, Body_arg,
		Pre, Pre, Post0, Post, 
		NeedWrapperClause0, NeedWrapperClause) :-
	handle_arg_type(Type, [-Type], Clause, New_type, Head_arg, Body_arg,
		Post0, Post,
		NeedWrapperClause0, NeedWrapperClause, -).

%  handle_arg_spec(+Arg_spec, +Clause, -New_spec, -Head_arg, -Body_arg,
%	  +ExtraGoals0, -ExtraGoals,
%	  +NeedWrapperClause0, -NeedWrapperClause, +PlusMinus)
%  Just like handle_arg_spec/7, except that Arg_spec does not have mode
%  information (eg, no +integer, -integer, or [-integer]; just integer).

handle_arg_type(pointer(Type), _Spec, _Clause, NewSpec,
		Head_arg, Body_arg, EG, EG, _, true, _) :-
	!,
	( atom(Type) ->
	      Head_arg =.. [Type,Body_arg],
	      NewSpec = address(Type)
	; user_type_defn(Type_name, Type) -> % This could be a hack!
	      Head_arg =.. [Type_name,Body_arg],
	      NewSpec = address(Type_name)
	).
handle_arg_type(Type, Spec, Clause, New_type, Head_arg, Body_arg,
		EG0, EG,
		NeedWrapperClause0, NeedWrapperClause, PlusMinus) :-
	(   user_type_defn(Type, enum(_)) ->
		enum_goal(PlusMinus, Type, Body_arg, Head_arg, EG1),
		New_type = integer,
		EG = (EG0, structs1:EG1),
		NeedWrapperClause = true
	;   user_type_defn(Type, Defn) ->
		handle_arg_type(Defn, Spec, Clause,New_type,Head_arg, Body_arg,
		EG0, EG, NeedWrapperClause0, NeedWrapperClause, PlusMinus)
	;   valid_foreign_arg_type(Type, New_type),
	    NeedWrapperClause = NeedWrapperClause0,
	    Head_arg = Body_arg,
	    EG0 = EG
	).

%  valid_foreign_arg_type(+Type0, -Type).
%  Type0 is a valid primitive foreign type, and Type is the type to be
%  used by the foreign interface.  This does mappings like
%  char -> integer.

valid_foreign_arg_type(integer,     integer).
valid_foreign_arg_type(integer_64,  integer).
valid_foreign_arg_type(integer_32,  integer).
valid_foreign_arg_type(integer_16,  integer).
valid_foreign_arg_type(integer_8,   integer).
valid_foreign_arg_type(unsigned,    integer).
valid_foreign_arg_type(unsigned_64, integer).
valid_foreign_arg_type(unsigned_32, integer).
valid_foreign_arg_type(unsigned_16, integer).
valid_foreign_arg_type(unsigned_8,  integer).
valid_foreign_arg_type(float,       float).
valid_foreign_arg_type(float_32,    float).
valid_foreign_arg_type(atom,        atom).
valid_foreign_arg_type(string,      string).
valid_foreign_arg_type(string(_N),  string).
valid_foreign_arg_type(address,     address).
valid_foreign_arg_type(address(X),  address(X)).


/****************************************************************
			Term Expansion code
 ****************************************************************/
:- if(current_prolog_flag(dialect, spider)).
%% Dummy definition for SPIDER.
foreign_type(_Foreigns).
:- endif.


term_exp(:-(X), Clauses) :-
	nonvar(X),
	X = foreign_type(Foreigns), !,
	compile_foreign_type_decl(Foreigns, :-(X), Clauses, []).
term_exp(X, Clauses) :-
	X = foreign(Fn,Lang,Spec0), !,
	declare_discontiguous_foreign(Clauses, [foreign(Fn,Lang,Spec)|ExtraClauses]),
	process_pred_spec(Spec0, X, Spec, ExtraClauses).
term_exp(X, Clauses) :-
	X = foreign(Fn,Spec0), !,
	declare_discontiguous_foreign(Clauses, [foreign(Fn,Spec)|ExtraClauses]),
	process_pred_spec(Spec0, X, Spec, ExtraClauses).
term_exp(end_of_file, end_of_file) :-
	(   dyn_fact(Fa),
	    retractall(Fa),
	    fail
	;   true
	).

dyn_fact(current_type_defn(_,_)).
dyn_fact(current_type_size(_,_,_)).
dyn_fact(current_type_file(_,_)).
dyn_fact(current_get_pred(_)).
dyn_fact(declared_multifile_discontiguous).
dyn_fact(declared_discontiguous_foreign).


:- user_type_defn/2 is nondet.
user_type_defn(Expr, Defn) :-
	structs1:type_defn(Expr, Defn).
user_type_defn(Expr, Defn) :-
	current_type_defn(Expr, Defn).

:- user_type_size/3 is nondet.
user_type_size(Expr, Size, Alignment) :-
	structs1:type_size(Expr, Size, Alignment).
user_type_size(Expr, Size, Alignment) :-
	current_type_size(Expr, Size, Alignment).

:- user_type_file/2 is nondet.
user_type_file(Expr, File) :-
	structs1:type_file(Expr, File).
user_type_file(Expr, File) :-
	current_type_file(Expr, File).

declare_discontiguous_foreign -->
	{declared_discontiguous_foreign}, !.
declare_discontiguous_foreign -->
	{assertz(declared_discontiguous_foreign)},
	[:-(discontiguous(foreign/2)),
	 :-(discontiguous(foreign/3))].

declare_multifile_discontiguous -->
	{declared_multifile_discontiguous}, !.
declare_multifile_discontiguous -->
	{assertz(declared_multifile_discontiguous)},
	[:-(multifile(structs1:type_size/3)),
	 :-(discontiguous(structs1:type_size/3)),
	 :-(multifile(structs1:type_defn/2)),
	 :-(discontiguous(structs1:type_defn/2)),
	 :-(multifile(structs1:type_file/2)),
	 :-(discontiguous(structs1:type_file/2)),
	 :-(multifile(structs1:get_address/3)),
	 :-(discontiguous(structs1:get_address/3)),
	 :-(multifile(structs1:get_contents/3)),
	 :-(discontiguous(structs1:get_contents/3)),
	 :-(multifile(structs1:put_contents/3)),
	 :-(discontiguous(structs1:put_contents/3))].


% Return the line number of the first line of the term layout
condense_layout([FL0|_], FL) :- !, FL=FL0.
condense_layout(FL, FL).

:- multifile user:term_expansion/6.

user:term_expansion(X, Lay0, Ids, Y, Lay, [str_decl|Ids]) :-
	nonvar(X),
	nonmember(str_decl, Ids),
	catch(enabled, error(_,_), fail),
	term_exp(X, Y), !,
        condense_layout(Lay0, Lay).

enabled.
