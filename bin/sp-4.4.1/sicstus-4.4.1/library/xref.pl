/* Copyright(C) 2001, Swedish Institute of Computer Science */
/*

Author: Tom Howland
Maintainer: Mats Carlsson

    Most functionality provided by this code has been superseded by
    the analysis performed by the SICStus Prolog IDE, SPIDER. Please
    contact SICStus Support if there is any functionality in this code
    that you would like to see in SPIDER.

*/

:- module(xref, [xref/2]).


:- use_module(library(avl), [
        empty_avl/1,
	avl_fetch/2,
	avl_fetch/3,
	avl_member/2,
	avl_store/4,
	avl_change/5,
	ord_list_to_avl/2,
	avl_to_list/2
	]).

:- meta_predicate
        conditional_is_true(0).

:- dynamic visited/1.		% so we won't visit a file twice.
:- volatile visited/1.
:- dynamic cant_follow/7.       % a rare warning
:- volatile cant_follow/7.

/* xref(+Files, +Options)
"Files" must be single prolog file specification or a ground list of
prolog file specifications. A ".pro" or ".pl" extension may be omitted.

"Options" must be a ground list of zero or more options of the form:

     runtime_entry ... This makes the cross referencer trace from
         user:runtime_entry/1.  In its absence, it traces from
         module declarations.

     compiler_errors ... This makes the cross referencer
         generate standard compiler style error messages.

     verbose ... verbose output. This forces the cross referencer to
         echo the names of the files being read to user_error like qld
         would do.

     warnings(WFile) ...  warning file. Warnings are written to
         user_error by default. "WFile" must be a file specification.

     xref(XFile) ... cross reference file. This is not generated
         by default. "XFile" must be a file specification.

     mod(MFile) ... generate a file indicating which predicates are
         imported and which are exported for each file. This is not
         generated by default. "MFile" must be a file specification.

     undefined(UFile) ... generate a list of undefined predicates.
         References to undefined predicates are given in the warnings
         file, but sometimes you just want a list of the undefined
         predicates. "UFile" must be a file specification.

For example, the following would be a reasonable invocation:

	?- xref(foo, [verbose]).

This would check "foo.pl" for undefined and unreachable code,
generating no cross reference file, displaying warnings on user_error.

*/

xref(Files, Options) :-

    retractall(cant_follow(_,_,_,_,_,_,_)),
    retractall(visited(_)),
    default(runtime_entry, runtime_entry, exports, Options, TraceRoot),
    default(compiler_errors, compiler, normal, Options, CompilerErrors),
    default(verbose, verbose, silent, Options, Verbose),
    default(warnings(WFile), WFile, user_error, Options, WFile),
    default(xref(XF), file(XF), suppress, Options, XFile),
    default(mod(MF), file(MF), suppress, Options, MFile),
    default(undefined(UF), file(UF), suppress, Options, UFile),
    prolog_flag(syntax_errors, Err, dec10),
    % prolog_flag(gc_margin, Old, 9216),	% 9 times the default,
    init_d(Dict0),
    load_files(Files, [], user, '', 0-Verbose, Dict0, Dict),
    print_message(help, xref(Verbose,thinking)),
    retractall(visited(_)),
    garbage_collect_atoms,
    think(Dict, TraceRoot, MFile, UFile, R, XREF, MMD),
    print_message(help, xref(Verbose,printing)),
    print_it(WFile, R, XFile, XREF, MFile, MMD, CompilerErrors),
    print_message(help, xref(Verbose,done)),
    % prolog_flag(gc_margin, _, Old),
    prolog_flag(syntax_errors, _, Err).

default(Key, Value,     _, Options, Value) :- memberchk(Key, Options), !.
default(_,       _, Value,       _, Value).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
/* this is where we read in the sources.

   The object is to create a d/6 structure representing the entire application.

   d(Defs, Imports, Externs, Initializations, MetaPredicates, Warnings)

   where

   Defs .. a list of clauses, represented as Head-Body, where

       Head is a g/3 structure, that is, a term of the form

       		g(Name, Arity, Module)

       Body is a a term clause(File, LC, Goals) where

          File is the file in which the clause was read
	  LC is the line number
	  Goals is a list of g/3 structures.

   Imports .. an avl tree. g(N,A,OldModule)-g(N,A,NewModule)

   Externs .. a list of terms of the form

   	extern(File, LC, Name, Arity, Module)

   Initializations ... a list of terms of the form

   	initialization(File, LC, Goals)
   	or [PM] 4.1
   	conditional(File, LC, Goals)

      where Goals is a list of g/3 structures.

   MetaPredicates ... an avl tree g(Name,Arity,Module)-(Head-Metas) where

      Head is a term that will unify with a meta predicate
      Metas is a list of variables occuring in Head that are the meta arguments

   Warnings is a list of error terms as handled by print_warning_list/3

This data structure is handled by the following predicates which implement an
abstract datatype suited for use in a DCG.
*/

init_d(d([],A,[],[],A,[])) :-
	empty_avl(A).

get_d_defs(Defs, d(Defs,_,_,_,_,_)).

set_d_defs(Defs0, Defs, d(Defs0,Im,Ex,In,Mt,Wrn), d(Defs,Im,Ex,In,Mt,Wrn)).

get_d_imports(Im, d(_,Im,_,_,_,_)).
get_d_imports(Im, D, D) :- get_d_imports(Im, D).
set_d_imports(Im0, Im, d(Defs,Im0,Ex,In,Mt,Wrn), d(Defs,Im,Ex,In,Mt,Wrn)).

get_d_externs(Ex, d(_,_,Ex,_,_,_)).

set_d_externs(Ex0, Ex, d(Defs,Im,Ex0,In,Mt,Wrn), d(Defs,Im,Ex,In,Mt,Wrn)).

get_d_initializations(In, d(_,_,_,In,_,_)).

set_d_initializations(In0, In, d(Defs,Im,Ex,In0,Mt,Wrn),
		      d(Defs,Im,Ex,In,Mt,Wrn)).

set_d_metas(Mt0, Mt, d(Defs,Im,Ex,In,Mt0,Wrn), d(Defs,Im,Ex,In,Mt,Wrn)).

get_d_warnings(Wrn, d(_,_,_,_,_,Wrn)).

set_d_warnings(Wrn0, Wrn, d(Defs,Im,Ex,In,Mt,Wrn0), d(Defs,Im,Ex,In,Mt,Wrn)).



load_files([], _, _, _, _) --> !.
load_files([H|T], Options, M, F, L) --> !,
    load_files(H, Options, M, F, L),
    load_files(T, Options, M, F, L).
load_files(Mod:Files, Options, _, D, L) --> !, % [MC] 3.9.1
	load_files(Files, Options, Mod, D, L).
load_files(X, Options, _, F, _) -->
    {append(Front, [when(When)|Back], Options)},
    {When \== run_time},		% SP: always true
    {append(Front, Back, Options1)},
    {
      Error = error(ISOError,_),
      on_exception(Error, 
                 ( absolute_file_name(X, File, [access(exist),file_type(source),relative_to(F)]),
                   load_files(File, Options1)
                 ),
                 print_message(error, Error)),
      ( nonvar(ISOError) ->
        %% [PM] 4.1 do not fall into next clause on error
        !,
        fail
      ; true
      )
    },
    {When == compile_time},
    % otherwise fall through to next clause to handle runtime dependency
    !.
load_files(X, Options, Mod, F, Level-Verbose, D0, D) :-
    Error = error(_,_),
    on_exception(Error, 
		 absolute_file_name(X, File, [access(exist),file_type(source),relative_to(F)]),
		 (print_message(error, Error), fail)), !,
    open(File, read, Stream),
    read_one(Stream, Term, LC),
    (   (Term = (:-module(M,Exports)); Term = (:-module(M,Exports,_)))
    ->  (   memberchk(imports(Imports), Options), Imports \== all
	->  true
	;   Imports = Exports
	),
	imports(Mod, M, Imports, D0, D1),
	read_one(Stream, TheTerm, TheLC),
	TheMod = M
    ;   TheTerm = Term, TheLC = LC, TheMod = Mod, D1 = D0
    ),
    (   visited(File)
    ->  D = D1
    ;   print_message(help, xref(Verbose,processing(Level,File))),
	assert(visited(File)),
	L is Level+1,
        read_loop(TheTerm, Stream, TheLC, TheMod, File, L-Verbose, D1, D)
    ),
    close(Stream).
load_files(_X, _, _, _F, _) --> [].

%% [PM] 4.1 FIXME: All callers should handle [VARIABLE] from read_one
read_one(Stream, X, LC) :-
    line_count(Stream, L0),
    LC is L0+1,
    read(Stream, Y),
    expand_term(Y, X).

read_one2(Stream, X, LC, Conds) :-
    line_count(Stream, L0),
    LC is L0+1,
    read(Stream, Y),
    ( Conds = [state(skip,_,_)|_] ->
      %% Do not expand term when skipping
      X = Y
    ; otherwise ->
      expand_term(Y, X)
    ).

imports(Mod, M, Exports, D0, D) :-
    set_d_imports(Imports0, Imports, D0, D),
    import(Exports, Mod, M, Imports0, Imports).

import([], _, _, I, I).
import([N/A|R], Mod, M, I0, I) :-
    avl_store(g(N,A,Mod), I0, g(N,A,M), I1),
    import(R, Mod, M, I1, I).

read_loop(X0, Stream, LC0, Mod, File, L, D0, D) :-
        Conds = [],
        read_loop2(X0, Stream, LC0, Mod, File, L, Conds, D0, D).
%% read_loop(end_of_file, _, _,   _,    _, _,  D, D) :- !.
%% read_loop(X0, Stream, LC0, Mod, File, L, D0, D) :-
%%     recognize(X0, LC0, Mod, File, L, D0, D1),
%%     read_one(Stream, X, LC),
%%     read_loop(X, Stream, LC, Mod, File, L, D1, D).


read_loop2(end_of_file, _, _,   _,    _, _,  Conds, D, D) :- !,
    ( Conds = [_|_] ->
      print_message(error, unterminated_conditionals(Conds))
    ; true
    ).
read_loop2((:- if(Test)), Stream, LC0, Mod, File, L, Conds, D0, D) :- !,
    ( Conds = [state(skip,_,_)|_] ->
      %% Continue skipping and pretend we have seen true-branch
      Conds1 = [state(skip, true, false)|Conds],
      D1 = D0
    ; otherwise ->
      % [PM] 4.2.1 Pass proper module context for test.
      ( conditional_is_true(Mod:Test) ->
        %% Continue, not skipping, seen true branch, not seen else branch
        Conds1 = [state(do, true, false)|Conds]
      ; otherwise ->
        %% Test assumed false
        %% Continue, skipping, not seen true branch, not seen else branch
       Conds1 = [state(skip, false, false)|Conds]
      ),
      %% follow goals in evaluated tests only
      % [PM] 4.2.1 pretend it was an initialization.
      recognize((:- initialization(Test)), LC0, Mod, File, L, D0, D1)
    ),
    read_one2(Stream, X, LC, Conds1),
    read_loop2(X, Stream, LC, Mod, File, L, Conds1, D1, D).
read_loop2((:- elif(Test)), Stream, LC0, Mod, File, L, Conds, D0, D) :- !,
    ( Conds = [state(_,true,_)|Conds2] ->
      %% Seen true-branch (and/or in surrounding skip branch)
      %% Continue skipping, seen true-branch, not seen else-branch
      Conds1 = [state(skip, true, false)|Conds2],
      D1 = D0
    ; Conds = [state(_,_,false)|Conds2] -> % not seen else yet
      % [PM] 4.2.1 Pass proper module context for test.
      ( conditional_is_true(Mod:Test) ->
        %% Continue, not skipping, seen true branch, not seen else branch
         Conds1 = [state(do, true, false)|Conds2]
      ; otherwise ->
        %% Test assumed false
        %% Continue, skipping, not seen true branch, not seen else branch
        Conds1 = [state(skip, false, false)|Conds2]
      ),
      %% follow goals in evaluated tests only
      % [PM] 4.2.1 pretend it was an initialization.
      recognize((:- initialization(Test)), LC0, Mod, File, L, D0, D1)
    ; otherwise ->
      %% elif without matching if/1. We are toast.
      print_message(error, mismatched_conditional((:- elif(Test)))),
      %% Start skipping, seen true branch, not seen else branch
      Conds1 = [state(skip, true, false)|Conds],
      D1 = D0
    ),
    read_one2(Stream, X, LC, Conds1),
    read_loop2(X, Stream, LC, Mod, File, L, Conds1, D1, D).
read_loop2((:- else), Stream, _LC0, Mod, File, L, Conds, D0, D) :- !,
    ( Conds = [state(_,true,_)|Conds2] ->
      %% Seen true-branch (and/or in surrounding skip branch)
      %% Continue skipping, seen true-branch, seen else-branch
      Conds1 = [state(skip, true, true)|Conds2]
    ; Conds = [state(_,_,false)|Conds2] -> % not seen else yet
      %% Continue, not skipping, seen true branch, seen else branch
      Conds1 = [state(do, true, true)|Conds2]
    ; otherwise ->
      %% else without matching if/1. We are toast.
      print_message(error, mismatched_conditional((:- else))),
      %% Start skipping, seen true branch, seen else branch
      Conds1 = [state(skip, true, true)|Conds]
    ),
    read_one2(Stream, X, LC, Conds1),
    read_loop2(X, Stream, LC, Mod, File, L, Conds1, D0, D).
read_loop2((:- endif), Stream, _LC0, Mod, File, L, Conds, D0, D) :- !,
    ( Conds = [_|Conds2] ->
      %% just pop the stack
      Conds1 = Conds2
    ; Conds = [] ->
      %% Mismatched endif
      print_message(error, mismatched_conditional((:- endif))),
      %% Ignore it
      Conds1 = []
    ),
    read_one2(Stream, X, LC, Conds1),
    read_loop2(X, Stream, LC, Mod, File, L, Conds1, D0, D).
read_loop2(_X0, Stream, _LC0, Mod, File, L, Conds, D0, D) :-
    %% Skipping, do not call recognize
    Conds = [state(skip,_,_)|_],
    !,
    Conds1 = Conds,
    read_one2(Stream, X, LC, Conds1),
    read_loop2(X, Stream, LC, Mod, File, L, Conds1, D0, D).
read_loop2(X0, Stream, LC0, Mod, File, L, Conds, D0, D) :-
    recognize(X0, LC0, Mod, File, L, D0, D1),
    read_one(Stream, X, LC),
    read_loop2(X, Stream, LC, Mod, File, L, Conds, D1, D).

%% Test whether a if/1 or elif/1 condition is true. Prints a message and fails on error.
conditional_is_true(Test) :-
        E = error(_,_),
        on_exception(E,
                     \+ \+ Test,
                     (print_message(error, E),
                      fail
                     )
                    ).

recognize(foreign_resource(_,_), _, _, _, _) --> !.
recognize([], _,  _, _, _) --> !.
recognize([H|T], LC, Mod, File, L) --> !,
    recognize(H, LC, Mod, File, L),
    recognize(T, LC, Mod, File, L).
recognize((:-G), LC, Mod, File, L) --> !,
    command(G, LC, Mod, File, L).
recognize((M:X), LC, _, File, L) --> !,
    recognize(X, LC, M, File, L).
recognize((X:-Y), LC, Mod, File, _) --> !,
    {module_prefix(X, Mod, Head, HeadC)},
    insert_clause(Head, Y, HeadC, LC, Mod, File).
recognize(foreign(_,_,G), LC, Mod, File, _) --> !,
    insert_clause(G, true, Mod, LC, Mod, File).
recognize(foreign(_,G), LC, Mod, File, _) --> !,
    insert_clause(G, true, Mod, LC, Mod, File).
recognize(X, LC, Mod, File, _) -->
    insert_clause(X, true, Mod, LC, Mod, File).

command((X,Y), LC, M, F, L) --> !,
    command(X, LC, M, F, L),
    command(Y, LC, M, F, L).
command(op(P,T,O), _, _, _, _) --> !,
    {op(P,T,O)}.
command(initialization(Body), LC, Mod, File, _) --> !,
    set_d_initializations(In, [initialization(File,LC,B)|In]),
    get_d_imports(Im),
    set_d_metas(Mt0, Mt),
    { body(Body, x('', initialization,1,LC,Mod,File,Im,Mt0), B, []),
      record_non_metas(B, Mt0, Mt)
    }.
command(if(Test), LC, Mod, File, _Line) --> !,
    set_d_initializations(In, [conditional(File,LC,B)|In]),
    get_d_imports(Im),
    set_d_metas(Mt0, Mt),
    { body(Test, x('', if,1,LC,Mod,File,Im,Mt0), B, []),
      record_non_metas(B, Mt0, Mt)
    }.
command(elif(Test), LC, Mod, File, _Line) --> !,
    set_d_initializations(In, [conditional(File,LC,B)|In]),
    get_d_imports(Im),
    set_d_metas(Mt0, Mt),
    { body(Test, x('', elif,1,LC,Mod,File,Im,Mt0), B, []),
      record_non_metas(B, Mt0, Mt)
    }.
command(meta_predicate(Meta), LC, Mod, File, _) --> !,
    set_d_warnings(Wrn0, Wrn),
    set_d_metas(M0, M),
    { parse_metas(Meta, Mod, File, LC, Wrn0, Wrn, M0, M) }.
command(dynamic(Dynamic), LC, Mod, File, _) --> !,
    parse_dynamics(Dynamic, LC, Mod, File, dynamic).
command(multifile(Dynamic), LC, Mod, File, _) --> !, % SP
    parse_dynamics(Dynamic, LC, Mod, File, multifile).
command(public(Public), LC, Mod, File, _) --> !, % SP
    parse_publics(Public, LC, Mod, File).
% command(extern(G), _, _, _, _) --> {predicate_property(G, built_in)}, !. % QP
% command(extern(G), LC, Mod, File, _) --> !, % QP
%     set_d_externs(E, [extern(File,LC,N1,A1,Mod)|E]),
%     { functor(G, N1, A1) }.
command(LoadCommand, _, M, F, L) -->
    {load_command(LoadCommand, Files, Options)}, !,
    load_files(Files, Options, M, F, L).
% [MC] 3.9.1 arbitrary commands treated as initializations
command(Cmd, LC, Mod, File, Line) -->
	command(initialization(Cmd), LC, Mod, File, Line).

parse_metas(M:X, _, F, LC, Wrn0, Wrn) --> !,
    parse_metas(X, M, F, LC, Wrn0, Wrn).
parse_metas((X,Y), Mod, F, LC, Wrn0, Wrn) --> !,
    parse_metas(X, Mod, F, LC, Wrn0, Wrn1),
    parse_metas(Y, Mod, F, LC, Wrn1, Wrn).
parse_metas(Meta, Mod, F, LC, Wrn0, Wrn, M0, M) :-
    functor(Meta, N, A),
    functor(X, N, A),
    parse_meta(A, Meta, X, L), !,
    (	avl_fetch(g(N,A,Mod), M0, Old)
    ->	(   Old == none
	->  Wrn = [p(F,LC,late_meta_decl(N,A,Mod))|Wrn0]
	;   Wrn = [p(F,LC,duplicate_meta_decl(N,A,Mod))|Wrn0]
	)
    ;	Wrn = Wrn0
    ),
    avl_store(g(N,A,Mod), M0, X-L, M).
parse_metas(Meta, _Mod, F, LC, Wrn0, Wrn) -->
	{Wrn = [p(F,LC,malformed(meta_predicate(Meta)))|Wrn0]}.

parse_meta(0, _, _, []) :- !.
parse_meta(A, Meta, X, L) :-
    (   arg(A, Meta, Arg),
        (   Arg == (:)
        ->  Extras = 0
	;   integer(Arg)
	->  Extras = Arg
	)
    ->  L = [H-Extras|T], arg(A, X, H)		% the crux of the biscuit
    ;   L = T
    ),
    B is A-1, parse_meta(B, Meta, X, T).

parse_dynamics((X,Y), LC, Mod, File, Decl) --> !,
    parse_dynamics(X, LC, Mod, File, Decl),
    parse_dynamics(Y, LC, Mod, File, Decl).
parse_dynamics(M:N/A, LC, _, File, _Decl) -->
    dynamic(N, A, LC, M, File), !.
parse_dynamics(N/A, LC, Mod, File, _Decl) -->
    dynamic(N, A, LC, Mod, File), !.
parse_dynamics(Spec, LC, _Mod, File, Decl) -->
	{Term =.. [Decl,Spec]},
	set_d_warnings(Wrn0, [p(File,LC,malformed(Term))|Wrn0]).

% dynamic(foreign, 2, _, _, _) --> !.
% dynamic(foreign, 3, _, _, _) --> !.
% dynamic(foreign_resource, 2, _, _, _) --> !.
dynamic(N, A, LC, Mod, File) -->
	{atom(N), integer(A)},
    insert_clause(N, A, true, Mod, LC, Mod, File).

parse_publics((X,Y), LC, Mod, File) --> !,
    parse_publics(X, LC, Mod, File),
    parse_publics(Y, LC, Mod, File).
parse_publics(M:N/A, LC, _, File) -->
    public(N, A, LC, M, File), !.
parse_publics(N/A, LC, Mod, File) -->
    public(N, A, LC, Mod, File), !.
parse_publics(Spec, LC, _Mod, File) -->
	set_d_warnings(Wrn0, [p(File,LC,malformed(public(Spec)))|Wrn0]).

public(N, A, LC, Mod, File) -->
	{atom(N), integer(A)},
    set_d_externs(E, [extern(File,LC,N,A,Mod)|E]).

load_command(load_files(Files, Options), Files, Options).
load_command(load_files(Files), Files, []).
load_command(include(Files), Files, []). % SP
load_command([H|T], [H|T], []).
load_command(compile(Files), Files, [load_type(compile)]).
load_command(consult(Files), Files, [load_type(compile)]).
load_command(ensure_loaded(Files), Files, [if(changed)]).
load_command(use_module(Files), Files, [must_be_module(yes)]).
load_command(use_module(Files,Imports), Files,
	     [must_be_module(yes),imports(Imports)]).
load_command(use_module(_, File, Imports), File,
	     [must_be_module(yes),imports(Imports)]) :- ground(File).

module_prefix(M:X, _, Head, HeadC) :- !,
    module_prefix(X, M, Head, HeadC).
module_prefix(Head, Mod, Head, Mod).

insert_clause(N, A, Y, HeadC, LC, BodyC, File) -->
    { functor(X, N, A) },
    insert_clause(X, Y, HeadC, LC, BodyC, File).

insert_clause(X, Y, HeadC, LC, BodyC, File) -->
    set_d_defs(T, [H|T]),
    get_d_imports(I),
    set_d_metas(Mt0, Mt),
    { H = G-clause(File,LC,Body),
      G = g(N,A,HeadC),
      functor(X, N, A),
      body(Y, x(G,N,A,LC,BodyC,File,I,Mt0), Body, []),
      record_non_metas(Body, Mt0, Mt)
    }.

body(X, M)                       --> {var(X)}, !, {cant_follow(M, X)}.
body((M:X), MM)                  --> !, change_mod(X, M, MM).
body((\+X), M)                   --> !, body(X, M).
body((X,Y), M)                   --> !, body(X, M), body(Y, M).
body((X->Y), M)                  --> !, body(X, M), body(Y, M).
body((X;Y), M)                   --> !, body(X, M), body(Y, M).
body(_^X, M)                     --> !, body(X, M).
body(if(X,Y,Z), M)               --> !,	% SP
	body(X, M),
	body(Y, M),
	body(Z, M).
body(once(X), M)                 --> !, body(X, M). % SP
body(do(_,X), M)                 --> !, body(X, M). % SP
body(abolish(X), M)              --> !, pred_spec_tree(abolish, 1, X, M).
body(abolish(X,_), M)            --> !, pred_spec_tree(abolish, 2, X, M).
% body(add_advice(X,_,Y), M0)    --> !, {parent(add_advice, 3, M0, M)}, % QP
%     body(X, M), body(Y, M).
body(assert(X), M)               --> !, parent(assert, 1, X, M).
body(assert(X,_), M)             --> !, parent(assert, 2, X, M).
body(asserta(X), M)              --> !, parent(asserta, 1, X, M).
body(asserta(X,_), M)            --> !, parent(asserta, 2, X, M).
body(assertz(X), M)              --> !, parent(assertz, 1, X, M).
body(assertz(X,_), M)            --> !, parent(assertz, 2, X, M).
body(bagof(_,X,_), M)            --> !, parent(bagof, 3, X, M).
% [MC] treat as opaque
% body(call(X), M)                 --> !, parent(call, 1, X, M).
body(call_residue_vars(X,_), M)       --> !, parent(call_residue_vars, 2, X, M). % SP
body(call_cleanup(X,C), M)       --> !, parent(call_cleanup, 2, X, M), % SP
	                                parent(call_cleanup, 2, C, M).
body(catch(X,_,Y), M0)           --> !, {parent(catch, 3, M0, M)}, % SP
	body(X, M),
	body(Y, M).
body(clause(X,_), M)             --> !, parent(clause, 2, X, M).
body(clause(X,_,_), M)           --> !, parent(clause, 3, X, M).
% body(current_advice(X,_,Y), M0)--> !, {parent(current_advice, 3, M0, M)}, % QP
%     body(X, M), body(Y, M).
body(current_predicate(X), M)    --> !, pred_spec_tree(current_predicate, 1, X, M).
body(current_predicate(_,X), M)  --> !, parent(current_predicate, 2, X, M).
body(findall(_,X,_), M)          --> !, parent(findall, 3, X, M).
body(findall(_,X,_,_), M)        --> !, parent(findall, 4, X, M). % SP
body(freeze(_,X), M)             --> !, parent(freeze, 2, X, M). % SP [MC] 3.11.3
body(listing(X), M)              --> !, pred_spec_tree(listing, 1, X, M). % SP
% body(multifile_assertz(X), M)  --> !, parent(multifile_assertz, 1, X, M). % QP
body(nospy(X), M)                --> !, pred_spec_tree(nospy, 1, X, M). % SP
body(on_exception(_,X,Y), M0)    --> !, {parent(on_exception, 3, M0, M)},
	body(X, M),
	body(Y, M).
% [MC] treat as opaque
% body(phrase(X,_), M)             --> !, phrase(phrase, 2, X, M).
% body(phrase(X,_,_), M)           --> !, phrase(phrase, 3, X, M).
body(predicate_property(X,_), M) --> !, parent(predicate_property, 2, X, M).
body(profile_data(X,_,_,_), M)   --> !, pred_spec_tree(profile_data, 4, X, M). % SP
body(profile_reset(X), M)        --> !, pred_spec_tree(profile_reset, 1, X, M). % SP
% body(require(X), M)              --> !, pred_spec_tree(require, 1, X, M). % SP3
body(retract(X), M)              --> !, parent(retract, 1, X, M).
body(retractall(X), M)           --> !, parent(retractall, 1, X, M).
body(save_predicates(X,_), M)	 --> !, pred_spec_tree(save_predicates, 2, X, M).
body(save_program(_,X), M)        --> !, parent(save_program, 2, X, M). % [MC] 3.11.3
body(setof(_,X,_), M)            --> !, parent(setof, 3, X, M).
body(source_file(X,_), M)        --> !, parent(source_file, 2, X, M).
% body(source_file(X,_,_), M)      --> !, parent(source_file, 3, X, M). % QP
body(spy(X), M)	                 --> !, pred_spec_tree(spy, 1, X, M). % SP
body(spy(X,_), M)                --> !, pred_spec_tree(spy, 2, X, M). % SP
% body(undo(X), M)                 --> !, parent(undo, 1, X, M).
body(when(_,X), M)               --> !, parent(when, 2, X, M).
% [PM] 4.2.1 Use an explicit module (instead of implied 'xref') but do
% not use the module from MM since predicate_property/2 will fail for unknown modules.
body(X, _)                       --> {predicate_property(user:X, built_in)}, !.
body(X, MM)                      --> [G],
    {functor(X, N, A)},
    {arg(5, MM, M)},
    maybe_meta(X, MM, g(N,A,M), G).

change_mod(Body, M, X) --> {var(M)}, !,
    {cant_follow(X, Body)}.
change_mod(X, M, x(G,N,A,LC,_,F,I,Mt)) -->
    body(X, x(G,N,A,LC,M,F,I,Mt)).

/* [MC] Messy and not helpful. */
cant_follow(_).

cant_follow(_, _).
% cant_follow(X0, Body) :-
% 	callable(Body), !,
% 	functor(Body, N, A),
% 	parent(N, A, X0, X),
% 	cant_follow(X).
% cant_follow(X, _) :-
% 	cant_follow(X).


% cant_follow(x(G,N,A,LC,_,F,_,Mt)) :-
%    (  functor(NF, N, A), need_not_follow(NF)
%    -> true
%    ;  avl_fetch(G, Mt, _)
%    -> true
%    ;  g(Ng,Ag,Mg) = G, assert(cant_follow(N,A,Mg,Ng,Ag,F,LC))
%    ).

% need_not_follow(assert(_,_)).
% need_not_follow(assert(_)).
% need_not_follow(abolish(_)).
% need_not_follow(abolish(_,_)).

parent(N, A, X, M0, S0, S) :-
    parent(N, A, M0, M),
    body(X, M, S0, S).

parent(N, A, x(G,_,_,LC,M,F,I,Mt), x(G,N,A,LC,M,F,I,Mt)).

pred_spec_tree(N, A, Tree, M0, S0, S) :- parent(N, A, M0, M),
    pred_spec_tree(Tree, M, S0, S).

pred_spec_tree([], _, S, S) :- !.
pred_spec_tree([H|T], M) --> !,
    pred_spec_tree(H, M),
    pred_spec_tree(T, M).
pred_spec_tree(M:_, MM, S, S) :- var(M), !,
    cant_follow(MM).
pred_spec_tree(M:X, x(G,N,A,LC,_,F,I,Mt)) --> !,
    pred_spec_tree(X, x(G,N,A,LC,M,F,I,Mt)).
pred_spec_tree(N/A, M, S, S) :- \+ (atom(N), integer(A)), !,
    cant_follow(M).
pred_spec_tree(N/A, M, S0, S) :-
    functor(X, N, A),
    body(X, M, S0, S).

% [MC] treat as opaque
% phrase(Phrase, Ap, X, M0, S0, S) :-
%     (   var(X)
%     ->  S0 = S,
%         parent(Phrase, Ap, M0, M),
%         cant_follow(M)
%     ;   expand_term((x-->X),(_:-Y)),
%         body(Y, M0, S0, S)
%     ).

maybe_meta(X, M0, G, G, S0, S) :-
    arg(8, M0, Metas),
    avl_fetch(G, Metas, V),
    V \== none, !,
    copy_term(V, X-L),
    functor(X, N, A),
    parent(N, A, M0, M),
    meta(L, M, S0, S).
maybe_meta(X, M, G0, G, S0, S) :-
    arg(7, M, Imports),
    avl_fetch(G0, Imports, G1), !,
    maybe_meta(X, M, G1, G, S0, S).
maybe_meta(_, _, G, G, S, S).

meta([], _) --> [].
meta([H-Extras|T], M) -->
    {   var(H)			% 3.9, was missing
    ->	H1 = H		% shortcut
    ;   Extras =:= 0
    ->	H1 = H		% shortcut
    ;	length(Tail, Extras),
	H =.. Front,
	append(Front, Tail, Whole),
	H1 =.. Whole
    },
    body(H1, M),
    meta(T, M).


%  Remember that we've seen calls to all the predicates in a clause body, so
%  if we haven't already seen a meta_predicate declaration for them, we
%  had better not see one later.

record_non_metas([], Mt, Mt).
record_non_metas([G|Gs], Mt0, Mt) :-
    (   avl_fetch(G, Mt0, _)
    ->	Mt1 = Mt0
    ;	avl_store(G, Mt0, none, Mt1)
    ),
    record_non_metas(Gs, Mt1, Mt).



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
% The list of clauses is converted into an avl tree.  The cross
% referencing is then done by following user:runtime_entry/1, publics, and
% initializations. Finally, the results are prepared for printing.

think(D, TraceRoot, MFile, UFile, Warnings, XREF, MMD) :-
    get_d_defs(Defs, D),
    get_d_imports(Imports, D),
    get_d_externs(Externs, D),
    get_d_initializations(INI, D),
    get_d_warnings(Warnings0, D),
    keysort(Defs, Sorted),
    merge_clauses(Sorted, Merged),
    ord_list_to_avl(Merged, Def0),
    follow_top(TraceRoot, Imports, Externs, INI, Def0, Def),
    massage(Def, MFile, UFile, Warnings0, Warnings, XREF, MMD).

follow_top(TraceRoot, Imports, Externs, INI) -->
    follow_initializations(INI, Imports),
    (   {TraceRoot==exports}
    ->  {avl_to_list(Imports, ImportList)},
	follow_imports(ImportList, Imports)
    ;   {Item = g(runtime_entry,1,user)},
	follow(Item, xref(Item), Imports)
    ),
    follow_hooks([term_expansion/6,
		  unknown_predicate_handler/3,
		  portray/1,
		  portray_message/2,
		  message_hook/3,
		  generate_message_hook/3,
		  query_hook/6,
		  query_class_hook/5,
		  query_input_hook/3,
		  query_map_hook/4,
		  breakpoint_expansion/2,
		  debugger_command_hook/2,
		  error_exception/1
		 ], user, Imports),
    follow_hooks([generate_message/3,
		  operation/3,
		  typename/3,
		  message/3,
		  contexttype/3,
		  commandtype/3,
		  query_abbreviation/3,
		  query_class/5,
		  query_input/3,
		  query_map/4
		 ], 'SU_messages', Imports),
    {findall(M, avl_member(g(_,_,M),Imports), Ms0)},
    {sort(Ms0, Ms)},
    (   foreach(Mod,Ms),
	param(Imports)
    do  follow_hooks([goal_expansion/5,
		      attribute_goal/2,
		      project_attributes/2,
		      verify_attributes/3
		     ], Mod, Imports)
    ),
    follow_externs(Externs, Imports).

merge_clauses([], []).
merge_clauses([K-H|T0], [K-clauses([H|L])|R]) :-
    merge(T0, K, L, T),
    merge_clauses(T, R).

merge([K-H|T], K, [H|R], ML) :- !,
    merge(T, K, R, ML).
merge(T, _, [], T).

follow_initializations([], _) --> [].
follow_initializations([Ini|T], Imports) -->
    {
      ( Ini = initialization(F,LC,B) ->
        Referee = initialization(F,LC)
      ; Ini = conditional(F,LC,B),
        Referee = conditional(F,LC)
      )
    },
    follow_body(B, Referee, Imports),
    follow_initializations(T, Imports).

follow_body([], _, _) --> [].
follow_body([H|T], Referee, Imports) -->
    follow(H, Referee, Imports),
    follow_body(T, Referee, Imports).

follow(G, Referee, Imports, Def0, Def) :- % [MC] SPRM 13397
	follow(G, Referee, Imports, [], Def0, Def).

follow(G, _, _, Stack, Def, Def) :-
	member(G, Stack), !.
follow(G, Referee, Imports, Stack, Def0, Def) :-
    (   avl_fetch(G, Def0, V)
    ->  found(V, G, Referee, Imports, Def0, Def)
    ;   avl_fetch(G, Imports, K)
    ->  follow(K, Referee, Imports, [G|Stack], Def0, Def)
    ;   (   Referee == hook
	->  true
 	;   undefined_ok(G)
	)
    ->  Def0 = Def
    ;   avl_store(G, Def0, undefined([Referee]), Def)
    ).

found(clauses(Clauses), G, Referee, Imports, Def0, Def) :-
    collect_files(Clauses, Files1),
    to_ordset(Files1, Files, []),
    avl_change(G, Def0, _, Def1, referenced(Files,[Referee])),
    g(N,A,M) = G,
    follow_bodies(Clauses, N, A, M, Imports, Def1, Def).
found(referenced(Files,R), G, Referee, _, Def0, Def) :-
    avl_change(G, Def0, _, Def, referenced(Files,[Referee|R])).
found(undefined(R), G, Referee, _, Def0, Def) :-
    avl_change(G, Def0, _, Def, undefined([Referee|R])).

collect_files([], _).
collect_files([clause(File,_,_)|T], Files) :-
    insert(File, Files),
    collect_files(T, Files).

insert(Name, dic(N,B,A)) :-
    (   Name = N
    ->  true
    ;   Name @< N
    ->  insert(Name, B)
    ;   insert(Name, A)
    ).

to_ordset(X) --> {var(X)}, !.
to_ordset(dic(N,B,A)) --> to_ordset(B), [N], to_ordset(A).

follow_bodies([], _, _, _, _) --> [].
follow_bodies([clause(File,LC,Body)|T], N, A, M, Imports) -->
    follow_body(Body, referee(File,LC,N,A,M), Imports),
    follow_bodies(T, N, A, M, Imports).

undefined_ok(g(N,A,M)) :-
	undefined_ok(N, A, M).

:- undefined_ok/3 is nondet.
undefined_ok(N, A, M) :-	% [MC] 4.1
	functor(F, N, A),
	predicate_property(M:F, built_in).
undefined_ok(file_search_path, 2, user).
undefined_ok(library_directory, 1, user).
undefined_ok('CHOICE IDIOM', 1, prolog).
% undefined_ok(parse_message, 3, 'SU_messages'). % QP
% undefined_ok(parse_message_hook, 3, user).     % QP

follow_hooks([], _, _) --> [].
follow_hooks([N/A|T], M, Imports) -->
    follow(g(N,A,M), hook, Imports),
    follow_hooks(T, M, Imports).

follow_externs([], _) --> [].
follow_externs([extern(F,LC,N,A,M)|T], Imports) -->
    follow(g(N,A,M), extern(F,LC), Imports),
    follow_externs(T, Imports).

follow_imports([], _) --> [].
follow_imports([Item-_|T], Imports) -->
	(   {Item=g(_,_,user)}
	->  follow(Item, xref(Item), Imports)
	;   []
	),
	follow_imports(T, Imports).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% get the data ready for output

massage(Def0, MFile, UFile, Warnings0, Warnings, XREF, MODULE_FINISH) :-
    empty_avl(Empty), 
    avl_to_list(Def0, L0),
    unreachable_files(L0, Def0, Def, Empty, UR1),
    avl_to_list(UR1, UR2),
    unreachable_f(UR2, Warnings, W),
    avl_to_list(Def, L),
    wx(L, UR1, UnsortedWarnings0, X),
    cnt_follow(UnsortedWarnings0, UnsortedWarnings1),
    append(Warnings0, UnsortedWarnings1, UnsortedWarnings),
    sort(UnsortedWarnings, W),
    sort(X, XREF),
    (   MFile == suppress -> true
    ;   module_create(L, Empty, MODULE_CREATE),
        module_finish(MODULE_CREATE, MODULE_FINISH)
    ),
    maybe_collect_undefined(UFile, L).

% collect unreachable files and unreachable references to undefined predicates

unreachable_files([], Def, Def, D, D).
unreachable_files([K-V|T], D0, D) -->
    urf(V, K, D0, D1),
    unreachable_files(T, D1, D).

urf(clauses(Clauses), K, D0, D) -->
    urfc(Clauses, K, D0, D).
urf(referenced(Files,_), _, D, D) -->
    urfr(Files).
urf(undefined(_), _, Df, Df, D, D).

urfc([], _, Df, Df, D, D).
urfc([clause(File,LC,Body)|T], K, Df0, Df, D0, D) :-
    ur_body(Body, File, LC, K, Df0, Df1),
    urfcc(File, D0, D1),
    urfc(T, K, Df1, Df, D1, D).

ur_body([], _, _, _, D, D).
ur_body([H|T], File, LC, K, Def0, Def) :-
    (   avl_fetch(H, Def0, V)
    ->  ur_found(V, H, File, LC, K, Def0, Def1)
    ;   undefined_ok(H) -> Def1 = Def0 % [MC] 4.1
    ;   avl_store(H, Def0, undefined([not_called(File,LC,K)]), Def1)
    ),
    ur_body(T, File, LC, K, Def1, Def).

ur_found(clauses(_), _, _, _, _, D, D).
ur_found(referenced(_,_), _, _, _, _, D, D).
ur_found(undefined(U), H, File, LC, K, D0, D) :-
    avl_change(H, D0, _, D, undefined([not_called(File,LC,K)|U])).

urfcc(File, Dic, Dic) :- avl_fetch(File, Dic), !.
urfcc(File, Dic0, Dic) :- avl_store(File, Dic0, unreachable, Dic).

urfr([], D, D).
urfr([H|T], D0, D) :-
    avl_store(H, D0, reached, D1),
    urfr(T, D1, D).

unreachable_f([], S, S).
unreachable_f([F-K|T]) -->
    urfk(K, F),
    unreachable_f(T).

urfk(reached, _) --> [].
urfk(unreachable, F) --> [unreachable(F)].

% generate the cross reference list and the rest of the warnings
% wx ... warnings + cross reference

wx([], _, [], []).
wx([g(N,A,M)-V|T], UR, L0, X0) :- wx1(V, UR, N, A, M, L0, L, X0, X),
    wx(T, UR, L, X).

wx1(clauses([clause(F,LC,_)|_]), UR, N, A, M, L0, L,
   X, X) :- avl_fetch(F, UR, reached), !,
        L0 = [p(F,LC,not_reached(N,A,M))|L].
wx1(clauses(_), _, _, _, _, L, L, X, X).
% wx1(undefined(_), _, N, A, M, L, L, X, X) :-
% 	undefined_ok(N, A, M), !.
wx1(undefined(R), _, N, A, M, L0, L, X, X) :-
	undefined(R, N, A, M, L0, L).
wx1(referenced(Files, R), _, N, A, M, L, L, [ref(M,N,A,Files,RS)|X], X) :-
    referenced(R, R1),
    to_ordset(R1, RS, []).

undefined([], _, _, _) --> [].
undefined([H|T], N, A, M) -->
    undefined1(H, N, A, M),
    undefined(T, N, A, M).

undefined1(hook,                  _,  _,  _) --> []. % [MC] 4.1.2
undefined1(xref(Item),            _,  _,  _) -->
    [undefined(Item)].
undefined1(referee(F,LC,N,A,M),  N1, A1, M1) -->
    [p(F,LC,referenced(M1,N1,A1,M,N,A))].
undefined1(initialization(F,LC), N,   A,  M) -->
    [p(F,LC,initialization(N,A,M))].
undefined1(conditional(F,LC), N,   A,  M) -->
    [p(F,LC,conditional(N,A,M))].
undefined1(extern(F,LC),         N,   A,  M) -->
    [p(F,LC,extern(N,A,M))].
undefined1(not_called(F,LC,K), N, A, M) -->
    [p(F,LC,not_called(M,N,A,K))].

referenced([], _).
referenced([H|T], D) :-
    referenced1(H, D),
    referenced(T, D).

referenced1(xref(_), _). 
referenced1(referee(_,_,N,A,M),   D) :- insert(referee(M,N,A),       D).
referenced1(initialization(F,LC), D) :- insert(initialization(F,LC), D).
referenced1(conditional(F,LC),    D) :- insert(conditional(F,LC),    D).
referenced1(extern(F,LC),         D) :- insert(extern(F,LC),         D).
referenced1(hook,                 D) :- insert(hook,                 D).

cnt_follow(L0, L) :-
    findall(p(F,LC,cant_follow(N,A,Mg,Ng,Ag)),
	    retract(cant_follow(N,A,Mg,Ng,Ag,F,LC)), X),
    append(L0, X, L).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% create the data structures for module file output

module_create([], D, D).
module_create([G-H|T], D0, D) :- module_create1(H, G, D0, D1),
    module_create(T, D1, D).

module_create1(clauses(_),        _, D,  D).
module_create1(undefined(_),      _, D,  D).
module_create1(referenced([F],R), G, D0, D) :- !, % don't know how to do
    module_create2(R, F, G, D0, D).		  % multifile yet
module_create1(referenced(_,_),   _, D,  D).

module_create2([], _, _, D, D).
module_create2([H|T], F, G, D0, D) :-
    module_create3(H, F, G, D0, D1),
    module_create2(T, F, G, D1, D).

module_create3(xref(_),              F, G, D0, D) :- ei(user, F, G, D0, D).
module_create3(hook,                 _, _, D,  D).
module_create3(initialization(F,_),  F, _, D,  D) :- !.
module_create3(initialization(FI,_), F, G, D0, D) :- ei(FI, F, G, D0, D).
module_create3(conditional(F,_),     F, _, D,  D) :- !.
module_create3(conditional(FI,_),    F, G, D0, D) :- ei(FI, F, G, D0, D).
module_create3(extern(F,_),          F, _, D,  D) :- !.
module_create3(extern(FI,_),         F, G, D0, D) :- ei(FI, F, G, D0, D).
module_create3(referee(F,_,_,_,_),   F, _, D,  D) :- !.
module_create3(referee(FI,_,_,_,_),  F, G, D0, D) :- ei(FI, F, G, D0, D).

% ei ... exports imports. This is fun. We have an avl tree whose keys
% are file names and whose values are pairs. The left member of a pair
% is an absorptive key tree indicating the predicates exported, the
% right member is an absorptive key-value tree, the keys of which are
% imported file names, and the values of which are absorptive key trees
% indicating the predicates imported. The terminology is my own. Sorry.

ei(ImportingFile, ExportingFile, g(Name,Arity,_), D0, D) :-
    Goal = [Name|Arity],
    fetchm(ExportingFile, D0, Exports, _, D1),
    insert(Goal, Exports),
    fetchm(ImportingFile, D1, _, ImportedFiles, D),
    insert(ExportingFile, ImportedFiles, Imports),
    insert(Goal, Imports).

fetchm(K, A0, E, I, A) :- avl_fetch(K, A0, EI), !, EI = E-I, A = A0.
fetchm(K, A0, E, I, A) :- avl_store(K, A0, E-I, A).

insert(Name, dic(N,V,B,A), Value) :-
    (   Name = N
    ->  Value = V
    ;   Name @< N
    ->  insert(Name, B, Value)
    ;   insert(Name, A, Value)
    ).

module_finish(D, L) :-
    avl_to_list(D, L1),
    module_finish1(L1, L).

module_finish1([], []).
module_finish1([F-(E-I)|T], [x(F,Exports,Imports)|R]) :-
    to_ordset(E, Exports, []),
    m_imports(I, Imports, []),
    module_finish1(T, R).

m_imports(D, S, S) :- var(D), !.
m_imports(dic(N,V,B,A), S0, S) :-
    m_imports(B, S0, [N-X|S1]),
    to_ordset(V, X, []),
    m_imports(A, S1, S).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

maybe_collect_undefined(suppress, _).
maybe_collect_undefined(file(UFile), L) :-
    empty_avl(Empty),
    collect_undefined(L, Empty, U0),
    avl_to_list(U0, U),
    telling(Telling),
    tell(UFile),
    print_undefined(U),
    told,
    tell(Telling).

collect_undefined([], X, X).
collect_undefined([G-H|T], D0, D) :-
    cu(H, G, D0, D1),
    collect_undefined(T, D1, D).

cu(undefined(_), G, D0, D) :- !,
    avl_store(G, D0, foo, D).
cu(_, _, X, X).

print_undefined([]).
print_undefined([g(N,A,M)-_|T]) :-
	(   M==prolog -> true
	;   writeq(M:N/A), nl
	),
	print_undefined(T).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% print it

print_it(WFile, Warnings, XFile, XREF, MFile, MODULE_FINISH, CompilerErrors) :-

    print_warnings(WFile, Warnings, CompilerErrors),
    print_cross_references(XFile, XREF),
    print_modules(MFile, MODULE_FINISH).

% print the warnings

print_warnings(File, Warnings, CE) :-
    telling(T),
    tell(File),
    print_warnings_top(Warnings, CE),
    told,
    tell(T).

print_warnings_top(Warnings, CE) :-
    length(Warnings, L),
    print_warning_list(Warnings, foo(boo), CE), nl,
    write(L),
    write(' warnings'), nl.

print_warning_list([], _, _).
print_warning_list([P|T], Old, CE) :-
    print_warning(P, Old, F, CE), nl,
    print_warning_list(T, F, CE).

print_warning(undefined(g(N,A,M)), O, O, _) :-
	write_pred_spec(M, N, A),
	write(' is not a defined predicate').
print_warning(unreachable(F), O, O, _) :-
    write('nothing in file '),
    write(F),
    write(' was called').
print_warning(p(F,LC,Ms), O, F, CE) :-
   (  CE == normal
   -> (  O == F
      -> true
      ;  nl, write(F), nl
      ),
      write('    '), write(LC)
   ;  format('~w:~w:', [F,LC])
   ),
   print_warning(Ms).

print_warning(not_reached(N,A,M)) :-
    write(' unreachable '),
    write_pred_spec(M, N, A).
print_warning(referenced(Mu,Nu,Au,M,N,A)) :-
    write(' '),
    referenced_undefined(M, N, A, Mu, Nu, Au).
print_warning(initialization(N,A,M)) :-
    write(' initialization refers to undefined predicate '),
    write_pred_spec(M, N, A).
print_warning(conditional(N,A,M)) :-
    write(' conditional refers to undefined predicate '),
    write_pred_spec(M, N, A).
print_warning(extern(N,A,M)) :-
    write(' public declaration for undefined predicate '),
    write_pred_spec(M, N, A).
print_warning(not_called(Mu,Nu,Au,g(N,A,M))) :-
    write(' unreachable '),
    referenced_undefined(M, N, A, Mu, Nu, Au).
print_warning(cant_follow(N,A,Mg,Ng,Ag)) :-
    write(' cannot follow '),
    writeq(N/A),
    write(' in '),
    write_pred_spec(Mg, Ng, Ag).
print_warning(late_meta_decl(N,A,M)) :-
    write(' meta_predicate declaration appears after use of predicate '),
    write_pred_spec(M, N, A).
print_warning(duplicate_meta_decl(N,A,M)) :-
    write(' repeated meta_predicate declaration for predicate '),
    write_pred_spec(M, N, A).
print_warning(malformed(Spec)) :-
    write(' malformed declaration '),
    writeq(Spec).

write_pred_spec(M, N, A) :-
	writeq(M:N/A).

referenced_undefined(M, N, A, Mu, Nu, Au) :-
    write_pred_spec(M, N, A),
    write(' referenced undefined '),
    write_pred_spec(Mu, Nu, Au).

% print the cross reference listing

print_cross_references(suppress, _).
print_cross_references(file(XFile), X) :-
    telling(T),
    tell(XFile),
    print_xref(X),
    told,
    tell(T).

print_xref(X) :-
    length(X, L),
    format('~d referenced predicates~n', [L]),
    print_xref_list(X).

print_xref_list([]).
print_xref_list([ref(M,N,A,Files,References)|T]) :- nl,
    write_pred_spec(M, N, A), nl,
    print_files(Files),
    print_references(References),
    print_xref_list(T).

print_files([]).
print_files([H|T]) :-
    write('  '),
    write(H), nl,
    print_files(T).

print_references([]).
print_references([H|T]) :-
    write('    '),
    print_reference(H), nl,
    print_references(T).

print_reference(referee(M,N,A)) :-
    write_pred_spec(M, N, A).
print_reference(initialization(F,LC)) :-
    write(initialization), line_ref(F, LC).
print_reference(conditional(F,LC)) :-
    write(conditional), line_ref(F, LC).
print_reference(extern(F,LC)) :-
    write('public declaration'),
    line_ref(F, LC).
print_reference(hook)         :-
    write(hook).

line_ref(F, LC) :-
    write(' in file '),
    write(F),
    write(' at line '),
    write(LC).

% print the imports & exports file

print_modules(suppress, _).
print_modules(file(MFile), X) :-
    telling(T),
    tell(MFile),
    print_module(X),
    told,
    tell(T).

print_module([]).
print_module([x(F,Exports,Imports)|T]) :-
	(   F==user -> true
	;   module_of_file(F, N),
	    format('% ~a ~2n:- module(~a, [~n', [F,N]),
	    print_module_exports(Exports, ''),
	    format(']).~2n', []),
	    print_module_imports(Imports), nl
	),
	print_module(T).

module_of_file(File, Module) :-
    open(File, read, S),
    read_one(S, Term, _),
    (   (Term = (:-module(M,_)); Term = (:-module(M,_,_)))
    ->  Module = M
    ;   Module = user
    ),
    close(S).	

print_module_exports([], _).
print_module_exports([[N|A]|T], Suffix) :-
    format(Suffix, []),
    format('\t\t\t~q', [N/A]),
    print_module_exports(T, ',~n').

print_module_imports([]).
print_module_imports([F-H|T]) :-
    format(':- use_module(~q, [~n', [F]),
    print_module_exports(H, ''),
    format(']).~2n', []),
    print_module_imports(T).


/* ----------------------------------------------------------------------
    Messages
   ---------------------------------------------------------------------- */

:- multifile user:generate_message_hook/3.

user:generate_message_hook(xref(Verbose,What)) --> !,
    verbose_or_silent(Verbose, What).

verbose_or_silent(silent, _) --> [].
verbose_or_silent(verbose, What) -->
    verbose(What).

verbose(Msg) --> {atom(Msg)}, !, [Msg-[],nl].
verbose(processing(Level,File)) --> ['~*c~a'-[Level,32,File],nl].


/* ----------------------------------------------------------------------
    Application extras
   ---------------------------------------------------------------------- */
usage :- usage(user_error).

usage(S) :- write(S,
 'usage: spxref [-R] [-c] [-v] [-i ifile] [-w wfile] [-x xfile] [-m ufile] [-u ufile] fspec ...\n\
\n\
  -R ......... follow user:runtime_entry/1 as opposed to module declarations\n\
  -c ......... generate standard compiler style error messages\n\
  -v ......... verbose output. This echoes the names of the files being read to\n\
               stderr.\n\
  -i ifile ... an initialization file. Read in prior to processing.\n\
  -w wfile ... warning file. Warnings are written to stderr by default.\n\
  -x xfile ... cross reference file. This is not generated by default.\n\
  -m mfile ... generate a file indicating which predicates are imported and\n\
               which are exported for each file. This is not generated by\n\
               default.\n\
  -u ufile ... generate a file listing all the undefined predicates.  This is\n\
               not generated by default.\n\
  --version .. print version\n\
  --help ..... print help\n\
  fspec ...... one or more filenames, ".pro" or ".pl" extensions optional\n\
\n\
The cross referencer follows initializations, hooks, user:runtime_entry/1,\n\
and module and public declarations.\n\
'), flush_output(S).


version :-  version(user_output).

version(S) :- 
        current_prolog_flag(version_data, sicstus(Major,Minor,Rev,Beta,_)),
        ( Beta > 0 ->
          number_codes(Beta, BetaCodes),
          append("beta", BetaCodes, BetaSuffix)
        ; BetaSuffix = ""
        ),
        Tool = spxref,
        format(S, '~w (SICStus Prolog ~d.~d.~d~s)~n', [Tool, Major,Minor,Rev,BetaSuffix]), flush_output(S).


user:runtime_entry(start) :-
	prolog_flag(argv, Args),
	parse(Args, Files, Options),
        % filter out the info markers
        findall(E,(member(E,Options), E \== info), Options1),
	( functor(Files, '.', 2) ->
          !,
	  xref(Files, Options1)
        ; otherwise ->
          % Fail (and show usage) unless info option(s) was present and nothing else.
          sort(Options, [info])
        ),
        !.
user:runtime_entry(start) :-
	usage,
	prolog_flag(system_type, runtime),
	halt(1).

parse([], [], []).
parse([H,A|R], F, L0) :-
    prs(H, A, L0, L), !,
    parse(R, F, L).
parse([H|T], Files, Options) :- atom_codes(H, [0'-,0'-|_]),
    !, parse_long(H, T, Files, Options).
parse([H|T], F, L0) :-
    atom_codes(H, [0'-|V]), !,
    prsc(V, L0, L),
    parse(T, F, L).
parse([H|T], [F|R], L) :-
    fn(H, F),
    parse(T, R, L).

prs('-i', A,                    L, L) :- fn(A, IFile), load_files(user:IFile).
prs('-m', A,       [mod(MFile)|L], L) :- fn(A, MFile).
prs('-w', A,  [warnings(WFile)|L], L) :- fn(A, WFile).
prs('-u', A, [undefined(UFile)|L], L) :- fn(A, UFile).
prs('-x', A,      [xref(XFile)|L], L) :- fn(A, XFile).

prsc([], L, L).
prsc([H|T], L0, L) :-
    prsc1(H, L0, L1),
    prsc(T, L1, L).

prsc1(0'R, [runtime_entry|L], L).
prsc1(0'c, [compiler_errors|L], L).
prsc1(0'v, [verbose|L], L).

fn('-', user) :- !. % treat '-' as stdin/stdout
fn(A, A).

parse_long('--version', T, Files, [info|Options]) :-
    version,
    parse(T, Files, Options).
parse_long('--help', T, Files, [info|Options]) :-
    usage(user_output),
    parse(T, Files, Options).
parse_long('--', T, Files, Options) :-
    Files = T,
    Options = [].

